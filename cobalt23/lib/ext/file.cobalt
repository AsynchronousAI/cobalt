var lfs = {};
var windows = package.config->sub(1,1) == "\\";

var other_sep;
var sep;
var dirsep;

if( windows ) {
	sep = '\\';
	other_sep = '/';
	dirsep = ';';
} else {
	sep = '/';
	dirsep = ':';
}


var function at(s,i) {
	return string.sub(s,i,i);
}

//- returns if the path is an absolute path
function lfs.isabs(path) {
	if( windows ) {
		return at(path, 1) == '/' || at(path, 1) == '\\' || at(path, 2) ==':';
	} else {
		return at(path, 1) == '/';
	}
}

// return the path resulting from combining the individual paths.
// if the second (or later) path is absolute, we return the last absolute path (joined with any non-absolute paths following).
// empty elements (except the last) will be ignored.
function lfs.join(path1, path2,...) {
	if( select('#', ...) > 0 ) {
		var p = lfs.join(path1, path2);
		var args = {...};
		for( i = 1,#args ) {
			p = lfs.join(p, args[i]);
		}
		return p;
	}
	if( lfs.isabs(path2) ) { return path2; }
	var endc = at(path1, #path1);
	if( endc != sep && endc != other_sep && endc != "" ) {
		path1 = path1 .. sep;
	}
	return path1 .. path2;
}

// Returns the users home directory
function lfs.home() {
	var home = os.getenv('HOME');
	if( ! home ) {
		home = os.getenv('USERPROFILE') || (os.getenv('HOMEDRIVE') .. os.getenv('HOMEPATH'));
	}
	return home;
}

// We make the simplifying assumption in these functions that path separators
// are always forward slashes. This is true on *nix and *should* be true on
// windows, but you can never tell what a user will put into a config file
// somewhere. This function enforces this.
function lfs.normalize(path) {
	if( windows ) {
		return (path->gsub("\\", "/"));
	} else {
		return path;
	}
}

var _attributes = lfs.attributes;
function lfs.attributes(path, ...) {
	path = lfs.normalize(path);
	if( windows ) {
		// Windows stat() is kind of awful. If the path has a trailing slash, it
		// will always fail. Except on drive root directories, which *require* a
		// trailing slash. Thankfully, appending a "." will always work if the
		// target is a directory; and if it's not, failing on paths with trailing
		// slashes is consistent with other OSes.
		path = path->gsub("/$", "/.");
	}

	return _attributes(path, ...);
}

function lfs.exists(path) {
	return lfs.attributes(path, "mode") != null;
}

function lfs.dirname(oldpath) {
	var path = lfs.normalize(oldpath)->gsub("[^/]+/*$", "");
	if( path == "" ) {
		return oldpath;
	}
	return path;
}

function lfs.basename(oldpath) {
	var path = lfs.normalize(oldpath)->match("[^/]+/*$");
	if( path == "" ) {
		return oldpath;
	}
	return path;
}

// Recursive directory creation a la mkdir -p. Unlike lfs.mkdir, this will
// create missing intermediate directories, and will not fail if the
// destination directory already exists.
// It assumes that the directory separator is '/' and that the path is valid
// for the OS it's running on, e.g. no trailing slashes on windows -- it's up
// to the caller to ensure this!
function lfs.mkdirs(path) {
	path = lfs.normalize(path);
	if( lfs.exists(path) ) {
		return true;
	}
	if( lfs.dirname(path) == path ) {
		// We're being asked to create the root directory!
		return null,"mkdir: unable to create root directory";
	}
	var r,err = lfs.mkdirs(lfs.dirname(path));
	if( ! r ) {
		return null,err.." (creating "..path..")";
	}
	return lfs.mkdir(path);
}


// Recursive directory deletion. Unlike lfs.rmdir, this will
// delete all files recursivly, and will not fail if the
// directory is not empty.
function lfs.rmdirs(path) {
	for( file in lfs.dir(path) ) {
		var file_path = path .. sep .. file;
		if( file != "." && file != ".." ) {
			if( lfs.attributes(file_path, 'mode') == 'file' ) {
				os.remove(file_path);
			} else if( lfs.attributes(file_path, 'mode') == 'directory' ) {
				deletedir(file_path);
			}
		}
	}
	return lfs.rmdir(path);
}

return lfs