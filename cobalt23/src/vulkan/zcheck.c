/* ============================================================================== //
// This file is apart of the Cobalt Programming Language. Cobalt is under the MIT //
// License. Read `cobalt.h` for license information.                              //
// ============================================================================== */

#include "internal.h"

#if 0
/* Notes for my future self
 * ----------------------------------------------------------------------------
 * This module replaces the original structs.[ch] for the handling of Vulkan structs.
 * A replacement was needed because the original module was not much consistent and was
 * too hard to extend. This new module is more consistent but less efficient because it
 * dynamically allocates and deallocates every struct at need. However, the former module
 * did so as well for most structs. I'm afraid that this is inevitable with the Vulkan
 * extension system if we don't know in advance which and how many structs are needed
 * (this is the case for language bindings such as MoonVulkan. Unfortunately the Vulkan
 * API doesn't seem much language-binding friendly, which in my opinion makes it not as
 * 'modern' as often claimed).
 *
 * Terminology used here:
 * - A 'typed struct' is a vulkan struct having the sType and pNext fields.
 * - A 'untyped struct' lacking the sType and pNext fields, so it is neither extendable
 *   nor chainable.
 * - A 'fresh struct' is a newly allocated struct, zeroed out. If it is a typed struct,
 *   its sType field is also properly initialized.
 * - A 'fresh chain' is a pNext-chain of fresh structs.
 *
 * For each typed or untyped VkXxx struct the functions listed below are declared, and they
 * are implemented only if actually needed. These functions are meant to provide the check/push
 * functionalities in the Lua style, as well as the allocation and release of the struct and
 * any nested struct.
 *
 * The declarations are contained in the zcheck.h header which is automatically generated by
 * the zcheck.lua script. To add a new struct, modify the latter (see the script itself for
 * details). The signatures are mostly standard, but in a few cases a non-standard signature
 * is needed, usually when a ud is needed to fill in a struct.
 *
 * The functions that have a 'int *err' parameter will set it with ERR_SUCCESS (0) on success
 * or with the relevant ERR_XXX code if an error occurs. Note that all error codes are <0
 * except for ERR_NOTPRESENT which is > 0.
 *
 * Functions for the generic VkXxx:
 *
 * VkXxx* znewVkXxx(lua_State *L, int *err);
 * VkXxx* znewarrayVkXxx(lua_State *L, uint32_t counter, int *err);
 *        Allocates a fresh struct or array of contiguous fresh structs.
 *        Allocate the base struct(s) only, with no pNext chain.
 *
 * VkXxx* znewchainVkXxx(lua_State *L, int *err);
 * VkXxx* znewchainarrayVkXxx(lua_State *L, uint32_t count, int *err);
 *        Allocates a fresh struct or array of contiguous structs, together 
 *        with the full pNext chain (also fresh). See ZINIT for more details.
 *
 * VkXxx* zcheckVkXxx(lua_State *L, int arg, int *err);
 * VkXxx* zcheckarrayVkXxx(lua_State *L, int arg, uint32_t *count, int *err);
 *        Similar to the standard luaL_checkxxx() functions. Checks the value on
 *        the Lua stack at index 'arg', allocates a fresh struct, sets it with
 *        the value and returns it. See ZCHECK for more details.
 *
 * int    zpushVkXxx(luaState *L, VkXxx *p);
 *        Similar to the standard lua_pushxxx() functions. Pushes on the Lua stack
 *        the value contained in the passed struct p. See ZPUSH for more details.
 *
 * void   zfreeVkXxx(luaState *L, VkXxx *p, int base);
 * void   zfreearrayVkXxx(lua_State *L, VkXxx *p, uint32_t count, int base);
 *        Frees the passed struct or array of contiguous structs, together with
 *        any nested allocated content (either fields or pNext chain).
 *        --> All structs returned by znew, znewchain, and zcheck and by their <--
 *        --> array versions must be freed using zfree or zfreearray, and this <--
 *        --> must be done also in case of error.                              <--
 *        The 'base' parameters controls the freeing of the base struct(s):
 *        - if base=0, the base struct is not freed (only its contents are)
 *        - if base!=0, the base struct is freed together with its contents.
 *        (Outside of this module always set base=1).
 *
 * For internal use only:
 * void   zclearVkXxx(luaState *L, VkXxx *p);           --> see ZCLEAR
 * int    zinitVkXxx(lua_State *L, VkXxx* p, int *err); --> see ZINIT
 *
 * IMPORTANT: The caller of a function that creates a new struct (znew, zcheck, etc.) must
 * subsequently issue the corresponding zfree call in any case, i.e. even if the creating
 * function failed and set err accordingly. This is to properly deallocate the struct itself
 * together with any nested or chained structure. While this may not be strictly needed in
 * the typical usage where the caller raises an error causing the application to exit (so
 * the allocated memory is released by the OS), we must keep in mind that the scripts may
 * also call vk function in protected mode (wrapped in pcall), thus we'd better guarantee
 * proper deallocations in any case, to avoid memory leakages.
 */
#endif

/********************************************************************************
 * Helper functions and macros                                                  *
 ********************************************************************************/

static int getfield(lua_State *L, int arg, const char *sname)
/* Pushes the field 'sname' from the table at arg, and returns its type (LUA_TXXX) */
    { lua_pushstring(L, sname); return lua_rawget(L, arg); }

static int pushfield(lua_State *L, int arg, const char *sname)
/* Pushes the field 'sname' from the table at arg, and returns its stack index */
    { lua_pushstring(L, sname); lua_rawget(L, arg); return lua_gettop(L); }

#define popfield    lua_remove
#define poperror()  lua_pop(L, 1)
#define pusherror() lua_pushstring(L, errstring(*err))
#define pushfielderror(name_) lua_pushfstring(L, "%s: %s", (name_), errstring(*err))
#define prependfield(name_) \
    do { lua_pushfstring(L, "%s.%s", (name_), lua_tostring(L, -1)); lua_remove(L, -2); } while(0)

/* ZCHECK - Must be implemented for structs that have to be passed from Lua to C */
#define ZCHECK_BEGIN(VkXxx) \
    VkXxx* zcheck##VkXxx(lua_State *L, int arg, int *err) { VkXxx *p; int arg1;
#define ZCHECK_END  (void)arg1; *err=0; return p; }

/* ZPUSH - Must be implemented for structs that have to be passed from C to Lua */
#define ZPUSH_BEGIN(VkXxx) int zpush##VkXxx(lua_State *L, const VkXxx *p) {
#define ZPUSH_END return 1; }

/* ZCLEAR - Must be implemented for structs that have allocated nested fields,
 * other than the pNext chain. It must deallocate those fields, with any nested
 * chain, but must not free the base struct pointed by p, nor parts of it.
 * Note that nested fields may appear either as pointers or as fully embedded: in the
 * former case they must be zfree()'d with base=1, otherwise with base=0.
 * - The zclear function for a nested typed struct (if it needs one) must be static
 *   and an entry for it must be added to the switch in the zfreeaux function.
 *-  The zclear function for a nested untyped struct must be either a global function
 *   or globally defined as a NULL pointer (in case no deallocation is needed).
 */
#define ZCLEAR_BEGIN(VkXxx) void zclear##VkXxx(lua_State *L, const void *p_) { VkXxx *p =(VkXxx*)p_; 
#define ZCLEAR_END }

/* ZINIT - Must be implemented for structs that have to be passed 'fresh' to Vulkan
 * for parameters retrieval. Given a fresh struct, it must allocate fresh structs for
 * its required extensions and add them to its pNext chain.
 * The ZINIT_BEGIN macro implements also the znewchain functions, which are those
 * actually used outside of this module (zinit should not be used directly). */
#define ZINIT_BEGIN(VkXxx)                                              \
VkXxx* znewchain##VkXxx(lua_State *L, int *err)                         \
    {                                                                   \
    VkXxx* p = znew##VkXxx(L, err);                                     \
    if(*err) return NULL;                                               \
    zinit##VkXxx(L, p, err);                                            \
    if(*err) { zfree##VkXxx(L, p, 1); return NULL; }                    \
    return p;                                                           \
    }                                                                   \
VkXxx* znewchainarray##VkXxx(lua_State *L, uint32_t count, int *err)    \
    {                                                                   \
    uint32_t i;                                                         \
    VkXxx* p = znewarray##VkXxx(L, count, err);                         \
    if(*err) return NULL;                                               \
    for(i=0; i<count; i++)                                              \
        {                                                               \
        zinit##VkXxx(L, &p[i], err);                                    \
        if(*err) { zfreearray##VkXxx(L, p, count, 1); return NULL; }    \
        }                                                               \
    return p;                                                           \
    }                                                                   \
int zinit##VkXxx(lua_State *L, VkXxx* p, int *err) { (void)L; (void)(p);
#define ZINIT_END *err=0; return *err;  }

/* Structs chaining via pNext -------------------------------------------------*/
#define pnextof(p_) (void**)&((p_)->pNext)
#define addtochain(chain_, p_) do {                                     \
    VkBaseOutStructure *pp_ = (VkBaseOutStructure*)p_;                  \
    while(pp_) {                                                        \
        *(chain_)=(pp_);                                                \
        (chain_)=pnextof(pp_);                                          \
        (pp_)=(VkBaseOutStructure*)(pp_)->pNext;                        \
    }                                                                   \
} while(0)
/* const void** chain_ contains the address of the pNext field of the struct that
 * is currently last in the pNext chain.
 * addtochain() appends to the chain the struct pointed to by p_, together with its
 * own pNext chain.
 */
#define EXTENSIONS_BEGIN do { void **chain = pnextof(p);
#define EXTENSIONS_END } while(0);
#define ADD_EXTENSION_STRUCT(sname_, VkXxx)  do { /* regular extension struct */    \
    VkXxx *p1;                                                                      \
    arg1 = pushfield(L, arg, sname_);                                               \
    p1 = zcheck##VkXxx(L, arg1, err);                                               \
    popfield(L, arg1);                                                              \
    if(*err<0) { zfree(L, p1, 1); prependfield(sname_); return p; }                 \
    else if(*err==ERR_NOTPRESENT) poperror();                                       \
    else addtochain(chain, p1);                                                     \
} while(0)
#define ADD_EXTENSION_INLINE(VkXxx)    do { /* for INLINED_EXTENSIONS only (see below) */\
    VkXxx *p1 = zcheck##VkXxx(L, arg, err);     \
    if(*err) { zfree(L, p1, 1); return p; }     \
    addtochain(chain, p1);                      \
} while(0)
/* INLINED_EXTENSIONS: The fields of an extension are logically fields of the struct they
 * extend, but since C structs are not extandable, the Vulkan API defines extension structs
 * to hold the new fields and chains them to the original one via the pNext pointer.
 * In Lua, however, we have the luxury of tables that can be easilly extended by adding new
 * optional fields without breaking backward compatibility, so we (usually) 'inline' the
 * extensions by just adding the new fields to the table to be extended instead of adding
 * a new table that contains them. As a consequence, checktable() must not be called in the
 * zcheckVkXxx function for an inlined extension.
 */

/* The following macros are meant to be used for long chains of extensions such as
 * VkPhysicalDeviceFeatures2, where the extensions structs are all typed, do not need
 * a zclear, and only appear as extensions in these chains (so there is no need to define
 * all the functions for them and we can use znew() and zfree() without wrappers).
 * Notice that in the Lua value the fields of an extension struct are often promoted to the
 * base table (i.e. inlined), so there is no lua_newtable() call in the zpush (or localpush)
 * function and no checktable() call in the zcheck function.
 */
#define ADDX(XXX, VkXxx) do {                                           \
    VkXxx* p1 = znew(L, VK_STRUCTURE_TYPE_##XXX, sizeof(VkXxx), err);   \
    if(*err) { zfree(L, p1, 1); return *err; }                          \
    addtochain(chain, p1);                                              \
} while(0)

/* defines a push function for local use only (localpushVkXxx). */
#define LOCALPUSH_BEGIN(VkXxx) static int localpush##VkXxx(lua_State *L, const VkXxx *p) {
#define LOCALPUSH_END return 1; }

/* defines a check function for local use only (zcheckVkXxx). */
#define LOCALCHECK_BEGIN(XXX, VkXxx)                                                    \
static VkXxx* zcheck##VkXxx(lua_State *L, int arg, int *err)                            \
    { VkXxx* p; /* checktable(arg); */                                                  \
    if((p = znew(L, VK_STRUCTURE_TYPE_##XXX, sizeof(VkXxx), err))==NULL) return NULL;
#define LOCALCHECK_END *err = 0; return p; }

#define XPUSH_BEGIN do {                                                \
    VkBaseOutStructure *pp_ = (VkBaseOutStructure*)p->pNext;            \
        while(pp_) { switch(pp_->sType) {
#define XCASE(XXX, VkXxx) case VK_STRUCTURE_TYPE_##XXX: localpush##VkXxx(L, (VkXxx*)pp_); break
#define XPUSH_END                                                       \
        default: unexpected(L); return 1; }                             \
            pp_ = pp_->pNext; }                                         \
} while(0);
/*--------------------------------------------------------------------------*/

static int checktable_(lua_State *L, int arg)
#define checktable(arg) if((*err = checktable_(L, (arg)))!=0) return NULL
    {
    if(lua_isnoneornil(L, arg))
        { lua_pushstring(L, errstring(ERR_NOTPRESENT)); return ERR_NOTPRESENT; }
    if(lua_type(L, arg) != LUA_TTABLE)
        { lua_pushstring(L, errstring(ERR_TABLE)); return ERR_TABLE; }
    return 0;
    }
#define newstruct(VkXxx) if((p = znew##VkXxx(L, err))==NULL) return NULL /* also sets sType */

static int ispresent_(lua_State *L, int arg, const char *sname)
#define ispresent(sname_) ispresent_(L, arg, (sname_))
/* Checks if field 'sname' is present in the table at arg */
    {
    int rc;
    lua_pushstring(L, sname);
    lua_rawget(L, arg);
    rc = lua_isnoneornil(L, -1) ? 0 : 1;
    lua_pop(L, 1);
    return rc;
    }

/*------------------------------------------------------------------------------*
 | Set macros (for push functions)                                              |
 *------------------------------------------------------------------------------*/

#define SetInteger(name_, sname_) do { lua_pushinteger(L, p->name_); lua_setfield(L, -2, sname_); } while(0)
#define SetHandle SetInteger /* uint64_t handle */
#define SetDeviceAddress SetInteger /* uint64_t */
#define SetLightuserdata(name_, sname_) do { lua_pushlightuserdata(L, p->name_); lua_setfield(L, -2, sname_); } while(0)
#define SetNumber(name_, sname_) do { lua_pushnumber(L, p->name_); lua_setfield(L, -2, sname_); } while(0)
#define SetFlags(name_, sname_) do { pushflags(L, p->name_); lua_setfield(L, -2, sname_); } while(0)
#define SetBits SetFlags
#define SetBoolean(name_, sname_) do { lua_pushboolean(L, p->name_); lua_setfield(L, -2, sname_); } while(0)
#define SetString(name_, sname_) do { lua_pushstring(L, p->name_); lua_setfield(L, -2, sname_); } while(0)
#define SetLString(name_, sname_, len) do { lua_pushlstring(L, p->name_, len); lua_setfield(L, -2, sname_); } while(0)
#define SetUUID(name_, sname_, len) do { lua_pushlstring(L, (char*)p->name_,(len)); lua_setfield(L, -2, sname_); } while(0)
#define SetEnum(name_, sname_, pushfunc) do { pushfunc(L, p->name_); lua_setfield(L, -2, sname_); } while(0)
#define SetStruct(name_, sname_, VkXxx) do { zpush##VkXxx(L, &(p->name_)); lua_setfield(L, -2, sname_); } while(0)
#define SetIntegerArray(name_, sname_, n_) do { unsigned int i_;                            \
    lua_newtable(L);                                                                        \
    for(i_=0; i_<(n_); i_++) { lua_pushinteger(L, p->name_[i_]); lua_seti(L, -2, i_+1); }   \
    lua_setfield(L, -2, sname_);                                                            \
} while(0)
#define SetNumberArray(name_, sname_, n_) do { int i_;                                      \
    lua_newtable(L);                                                                        \
    for(i_=0; i_<(n_); i_++) { lua_pushnumber(L, p->name_[i_]); lua_seti(L, -2, i_+1); }    \
    lua_setfield(L, -2, sname_);                                                            \
} while(0)
#define SetEnumList(name_, sname_, pushfunc, n_) do { uint32_t i_;                          \
    lua_newtable(L);                                                                        \
    for(i_=0; i_<(n_); i_++) { pushfunc(L, p->name_[i_]); lua_seti(L, -2, i_+1); }          \
    lua_setfield(L, -2, sname_);                                                            \
} while(0)

/*------------------------------------------------------------------------------*
 | Get macros (for check functions)                                             |
 *------------------------------------------------------------------------------*/

static VkFlags64 GetFlags_(lua_State *L, int arg, const char *sname, int *err)
/* always opt., defaults to 0 */
    {
    int arg_ = pushfield(L, arg, sname);
    VkFlags64 flags = testflags(L, arg_, err);
    popfield(L, arg_);
    if(*err == ERR_NOTPRESENT) { *err=0; return 0; }
    if(*err) pushfielderror(sname);
    return flags;
    }

#define GetFlags(name_, sname_)  do {                           \
    p->name_ = GetFlags_(L, arg, sname_, err);                  \
    if(*err) return p;                                          \
} while(0)

#define GetBits(name_, sname_, T) do {                          \
    /* same as GetFlags, but casts to T */                      \
    p->name_ = (T)GetFlags_(L, arg, sname_, err);               \
    if(*err) return p;                                          \
} while(0)

#define GetSamples(name_, sname_) do {                          \
/* VkSampleCountFlags may be passed either as string or number (eg 1 or "1" for 1 bit) */\
    int arg_ = pushfield(L, arg, sname_);                       \
    p->name_ = (VkSampleCountFlagBits)testflags(L, arg_, err);  \
    popfield(L, arg_);                                          \
    if(*err == ERR_NOTPRESENT)                                  \
        { p->name_ = VK_SAMPLE_COUNT_1_BIT; *err = 0; }         \
    else if(*err)                                               \
        { pushfielderror(sname_); return p; }                   \
} while(0)

/* Numbers -------------------------------------------------------------------*/

static lua_Number GetNumberDef_(lua_State *L, int arg, const char *sname, lua_Number defval, int *err)
    {
    lua_Number val = defval;
    int arg_ = pushfield(L, arg, sname);
    *err = 0;
    if(lua_isnumber(L, arg_)) val = lua_tonumber(L, arg_);
    else if(!lua_isnoneornil(L, arg_)) *err = ERR_TYPE;
    popfield(L, arg_);
    if(*err) pushfielderror(sname);
    return val;
    }

#define GetNumberDef(name_, sname_, defval) /* defaults to defval */ do { \
    p->name_ = GetNumberDef_(L, arg, sname_, defval, err);                \
    if(*err) return p;                                                  \
} while(0)

#define GetNumber(name_, sname_) GetNumberDef(name_, sname_, 0) /* defaults to 0 */

static lua_Integer GetInteger_(lua_State *L, int arg, const char *sname, lua_Integer defval, int *err)
    {
    int isnum;
    lua_Integer val = defval;
    int arg_ = pushfield(L, arg, sname);
    *err = 0;
    if(!lua_isnoneornil(L, arg_))
        {
        val = lua_tointegerx(L, arg_, &isnum);
        if(!isnum) *err = ERR_TYPE;
        }
    popfield(L, arg_);
    if(*err)
        pushfielderror(sname);
    return val;
    }

#define GetIntegerOpt(name_, sname_, defval_)  /* defaults to defval_ */ do {   \
    p->name_ = GetInteger_(L, arg, sname_, defval_, err);                       \
    if(*err) return p;                                                          \
} while(0)

#define GetInteger(name_, sname_) GetIntegerOpt(name_, sname_, 0) /* defaults to 0 */
#define GetHandle GetInteger /* uint64_t handle */
#define GetDeviceAddress /* uint64_t */

#define GetNumArray_(name_, sname_, n_, towhatx_) do {                      \
/* get a fixed-length n_ array of floats or integers */                     \
    int arg1_, arg2_, t_, i_, isnum_;                                       \
    *err = 0;                                                               \
    arg1_ = pushfield(L, arg, sname_);                                      \
    t_ = lua_type(L, arg1_);                                                \
    if(t_ != LUA_TTABLE)                                                    \
        {                                                                   \
        popfield(L, arg1_);                                                 \
        if(t_ == LUA_TNIL || t_ == LUA_TNONE) { *err = ERR_NOTPRESENT; }    \
        else { *err=ERR_TABLE; pushfielderror(sname_); return p; }          \
        }                                                                   \
    else {                                                                  \
        for(i_=0; i_ <(n_); i_++)                                           \
            {                                                               \
            lua_rawgeti(L, arg1_, i_+1);                                    \
            arg2_ = lua_gettop(L);                                          \
            p->name_[i_] = towhatx_(L, arg2_, &isnum_);                     \
            popfield(L, arg2_);                                             \
            if(!isnum_) { *err=ERR_TYPE; break; }                           \
            }                                                               \
        popfield(L, arg1_);                                                 \
        if(*err < 0)                                                        \
            {                                                               \
            switch(*err)                                                    \
                {                                                           \
                case ERR_TABLE:                                             \
                case ERR_MEMORY:                                            \
                case ERR_EMPTY: pushfielderror(sname_); return p;           \
                default:        prependfield(sname_); return p;             \
                }                                                           \
            }                                                               \
        }                                                                   \
} while(0)

#define GetIntegerArray(name_, sname_, n_) GetNumArray_(name_, sname_, n_, lua_tointegerx)
#define GetNumberArray(name_, sname_, n_) GetNumArray_(name_, sname_, n_, lua_tonumberx)

#define GetEnumArray(name_, sname_, n_, testfunc_) do {                     \
/* get a fixed-length n_ array of enums */                                  \
    int arg1_, arg2_, t_, i_;                                               \
    *err = 0;                                                               \
    arg1_ = pushfield(L, arg, sname_);                                      \
    t_ = lua_type(L, arg1_);                                                \
    if(t_ != LUA_TTABLE)                                                    \
        {                                                                   \
        popfield(L, arg1_);                                                 \
        if(t_ == LUA_TNIL || t_ == LUA_TNONE) { *err = ERR_NOTPRESENT; }    \
        else { *err=ERR_TABLE; pushfielderror(sname_); return p; }          \
        }                                                                   \
    else {                                                                  \
        for(i_=0; i_ <(n_); i_++)                                           \
            {                                                               \
            lua_rawgeti(L, arg1_, i_+1);                                    \
            arg2_ = lua_gettop(L);                                          \
            p->name_[i_] = testfunc_(L, arg2_, err);                        \
            popfield(L, arg2_);                                             \
            if(*err) break;                                                 \
            }                                                               \
        popfield(L, arg1_);                                                 \
        if(*err < 0)                                                        \
            {                                                               \
            switch(*err)                                                    \
                {                                                           \
                case ERR_TABLE:                                             \
                case ERR_MEMORY:                                            \
                case ERR_EMPTY: pushfielderror(sname_); return p;           \
                default:        prependfield(sname_); return p;             \
                }                                                           \
            }                                                               \
        }                                                                   \
} while(0)


/* Booleans ------------------------------------------------------------------*/

static int GetBoolean_(lua_State *L, int arg, const char *sname, int *err)
/* always opt., defaults to 0 (false) */
    {
    int val = 0;
    int arg_ = pushfield(L, arg, sname);
    *err = 0;
    if(lua_isboolean(L, arg_))
        val = lua_toboolean(L, arg_);
    else if(!lua_isnoneornil(L, arg_))
        *err = ERR_TYPE;
    popfield(L, arg_);
    if(*err)
        pushfielderror(sname);
    return val;
    }

#define GetBoolean(name_, sname_) do {                  \
    p->name_ = GetBoolean_(L, arg, sname_, err);        \
    if(*err) return p;                                  \
} while(0)

/* Strings -------------------------------------------------------------------*/

static const char *GetString_(lua_State *L, int arg, const char *sname, const char *defval, int *err, size_t *len)
/* The caller must Free() the returned string (if not NULL).
 * If len!=NULL, sets len with the string length or with 0 if defval is used. */
    {
    const char *val = NULL;
    int arg_ = pushfield(L, arg, sname);
    int t_ = lua_type(L, arg_);
    *err = 0;
    if(len) *len = 0;
    if(t_ == LUA_TSTRING)
        val = Strdup(L, lua_tolstring(L, arg_, len));
    else if((t_ == LUA_TNONE)||(t_ == LUA_TNIL))
        {
        if(defval)
            val = Strdup(L, defval);
        else
            *err = ERR_NOTPRESENT;
        }
    else
        *err = ERR_TYPE;
    popfield(L, arg_);
    if(*err)
        pushfielderror(sname);
    return val;
    }

#define GetString(name_, sname_) do {                           \
    p->name_ =  GetString_(L, arg, sname_, NULL, err, NULL);    \
    if(*err) return p;                                          \
} while(0)

#define GetStringOpt(name_, sname_) do {                        \
    p->name_ =  GetString_(L, arg, sname_, NULL, err, NULL);    \
    if(*err < 0) return p;                                      \
    if(*err == ERR_NOTPRESENT) { *err = 0; poperror(); }        \
} while(0)

#define GetStringDef(name_, sname_, defval) do {                \
    p->name_ =  GetString_(L, arg, sname_, defval, err, NULL);  \
    if(*err) return p;                                          \
} while(0)

#define GetLString(name_, sname_, len_) /* size_t* */ do {      \
    p->name_ =  GetString_(L, arg, sname_, NULL, err, len_);    \
    if(*err) return p;                                          \
} while(0)

/* Lightuserdata -------------------------------------------------------------*/

#define GetLightuserdataOpt(name_, sname_, TTT) do {    \
    int arg_ = pushfield(L, arg, sname_);               \
    *err = 0;                                           \
    if(lua_isnoneornil(L, arg_))                        \
        p->name_ = NULL;                                \
    else                                                \
        {                                               \
        if(lua_type(L, arg_) != LUA_TLIGHTUSERDATA)     \
            *err = ERR_TYPE;                            \
        else                                            \
            p->name_ = (TTT)lua_touserdata(L, arg_);    \
        }                                               \
    popfield(L, arg_);                                  \
    if(*err)                                            \
        { pushfielderror(sname_); return p; }           \
} while(0)

#define GetLightuserdata GetLightuserdataOpt

/* Enums ---------------------------------------------------------------------*/

#define GetEnum_(name_, sname_, testfunc_, defval_, opt_) do {      \
    int arg_ = pushfield(L, arg, sname_);                           \
    *err = 0;                                                       \
    p->name_ = testfunc_(L, arg_, err);                             \
    popfield(L, arg_);                                              \
    if(opt_ && (*err == ERR_NOTPRESENT))                            \
        { p->name_ = (defval_); *err = 0; }                         \
    else if(*err)                                                   \
        { pushfielderror(sname_); return p; }                       \
} while(0)

#define GetEnum(name_, sname_, testfunc_) GetEnum_(name_, sname_, testfunc_, 0,  0)
#define GetEnumOpt(name_, sname_, testfunc_, defval_) GetEnum_(name_, sname_, testfunc_, defval_, 1)

/* enums without default value (ie required) */
#define GetDescriptorType(name_, sname_) GetEnum(name_, sname_, testdescriptortype)
#define GetImageType(name_, sname_) GetEnum(name_, sname_, testimagetype)
#define GetImageViewType(name_, sname_) GetEnum(name_, sname_, testimageviewtype)
#define GetDescriptorUpdateTemplateType(name_, sname_) GetEnum(name_, sname_, testdescriptorupdatetemplatetype)
#define GetQueueGlobalPriority(name_, sname_) GetEnum(name_, sname_, testqueueglobalpriority)

#define GetCommandBufferLevel(name_, sname_) GetEnum(name_, sname_, testcommandbufferlevel)
#define GetQueryType(name_, sname_) GetEnum(name_, sname_, testquerytype)
#define GetDiscardRectangleMode(name_, sname_) GetEnum(name_, sname_, testdiscardrectanglemode)
#define GetDeviceEventType(name_, sname_) GetEnum(name_, sname_, testdeviceeventtype)
#define GetDisplayEventType(name_, sname_) GetEnum(name_, sname_, testdisplayeventtype)
#define GetDisplayPowerState(name_, sname_) GetEnum(name_, sname_, testdisplaypowerstate)
#define GetTessellationDomainOrigin(name_, sname_) GetEnum(name_, sname_, testtessellationdomainorigin)
#define GetSubpassContents(name_, sname_) GetEnum(name_, sname_, testsubpasscontents)
#define GetObjectType(name_, sname_) GetEnum(name_, sname_, testobjecttype)
#define GetTimeDomain(name_, sname_) GetEnum(name_, sname_, testtimedomain)
#define GetSemaphoreType(name_, sname_) GetEnum(name_, sname_, testsemaphoretype)
#define GetProvokingVertexMode(name_, sname_) GetEnum(name_, sname_, testprovokingvertexmode)
#define GetLineRasterizationMode(name_, sname_) GetEnum(name_, sname_, testlinerasterizationmode)

/* enums with default value (ie optional) */
#define GetPipelineBindPoint(name_, sname_) GetEnumOpt(name_, sname_, testpipelinebindpoint, VK_PIPELINE_BIND_POINT_GRAPHICS)
#define GetSharingMode(name_, sname_) GetEnumOpt(name_, sname_, testsharingmode, VK_SHARING_MODE_EXCLUSIVE)
#define GetImageLayout(name_, sname_) GetEnumOpt(name_, sname_, testimagelayout, VK_IMAGE_LAYOUT_UNDEFINED)
#define GetCompareOp(name_, sname_) GetEnumOpt(name_, sname_, testcompareop, VK_COMPARE_OP_NEVER)
#define GetBlendFactor(name_, sname_) GetEnumOpt(name_, sname_, testblendfactor, VK_BLEND_FACTOR_ZERO)
#define GetBlendOp(name_, sname_) GetEnumOpt(name_, sname_, testblendop, VK_BLEND_OP_ADD)
#define GetStencilOp(name_, sname_) GetEnumOpt(name_, sname_, teststencilop, VK_STENCIL_OP_KEEP)
#define GetFormat(name_, sname_) GetEnumOpt(name_, sname_, testformat, VK_FORMAT_UNDEFINED)
#define GetAttachmentLoadOp(name_, sname_) GetEnumOpt(name_, sname_, testattachmentloadop, VK_ATTACHMENT_LOAD_OP_DONT_CARE)
#define GetAttachmentStoreOp(name_, sname_) GetEnumOpt(name_, sname_, testattachmentstoreop, VK_ATTACHMENT_STORE_OP_DONT_CARE)
#define GetFilter(name_, sname_) GetEnumOpt(name_, sname_, testfilter, VK_FILTER_NEAREST)
#define GetSamplerMipmapMode(name_, sname_) GetEnumOpt(name_, sname_, testsamplermipmapmode, VK_SAMPLER_MIPMAP_MODE_NEAREST)
#define GetSamplerAddressMode(name_, sname_) GetEnumOpt(name_, sname_, testsampleraddressmode, VK_SAMPLER_ADDRESS_MODE_REPEAT)
#define GetBorderColor(name_, sname_) GetEnumOpt(name_, sname_, testbordercolor, VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK)
#define GetComponentSwizzle(name_, sname_) GetEnumOpt(name_, sname_, testcomponentswizzle, VK_COMPONENT_SWIZZLE_IDENTITY)
#define GetImageTiling(name_, sname_) GetEnumOpt(name_, sname_, testimagetiling, VK_IMAGE_TILING_OPTIMAL)
#define GetTopology(name_, sname_) GetEnumOpt(name_, sname_, testprimitivetopology, VK_PRIMITIVE_TOPOLOGY_POINT_LIST)
#define GetPolygonMode(name_, sname_) GetEnumOpt(name_, sname_, testpolygonmode, VK_POLYGON_MODE_FILL)
#define GetFrontFace(name_, sname_) GetEnumOpt(name_, sname_, testfrontface, VK_FRONT_FACE_COUNTER_CLOCKWISE)
#define GetVertexInputRate(name_, sname_) GetEnumOpt(name_, sname_, testvertexinputrate, VK_VERTEX_INPUT_RATE_VERTEX)
#define GetLogicOp(name_, sname_) GetEnumOpt(name_, sname_, testlogicop, VK_LOGIC_OP_CLEAR)
#define GetColorSpace(name_, sname_) GetEnumOpt(name_, sname_, testcolorspace, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR)
#define GetPresentMode(name_, sname_) GetEnumOpt(name_, sname_, testpresentmode, VK_PRESENT_MODE_FIFO_KHR)
#define GetBlendOverlap(name_, sname_) GetEnumOpt(name_, sname_, testblendoverlap, VK_BLEND_OVERLAP_UNCORRELATED_EXT)
#define GetSamplerReductionMode(name_, sname_) GetEnumOpt(name_, sname_, testsamplerreductionmode, VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT)
#define GetSamplerYcbcrModelConversion(name_, sname_) GetEnumOpt(name_, sname_, testsamplerycbcrmodelconversion, VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY)
#define GetSamplerYcbcrRange(name_, sname_) GetEnumOpt(name_, sname_, testsamplerycbcrrange, VK_SAMPLER_YCBCR_RANGE_ITU_FULL)
#define GetChromaLocation(name_, sname_) GetEnumOpt(name_, sname_, testchromalocation, VK_CHROMA_LOCATION_COSITED_EVEN)
#define GetConservativeRasterizationMode(name_, sname_) GetEnumOpt(name_, sname_, testconservativerasterizationmode, VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT)

/* Structs -------------------------------------------------------------------*/

/* For fields defined as:
 * VkXxx *name;
 */
#define GetStructp(name_, VkXxx, sname_)    do {                \
    arg1 = pushfield(L, arg, sname_);                           \
    p->name_ = zcheck##VkXxx(L, arg1, err);                     \
    popfield(L, arg1);                                          \
    if(*err < 0) { prependfield(sname_); return p; }            \
    else if(*err == ERR_NOTPRESENT) poperror();                 \
} while(0)
#define FreeStructp(name_, VkXxx) do {                          \
    if(p->name_) zfree##VkXxx(L, p->name_, 1);                  \
} while(0)

/* For fields defined as:
 * VkXxx name;
 */
#define GetStruct_(name_, sname_, VkXxx, opt_) do {                 \
    int arg_ = pushfield(L, arg, sname_);                           \
    VkXxx *tmp = zcheck##VkXxx(L, arg_, err);                       \
    if(tmp)                                                         \
        { memcpy(&(p->name_), tmp, sizeof(VkXxx)); Free(L, tmp); }  \
    popfield(L, arg_);                                              \
    if(*err)                                                        \
        {                                                           \
        switch(*err)                                                \
            {                                                       \
            case ERR_NOTPRESENT: if(opt_) /*@@ *err=0; */ break; /* else fallthrough */\
            case ERR_TABLE:                                         \
            case ERR_MEMORY:                                        \
            case ERR_EMPTY:                                         \
                { pushfielderror(sname_); return p; }               \
            default:                                                \
                { prependfield(sname_); return p; }                 \
            }                                                       \
        }                                                           \
} while(0)

#define GetStruct(name_, sname_, VkXxx) GetStruct_(name_, sname_, VkXxx, 0)
#define GetStructOpt(name_, sname_, VkXxx) GetStruct_(name_, sname_, VkXxx, 1)
#define FreeStruct(name_, VkXxx) zfree##VkXxx(L, &p->name_, /*base=*/ 0)

/* For arrays of fixed size defined as
 * VkXxx name[n];
 */
#define GetStructArrayOpt(name_, sname_, n_, VkXxx) do { /* arrays of fixed size */\
    VkXxx *tmp;                                                     \
    int arg1_, arg2_, t_, i_;                                       \
    arg1_ = pushfield(L, arg, sname_);                              \
    t_ = lua_type(L, arg1_);                                        \
    *err = 0;                                                       \
    if(t_ != LUA_TTABLE)                                            \
        {                                                           \
        popfield(L, arg1_);                                         \
        if(t_ == LUA_TNIL || t_ == LUA_TNONE)                       \
            *err = ERR_NOTPRESENT;                                  \
        else                                                        \
            { *err=ERR_TABLE; pushfielderror(sname_); return p; }   \
        }                                                           \
    else {                                                          \
        for(i_=0; i_ <(n_); i_++)                                   \
            {                                                       \
            lua_rawgeti(L, arg1_, i_+1);                            \
            arg2_ = lua_gettop(L);                                  \
            tmp = zcheck##VkXxx(L, arg2_, err);                     \
            if(tmp)                                                 \
                { memcpy(&(p->name_[i_]), tmp, sizeof(VkXxx)); Free(L, tmp); } \
            popfield(L, arg2_);                                     \
            if(*err < 0) break;                                     \
            }                                                       \
        popfield(L, arg1_);                                         \
        if(*err < 0)                                                \
            {                                                       \
            switch(*err)                                            \
                {                                                   \
                case ERR_TABLE:                                     \
                case ERR_MEMORY:                                    \
                case ERR_EMPTY:                                     \
                    pushfielderror(sname_); return p;               \
                default:                                            \
                    prependfield(sname_); return p;                 \
                }                                                   \
            }                                                       \
        }                                                           \
} while(0)

/* Objects -------------------------------------------------------------------*/

#define GetObject_(name_, sname_, TTT, ttt, opt_) do {  \
/* eg: TTT = VkRenderPass, ttt = render_pass */         \
    int arg_ = pushfield(L, arg, sname_);               \
    *err = 0;                                           \
    if(lua_isnoneornil(L, arg_))                        \
        {                                               \
        p->name_ = 0;                                   \
        if(!opt_) *err = ERR_NOTPRESENT;                \
        }                                               \
    else                                                \
        {                                               \
        p->name_ = test##ttt(L, arg_, NULL);            \
        if(!p->name_) *err = ERR_TYPE;                  \
        }                                               \
    popfield(L, arg_);                                  \
    if(*err)                                            \
        { pushfielderror(sname_);  return p; }          \
} while(0)

#define GetObject(name_, sname_, TTT, ttt) GetObject_(name_, sname_, TTT, ttt, 0)
#define GetObjectOpt(name_, sname_, TTT, ttt) GetObject_(name_, sname_, TTT, ttt, 1)
#define GetRenderPass(name_, sname_) GetObject(name_, sname_, VkRenderPass, render_pass)
#define GetRenderPassOpt(name_, sname_) GetObjectOpt(name_, sname_, VkRenderPass, render_pass)
#define GetFramebuffer(name_, sname_) GetObject(name_, sname_, VkFramebuffer, framebuffer)
#define GetFramebufferOpt(name_, sname_) GetObjectOpt(name_, sname_, VkFramebuffer, framebuffer)
#define GetBuffer(name_, sname_) GetObject(name_, sname_, VkBuffer, buffer)
#define GetBufferOpt(name_, sname_) GetObjectOpt(name_, sname_, VkBuffer, buffer)
#define GetImage(name_, sname_) GetObject(name_, sname_, VkImage, image)
#define GetImageOpt(name_, sname_) GetObjectOpt(name_, sname_, VkImage, image)
#define GetDeviceMemory(name_, sname_) GetObject(name_, sname_, VkDeviceMemory, device_memory)
#define GetShaderModule(name_, sname_) GetObject(name_, sname_, VkShaderModule, shader_module)
#define GetPipelineLayout(name_, sname_) GetObject(name_, sname_, VkPipelineLayout, pipeline_layout)
#define GetPipelineLayoutOpt(name_, sname_) GetObjectOpt(name_, sname_, VkPipelineLayout, pipeline_layout)
#define GetPipeline(name_, sname_) GetObject(name_, sname_, VkPipeline, pipeline)
#define GetPipelineOpt(name_, sname_) GetObjectOpt(name_, sname_, VkPipeline, pipeline)
#define GetSurface(name_, sname_) GetObject(name_, sname_, VkSurfaceKHR, surface)
#define GetSwapchain(name_, sname_) GetObject(name_, sname_, VkSwapchainKHR, swapchain)
#define GetSwapchainOpt(name_, sname_) GetObjectOpt(name_, sname_, VkSwapchainKHR, swapchain)
#define GetSampler(name_, sname_) GetObject(name_, sname_, VkSampler, sampler)
#define GetImageView(name_, sname_) GetObject(name_, sname_, VkImageView, image_view)
#define GetImageViewOpt(name_, sname_) GetObject(name_, sname_, VkImageView, image_view)
#define GetDescriptorSet(name_, sname_) GetObject(name_, sname_, VkDescriptorSet, descriptor_set)
#define GetDescriptorSetLayoutOpt(name_, sname_) GetObject(name_, sname_, VkDescriptorSetLayout, descriptor_set_layout)
#define GetValidationCache(name_, sname_) GetObject(name_, sname_, VkValidationCacheEXT, validation_cache)
#define GetSamplerYcbcrConversion(name_, sname_) GetObject(name_, sname_, VkSamplerYcbcrConversion, sampler_ycbcr_conversion)
#define GetSemaphore(name_, sname_) GetObject(name_, sname_, VkSemaphore, semaphore)
#define GetSemaphoreOpt(name_, sname_) GetObjectOpt(name_, sname_, VkSemaphore, semaphore)
#define GetFence(name_, sname_) GetObject(name_, sname_, VkFence, fence)
#define GetFenceOpt(name_, sname_) GetObjectOpt(name_, sname_, VkFence, fence)
#define GetCommandBuffer(name_, sname_) GetObject(name_, sname_, VkCommandBuffer, command_buffer)

/* Integers with special values ----------------------------------------------*/

#define GetSubpass(name_, sname_) /* integer or 'external' */ do {\
    const char *s_;                                 \
    int arg_ = pushfield(L, arg, sname_);            \
    int t_ = lua_type(L, arg_);                     \
    *err = 0;                                       \
    if(t_ == LUA_TSTRING)                           \
        {                                           \
        s_ = lua_tostring(L, arg_);                 \
        if(strcmp(s_, "external") == 0)             \
            p->name_ = VK_SUBPASS_EXTERNAL;          \
        else                                        \
            *err = ERR_VALUE;                       \
        }                                           \
    else if(t_ == LUA_TNONE || t_ == LUA_TNIL)      \
        p->name_ = 0;                                \
    else if(lua_isinteger(L, arg_))                 \
        p->name_ = lua_tointeger(L, arg_);           \
    else                                            \
        *err = ERR_TYPE;                            \
    popfield(L, arg_);                              \
    if(*err)                                        \
        { pushfielderror(sname_); return p; }  \
} while(0)

#define GetTimeout(name_, sname_) {   \
    int arg_ = pushfield(L, arg, sname_);            \
    *err = 0;                                       \
    p->name_ = testtimeout(L, arg_, err);            \
    popfield(L, arg_);                              \
    if(*err)                                        \
        { pushfielderror(sname_);  return p; }       \
} while(0)



/* 'remaining' stands for VK_REMAINING_MIP_LEVELS, VK_REMAINING_ARRAY_LAYERS, etc
 * (provided it has a value of ~0U) */
#define GetIntegerOrRemaining(name_, sname_, defval) /* integer or 'remaining' */ do {\
    const char *s_;                                 \
    int arg_ = pushfield(L, arg, sname_);            \
    int t_ = lua_type(L, arg_);                     \
    *err = 0;                                       \
    if(t_ == LUA_TSTRING)                           \
        {                                           \
        s_ = lua_tostring(L, arg_);                 \
        if(strcmp(s_, "remaining") == 0)            \
            p->name_ = ~0U; /* VK_REMAINING_XXX */   \
        else                                        \
            *err = ERR_VALUE;                       \
        }                                           \
    else if(t_ == LUA_TNONE || t_ == LUA_TNIL)      \
        p->name_ = defval;                           \
    else if(lua_isinteger(L, arg_))                 \
        p->name_ = lua_tointeger(L, arg_);           \
    else                                            \
        *err = ERR_TYPE;                            \
    popfield(L, arg_);                              \
    if(*err)                                        \
        { pushfielderror(sname_); return p; }  \
} while(0)

#define GetIntegerOrWholeSize(name_, sname_) /* integer or 'whole size' */ do {\
    const char *s_;                                 \
    int arg_ = pushfield(L, arg, sname_);            \
    int t_ = lua_type(L, arg_);                     \
    *err = 0;                                       \
    if(t_ == LUA_TSTRING)                           \
        {                                           \
        s_ = lua_tostring(L, arg_);                 \
        if(strcmp(s_, "whole size") == 0)           \
            p->name_ = VK_WHOLE_SIZE;                \
        else                                        \
            *err = ERR_VALUE;                       \
        }                                           \
    else if(t_ == LUA_TNONE || t_ == LUA_TNIL)      \
        p->name_ = VK_WHOLE_SIZE;                    \
    else if(lua_isinteger(L, arg_))                 \
        p->name_ = lua_tointeger(L, arg_);           \
    else                                            \
        *err = ERR_TYPE;                            \
    popfield(L, arg_);                              \
    if(*err)                                        \
        { pushfielderror(sname_); return p; }  \
} while(0)

#define GetAttachment(name_, sname_) /* integer or 'unused', defval = 'unused' */ do {\
    const char *s_;                                 \
    int arg_ = pushfield(L, arg, sname_);            \
    int t_ = lua_type(L, arg_);                     \
    *err = 0;                                       \
    if(t_ == LUA_TSTRING)                           \
        {                                           \
        s_ = lua_tostring(L, arg_);                 \
        if(strcmp(s_, "unused") == 0)               \
            p->name_ = VK_ATTACHMENT_UNUSED;         \
        else                                        \
            *err = ERR_VALUE;                       \
        }                                           \
    else if(t_ == LUA_TNONE || t_ == LUA_TNIL)      \
        p->name_ = VK_ATTACHMENT_UNUSED;             \
    else if(lua_isinteger(L, arg_))                 \
        p->name_ = lua_tointeger(L, arg_);           \
    else                                            \
        *err = ERR_TYPE;                            \
    popfield(L, arg_);                              \
    if(*err)                                        \
        { pushfielderror(sname_); return p; }  \
} while(0)

/*------------------------------------------------------------------------------*
 | Arrays and lists                                                             |
 *------------------------------------------------------------------------------*
 * VkXxx* zcheckarrayVkXxx(lua_State *L, int arg, uint32_t *count, int *err)
 *
 * Checks if the variable at arg on the Lua stack is a list of VkXxx structures.
 * On success, returns an array of VkXxx structs and sets its length in *count.
 * The array must be released by the caller using zfreearray().
 *
 * On error, sets *err to ERR_XXX, *count to 0, leaves an error message on the
 * Lua stack and returns NULL. 
 *
 * This function espects the existence of the zcheckVkXxx function.
 * The returned array must be released with zfreearrayVkXxx().
 * Works only with structures having the sType and pNext fields.
 */

#define ZCHECKARRAY(VkXxx)                                                  \
VkXxx* zcheckarray##VkXxx(lua_State *L, int arg, uint32_t *count, int *err) \
    {                                                                       \
    int arg_;                                                               \
    VkXxx *list, *tmp;                                                      \
    uint32_t i;                                                             \
    *count = 0;                                                             \
    *err = 0;                                                               \
    if(lua_isnoneornil(L, arg))                                             \
        { *err = ERR_NOTPRESENT; lua_pushfstring(L, ": %s", errstring(*err)); return NULL; } \
    if(lua_type(L, arg) != LUA_TTABLE)                                      \
        { *err = ERR_TABLE; lua_pushfstring(L, ": %s", errstring(*err)); return NULL; } \
    *count = lua_rawlen(L, arg);                                            \
    if(*count == 0)                                                         \
        { *err = ERR_EMPTY; lua_pushfstring(L, ": %s", errstring(*err)); return NULL; } \
    list = znewarray##VkXxx(L, *count, err);                                \
    if(!list)                                                               \
        { *count = 0; lua_pushfstring(L, ": %s", errstring(*err)); return NULL; }\
    for(i=0; i<*count; i++)                                                 \
        {                                                                   \
        lua_rawgeti(L, arg, i+1);                                           \
        arg_ = lua_gettop(L);                                               \
        tmp = zcheck##VkXxx(L, arg_, err);                                  \
        if(tmp)                                                             \
            { memcpy(&list[i], tmp, sizeof(VkXxx)); Free(L, tmp); }         \
        lua_remove(L, arg_);                                                \
        if(*err)                                                            \
            {                                                               \
            zfreearray##VkXxx(L, list, *count, 1);                          \
            *count = 0;                                                     \
            /* an error message has been already pushed by zcheckVkXxx() */ \
            lua_pushfstring(L, "%d.%s", i+1, lua_tostring(L, -1));          \
            lua_remove(L, -2);                                              \
            *err = ERR_GENERIC;                                             \
            return NULL;                                                    \
            }                                                               \
        }                                                                   \
    return list;                                                            \
    }

/* Get a variable length list of VkXxxx elements, defined in the parent structure as:
 * uint32_t nameCount;
 * VkXxx    *name;
 */
#define GetList(name_, nameCount_, VkXxx, sname_)   do {                    \
    arg1 = pushfield(L, arg, sname_);                                       \
    p->name_ = zcheckarray##VkXxx(L, arg1, &p->nameCount_, err);            \
    popfield(L, arg1);                                                      \
    if(*err) { prependfield(sname_); return p; }                            \
} while(0)
#define GetListOpt(name_, nameCount_, VkXxx, sname_)    do {                \
    arg1 = pushfield(L, arg, sname_);                                       \
    p->name_ = zcheckarray##VkXxx(L, arg1, &p->nameCount_, err);            \
    popfield(L, arg1);                                                      \
    if(*err == ERR_NOTPRESENT || *err == ERR_EMPTY) { *err=0; poperror(); } \
    else if(*err < 0) { prependfield(sname_); return p; }                   \
} while(0)
#define FreeList(name_, nameCount_, VkXxx) do { /* to be used in the zclear of the parent struct */\
    if(p->name_) zfreearray##VkXxx(L, p->name_, p->nameCount_, 1);          \
} while(0)

#define GetBooleanList(name_, nameCount_, sname_) do {                      \
    arg1 = pushfield(L, arg, sname_);                                       \
    p->name_ = checkbooleanlist(L, arg1, &p->nameCount_, err);              \
    popfield(L, arg1);                                                      \
    if(*err == ERR_NOTPRESENT || *err == ERR_EMPTY) { *err=0; }             \
    else if(*err < 0) { pushfielderror(sname_); return p; }                 \
} while(0)
#define FreeBooleanList(name_) do { /* to be used in the zclear of the parent struct */\
    if(p->name_) Free(L, (void*)p->name_);                                  \
} while(0)

#define GetUint32List(name_, nameCount_, sname_)    do {                    \
    arg1 = pushfield(L, arg, sname_);                                       \
    p->name_ = checkuint32list(L, arg1, &p->nameCount_, err);               \
    popfield(L, arg1);                                                      \
    if(*err == ERR_NOTPRESENT || *err == ERR_EMPTY) { *err=0; }             \
    else if(*err < 0) { pushfielderror(sname_); return p; }                 \
} while(0)
#define FreeUint32List(name_) do { /* to be used in the zclear of the parent struct */\
    if(p->name_) Free(L, (void*)p->name_);                                  \
} while(0)

#define GetInt32List(name_, nameCount_, sname_) do {                        \
    arg1 = pushfield(L, arg, sname_);                                       \
    p->name_ = checkint32list(L, arg1, &p->nameCount_, err);                \
    popfield(L, arg1);                                                      \
    if(*err == ERR_NOTPRESENT || *err == ERR_EMPTY) { *err=0; }             \
    else if(*err < 0) { pushfielderror(sname_); return p; }                 \
} while(0)
#define FreeInt32List(name_) do { /* to be used in the zclear of the parent struct */\
    if(p->name_) Free(L, (void*)p->name_);                                  \
} while(0)

#define GetUint64List(name_, nameCount_, sname_)    do {                    \
    arg1 = pushfield(L, arg, sname_);                                       \
    p->name_ = checkuint64list(L, arg1, &p->nameCount_, err);               \
    popfield(L, arg1);                                                      \
    if(*err == ERR_NOTPRESENT || *err == ERR_EMPTY) { *err=0; }             \
    else if(*err < 0) { pushfielderror(sname_); return p; }                 \
} while(0)
#define FreeUint64List(name_) do { /* to be used in the zclear of the parent struct */\
    if(p->name_) Free(L, (void*)p->name_);                                  \
} while(0)

#define GetFloatList(name_, nameCount_, sname_) do {                    \
    arg1 = pushfield(L, arg, sname_);                                       \
    p->name_ = checkfloatlist(L, arg1, &p->nameCount_, err);                \
    popfield(L, arg1);                                                      \
    if(*err == ERR_NOTPRESENT || *err == ERR_EMPTY) { *err=0; }             \
    else if(*err < 0) { pushfielderror(sname_); return p; }                 \
} while(0)
#define FreeFloatList(name_) do { /* to be used in the zclear of the parent struct */\
    if(p->name_) Free(L, (void*)p->name_);                                  \
} while(0)

#define GetStringList(name_, nameCount_, sname_)    do {                    \
    arg1 = pushfield(L, arg, sname_);                                       \
    p->name_ = (const char* const*)checkstringlist(L, arg1, &p->nameCount_, err);\
    popfield(L, arg1);                                                      \
    if(*err == ERR_NOTPRESENT || *err == ERR_EMPTY) { *err=0; }             \
    else if(*err < 0) { pushfielderror(sname_); return p; }                 \
} while(0)
#define FreeStringList(name_, nameCount_) do { /* to be used in the zclear of the parent struct */\
    if(p->name_) freestringlist(L, (char**)p->name_, p->nameCount_);    \
} while(0)

#define GetObjectList(name_, nameCount_, otype_,  sname_)   do {            \
    arg1 = pushfield(L, arg, sname_);                                       \
    p->name_ = check##otype_##list(L, arg1, &p->nameCount_, err, NULL);     \
    popfield(L, arg1);                                                      \
    if(*err == ERR_NOTPRESENT || *err == ERR_EMPTY) { *err=0; /*or ERR_NOTPRESENT ? @@ */ }\
    else if(*err < 0) { pushfielderror(sname_); return p; }                 \
} while(0)
#define FreeObjectList(name_) do { /* to be used in the zclear of the parent struct */\
    if(p->name_) Free(L, (void*)p->name_);                                  \
} while(0)

#define GetFlagsList(name_, nameCount_, sname_) do {                        \
    arg1 = pushfield(L, arg, sname_);                                       \
    p->name_ = checkflagslist(L, arg1, &p->nameCount_, err);                \
    popfield(L, arg1);                                                      \
    if(*err == ERR_NOTPRESENT || *err == ERR_EMPTY) { *err=0; }             \
    else if(*err < 0) { pushfielderror(sname_); return p; }                 \
} while(0)
#define FreeFlagsList(name_) do { /* to be used in the zclear of the parent struct */\
    if(p->name_) Free(L, (void*)p->name_);                                  \
} while(0)

#define GetEnumList(name_, nameCount_, etype_, sname_) do {                 \
    arg1 = pushfield(L, arg, sname_);                                       \
    p->name_ = check##etype_##list(L, arg1, &p->nameCount_, err);           \
    popfield(L, arg1);                                                      \
    if(*err == ERR_NOTPRESENT || *err == ERR_EMPTY) { *err=0; }             \
    else if(*err < 0) { pushfielderror(sname_); return p; }                 \
} while(0)
#define FreeEnumList(name_, etype_) do { /* to be used in the zclear of the parent struct */\
    if(p->name_) free##etype_##list(L, p->name_);                           \
} while(0)

/********************************************************************************
 * Untyped structs                                                              *
 ********************************************************************************/

ZCHECK_BEGIN(VkViewport)
    checktable(arg);
    newstruct(VkViewport);
    GetNumber(x, "x");
    GetNumber(y, "y");
    GetNumber(width, "width");
    GetNumber(height, "height");
    GetNumber(minDepth, "min_depth");
    GetNumber(maxDepth, "max_depth");
ZCHECK_END
ZPUSH_BEGIN(VkViewport)
    lua_newtable(L);
    SetNumber(x, "x");
    SetNumber(y, "y");
    SetNumber(width, "width");
    SetNumber(height, "height");
    SetNumber(minDepth, "min_depth");
    SetNumber(maxDepth, "max_depth");
ZPUSH_END
ZCHECKARRAY(VkViewport)

ZCHECK_BEGIN(VkOffset2D)
    checktable(arg);
    newstruct(VkOffset2D);
    GetInteger(x, "x");
    GetInteger(y, "y");
ZCHECK_END
ZPUSH_BEGIN(VkOffset2D)
    lua_newtable(L);
    SetInteger(x, "x");
    SetInteger(y, "y");
ZPUSH_END

ZCHECK_BEGIN(VkOffset3D)
    checktable(arg);
    newstruct(VkOffset3D);
    GetInteger(x, "x");
    GetInteger(y, "y");
    GetInteger(z, "z");
ZCHECK_END
ZPUSH_BEGIN(VkOffset3D)
    lua_newtable(L);
    SetInteger(x, "x");
    SetInteger(y, "y");
    SetInteger(z, "z");
ZPUSH_END

ZCHECK_BEGIN(VkExtent2D)
    checktable(arg);
    newstruct(VkExtent2D);
    GetInteger(width, "width");
    GetInteger(height, "height");
ZCHECK_END
ZPUSH_BEGIN(VkExtent2D)
    lua_newtable(L);
    SetInteger(width, "width");
    SetInteger(height, "height");
ZPUSH_END

ZCHECK_BEGIN(VkExtent3D)
    checktable(arg);
    newstruct(VkExtent3D);
    GetInteger(width, "width");
    GetInteger(height, "height");
    GetInteger(depth, "depth");
ZCHECK_END
ZPUSH_BEGIN(VkExtent3D)
    lua_newtable(L);
    SetInteger(width, "width");
    SetInteger(height, "height");
    SetInteger(depth, "depth");
ZPUSH_END

ZCHECK_BEGIN(VkRect2D)
    checktable(arg);
    newstruct(VkRect2D);
    GetStructOpt(offset, "offset", VkOffset2D);
    GetStructOpt(extent, "extent", VkExtent2D);
ZCHECK_END
ZPUSH_BEGIN(VkRect2D)
    lua_newtable(L);
    SetStruct(offset, "offset", VkOffset2D);
    SetStruct(extent, "extent", VkExtent2D);
ZPUSH_END
ZCHECKARRAY(VkRect2D)

ZCHECK_BEGIN(VkXYColorEXT)
    checktable(arg);
    newstruct(VkXYColorEXT);
    GetNumber(x, "x");
    GetNumber(y, "y");
ZCHECK_END

ZCHECK_BEGIN(VkComponentMapping)
    checktable(arg);
    newstruct(VkComponentMapping);
    GetComponentSwizzle(r, "r");
    GetComponentSwizzle(g, "g");
    GetComponentSwizzle(b, "b");
    GetComponentSwizzle(a, "a");
ZCHECK_END
ZPUSH_BEGIN(VkComponentMapping)
    lua_newtable(L);
    SetEnum(r, "r", pushcomponentswizzle);
    SetEnum(g, "g", pushcomponentswizzle);
    SetEnum(b, "b", pushcomponentswizzle);
    SetEnum(a, "a", pushcomponentswizzle);
ZPUSH_END

ZCHECK_BEGIN(VkSampleLocationEXT)
    checktable(arg);
    newstruct(VkSampleLocationEXT);
    GetNumber(x, "x");
    GetNumber(y, "y");
ZCHECK_END
ZPUSH_BEGIN(VkSampleLocationEXT)
    lua_newtable(L);
    SetNumber(x, "x");
    SetNumber(y, "y");
ZPUSH_END
ZCHECKARRAY(VkSampleLocationEXT)

ZCHECK_BEGIN(VkImageSubresourceRange)
    checktable(arg);
    newstruct(VkImageSubresourceRange);
    GetFlags(aspectMask, "aspect_mask");
    GetInteger(baseMipLevel, "base_mip_level");
    GetIntegerOrRemaining(levelCount, "level_count", 1);
    GetInteger(baseArrayLayer, "base_array_layer");
    GetIntegerOrRemaining(layerCount, "layer_count", 1);
ZCHECK_END
ZPUSH_BEGIN(VkImageSubresourceRange)
    lua_newtable(L);
    SetFlags(aspectMask, "aspect_mask");
    SetInteger(baseMipLevel, "base_mip_level");
    SetInteger(levelCount, "level_count");
    SetInteger(baseArrayLayer, "base_array_layer");
    SetInteger(layerCount, "layer_count");
ZPUSH_END
ZCHECKARRAY(VkImageSubresourceRange)

ZPUSH_BEGIN(VkExtensionProperties)
    lua_newtable(L);
    SetString(extensionName, "extension_name");
    SetInteger(specVersion, "spec_version");
ZPUSH_END

ZPUSH_BEGIN(VkLayerProperties)
    lua_newtable(L);
    SetString(layerName, "layer_name");
    SetInteger(specVersion, "spec_version");
    SetInteger(implementationVersion, "implementation_version");
    SetString(description, "description");
ZPUSH_END

ZCHECK_BEGIN(VkClearColorValue) 
    int i, t;
    const char* s;
    int colortype = -1;
    checktable(arg);
    newstruct(VkClearColorValue);
    getfield(L, arg, "t");
    s = luaL_optstring(L, -1, NULL);
    if(!s || (strcmp(s, "float32")==0)) colortype = 0;
    else if(strcmp(s, "int32")==0) colortype = 1;
    else if(strcmp(s, "uint32")==0) colortype = 2;
    else { lua_pop(L, 1); lua_pushstring(L, "t"); *err = ERR_VALUE; return p; }
    lua_pop(L, 1);
    if(colortype == 0) /* float32 */
        {
        for(i = 0; i < 4; i++)
            {
            t = lua_rawgeti(L, arg, i + 1);
            if(t != LUA_TNUMBER)
                { lua_pop(L, 1); lua_pushfstring(L, "%d", i+1); *err = ERR_TYPE; return p; }
            p->float32[i] = lua_tonumber(L, -1);
            lua_pop(L, 1);
            }
        }
    else if(colortype == 1) /* int32 */
        {
        for(i = 0; i < 4; i++)
            {
            lua_rawgeti(L, arg, i + 1);
            if(!lua_isinteger(L, -1))
                { lua_pop(L, 1); lua_pushfstring(L, "%d", i+1); *err = ERR_TYPE; return p; } 
            p->int32[i] = lua_tointeger(L, -1);
            lua_pop(L, 1);
            }
        }
    else if(colortype == 2) /* uint32 */
        {
        for(i = 0; i < 4; i++)
            {
            lua_rawgeti(L, arg, i + 1);
            if(!lua_isinteger(L, -1))
                { lua_pop(L, 1); lua_pushfstring(L, "%d", i+1);  *err = ERR_TYPE; return p; } 
            p->uint32[i] = lua_tointeger(L, -1);
            lua_pop(L, 1);
            }
        }
ZCHECK_END

ZCHECK_BEGIN(VkClearValue)
    int t;
    checktable(arg);
    newstruct(VkClearValue);
    t = getfield(L, arg, "depth");
    lua_pop(L, 1);
    if(t==LUA_TNIL)
        {
        GetStruct(color, "color", VkClearColorValue);
        *err = 0;
        return p;
        }
    GetNumber(depthStencil.depth, "depth");
    GetInteger(depthStencil.stencil, "stencil");
ZCHECK_END
ZCHECKARRAY(VkClearValue)

ZCHECK_BEGIN(VkClearAttachment)
    checktable(arg);
    newstruct(VkClearAttachment);
    GetFlags(aspectMask, "aspect_mask");
    GetAttachment(colorAttachment, "color_attachment");
    GetStruct(clearValue, "clear_value", VkClearValue);
ZCHECK_END
ZCHECKARRAY(VkClearAttachment)

ZCHECK_BEGIN(VkClearRect)
    checktable(arg);
    newstruct(VkClearRect);
    GetStructOpt(rect, "rect", VkRect2D);
    GetInteger(baseArrayLayer, "base_array_layer");
    GetInteger(layerCount, "layer_count");
ZCHECK_END
ZCHECKARRAY(VkClearRect)

ZCHECK_BEGIN(VkImageSubresourceLayers)
    checktable(arg);
    newstruct(VkImageSubresourceLayers);
    GetFlags(aspectMask, "aspect_mask");
    GetInteger(mipLevel, "mip_level");
    GetInteger(baseArrayLayer, "base_array_layer");
    GetInteger(layerCount, "layer_count");
ZCHECK_END

ZCHECK_BEGIN(VkImageCopy)
    checktable(arg);
    newstruct(VkImageCopy);
    GetStruct(srcSubresource, "src_subresource", VkImageSubresourceLayers);
    GetStructOpt(srcOffset, "src_offset", VkOffset3D);
    GetStruct(dstSubresource, "dst_subresource", VkImageSubresourceLayers);
    GetStructOpt(dstOffset, "dst_offset", VkOffset3D);
    GetStructOpt(extent, "extent", VkExtent3D);
ZCHECK_END
ZCHECKARRAY(VkImageCopy)

ZCHECK_BEGIN(VkImageBlit)
    checktable(arg);
    newstruct(VkImageBlit);
    GetStruct(srcSubresource, "src_subresource", VkImageSubresourceLayers);
    GetStructArrayOpt(srcOffsets, "src_offsets", 2, VkOffset3D);
    GetStruct(dstSubresource, "dst_subresource", VkImageSubresourceLayers);
    GetStructArrayOpt(dstOffsets, "dst_offsets", 2, VkOffset3D);
ZCHECK_END
ZCHECKARRAY(VkImageBlit)

ZCHECK_BEGIN(VkBufferImageCopy)
    checktable(arg);
    newstruct(VkBufferImageCopy);
    GetInteger(bufferOffset, "buffer_offset");
    GetInteger(bufferRowLength, "buffer_row_length");
    GetInteger(bufferImageHeight, "buffer_image_height");
    GetStruct(imageSubresource, "image_subresource", VkImageSubresourceLayers);
    GetStructOpt(imageOffset, "image_offset", VkOffset3D);
    GetStructOpt(imageExtent, "image_extent", VkExtent3D);
ZCHECK_END
ZCHECKARRAY(VkBufferImageCopy)

ZCHECK_BEGIN(VkImageResolve)
    checktable(arg);
    newstruct(VkImageResolve);
    GetStruct(srcSubresource, "src_subresource", VkImageSubresourceLayers);
    GetStructOpt(srcOffset, "src_offset", VkOffset3D);
    GetStruct(dstSubresource, "dst_subresource", VkImageSubresourceLayers);
    GetStructOpt(dstOffset, "dst_offset", VkOffset3D);
    GetStructOpt(extent, "extent", VkExtent3D);
ZCHECK_END
ZCHECKARRAY(VkImageResolve)

ZCHECK_BEGIN(VkBufferCopy)
    checktable(arg);
    newstruct(VkBufferCopy);
    GetInteger(srcOffset, "src_offset");
    GetInteger(dstOffset, "dst_offset");
    GetInteger(size, "size");
ZCHECK_END
ZCHECKARRAY(VkBufferCopy)

ZCHECK_BEGIN(VkSparseMemoryBind)
    checktable(arg);
    newstruct(VkSparseMemoryBind);
    GetInteger(resourceOffset, "resource_offset");
    GetInteger(size, "size");
    GetDeviceMemory(memory, "memory");
    GetInteger(memoryOffset, "memory_offset");
    GetFlags(flags, "flags");
ZCHECK_END
ZCHECKARRAY(VkSparseMemoryBind)

ZCHECK_BEGIN(VkImageSubresource)
    checktable(arg);
    newstruct(VkImageSubresource);
    GetFlags(aspectMask, "aspect_mask");
    GetInteger(mipLevel, "mip_level");
    GetInteger(arrayLayer, "array_layer");
ZCHECK_END

ZCHECK_BEGIN(VkSparseImageMemoryBind)
    checktable(arg);
    newstruct(VkSparseImageMemoryBind);
    GetStruct(subresource, "subresource", VkImageSubresource);
    GetStructOpt(offset, "offset", VkOffset3D);
    GetStructOpt(extent, "extent", VkExtent3D);
    GetDeviceMemory(memory, "memory");
    GetInteger(memoryOffset, "memory_offset");
    GetFlags(flags, "flags");
ZCHECK_END
ZCHECKARRAY(VkSparseImageMemoryBind)

ZCLEAR_BEGIN(VkSparseBufferMemoryBindInfo)
    FreeList(pBinds, bindCount, VkSparseMemoryBind);
ZCLEAR_END
ZCHECK_BEGIN(VkSparseBufferMemoryBindInfo)
    checktable(arg);
    newstruct(VkSparseBufferMemoryBindInfo);
    GetBuffer(buffer, "buffer");
    GetList(pBinds, bindCount, VkSparseMemoryBind, "binds");
ZCHECK_END
ZCHECKARRAY(VkSparseBufferMemoryBindInfo)

ZCLEAR_BEGIN(VkSparseImageOpaqueMemoryBindInfo)
    FreeList(pBinds, bindCount, VkSparseMemoryBind);
ZCLEAR_END
ZCHECK_BEGIN(VkSparseImageOpaqueMemoryBindInfo)
    checktable(arg);
    newstruct(VkSparseImageOpaqueMemoryBindInfo);
    GetImage(image, "image");
    GetList(pBinds, bindCount, VkSparseMemoryBind, "binds");
ZCHECK_END
ZCHECKARRAY(VkSparseImageOpaqueMemoryBindInfo)

ZCLEAR_BEGIN(VkSparseImageMemoryBindInfo)
    FreeList(pBinds, bindCount, VkSparseImageMemoryBind);
ZCLEAR_END
ZCHECK_BEGIN(VkSparseImageMemoryBindInfo)
    checktable(arg);
    newstruct(VkSparseImageMemoryBindInfo);
    GetImage(image, "image");
    GetList(pBinds, bindCount, VkSparseImageMemoryBind, "binds");
ZCHECK_END
ZCHECKARRAY(VkSparseImageMemoryBindInfo)

ZPUSH_BEGIN(VkSubresourceLayout) 
    lua_newtable(L);
    SetInteger(offset, "offset");
    SetInteger(size, "size");
    SetInteger(rowPitch, "row_pitch");
    SetInteger(arrayPitch, "array_pitch");
    SetInteger(depthPitch, "depth_pitch");
ZPUSH_END

ZCHECK_BEGIN(VkSpecializationMapEntry)
    checktable(arg);
    newstruct(VkSpecializationMapEntry);
    GetInteger(constantID, "constant_id");
    GetInteger(offset, "offset");
    GetInteger(size, "size");
ZCHECK_END
ZCHECKARRAY(VkSpecializationMapEntry)

ZCLEAR_BEGIN(VkSpecializationInfo)
    FreeList(pMapEntries, mapEntryCount, VkSpecializationMapEntry);
    if(p->pData) Free(L, (void*)p->pData);
ZCLEAR_END
ZCHECK_BEGIN(VkSpecializationInfo)
    size_t size;
    const char* data;
    checktable(arg);
    newstruct(VkSpecializationInfo);
    GetListOpt(pMapEntries, mapEntryCount, VkSpecializationMapEntry, "map_entries");
#define F "data"
    arg1 = pushfield(L, arg, F);
    data = lua_tolstring(L, arg1, &size);
    if(!data || size == 0)
        { popfield(L, arg1); *err=ERR_LENGTH; pushfielderror(F); return p; }
    p->pData = MallocNoErr(L, size);
    if(!p->pData)
        { popfield(L, arg1); *err=ERR_MEMORY; pushfielderror(F); return p; }
    memcpy((void*)p->pData, data, size);
    p->dataSize = size;
    popfield(L, arg1);
#undef F
ZCHECK_END

ZCHECK_BEGIN(VkVertexInputBindingDescription)
    checktable(arg);
    newstruct(VkVertexInputBindingDescription);
    GetInteger(binding, "binding");
    GetInteger(stride, "stride");
    GetVertexInputRate(inputRate, "input_rate");
ZCHECK_END
ZCHECKARRAY(VkVertexInputBindingDescription)

ZCHECK_BEGIN(VkVertexInputBindingDescription2EXT)
    checktable(arg);
    newstruct(VkVertexInputBindingDescription2EXT);
    GetInteger(binding, "binding");
    GetInteger(stride, "stride");
    GetVertexInputRate(inputRate, "input_rate");
    GetInteger(divisor, "divisor");
ZCHECK_END
ZCHECKARRAY(VkVertexInputBindingDescription2EXT)

ZCHECK_BEGIN(VkVertexInputAttributeDescription)
    checktable(arg);
    newstruct(VkVertexInputAttributeDescription);
    GetInteger(location, "location");
    GetInteger(binding, "binding");
    GetFormat(format, "format");
    GetInteger(offset, "offset");
ZCHECK_END
ZCHECKARRAY(VkVertexInputAttributeDescription)

ZCHECK_BEGIN(VkVertexInputAttributeDescription2EXT)
    checktable(arg);
    newstruct(VkVertexInputAttributeDescription2EXT);
    GetInteger(location, "location");
    GetInteger(binding, "binding");
    GetFormat(format, "format");
    GetInteger(offset, "offset");
ZCHECK_END
ZCHECKARRAY(VkVertexInputAttributeDescription2EXT)

ZCHECK_BEGIN(VkStencilOpState)
    checktable(arg);
    newstruct(VkStencilOpState);
    GetStencilOp(failOp, "fail_op");
    GetStencilOp(passOp, "pass_op");
    GetStencilOp(depthFailOp, "depth_fail_op");
    GetCompareOp(compareOp, "compare_op");
    GetInteger(compareMask, "compare_mask");
    GetInteger(writeMask, "write_mask");
    GetInteger(reference, "reference");
ZCHECK_END

ZCHECK_BEGIN(VkPipelineColorBlendAttachmentState)
    checktable(arg);
    newstruct(VkPipelineColorBlendAttachmentState);
    GetBoolean(blendEnable, "blend_enable");
    GetBlendFactor(srcColorBlendFactor, "src_color_blend_factor");
    GetBlendFactor(dstColorBlendFactor, "dst_color_blend_factor");
    GetBlendOp(colorBlendOp, "color_blend_op");
    GetBlendFactor(srcAlphaBlendFactor, "src_alpha_blend_factor");
    GetBlendFactor(dstAlphaBlendFactor, "dst_alpha_blend_factor");
    GetBlendOp(alphaBlendOp, "alpha_blend_op");
    GetFlags(colorWriteMask, "color_write_mask");
ZCHECK_END
ZCHECKARRAY(VkPipelineColorBlendAttachmentState)

ZCHECK_BEGIN(VkRectLayerKHR)
    checktable(arg);
    newstruct(VkRectLayerKHR);
    GetStruct(offset, "offset", VkOffset2D);
    GetStruct(extent, "extent", VkExtent2D);
    GetInteger(layer, "layer");
ZCHECK_END
ZCHECKARRAY(VkRectLayerKHR)

ZCLEAR_BEGIN(VkPresentRegionKHR)
    FreeList(pRectangles, rectangleCount, VkRectLayerKHR);
ZCLEAR_END
ZCHECK_BEGIN(VkPresentRegionKHR)
    checktable(arg);
    newstruct(VkPresentRegionKHR);
    GetListOpt(pRectangles, rectangleCount, VkRectLayerKHR, "rectangles");
ZCHECK_END
ZCHECKARRAY(VkPresentRegionKHR)

ZCHECK_BEGIN(VkDescriptorImageInfo)
    checktable(arg);
    newstruct(VkDescriptorImageInfo);
    GetSampler(sampler, "sampler");
    GetImageView(imageView, "image_view");
    GetImageLayout(imageLayout, "image_layout");
ZCHECK_END
ZCHECKARRAY(VkDescriptorImageInfo)

ZCHECK_BEGIN(VkDescriptorBufferInfo)
    checktable(arg);
    newstruct(VkDescriptorBufferInfo);
    GetBuffer(buffer, "buffer");
    GetInteger(offset, "offset");
    GetIntegerOrWholeSize(range, "range");
ZCHECK_END
ZCHECKARRAY(VkDescriptorBufferInfo)

ZCHECK_BEGIN(VkDisplayModeParametersKHR)
    checktable(arg);
    newstruct(VkDisplayModeParametersKHR);
    GetStruct(visibleRegion, "visible_region", VkExtent2D);
    GetInteger(refreshRate, "refresh_rate");
ZCHECK_END
ZPUSH_BEGIN(VkDisplayModeParametersKHR)
    lua_newtable(L);
    SetStruct(visibleRegion, "visible_region", VkExtent2D);
    SetInteger(refreshRate, "refresh_rate");
ZPUSH_END

ZCHECK_BEGIN(VkDescriptorUpdateTemplateEntry)
    checktable(arg);
    newstruct(VkDescriptorUpdateTemplateEntry);
    GetInteger(dstBinding, "dst_binding");
    GetInteger(dstArrayElement, "dst_array_element");
    GetInteger(descriptorCount, "descriptor_count");
    GetDescriptorType(descriptorType, "descriptor_type");
    GetInteger(offset, "offset");
    GetInteger(stride, "stride");
ZCHECK_END
ZCHECKARRAY(VkDescriptorUpdateTemplateEntry)

ZCHECK_BEGIN(VkAttachmentDescription)
    checktable(arg);
    newstruct(VkAttachmentDescription);
    GetFlags(flags, "flags");
    GetFormat(format, "format");
    GetSamples(samples, "samples");
    GetAttachmentLoadOp(loadOp, "load_op");
    GetAttachmentStoreOp(storeOp, "store_op");
    GetAttachmentLoadOp(stencilLoadOp, "stencil_load_op");
    GetAttachmentStoreOp(stencilStoreOp, "stencil_store_op");
    GetImageLayout(initialLayout, "initial_layout");
    GetImageLayout(finalLayout, "final_layout");
ZCHECK_END
ZCHECKARRAY(VkAttachmentDescription)

ZCHECK_BEGIN(VkSubpassDependency)
    checktable(arg);
    newstruct(VkSubpassDependency);
    GetSubpass(srcSubpass, "src_subpass");
    GetSubpass(dstSubpass, "dst_subpass");
    GetFlags(srcStageMask, "src_stage_mask");
    GetFlags(dstStageMask, "dst_stage_mask");
    GetFlags(srcAccessMask, "src_access_mask");
    GetFlags(dstAccessMask, "dst_access_mask");
    GetFlags(dependencyFlags, "dependency_flags");
ZCHECK_END
ZCHECKARRAY(VkSubpassDependency)

ZCHECK_BEGIN(VkAttachmentReference)
    checktable(arg);
    newstruct(VkAttachmentReference);
    GetAttachment(attachment, "attachment");
    GetImageLayout(layout, "layout");
ZCHECK_END
ZCHECKARRAY(VkAttachmentReference)

ZCHECK_BEGIN(VkDescriptorPoolSize)
    checktable(arg);
    newstruct(VkDescriptorPoolSize);
    GetDescriptorType(type, "type");
    GetIntegerOpt(descriptorCount, "descriptor_count", 1);
ZCHECK_END
ZCHECKARRAY(VkDescriptorPoolSize)

ZCHECK_BEGIN(VkPushConstantRange)
    checktable(arg);
    newstruct(VkPushConstantRange);
    GetFlags(stageFlags, "stage_flags");
    GetInteger(offset, "offset");
    GetInteger(size, "size");
ZCHECK_END
ZCHECKARRAY(VkPushConstantRange)

ZCLEAR_BEGIN(VkSubpassDescription)
    FreeList(pInputAttachments, inputAttachmentCount, VkAttachmentReference);
    FreeList(pColorAttachments, colorAttachmentCount, VkAttachmentReference);
    FreeList(pResolveAttachments, colorAttachmentCount, VkAttachmentReference);
    FreeUint32List(pPreserveAttachments);
    FreeStructp(pDepthStencilAttachment, VkAttachmentReference);
ZCLEAR_END
ZCHECK_BEGIN(VkSubpassDescription)
    uint32_t count;
    checktable(arg);
    newstruct(VkSubpassDescription);
    GetFlags(flags, "flags");
    GetPipelineBindPoint(pipelineBindPoint, "pipeline_bind_point");
    GetListOpt(pInputAttachments, inputAttachmentCount, VkAttachmentReference, "input_attachments");
    GetListOpt(pColorAttachments, colorAttachmentCount, VkAttachmentReference, "color_attachments");
    count = p->colorAttachmentCount;
    GetListOpt(pResolveAttachments, colorAttachmentCount, VkAttachmentReference, "resolve_attachments");
    if(p->pResolveAttachments && count != p->colorAttachmentCount)
        {
        FreeList(pResolveAttachments, colorAttachmentCount, VkAttachmentReference);
        p->pResolveAttachments = NULL;
        p->colorAttachmentCount = count;
        *err = ERR_LENGTH; lua_pushstring(L, errstring(*err));
        return p;
        }
    p->colorAttachmentCount = count;
    GetStructp(pDepthStencilAttachment , VkAttachmentReference, "depth_stencil_attachment");
    GetUint32List(pPreserveAttachments, preserveAttachmentCount, "preserve_attachments");
ZCHECK_END
ZCHECKARRAY(VkSubpassDescription)

ZCHECK_BEGIN(VkInputAttachmentAspectReference)
    checktable(arg);
    newstruct(VkInputAttachmentAspectReference);
    GetInteger(subpass, "subpass");
    GetInteger(inputAttachmentIndex, "input_attachment_index");
    GetFlags(aspectMask, "aspect_mask");
ZCHECK_END
ZCHECKARRAY(VkInputAttachmentAspectReference)

ZCLEAR_BEGIN(VkAttachmentSampleLocationsEXT)
    FreeStruct(sampleLocationsInfo, VkSampleLocationsInfoEXT);
ZCLEAR_END
ZCHECK_BEGIN(VkAttachmentSampleLocationsEXT)
    checktable(arg);
    newstruct(VkAttachmentSampleLocationsEXT);
    GetInteger(attachmentIndex, "attachment_index");
    GetStruct(sampleLocationsInfo, "sample_locations_info", VkSampleLocationsInfoEXT);
ZCHECK_END
ZCHECKARRAY(VkAttachmentSampleLocationsEXT)

ZCLEAR_BEGIN(VkSubpassSampleLocationsEXT)
    FreeStruct(sampleLocationsInfo, VkSampleLocationsInfoEXT);
ZCLEAR_END
ZCHECK_BEGIN(VkSubpassSampleLocationsEXT)
    checktable(arg);
    newstruct(VkSubpassSampleLocationsEXT);
    GetInteger(subpassIndex, "subpass_index");
    GetStruct(sampleLocationsInfo, "sample_locations_info", VkSampleLocationsInfoEXT);
ZCHECK_END
ZCHECKARRAY(VkSubpassSampleLocationsEXT)

ZPUSH_BEGIN(VkExternalMemoryProperties)
    lua_newtable(L);
    SetFlags(externalMemoryFeatures, "external_memory_features");
    SetFlags(exportFromImportedHandleTypes, "export_from_imported_handle_types");
    SetFlags(compatibleHandleTypes, "compatible_handle_types");
ZPUSH_END

ZCLEAR_BEGIN(VkDescriptorSetLayoutBinding)
    FreeObjectList(pImmutableSamplers);
ZCLEAR_END
ZCHECK_BEGIN(VkDescriptorSetLayoutBinding)
    uint32_t count;
    checktable(arg);
    newstruct(VkDescriptorSetLayoutBinding);
    GetInteger(binding, "binding");
    GetDescriptorType(descriptorType, "descriptor_type");
    GetInteger(descriptorCount, "descriptor_count");
    GetFlags(stageFlags, "stage_flags");
    if((p->descriptorType == VK_DESCRIPTOR_TYPE_SAMPLER ||
        p->descriptorType == VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER) &&
        p->descriptorCount != 0)
        {
        count = p->descriptorCount;
        GetObjectList(pImmutableSamplers, descriptorCount, sampler, "immutable_samplers");
        if(p->pImmutableSamplers && (p->descriptorCount != count))
            { *err=ERR_LENGTH; pushfielderror("immutable_samplers"); return p; }
        p->descriptorCount = count;
        }
ZCHECK_END
ZCHECKARRAY(VkDescriptorSetLayoutBinding)

ZCHECK_BEGIN(VkVertexInputBindingDivisorDescriptionEXT)
    checktable(arg);
    newstruct(VkVertexInputBindingDivisorDescriptionEXT);
    GetInteger(binding, "binding");
    GetInteger(divisor, "divisor");
ZCHECK_END
ZCHECKARRAY(VkVertexInputBindingDivisorDescriptionEXT)

ZCHECK_BEGIN(VkPipelineCreationFeedbackEXT)
    checktable(arg);
    newstruct(VkPipelineCreationFeedbackEXT);
    GetFlags(flags, "flags");
    GetInteger(duration, "duration");
ZCHECK_END
ZCHECKARRAY(VkPipelineCreationFeedbackEXT)

ZCHECK_BEGIN(VkMultiDrawInfoEXT)
    checktable(arg);
    newstruct(VkMultiDrawInfoEXT);
    GetInteger(firstVertex, "first_vertex");
    GetInteger(vertexCount, "vertex_count");
ZCHECK_END
ZCHECKARRAY(VkMultiDrawInfoEXT)

ZCHECK_BEGIN(VkMultiDrawIndexedInfoEXT)
    checktable(arg);
    newstruct(VkMultiDrawIndexedInfoEXT);
    GetInteger(firstIndex, "first_index");
    GetInteger(indexCount, "index_count");
    GetInteger(vertexOffset, "vertex_offset");
ZCHECK_END
ZCHECKARRAY(VkMultiDrawIndexedInfoEXT)

/********************************************************************************
 * Typed structs                                                                *
 ********************************************************************************/

/*------------------------------------------------------------------------------*
 | Physical Device Features                                                     |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkPhysicalDeviceFeatures)
    checktable(arg);
    newstruct(VkPhysicalDeviceFeatures);
    GetBoolean(robustBufferAccess, "robust_buffer_access");
    GetBoolean(fullDrawIndexUint32, "full_draw_index_uint32");
    GetBoolean(imageCubeArray, "image_cube_array");
    GetBoolean(independentBlend, "independent_blend");
    GetBoolean(geometryShader, "geometry_shader");
    GetBoolean(tessellationShader, "tessellation_shader");
    GetBoolean(sampleRateShading, "sample_rate_shading");
    GetBoolean(dualSrcBlend, "dual_src_blend");
    GetBoolean(logicOp, "logic_op");
    GetBoolean(multiDrawIndirect, "multi_draw_indirect");
    GetBoolean(drawIndirectFirstInstance, "draw_indirect_first_instance");
    GetBoolean(depthClamp, "depth_clamp");
    GetBoolean(depthBiasClamp, "depth_bias_clamp");
    GetBoolean(fillModeNonSolid, "fill_mode_non_solid");
    GetBoolean(depthBounds, "depth_bounds");
    GetBoolean(wideLines, "wide_lines");
    GetBoolean(largePoints, "large_points");
    GetBoolean(alphaToOne, "alpha_to_one");
    GetBoolean(multiViewport, "multi_viewport");
    GetBoolean(samplerAnisotropy, "sampler_anisotropy");
    GetBoolean(textureCompressionETC2, "texture_compression_etc2");
    GetBoolean(textureCompressionASTC_LDR, "texture_compression_astc_ldr");
    GetBoolean(textureCompressionBC, "texture_compression_bc");
    GetBoolean(occlusionQueryPrecise, "occlusion_query_precise");
    GetBoolean(pipelineStatisticsQuery, "pipeline_statistics_query");
    GetBoolean(vertexPipelineStoresAndAtomics, "vertex_pipeline_stores_and_atomics");
    GetBoolean(fragmentStoresAndAtomics, "fragment_stores_and_atomics");
    GetBoolean(shaderTessellationAndGeometryPointSize, "shader_tessellation_and_geometry_point_size");
    GetBoolean(shaderImageGatherExtended, "shader_image_gather_extended");
    GetBoolean(shaderStorageImageExtendedFormats, "shader_storage_image_extended_formats");
    GetBoolean(shaderStorageImageMultisample, "shader_storage_image_multisample");
    GetBoolean(shaderStorageImageReadWithoutFormat, "shader_storage_image_read_without_format");
    GetBoolean(shaderStorageImageWriteWithoutFormat, "shader_storage_image_write_without_format");
    GetBoolean(shaderUniformBufferArrayDynamicIndexing, "shader_uniform_buffer_array_dynamic_indexing");
    GetBoolean(shaderSampledImageArrayDynamicIndexing, "shader_sampled_image_array_dynamic_indexing");
    GetBoolean(shaderStorageBufferArrayDynamicIndexing, "shader_storage_buffer_array_dynamic_indexing");
    GetBoolean(shaderStorageImageArrayDynamicIndexing, "shader_storage_image_array_dynamic_indexing");
    GetBoolean(shaderClipDistance, "shader_clip_distance");
    GetBoolean(shaderCullDistance, "shader_cull_distance");
    GetBoolean(shaderFloat64, "shader_float64");
    GetBoolean(shaderInt64, "shader_int64");
    GetBoolean(shaderInt16, "shader_int16");
    GetBoolean(shaderResourceResidency, "shader_resource_residency");
    GetBoolean(shaderResourceMinLod, "shader_resource_min_lod");
    GetBoolean(sparseBinding, "sparse_binding");
    GetBoolean(sparseResidencyBuffer, "sparse_residency_buffer");
    GetBoolean(sparseResidencyImage2D, "sparse_residency_image_2d");
    GetBoolean(sparseResidencyImage3D, "sparse_residency_image_3d");
    GetBoolean(sparseResidency2Samples, "sparse_residency_2_samples");
    GetBoolean(sparseResidency4Samples, "sparse_residency_4_samples");
    GetBoolean(sparseResidency8Samples, "sparse_residency_8_samples");
    GetBoolean(sparseResidency16Samples, "sparse_residency_16_samples");
    GetBoolean(sparseResidencyAliased, "sparse_residency_aliased");
    GetBoolean(variableMultisampleRate, "variable_multisample_rate");
    GetBoolean(inheritedQueries, "inherited_queries");
ZCHECK_END
 

LOCALCHECK_BEGIN(PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES, VkPhysicalDevice16BitStorageFeatures)
    GetBoolean(storageBuffer16BitAccess, "storage_buffer_16bit_access");
    GetBoolean(uniformAndStorageBuffer16BitAccess, "uniform_and_storage_buffer_16bit_access");
    GetBoolean(storagePushConstant16, "storage_push_constant_16");
    GetBoolean(storageInputOutput16, "storage_input_output_16");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES, VkPhysicalDeviceVariablePointersFeatures)
    GetBoolean(variablePointersStorageBuffer, "variable_pointers_storage_buffer");
    GetBoolean(variablePointers, "variable_pointers");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT)
    GetBoolean(advancedBlendCoherentOperations, "advanced_blend_coherent_operations");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES, VkPhysicalDeviceSamplerYcbcrConversionFeatures)
    GetBoolean(samplerYcbcrConversion, "sampler_ycbcr_conversion");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT, VkPhysicalDeviceConditionalRenderingFeaturesEXT)
    GetBoolean(conditionalRendering, "conditional_rendering");
    GetBoolean(inheritedConditionalRendering, "inherited_conditional_rendering");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES, VkPhysicalDevice8BitStorageFeatures)
    GetBoolean(storageBuffer8BitAccess, "storage_buffer_8bit_access");
    GetBoolean(uniformAndStorageBuffer8BitAccess, "uniform_and_storage_buffer_8bit_access");
    GetBoolean(storagePushConstant8, "storage_push_constant_8");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES, VkPhysicalDeviceProtectedMemoryFeatures)
    GetBoolean(protectedMemory, "protected_memory");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES, VkPhysicalDeviceShaderDrawParametersFeatures)
    GetBoolean(shaderDrawParameters, "shader_draw_parameters");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT, VkPhysicalDeviceASTCDecodeFeaturesEXT)
    GetBoolean(decodeModeSharedExponent, "decode_mode_shared_exponent");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT)
    GetBoolean(vertexAttributeInstanceRateDivisor, "vertex_attribute_instance_rate_divisor");
    GetBoolean(vertexAttributeInstanceRateZeroDivisor, "vertex_attribute_instance_rate_zero_divisor");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT, VkPhysicalDeviceInlineUniformBlockFeaturesEXT)
    GetBoolean(inlineUniformBlock, "inline_uniform_block");
    GetBoolean(descriptorBindingInlineUniformBlockUpdateAfterBind, "descriptor_binding_inline_uniform_block_update_after_bind");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT, VkPhysicalDeviceDescriptorIndexingFeaturesEXT)
    GetBoolean(shaderInputAttachmentArrayDynamicIndexing, "shader_input_attachment_array_dynamic_indexing");
    GetBoolean(shaderUniformTexelBufferArrayDynamicIndexing, "shader_uniform_texel_buffer_array_dynamic_indexing");
    GetBoolean(shaderStorageTexelBufferArrayDynamicIndexing, "shader_storage_texel_buffer_array_dynamic_indexing");
    GetBoolean(shaderUniformBufferArrayNonUniformIndexing, "shader_uniform_buffer_array_non_uniform_indexing");
    GetBoolean(shaderSampledImageArrayNonUniformIndexing, "shader_sampled_image_array_non_uniform_indexing");
    GetBoolean(shaderStorageBufferArrayNonUniformIndexing, "shader_storage_buffer_array_non_uniform_indexing");
    GetBoolean(shaderStorageImageArrayNonUniformIndexing, "shader_storage_image_array_non_uniform_indexing");
    GetBoolean(shaderInputAttachmentArrayNonUniformIndexing, "shader_input_attachment_array_non_uniform_indexing");
    GetBoolean(shaderUniformTexelBufferArrayNonUniformIndexing, "shader_uniform_texel_buffer_array_non_uniform_indexing");
    GetBoolean(shaderStorageTexelBufferArrayNonUniformIndexing, "shader_storage_texel_buffer_array_non_uniform_indexing");
    GetBoolean(descriptorBindingUniformBufferUpdateAfterBind, "descriptor_binding_uniform_buffer_update_after_bind");
    GetBoolean(descriptorBindingSampledImageUpdateAfterBind, "descriptor_binding_sampled_image_update_after_bind");
    GetBoolean(descriptorBindingStorageImageUpdateAfterBind, "descriptor_binding_storage_image_update_after_bind");
    GetBoolean(descriptorBindingStorageBufferUpdateAfterBind, "descriptor_binding_storage_buffer_update_after_bind");
    GetBoolean(descriptorBindingUniformTexelBufferUpdateAfterBind, "descriptor_binding_uniform_texel_buffer_update_after_bind");
    GetBoolean(descriptorBindingStorageTexelBufferUpdateAfterBind, "descriptor_binding_storage_texel_buffer_update_after_bind");
    GetBoolean(descriptorBindingUpdateUnusedWhilePending, "descriptor_binding_update_unused_while_pending");
    GetBoolean(descriptorBindingPartiallyBound, "descriptor_binding_partially_bound");
    GetBoolean(descriptorBindingVariableDescriptorCount, "descriptor_binding_variable_descriptor_count");
    GetBoolean(runtimeDescriptorArray, "runtime_descriptor_array");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_MULTIVIEW_FEATURES, VkPhysicalDeviceMultiviewFeaturesKHR)
    GetBoolean(multiview, "multiview");
    GetBoolean(multiviewGeometryShader, "multiview_geometry_shader");
    GetBoolean(multiviewTessellationShader, "multiview_tessellation_shader");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES, VkPhysicalDeviceVulkanMemoryModelFeatures)
    GetBoolean(vulkanMemoryModel, "vulkan_memory_model");
    GetBoolean(vulkanMemoryModelDeviceScope, "vulkan_memory_model_device_scope");
    GetBoolean(vulkanMemoryModelAvailabilityVisibilityChains, "vulkan_memory_model_availability_visibility_chains");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES, VkPhysicalDeviceShaderAtomicInt64Features)
    GetBoolean(shaderBufferInt64Atomics, "shader_buffer_int64_atomics");
    GetBoolean(shaderSharedInt64Atomics, "shader_shared_int64_atomics");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT, VkPhysicalDeviceTransformFeedbackFeaturesEXT)
    GetBoolean(transformFeedback, "transform_feedback");
    GetBoolean(geometryStreams, "geometry_streams");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES, VkPhysicalDeviceShaderFloat16Int8Features)
    GetBoolean(shaderFloat16, "shader_float16");
    GetBoolean(shaderInt8, "shader_int8");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES, VkPhysicalDeviceUniformBufferStandardLayoutFeatures)
    GetBoolean(uniformBufferStandardLayout, "uniform_buffer_standard_layout");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES, VkPhysicalDeviceScalarBlockLayoutFeatures)
    GetBoolean(scalarBlockLayout, "scalar_block_layout");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT)
    GetBoolean(fragmentShaderSampleInterlock, "fragment_shader_sample_interlock");
    GetBoolean(fragmentShaderPixelInterlock, "fragment_shader_pixel_interlock");
    GetBoolean(fragmentShaderShadingRateInterlock, "fragment_shader_shading_rate_interlock");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT)
    GetBoolean(ycbcrImageArrays, "ycbcr_image_arrays");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT, VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT)
    GetBoolean(shaderDemoteToHelperInvocation, "shader_demote_to_helper_invocation");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES, VkPhysicalDeviceImagelessFramebufferFeatures)
    GetBoolean(imagelessFramebuffer, "imageless_framebuffer");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT, VkPhysicalDeviceDepthClipEnableFeaturesEXT)
    GetBoolean(depthClipEnable, "depth_clip_enable");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT, VkPhysicalDeviceFragmentDensityMapFeaturesEXT)
    GetBoolean(fragmentDensityMap, "fragment_density_map");
    GetBoolean(fragmentDensityMapDynamic, "fragment_density_map_dynamic");
    GetBoolean(fragmentDensityMapNonSubsampledImages, "fragment_density_map_non_subsampled_images");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT, VkPhysicalDeviceMemoryPriorityFeaturesEXT)
    GetBoolean(memoryPriority, "memory_priority");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT)
    GetBoolean(bufferDeviceAddress, "buffer_device_address");
    GetBoolean(bufferDeviceAddressCaptureReplay, "buffer_device_address_capture_replay");
    GetBoolean(bufferDeviceAddressMultiDevice, "buffer_device_address_multi_device");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES, VkPhysicalDeviceHostQueryResetFeatures)
    GetBoolean(hostQueryReset, "host_query_reset");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT)
    GetBoolean(texelBufferAlignment, "texel_buffer_alignment");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR, VkPhysicalDevicePerformanceQueryFeaturesKHR)
    GetBoolean(performanceCounterQueryPools, "performance_counter_query_pools");
    GetBoolean(performanceCounterMultipleQueryPools, "performance_counter_multiple_query_pools");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures)
    GetBoolean(shaderSubgroupExtendedTypes, "shader_subgroup_extended_types");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR, VkPhysicalDeviceShaderClockFeaturesKHR)
    GetBoolean(shaderSubgroupClock, "shader_subgroup_clock");
    GetBoolean(shaderDeviceClock, "shader_device_clock");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES, VkPhysicalDeviceTimelineSemaphoreFeatures)
    GetBoolean(timelineSemaphore, "timeline_semaphore");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR, VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR)
    GetBoolean(shaderTerminateInvocation, "shader_terminate_invocation");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR, VkPhysicalDeviceFragmentShadingRateFeaturesKHR)
    GetBoolean(pipelineFragmentShadingRate, "pipeline_fragment_shading_rate");
    GetBoolean(primitiveFragmentShadingRate, "primitive_fragment_shading_rate");
    GetBoolean(attachmentFragmentShadingRate, "attachment_fragment_shading_rate");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures)
    GetBoolean(separateDepthStencilLayouts, "separate_depth_stencil_layouts");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR, VkPhysicalDevicePresentWaitFeaturesKHR)
    GetBoolean(presentWait, "present_wait");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES, VkPhysicalDeviceBufferDeviceAddressFeatures)
    GetBoolean(bufferDeviceAddress, "buffer_device_address");
    GetBoolean(bufferDeviceAddressCaptureReplay, "buffer_device_address_capture_replay");
    GetBoolean(bufferDeviceAddressMultiDevice, "buffer_device_address_multi_device");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR)
    GetBoolean(pipelineExecutableInfo, "pipeline_executable_info");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR, VkPhysicalDevicePresentIdFeaturesKHR)
    GetBoolean(presentId, "present_id");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR, VkPhysicalDeviceSynchronization2FeaturesKHR)
    GetBoolean(synchronization2, "synchronization2");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR, VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR)
    GetBoolean(shaderSubgroupUniformControlFlow, "shader_subgroup_uniform_control_flow");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR, VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR)
    GetBoolean(shaderZeroInitializeWorkgroupMemory, "shader_zero_initialize_workgroup_memory");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR, VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR)
    GetBoolean(workgroupMemoryExplicitLayout, "workgroup_memory_explicit_layout");
    GetBoolean(workgroupMemoryExplicitLayoutScalarBlockLayout, "workgroup_memory_explicit_layout_scalar_block_layout");
    GetBoolean(workgroupMemoryExplicitLayout8BitAccess, "workgroup_memory_explicit_layout_8bit_access");
    GetBoolean(workgroupMemoryExplicitLayout16BitAccess, "workgroup_memory_explicit_layout_16bit_access");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR, VkPhysicalDeviceAccelerationStructureFeaturesKHR)
    GetBoolean(accelerationStructure, "acceleration_structure");
    GetBoolean(accelerationStructureCaptureReplay, "acceleration_structure_capture_replay");
    GetBoolean(accelerationStructureIndirectBuild, "acceleration_structure_indirect_build");
    GetBoolean(accelerationStructureHostCommands, "acceleration_structure_host_commands");
    GetBoolean(descriptorBindingAccelerationStructureUpdateAfterBind, "descriptor_binding_acceleration_structure_update_after_bind");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR, VkPhysicalDeviceRayTracingPipelineFeaturesKHR)
    GetBoolean(rayTracingPipeline, "ray_tracing_pipeline");
    GetBoolean(rayTracingPipelineShaderGroupHandleCaptureReplay, "ray_tracing_pipeline_shader_group_handle_capture_replay");
    GetBoolean(rayTracingPipelineShaderGroupHandleCaptureReplayMixed, "ray_tracing_pipeline_shader_group_handle_capture_replay_mixed");
    GetBoolean(rayTracingPipelineTraceRaysIndirect, "ray_tracing_pipeline_trace_rays_indirect");
    GetBoolean(rayTraversalPrimitiveCulling, "ray_traversal_primitive_culling");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR, VkPhysicalDeviceRayQueryFeaturesKHR)
    GetBoolean(rayQuery, "ray_query");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT, VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT)
    GetBoolean(textureCompressionASTC_HDR, "texture_compression_astc_hdr");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT, VkPhysicalDeviceSubgroupSizeControlFeaturesEXT)
    GetBoolean(subgroupSizeControl, "subgroup_size_control");
    GetBoolean(computeFullSubgroups, "compute_full_subgroups");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT)
    GetBoolean(shaderImageInt64Atomics, "shader_image_int64_atomics");
    GetBoolean(sparseImageInt64Atomics, "sparse_image_int64_atomics");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT, VkPhysicalDeviceProvokingVertexFeaturesEXT)
    GetBoolean(provokingVertexLast, "provoking_vertex_last");
    GetBoolean(transformFeedbackPreservesProvokingVertex, "transform_feedback_preserves_provoking_vertex");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT, VkPhysicalDeviceLineRasterizationFeaturesEXT)
    GetBoolean(rectangularLines, "rectangular_lines");
    GetBoolean(bresenhamLines, "bresenham_lines");
    GetBoolean(smoothLines, "smooth_lines");
    GetBoolean(stippledRectangularLines, "stippled_rectangular_lines");
    GetBoolean(stippledBresenhamLines, "stippled_bresenham_lines");
    GetBoolean(stippledSmoothLines, "stippled_smooth_lines");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT)
    GetBoolean(shaderBufferFloat32Atomics, "shader_buffer_float32_atomics");
    GetBoolean(shaderBufferFloat32AtomicAdd, "shader_buffer_float32_atomic_add");
    GetBoolean(shaderBufferFloat64Atomics, "shader_buffer_float64_atomics");
    GetBoolean(shaderBufferFloat64AtomicAdd, "shader_buffer_float64_atomic_add");
    GetBoolean(shaderSharedFloat32Atomics, "shader_shared_float32_atomics");
    GetBoolean(shaderSharedFloat32AtomicAdd, "shader_shared_float32_atomic_add");
    GetBoolean(shaderSharedFloat64Atomics, "shader_shared_float64_atomics");
    GetBoolean(shaderSharedFloat64AtomicAdd, "shader_shared_float64_atomic_add");
    GetBoolean(shaderImageFloat32Atomics, "shader_image_float32_atomics");
    GetBoolean(shaderImageFloat32AtomicAdd, "shader_image_float32_atomic_add");
    GetBoolean(sparseImageFloat32Atomics, "sparse_image_float32_atomics");
    GetBoolean(sparseImageFloat32AtomicAdd, "sparse_image_float32_atomic_add");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT, VkPhysicalDeviceIndexTypeUint8FeaturesEXT)
    GetBoolean(indexTypeUint8, "index_type_uint8");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT)
    GetBoolean(extendedDynamicState, "extended_dynamic_state");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT, VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT)
    GetBoolean(shaderBufferFloat16Atomics, "shader_buffer_float16_atomics");
    GetBoolean(shaderBufferFloat16AtomicAdd, "shader_buffer_float16_atomicAdd");
    GetBoolean(shaderBufferFloat16AtomicMinMax, "shader_buffer_float16_atomic_min_max");
    GetBoolean(shaderBufferFloat32AtomicMinMax, "shader_buffer_float32_atomic_min_max");
    GetBoolean(shaderBufferFloat64AtomicMinMax, "shader_buffer_float64_atomic_min_max");
    GetBoolean(shaderSharedFloat16Atomics, "shader_shared_float16_atomics");
    GetBoolean(shaderSharedFloat16AtomicAdd, "shader_shared_float16_atomic_add");
    GetBoolean(shaderSharedFloat16AtomicMinMax, "shader_shared_float16_atomic_min_max");
    GetBoolean(shaderSharedFloat32AtomicMinMax, "shader_shared_float32_atomic_min_max");
    GetBoolean(shaderSharedFloat64AtomicMinMax, "shader_shared_float64_atomic_min_max");
    GetBoolean(shaderImageFloat32AtomicMinMax, "shader_image_float32_atomic_min_max");
    GetBoolean(sparseImageFloat32AtomicMinMax, "sparse_image_float32_atomic_min_max");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT)
    GetBoolean(deviceMemoryReport, "device_memory_report");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT, VkPhysicalDeviceRobustness2FeaturesEXT)
    GetBoolean(robustBufferAccess2, "robust_buffer_access2");
    GetBoolean(robustImageAccess2, "robust_image_access2");
    GetBoolean(nullDescriptor, "null_descriptor");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT, VkPhysicalDeviceCustomBorderColorFeaturesEXT)
    GetBoolean(customBorderColors, "custom_border_colors");
    GetBoolean(customBorderColorWithoutFormat, "custom_border_color_without_format");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT, VkPhysicalDevicePrivateDataFeaturesEXT)
    GetBoolean(privateData, "private_data");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT, VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT)
    GetBoolean(pipelineCreationCacheControl, "pipeline_creation_cache_control");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT, VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT)
    GetBoolean(ycbcr2plane444Formats, "ycbcr_2plane_444_formats");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT)
    GetBoolean(fragmentDensityMapDeferred, "fragment_density_map_deferred");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT, VkPhysicalDeviceImageRobustnessFeaturesEXT)
    GetBoolean(robustImageAccess, "robust_image_access");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT, VkPhysicalDevice4444FormatsFeaturesEXT)
    GetBoolean(formatA4R4G4B4, "format_a4r4g4b4");
    GetBoolean(formatA4B4G4R4, "format_a4b4g4r4");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT, VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT)
    GetBoolean(vertexInputDynamicState, "vertex_input_dynamic_state");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT, VkPhysicalDeviceExtendedDynamicState2FeaturesEXT)
    GetBoolean(extendedDynamicState2, "extended_dynamic_state2");
    GetBoolean(extendedDynamicState2LogicOp, "extended_dynamic_state2_logic_op");
    GetBoolean(extendedDynamicState2PatchControlPoints, "extended_dynamic_state2_patch_control_points");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT, VkPhysicalDeviceColorWriteEnableFeaturesEXT)
    GetBoolean(colorWriteEnable, "color_write_enable");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT, VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT)
    GetBoolean(globalPriorityQuery, "global_priority_query");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT, VkPhysicalDeviceMultiDrawFeaturesEXT)
    GetBoolean(multiDraw, "multi_draw");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR, VkPhysicalDeviceDynamicRenderingFeaturesKHR)
    GetBoolean(dynamicRendering, "dynamic_rendering");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR, VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR)
    GetBoolean(shaderIntegerDotProduct, "shader_integer_dot_product");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR, VkPhysicalDeviceMaintenance4FeaturesKHR)
    GetBoolean(maintenance4, "maintenance4");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT, VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT)
    GetBoolean(formatRgba10x6WithoutYCbCrSampler, "format_rgba10x6_without_ycbcr_sampler");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT, VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT)
    GetBoolean(primitiveTopologyListRestart, "primitive_topology_list_restart");
    GetBoolean(primitiveTopologyPatchListRestart, "primitive_topology_patch_list_restart");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT, VkPhysicalDeviceBorderColorSwizzleFeaturesEXT)
    GetBoolean(borderColorSwizzle, "border_color_swizzle");
    GetBoolean(borderColorSwizzleFromImage, "border_color_swizzle_from_image");
LOCALCHECK_END
LOCALCHECK_BEGIN(PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT, VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT)
    GetBoolean(pageableDeviceLocalMemory, "pageable_device_local_memory");
LOCALCHECK_END

#if 0 // 9yy scaffolding
LOCALCHECK_BEGIN(, )
    GetBoolean(, "");
LOCALCHECK_END
        ADDX(, );
        ADD();
LOCALPUSH_BEGIN()
    SetBoolean(, "");
LOCALPUSH_END
        XCASE(, );
#endif

ZINIT_BEGIN(VkPhysicalDeviceFeatures2)
    EXTENSIONS_BEGIN
        ADDX(PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES, VkPhysicalDevice16BitStorageFeatures);
        ADDX(PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES, VkPhysicalDeviceVariablePointersFeatures);
        ADDX(PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES, VkPhysicalDeviceSamplerYcbcrConversionFeatures);
        ADDX(PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT, VkPhysicalDeviceConditionalRenderingFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR , VkPhysicalDevice8BitStorageFeatures);
        ADDX(PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES, VkPhysicalDeviceProtectedMemoryFeatures);
        ADDX(PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,VkPhysicalDeviceShaderDrawParametersFeatures);
        ADDX(PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT, VkPhysicalDeviceASTCDecodeFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT, VkPhysicalDeviceInlineUniformBlockFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT, VkPhysicalDeviceDescriptorIndexingFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR, VkPhysicalDeviceMultiviewFeaturesKHR);
        ADDX(PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES, VkPhysicalDeviceVulkanMemoryModelFeatures);
        ADDX(PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES, VkPhysicalDeviceShaderAtomicInt64Features);
        ADDX(PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT, VkPhysicalDeviceTransformFeedbackFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES, VkPhysicalDeviceShaderFloat16Int8Features);
        ADDX(PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES, VkPhysicalDeviceUniformBufferStandardLayoutFeatures);
        ADDX(PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES, VkPhysicalDeviceScalarBlockLayoutFeatures);
        ADDX(PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT, VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES, VkPhysicalDeviceImagelessFramebufferFeatures);
        ADDX(PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT, VkPhysicalDeviceDepthClipEnableFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT, VkPhysicalDeviceFragmentDensityMapFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT, VkPhysicalDeviceMemoryPriorityFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES, VkPhysicalDeviceHostQueryResetFeatures);
        ADDX(PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR, VkPhysicalDevicePerformanceQueryFeaturesKHR);
        ADDX(PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures);
        ADDX(PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR, VkPhysicalDeviceShaderClockFeaturesKHR);
        ADDX(PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES, VkPhysicalDeviceTimelineSemaphoreFeatures);
        ADDX(PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR, VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR);
        ADDX(PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR, VkPhysicalDeviceFragmentShadingRateFeaturesKHR);
        ADDX(PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures);
        ADDX(PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR, VkPhysicalDevicePresentWaitFeaturesKHR);
        ADDX(PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES, VkPhysicalDeviceBufferDeviceAddressFeatures);
        ADDX(PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR);
        ADDX(PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR, VkPhysicalDevicePresentIdFeaturesKHR);
        ADDX(PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR, VkPhysicalDeviceSynchronization2FeaturesKHR);
        ADDX(PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR, VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR);
        ADDX(PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR, VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR);
        ADDX(PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR, VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR);
        ADDX(PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR, VkPhysicalDeviceAccelerationStructureFeaturesKHR);
        ADDX(PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR, VkPhysicalDeviceRayTracingPipelineFeaturesKHR);
        ADDX(PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR, VkPhysicalDeviceRayQueryFeaturesKHR);
        ADDX(PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT, VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT, VkPhysicalDeviceSubgroupSizeControlFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT);
        ADDX(PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT, VkPhysicalDeviceProvokingVertexFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT, VkPhysicalDeviceLineRasterizationFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT, VkPhysicalDeviceIndexTypeUint8FeaturesEXT);
        ADDX(PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT, VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT);
        ADDX(PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT, VkPhysicalDeviceRobustness2FeaturesEXT);
        ADDX(PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT, VkPhysicalDeviceCustomBorderColorFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT, VkPhysicalDevicePrivateDataFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT, VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT, VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT);
        ADDX(PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT, VkPhysicalDeviceImageRobustnessFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT, VkPhysicalDevice4444FormatsFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT, VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT, VkPhysicalDeviceExtendedDynamicState2FeaturesEXT);
        ADDX(PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT, VkPhysicalDeviceColorWriteEnableFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT, VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT, VkPhysicalDeviceMultiDrawFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR, VkPhysicalDeviceDynamicRenderingFeaturesKHR);
        ADDX(PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR, VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR);
        ADDX(PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR, VkPhysicalDeviceMaintenance4FeaturesKHR);
        ADDX(PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT, VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT, VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT, VkPhysicalDeviceBorderColorSwizzleFeaturesEXT);
        ADDX(PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT, VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT);
    EXTENSIONS_END
ZINIT_END

ZCHECK_BEGIN(VkPhysicalDeviceFeatures2)
    VkPhysicalDeviceFeatures* features;
    checktable(arg);
    newstruct(VkPhysicalDeviceFeatures2);
    features = zcheckVkPhysicalDeviceFeatures(L, arg, err);
    if(features)
        { memcpy(&p->features, features, sizeof(VkPhysicalDeviceFeatures)); Free(L, features); }
    if(*err < 0) return p;
    else if(*err == ERR_NOTPRESENT) poperror();
    EXTENSIONS_BEGIN
    #define ADD(VkXxx) do {                         \
        VkXxx* p1 = zcheck##VkXxx(L, arg, err);     \
        if(*err < 0) { zfree(L, p1, 1); return p; } \
        else if(*err == ERR_NOTPRESENT) poperror(); \
        else addtochain(chain, p1);                 \
    } while(0)
        ADD(VkPhysicalDevice16BitStorageFeatures);
        ADD(VkPhysicalDeviceVariablePointersFeatures);
        ADD(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT);
        ADD(VkPhysicalDeviceSamplerYcbcrConversionFeatures);
        ADD(VkPhysicalDeviceConditionalRenderingFeaturesEXT);
        ADD(VkPhysicalDevice8BitStorageFeatures);
        ADD(VkPhysicalDeviceProtectedMemoryFeatures);
        ADD(VkPhysicalDeviceShaderDrawParametersFeatures);
        ADD(VkPhysicalDeviceASTCDecodeFeaturesEXT);
        ADD(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT);
        ADD(VkPhysicalDeviceInlineUniformBlockFeaturesEXT);
        ADD(VkPhysicalDeviceDescriptorIndexingFeaturesEXT);
        ADD(VkPhysicalDeviceMultiviewFeaturesKHR);
        ADD(VkPhysicalDeviceVulkanMemoryModelFeatures);
        ADD(VkPhysicalDeviceShaderAtomicInt64Features);
        ADD(VkPhysicalDeviceTransformFeedbackFeaturesEXT);
        ADD(VkPhysicalDeviceShaderFloat16Int8Features);
        ADD(VkPhysicalDeviceUniformBufferStandardLayoutFeatures);
        ADD(VkPhysicalDeviceScalarBlockLayoutFeatures);
        ADD(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT);
        ADD(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT);
        ADD(VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT);
        ADD(VkPhysicalDeviceImagelessFramebufferFeatures);
        ADD(VkPhysicalDeviceDepthClipEnableFeaturesEXT);
        ADD(VkPhysicalDeviceFragmentDensityMapFeaturesEXT);
        ADD(VkPhysicalDeviceMemoryPriorityFeaturesEXT);
        ADD(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT);
        ADD(VkPhysicalDeviceHostQueryResetFeatures);
        ADD(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT);
        ADD(VkPhysicalDevicePerformanceQueryFeaturesKHR);
        ADD(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures);
        ADD(VkPhysicalDeviceShaderClockFeaturesKHR);
        ADD(VkPhysicalDeviceTimelineSemaphoreFeatures);
        ADD(VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR);
        ADD(VkPhysicalDeviceFragmentShadingRateFeaturesKHR);
        ADD(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures);
        ADD(VkPhysicalDevicePresentWaitFeaturesKHR);
        ADD(VkPhysicalDeviceBufferDeviceAddressFeatures);
        ADD(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR);
        ADD(VkPhysicalDevicePresentIdFeaturesKHR);
        ADD(VkPhysicalDeviceSynchronization2FeaturesKHR);
        ADD(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR);
        ADD(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR);
        ADD(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR);
        ADD(VkPhysicalDeviceAccelerationStructureFeaturesKHR);
        ADD(VkPhysicalDeviceRayTracingPipelineFeaturesKHR);
        ADD(VkPhysicalDeviceRayQueryFeaturesKHR);
        ADD(VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT);
        ADD(VkPhysicalDeviceSubgroupSizeControlFeaturesEXT);
        ADD(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT);
        ADD(VkPhysicalDeviceProvokingVertexFeaturesEXT);
        ADD(VkPhysicalDeviceLineRasterizationFeaturesEXT);
        ADD(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT);
        ADD(VkPhysicalDeviceIndexTypeUint8FeaturesEXT);
        ADD(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT);
        ADD(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT);
        ADD(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT);
        ADD(VkPhysicalDeviceRobustness2FeaturesEXT);
        ADD(VkPhysicalDeviceCustomBorderColorFeaturesEXT);
        ADD(VkPhysicalDevicePrivateDataFeaturesEXT);
        ADD(VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT);
        ADD(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT);
        ADD(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT);
        ADD(VkPhysicalDeviceImageRobustnessFeaturesEXT);
        ADD(VkPhysicalDevice4444FormatsFeaturesEXT);
        ADD(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT);
        ADD(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT);
        ADD(VkPhysicalDeviceColorWriteEnableFeaturesEXT);
        ADD(VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT);
        ADD(VkPhysicalDeviceMultiDrawFeaturesEXT);
        ADD(VkPhysicalDeviceDynamicRenderingFeaturesKHR);
        ADD(VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR);
        ADD(VkPhysicalDeviceMaintenance4FeaturesKHR);
        ADD(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT);
        ADD(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT);
        ADD(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT);
        ADD(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT);
    #undef ADD
    EXTENSIONS_END
ZCHECK_END

LOCALPUSH_BEGIN(VkPhysicalDeviceFeatures)
    SetBoolean(robustBufferAccess, "robust_buffer_access");
    SetBoolean(fullDrawIndexUint32, "full_draw_index_uint32");
    SetBoolean(imageCubeArray, "image_cube_array");
    SetBoolean(independentBlend, "independent_blend");
    SetBoolean(geometryShader, "geometry_shader");
    SetBoolean(tessellationShader, "tessellation_shader");
    SetBoolean(sampleRateShading, "sample_rate_shading");
    SetBoolean(dualSrcBlend, "dual_src_blend");
    SetBoolean(logicOp, "logic_op");
    SetBoolean(multiDrawIndirect, "multi_draw_indirect");
    SetBoolean(drawIndirectFirstInstance, "draw_indirect_first_instance");
    SetBoolean(depthClamp, "depth_clamp");
    SetBoolean(depthBiasClamp, "depth_bias_clamp");
    SetBoolean(fillModeNonSolid, "fill_mode_non_solid");
    SetBoolean(depthBounds, "depth_bounds");
    SetBoolean(wideLines, "wide_lines");
    SetBoolean(largePoints, "large_points");
    SetBoolean(alphaToOne, "alpha_to_one");
    SetBoolean(multiViewport, "multi_viewport");
    SetBoolean(samplerAnisotropy, "sampler_anisotropy");
    SetBoolean(textureCompressionETC2, "texture_compression_etc2");
    SetBoolean(textureCompressionASTC_LDR, "texture_compression_astc_ldr");
    SetBoolean(textureCompressionBC, "texture_compression_bc");
    SetBoolean(occlusionQueryPrecise, "occlusion_query_precise");
    SetBoolean(pipelineStatisticsQuery, "pipeline_statistics_query");
    SetBoolean(vertexPipelineStoresAndAtomics, "vertex_pipeline_stores_and_atomics");
    SetBoolean(fragmentStoresAndAtomics, "fragment_stores_and_atomics");
    SetBoolean(shaderTessellationAndGeometryPointSize, "shader_tessellation_and_geometry_point_size");
    SetBoolean(shaderImageGatherExtended, "shader_image_gather_extended");
    SetBoolean(shaderStorageImageExtendedFormats, "shader_storage_image_extended_formats");
    SetBoolean(shaderStorageImageMultisample, "shader_storage_image_multisample");
    SetBoolean(shaderStorageImageReadWithoutFormat, "shader_storage_image_read_without_format");
    SetBoolean(shaderStorageImageWriteWithoutFormat, "shader_storage_image_write_without_format");
    SetBoolean(shaderUniformBufferArrayDynamicIndexing, "shader_uniform_buffer_array_dynamic_indexing");
    SetBoolean(shaderSampledImageArrayDynamicIndexing, "shader_sampled_image_array_dynamic_indexing");
    SetBoolean(shaderStorageBufferArrayDynamicIndexing, "shader_storage_buffer_array_dynamic_indexing");
    SetBoolean(shaderStorageImageArrayDynamicIndexing, "shader_storage_image_array_dynamic_indexing");
    SetBoolean(shaderClipDistance, "shader_clip_distance");
    SetBoolean(shaderCullDistance, "shader_cull_distance");
    SetBoolean(shaderFloat64, "shader_float64");
    SetBoolean(shaderInt64, "shader_int64");
    SetBoolean(shaderInt16, "shader_int16");
    SetBoolean(shaderResourceResidency, "shader_resource_residency");
    SetBoolean(shaderResourceMinLod, "shader_resource_min_lod");
    SetBoolean(sparseBinding, "sparse_binding");
    SetBoolean(sparseResidencyBuffer, "sparse_residency_buffer");
    SetBoolean(sparseResidencyImage2D, "sparse_residency_image_2d");
    SetBoolean(sparseResidencyImage3D, "sparse_residency_image_3d");
    SetBoolean(sparseResidency2Samples, "sparse_residency_2_samples");
    SetBoolean(sparseResidency4Samples, "sparse_residency_4_samples");
    SetBoolean(sparseResidency8Samples, "sparse_residency_8_samples");
    SetBoolean(sparseResidency16Samples, "sparse_residency_16_samples");
    SetBoolean(sparseResidencyAliased, "sparse_residency_aliased");
    SetBoolean(variableMultisampleRate, "variable_multisample_rate");
    SetBoolean(inheritedQueries, "inherited_queries");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDevice16BitStorageFeatures)
    SetBoolean(storageBuffer16BitAccess, "storage_buffer_16bit_access");
    SetBoolean(uniformAndStorageBuffer16BitAccess, "uniform_and_storage_buffer_16bit_access");
    SetBoolean(storagePushConstant16, "storage_push_constant_16");
    SetBoolean(storageInputOutput16, "storage_input_output_16");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceVariablePointersFeatures)
    SetBoolean(variablePointersStorageBuffer, "variable_pointers_storage_buffer");
    SetBoolean(variablePointers, "variable_pointers");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT)
    SetBoolean(advancedBlendCoherentOperations, "advanced_blend_coherent_operations");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceSamplerYcbcrConversionFeatures)
    SetBoolean(samplerYcbcrConversion, "sampler_ycbcr_conversion");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceConditionalRenderingFeaturesEXT)
    SetBoolean(conditionalRendering, "conditional_rendering");
    SetBoolean(inheritedConditionalRendering, "inherited_conditional_rendering");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDevice8BitStorageFeatures)
    SetBoolean(storageBuffer8BitAccess, "storage_buffer_8bit_access");
    SetBoolean(uniformAndStorageBuffer8BitAccess, "uniform_and_storage_buffer_8bit_access");
    SetBoolean(storagePushConstant8, "storage_push_constant_8");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceProtectedMemoryFeatures)
    SetBoolean(protectedMemory, "protected_memory");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceShaderDrawParametersFeatures)
    SetBoolean(shaderDrawParameters, "shader_draw_parameters");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceASTCDecodeFeaturesEXT)
    SetBoolean(decodeModeSharedExponent, "decode_mode_shared_exponent");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT)
    SetBoolean(vertexAttributeInstanceRateDivisor, "vertex_attribute_instance_rate_divisor");
    SetBoolean(vertexAttributeInstanceRateZeroDivisor, "vertex_attribute_instance_rate_zero_divisor");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceInlineUniformBlockFeaturesEXT)
    SetBoolean(inlineUniformBlock, "inline_uniform_block");
    SetBoolean(descriptorBindingInlineUniformBlockUpdateAfterBind, "descriptor_binding_inline_uniform_block_update_after_bind");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceDescriptorIndexingFeaturesEXT)
    SetBoolean(shaderInputAttachmentArrayDynamicIndexing, "shader_input_attachment_array_dynamic_indexing");
    SetBoolean(shaderUniformTexelBufferArrayDynamicIndexing, "shader_uniform_texel_buffer_array_dynamic_indexing");
    SetBoolean(shaderStorageTexelBufferArrayDynamicIndexing, "shader_storage_texel_buffer_array_dynamic_indexing");
    SetBoolean(shaderUniformBufferArrayNonUniformIndexing, "shader_uniform_buffer_array_non_uniform_indexing");
    SetBoolean(shaderSampledImageArrayNonUniformIndexing, "shader_sampled_image_array_non_uniform_indexing");
    SetBoolean(shaderStorageBufferArrayNonUniformIndexing, "shader_storage_buffer_array_non_uniform_indexing");
    SetBoolean(shaderStorageImageArrayNonUniformIndexing, "shader_storage_image_array_non_uniform_indexing");
    SetBoolean(shaderInputAttachmentArrayNonUniformIndexing, "shader_input_attachment_array_non_uniform_indexing");
    SetBoolean(shaderUniformTexelBufferArrayNonUniformIndexing, "shader_uniform_texel_buffer_array_non_uniform_indexing");
    SetBoolean(shaderStorageTexelBufferArrayNonUniformIndexing, "shader_storage_texel_buffer_array_non_uniform_indexing");
    SetBoolean(descriptorBindingUniformBufferUpdateAfterBind, "descriptor_binding_uniform_buffer_update_after_bind");
    SetBoolean(descriptorBindingSampledImageUpdateAfterBind, "descriptor_binding_sampled_image_update_after_bind");
    SetBoolean(descriptorBindingStorageImageUpdateAfterBind, "descriptor_binding_storage_image_update_after_bind");
    SetBoolean(descriptorBindingStorageBufferUpdateAfterBind, "descriptor_binding_storage_buffer_update_after_bind");
    SetBoolean(descriptorBindingUniformTexelBufferUpdateAfterBind, "descriptor_binding_uniform_texel_buffer_update_after_bind");
    SetBoolean(descriptorBindingStorageTexelBufferUpdateAfterBind, "descriptor_binding_storage_texel_buffer_update_after_bind");
    SetBoolean(descriptorBindingUpdateUnusedWhilePending, "descriptor_binding_update_unused_while_pending");
    SetBoolean(descriptorBindingPartiallyBound, "descriptor_binding_partially_bound");
    SetBoolean(descriptorBindingVariableDescriptorCount, "descriptor_binding_variable_descriptor_count");
    SetBoolean(runtimeDescriptorArray, "runtime_descriptor_array");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceMultiviewFeaturesKHR)
    SetBoolean(multiview, "multiview");
    SetBoolean(multiviewGeometryShader, "multiview_geometry_shader");
    SetBoolean(multiviewTessellationShader, "multiview_tessellation_shader");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceVulkanMemoryModelFeatures)
    SetBoolean(vulkanMemoryModel, "vulkan_memory_model");
    SetBoolean(vulkanMemoryModelDeviceScope, "vulkan_memory_model_device_scope");
    SetBoolean(vulkanMemoryModelAvailabilityVisibilityChains, "vulkan_memory_model_availability_visibility_chains");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceShaderAtomicInt64Features)
    SetBoolean(shaderBufferInt64Atomics, "shader_buffer_int64_atomics");
    SetBoolean(shaderSharedInt64Atomics, "shader_shared_int64_atomics");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceTransformFeedbackFeaturesEXT)
    SetBoolean(transformFeedback, "transform_feedback");
    SetBoolean(geometryStreams, "geometry_streams");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceShaderFloat16Int8Features)
    SetBoolean(shaderFloat16, "shader_float16");
    SetBoolean(shaderInt8, "shader_int8");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceUniformBufferStandardLayoutFeatures)
    SetBoolean(uniformBufferStandardLayout, "uniform_buffer_standard_layout");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceScalarBlockLayoutFeatures)
    SetBoolean(scalarBlockLayout, "scalar_block_layout");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT)
    SetBoolean(fragmentShaderSampleInterlock, "fragment_shader_sample_interlock");
    SetBoolean(fragmentShaderPixelInterlock, "fragment_shader_pixel_interlock");
    SetBoolean(fragmentShaderShadingRateInterlock, "fragment_shader_shading_rate_interlock");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT)
    SetBoolean(ycbcrImageArrays, "ycbcr_image_arrays");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT)
    SetBoolean(shaderDemoteToHelperInvocation, "shader_demote_to_helper_invocation");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceImagelessFramebufferFeatures)
    SetBoolean(imagelessFramebuffer, "imageless_framebuffer");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceDepthClipEnableFeaturesEXT)
    SetBoolean(depthClipEnable, "depth_clip_enable");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceFragmentDensityMapFeaturesEXT)
    SetBoolean(fragmentDensityMap, "fragment_density_map");
    SetBoolean(fragmentDensityMapDynamic, "fragment_density_map_dynamic");
    SetBoolean(fragmentDensityMapNonSubsampledImages, "fragment_density_map_non_subsampled_images");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceMemoryPriorityFeaturesEXT)
    SetBoolean(memoryPriority, "memory_priority");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT)
    SetBoolean(bufferDeviceAddress, "buffer_device_address");
    SetBoolean(bufferDeviceAddressCaptureReplay, "buffer_device_address_capture_replay");
    SetBoolean(bufferDeviceAddressMultiDevice, "buffer_device_address_multi_device");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceHostQueryResetFeatures)
    SetBoolean(hostQueryReset, "host_query_reset");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT)
    SetBoolean(texelBufferAlignment, "texel_buffer_alignment");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDevicePerformanceQueryFeaturesKHR)
    SetBoolean(performanceCounterQueryPools, "performance_counter_query_pools");
    SetBoolean(performanceCounterMultipleQueryPools, "performance_counter_multiple_query_pools");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures)
    SetBoolean(shaderSubgroupExtendedTypes, "shader_subgroup_extended_types");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceShaderClockFeaturesKHR)
    SetBoolean(shaderSubgroupClock, "shader_subgroup_clock");
    SetBoolean(shaderDeviceClock, "shader_device_clock");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceTimelineSemaphoreFeatures)
    SetBoolean(timelineSemaphore, "timeline_semaphore");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR)
    SetBoolean(shaderTerminateInvocation, "shader_terminate_invocation");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceFragmentShadingRateFeaturesKHR)
    SetBoolean(pipelineFragmentShadingRate, "pipeline_fragment_shading_rate");
    SetBoolean(primitiveFragmentShadingRate, "primitive_fragment_shading_rate");
    SetBoolean(attachmentFragmentShadingRate, "attachment_fragment_shading_rate");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures)
    SetBoolean(separateDepthStencilLayouts, "separate_depth_stencil_layouts");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDevicePresentWaitFeaturesKHR)
    SetBoolean(presentWait, "present_wait");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceBufferDeviceAddressFeatures)
    SetBoolean(bufferDeviceAddress, "buffer_device_address");
    SetBoolean(bufferDeviceAddressCaptureReplay, "buffer_device_address_capture_replay");
    SetBoolean(bufferDeviceAddressMultiDevice, "buffer_device_address_multi_device");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR)
    SetBoolean(pipelineExecutableInfo, "pipeline_executable_info");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDevicePresentIdFeaturesKHR)
    SetBoolean(presentId, "present_id");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceSynchronization2FeaturesKHR)
    SetBoolean(synchronization2, "synchronization2");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR)
    SetBoolean(shaderSubgroupUniformControlFlow, "shader_subgroup_uniform_control_flow");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR)
    SetBoolean(shaderZeroInitializeWorkgroupMemory, "shader_zero_initialize_workgroup_memory");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR)
    SetBoolean(workgroupMemoryExplicitLayout, "workgroup_memory_explicit_layout");
    SetBoolean(workgroupMemoryExplicitLayoutScalarBlockLayout, "workgroup_memory_explicit_layout_scalar_block_layout");
    SetBoolean(workgroupMemoryExplicitLayout8BitAccess, "workgroup_memory_explicit_layout_8bit_access");
    SetBoolean(workgroupMemoryExplicitLayout16BitAccess, "workgroup_memory_explicit_layout_16bit_access");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceAccelerationStructureFeaturesKHR)
    SetBoolean(accelerationStructure, "acceleration_structure");
    SetBoolean(accelerationStructureCaptureReplay, "acceleration_structure_capture_replay");
    SetBoolean(accelerationStructureIndirectBuild, "acceleration_structure_indirect_build");
    SetBoolean(accelerationStructureHostCommands, "acceleration_structure_host_commands");
    SetBoolean(descriptorBindingAccelerationStructureUpdateAfterBind, "descriptor_binding_acceleration_structure_update_after_bind");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceRayTracingPipelineFeaturesKHR)
    SetBoolean(rayTracingPipeline, "ray_tracing_pipeline");
    SetBoolean(rayTracingPipelineShaderGroupHandleCaptureReplay, "ray_tracing_pipeline_shader_group_handle_capture_replay");
    SetBoolean(rayTracingPipelineShaderGroupHandleCaptureReplayMixed, "ray_tracing_pipeline_shader_group_handle_capture_replay_mixed");
    SetBoolean(rayTracingPipelineTraceRaysIndirect, "ray_tracing_pipeline_trace_rays_indirect");
    SetBoolean(rayTraversalPrimitiveCulling, "ray_traversal_primitive_culling");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceRayQueryFeaturesKHR)
    SetBoolean(rayQuery, "ray_query");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT)
    SetBoolean(textureCompressionASTC_HDR, "texture_compression_astc_hdr");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceSubgroupSizeControlFeaturesEXT)
    SetBoolean(subgroupSizeControl, "subgroup_size_control");
    SetBoolean(computeFullSubgroups, "compute_full_subgroups");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT)
    SetBoolean(shaderImageInt64Atomics, "shader_image_int64_atomics");
    SetBoolean(sparseImageInt64Atomics, "sparse_image_int64_atomics");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceProvokingVertexFeaturesEXT)
    SetBoolean(provokingVertexLast, "provoking_vertex_last");
    SetBoolean(transformFeedbackPreservesProvokingVertex, "transform_feedback_preserves_provoking_vertex");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceLineRasterizationFeaturesEXT)
    SetBoolean(rectangularLines, "rectangular_lines");
    SetBoolean(bresenhamLines, "bresenham_lines");
    SetBoolean(smoothLines, "smooth_lines");
    SetBoolean(stippledRectangularLines, "stippled_rectangular_lines");
    SetBoolean(stippledBresenhamLines, "stippled_bresenham_lines");
    SetBoolean(stippledSmoothLines, "stippled_smooth_lines");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT)
    SetBoolean(shaderBufferFloat32Atomics, "shader_buffer_float32_atomics");
    SetBoolean(shaderBufferFloat32AtomicAdd, "shader_buffer_float32_atomic_add");
    SetBoolean(shaderBufferFloat64Atomics, "shader_buffer_float64_atomics");
    SetBoolean(shaderBufferFloat64AtomicAdd, "shader_buffer_float64_atomic_add");
    SetBoolean(shaderSharedFloat32Atomics, "shader_shared_float32_atomics");
    SetBoolean(shaderSharedFloat32AtomicAdd, "shader_shared_float32_atomic_add");
    SetBoolean(shaderSharedFloat64Atomics, "shader_shared_float64_atomics");
    SetBoolean(shaderSharedFloat64AtomicAdd, "shader_shared_float64_atomic_add");
    SetBoolean(shaderImageFloat32Atomics, "shader_image_float32_atomics");
    SetBoolean(shaderImageFloat32AtomicAdd, "shader_image_float32_atomic_add");
    SetBoolean(sparseImageFloat32Atomics, "sparse_image_float32_atomics");
    SetBoolean(sparseImageFloat32AtomicAdd, "sparse_image_float32_atomic_add");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceIndexTypeUint8FeaturesEXT)
    SetBoolean(indexTypeUint8, "index_type_uint8");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT)
    SetBoolean(extendedDynamicState, "extended_dynamic_state");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT)
    SetBoolean(shaderBufferFloat16Atomics, "shader_buffer_float16_atomics");
    SetBoolean(shaderBufferFloat16AtomicAdd, "shader_buffer_float16_atomicAdd");
    SetBoolean(shaderBufferFloat16AtomicMinMax, "shader_buffer_float16_atomic_min_max");
    SetBoolean(shaderBufferFloat32AtomicMinMax, "shader_buffer_float32_atomic_min_max");
    SetBoolean(shaderBufferFloat64AtomicMinMax, "shader_buffer_float64_atomic_min_max");
    SetBoolean(shaderSharedFloat16Atomics, "shader_shared_float16_atomics");
    SetBoolean(shaderSharedFloat16AtomicAdd, "shader_shared_float16_atomic_add");
    SetBoolean(shaderSharedFloat16AtomicMinMax, "shader_shared_float16_atomic_min_max");
    SetBoolean(shaderSharedFloat32AtomicMinMax, "shader_shared_float32_atomic_min_max");
    SetBoolean(shaderSharedFloat64AtomicMinMax, "shader_shared_float64_atomic_min_max");
    SetBoolean(shaderImageFloat32AtomicMinMax, "shader_image_float32_atomic_min_max");
    SetBoolean(sparseImageFloat32AtomicMinMax, "sparse_image_float32_atomic_min_max");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT)
    SetBoolean(deviceMemoryReport, "device_memory_report");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceRobustness2FeaturesEXT)
    SetBoolean(robustBufferAccess2, "robust_buffer_access2");
    SetBoolean(robustImageAccess2, "robust_image_access2");
    SetBoolean(nullDescriptor, "null_descriptor");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceCustomBorderColorFeaturesEXT)
    SetBoolean(customBorderColors, "custom_border_colors");
    SetBoolean(customBorderColorWithoutFormat, "custom_border_color_without_format");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDevicePrivateDataFeaturesEXT)
    SetBoolean(privateData, "private_data");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT)
    SetBoolean(pipelineCreationCacheControl, "pipeline_creation_cache_control");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT)
    SetBoolean(ycbcr2plane444Formats, "ycbcr_2plane_444_formats");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT)
    SetBoolean(fragmentDensityMapDeferred, "fragment_density_map_deferred");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceImageRobustnessFeaturesEXT)
    SetBoolean(robustImageAccess, "robust_image_access");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDevice4444FormatsFeaturesEXT)
    SetBoolean(formatA4R4G4B4, "format_a4r4g4b4");
    SetBoolean(formatA4B4G4R4, "format_a4b4g4r4");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT)
    SetBoolean(vertexInputDynamicState, "vertex_input_dynamic_state");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT)
    SetBoolean(extendedDynamicState2, "extended_dynamic_state2");
    SetBoolean(extendedDynamicState2LogicOp, "extended_dynamic_state2_logic_op");
    SetBoolean(extendedDynamicState2PatchControlPoints, "extended_dynamic_state2_patch_control_points");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceColorWriteEnableFeaturesEXT)
    SetBoolean(colorWriteEnable, "color_write_enable");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT)
    SetBoolean(globalPriorityQuery, "global_priority_query");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceMultiDrawFeaturesEXT)
    SetBoolean(multiDraw, "multi_draw");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceDynamicRenderingFeaturesKHR)
    SetBoolean(dynamicRendering, "dynamic_rendering");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR)
    SetBoolean(shaderIntegerDotProduct, "shader_integer_dot_product");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceMaintenance4FeaturesKHR)
    SetBoolean(maintenance4, "maintenance4");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT)
    SetBoolean(formatRgba10x6WithoutYCbCrSampler, "format_rgba10x6_without_ycbcr_sampler");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT)
    SetBoolean(primitiveTopologyListRestart, "primitive_topology_list_restart");
    SetBoolean(primitiveTopologyPatchListRestart, "primitive_topology_patch_list_restart");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT)
    SetBoolean(borderColorSwizzle, "border_color_swizzle");
    SetBoolean(borderColorSwizzleFromImage, "border_color_swizzle_from_image");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT)
    SetBoolean(pageableDeviceLocalMemory, "pageable_device_local_memory");
LOCALPUSH_END

ZPUSH_BEGIN(VkPhysicalDeviceFeatures)
    lua_newtable(L);
    localpushVkPhysicalDeviceFeatures(L, p);
ZPUSH_END


ZPUSH_BEGIN(VkPhysicalDeviceFeatures2)
    lua_newtable(L);
    localpushVkPhysicalDeviceFeatures(L, &p->features);
    XPUSH_BEGIN
        XCASE(PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES, VkPhysicalDevice16BitStorageFeatures);
        XCASE(PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES, VkPhysicalDeviceVariablePointersFeatures);
        XCASE(PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES, VkPhysicalDeviceSamplerYcbcrConversionFeatures);
        XCASE(PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT, VkPhysicalDeviceConditionalRenderingFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES, VkPhysicalDevice8BitStorageFeatures);
        XCASE(PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES, VkPhysicalDeviceProtectedMemoryFeatures);
        XCASE(PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES, VkPhysicalDeviceShaderDrawParametersFeatures);
        XCASE(PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT, VkPhysicalDeviceASTCDecodeFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT, VkPhysicalDeviceInlineUniformBlockFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT, VkPhysicalDeviceDescriptorIndexingFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR, VkPhysicalDeviceMultiviewFeaturesKHR);
        XCASE(PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES, VkPhysicalDeviceVulkanMemoryModelFeatures);
        XCASE(PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES, VkPhysicalDeviceShaderAtomicInt64Features);
        XCASE(PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT, VkPhysicalDeviceTransformFeedbackFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES, VkPhysicalDeviceShaderFloat16Int8Features);
        XCASE(PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES, VkPhysicalDeviceUniformBufferStandardLayoutFeatures);
        XCASE(PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES, VkPhysicalDeviceScalarBlockLayoutFeatures);
        XCASE(PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT, VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES, VkPhysicalDeviceImagelessFramebufferFeatures);
        XCASE(PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT, VkPhysicalDeviceDepthClipEnableFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT, VkPhysicalDeviceFragmentDensityMapFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT, VkPhysicalDeviceMemoryPriorityFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES, VkPhysicalDeviceHostQueryResetFeatures);
        XCASE(PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR, VkPhysicalDevicePerformanceQueryFeaturesKHR);
        XCASE(PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures);
        XCASE(PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR, VkPhysicalDeviceShaderClockFeaturesKHR);
        XCASE(PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES, VkPhysicalDeviceTimelineSemaphoreFeatures);
        XCASE(PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR, VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR);
        XCASE(PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR, VkPhysicalDeviceFragmentShadingRateFeaturesKHR);
        XCASE(PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures);
        XCASE(PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR, VkPhysicalDevicePresentWaitFeaturesKHR);
        XCASE(PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES, VkPhysicalDeviceBufferDeviceAddressFeatures);
        XCASE(PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR);
        XCASE(PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR, VkPhysicalDevicePresentIdFeaturesKHR);
        XCASE(PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR, VkPhysicalDeviceSynchronization2FeaturesKHR);
        XCASE(PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR, VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR);
        XCASE(PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR, VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR);
        XCASE(PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR, VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR);
        XCASE(PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR, VkPhysicalDeviceAccelerationStructureFeaturesKHR);
        XCASE(PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR, VkPhysicalDeviceRayTracingPipelineFeaturesKHR);
        XCASE(PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR, VkPhysicalDeviceRayQueryFeaturesKHR);
        XCASE(PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT, VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT, VkPhysicalDeviceSubgroupSizeControlFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT);
        XCASE(PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT, VkPhysicalDeviceProvokingVertexFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT, VkPhysicalDeviceLineRasterizationFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT, VkPhysicalDeviceIndexTypeUint8FeaturesEXT);
        XCASE(PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT, VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT);
        XCASE(PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT, VkPhysicalDeviceRobustness2FeaturesEXT);
        XCASE(PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT, VkPhysicalDeviceCustomBorderColorFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT, VkPhysicalDevicePrivateDataFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT, VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT, VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT);
        XCASE(PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT, VkPhysicalDeviceImageRobustnessFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT, VkPhysicalDevice4444FormatsFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT, VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT, VkPhysicalDeviceExtendedDynamicState2FeaturesEXT);
        XCASE(PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT, VkPhysicalDeviceColorWriteEnableFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT, VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT, VkPhysicalDeviceMultiDrawFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR, VkPhysicalDeviceDynamicRenderingFeaturesKHR);
        XCASE(PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR, VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR);
        XCASE(PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR, VkPhysicalDeviceMaintenance4FeaturesKHR);
        XCASE(PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT, VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT, VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT, VkPhysicalDeviceBorderColorSwizzleFeaturesEXT);
        XCASE(PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT, VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT);
    XPUSH_END
ZPUSH_END

/*------------------------------------------------------------------------------*
 | Physical Device Properties                                                   |
 *------------------------------------------------------------------------------*/

ZPUSH_BEGIN(VkPhysicalDeviceLimits)
    lua_newtable(L);
    SetInteger(maxImageDimension1D, "max_image_dimension_1d");
    SetInteger(maxImageDimension2D, "max_image_dimension_2d");
    SetInteger(maxImageDimension3D, "max_image_dimension_3d");
    SetInteger(maxImageDimensionCube, "max_image_dimension_cube");
    SetInteger(maxImageArrayLayers, "max_image_array_layers");
    SetInteger(maxTexelBufferElements, "max_texel_buffer_elements");
    SetInteger(maxUniformBufferRange, "max_uniform_buffer_range");
    SetInteger(maxStorageBufferRange, "max_storage_buffer_range");
    SetInteger(maxPushConstantsSize, "max_push_constants_size");
    SetInteger(maxMemoryAllocationCount, "max_memory_allocation_count");
    SetInteger(maxSamplerAllocationCount, "max_sampler_allocation_count");
    SetInteger(bufferImageGranularity, "buffer_image_granularity");
    SetInteger(sparseAddressSpaceSize, "sparse_address_space_size");
    SetInteger(maxBoundDescriptorSets, "max_bound_descriptor_sets");
    SetInteger(maxPerStageDescriptorSamplers, "max_per_stage_descriptor_samplers");
    SetInteger(maxPerStageDescriptorUniformBuffers, "max_per_stage_descriptor_uniform_buffers");
    SetInteger(maxPerStageDescriptorStorageBuffers, "max_per_stage_descriptor_storage_buffers");
    SetInteger(maxPerStageDescriptorSampledImages, "max_per_stage_descriptor_sampled_images");
    SetInteger(maxPerStageDescriptorStorageImages, "max_per_stage_descriptor_storage_images");
    SetInteger(maxPerStageDescriptorInputAttachments, "max_per_stage_descriptor_input_attachments");
    SetInteger(maxPerStageResources, "max_per_stage_resources");
    SetInteger(maxDescriptorSetSamplers, "max_descriptor_set_samplers");
    SetInteger(maxDescriptorSetUniformBuffers, "max_descriptor_set_uniform_buffers");
    SetInteger(maxDescriptorSetUniformBuffersDynamic, "max_descriptor_set_uniform_buffers_dynamic");
    SetInteger(maxDescriptorSetStorageBuffers, "max_descriptor_set_storage_buffers");
    SetInteger(maxDescriptorSetStorageBuffersDynamic, "max_descriptor_set_storage_buffers_dynamic");
    SetInteger(maxDescriptorSetSampledImages, "max_descriptor_set_sampled_images");
    SetInteger(maxDescriptorSetStorageImages, "max_descriptor_set_storage_images");
    SetInteger(maxDescriptorSetInputAttachments, "max_descriptor_set_input_attachments");
    SetInteger(maxVertexInputAttributes, "max_vertex_input_attributes");
    SetInteger(maxVertexInputBindings, "max_vertex_input_bindings");
    SetInteger(maxVertexInputAttributeOffset, "max_vertex_input_attribute_offset");
    SetInteger(maxVertexInputBindingStride, "max_vertex_input_binding_stride");
    SetInteger(maxVertexOutputComponents, "max_vertex_output_components");
    SetInteger(maxTessellationGenerationLevel, "max_tessellation_generation_level");
    SetInteger(maxTessellationPatchSize, "max_tessellation_patch_size");
    SetInteger(maxTessellationControlPerVertexInputComponents, "max_tessellation_control_per_vertex_input_components");
    SetInteger(maxTessellationControlPerVertexOutputComponents, "max_tessellation_control_per_vertex_output_components");
    SetInteger(maxTessellationControlPerPatchOutputComponents, "max_tessellation_control_per_patch_output_components");
    SetInteger(maxTessellationControlTotalOutputComponents, "max_tessellation_control_total_output_components");
    SetInteger(maxTessellationEvaluationInputComponents, "max_tessellation_evaluation_input_components");
    SetInteger(maxTessellationEvaluationOutputComponents, "max_tessellation_evaluation_output_components");
    SetInteger(maxGeometryShaderInvocations, "max_geometry_shader_invocations");
    SetInteger(maxGeometryInputComponents, "max_geometry_input_components");
    SetInteger(maxGeometryOutputComponents, "max_geometry_output_components");
    SetInteger(maxGeometryOutputVertices, "max_geometry_output_vertices");
    SetInteger(maxGeometryTotalOutputComponents, "max_geometry_total_output_components");
    SetInteger(maxFragmentInputComponents, "max_fragment_input_components");
    SetInteger(maxFragmentOutputAttachments, "max_fragment_output_attachments");
    SetInteger(maxFragmentDualSrcAttachments, "max_fragment_dual_src_attachments");
    SetInteger(maxFragmentCombinedOutputResources, "max_fragment_combined_output_resources");
    SetInteger(maxComputeSharedMemorySize, "max_compute_shared_memory_size");
    SetIntegerArray(maxComputeWorkGroupCount, "max_compute_work_group_count", 3);
    SetInteger(maxComputeWorkGroupInvocations, "max_compute_work_group_invocations");
    SetIntegerArray(maxComputeWorkGroupSize, "max_compute_work_group_size", 3);
    SetInteger(subPixelPrecisionBits, "sub_pixel_precision_bits");
    SetInteger(subTexelPrecisionBits, "sub_texel_precision_bits");
    SetInteger(mipmapPrecisionBits, "mipmap_precision_bits");
    SetInteger(maxDrawIndexedIndexValue, "max_draw_indexed_index_value");
    SetInteger(maxDrawIndirectCount, "max_draw_indirect_count");
    SetInteger(maxSamplerLodBias, "max_sampler_lod_bias");
    SetNumber(maxSamplerAnisotropy, "max_sampler_anisotropy");
    SetInteger(maxViewports, "max_viewports");
    SetIntegerArray(maxViewportDimensions, "max_viewport_dimensions", 2);
    SetNumberArray(viewportBoundsRange, "viewport_bounds_range", 2);
    SetInteger(viewportSubPixelBits, "viewport_sub_pixel_bits");
    SetInteger(minMemoryMapAlignment, "min_memory_map_alignment");
    SetInteger(minTexelBufferOffsetAlignment, "min_texel_buffer_offset_alignment");
    SetInteger(minUniformBufferOffsetAlignment, "minuniform_buffer_offset_alignment");
    SetInteger(minStorageBufferOffsetAlignment, "min_storage_buffer_offset_alignment");
    SetInteger(minTexelOffset, "min_texel_offset");
    SetInteger(maxTexelOffset, "max_texel_offset");
    SetInteger(minTexelGatherOffset, "min_texel_gather_offset");
    SetInteger(maxTexelGatherOffset, "max_texel_gather_offset");
    SetNumber(minInterpolationOffset, "min_interpolation_offset");
    SetNumber(maxInterpolationOffset, "max_interpolation_offset");
    SetInteger(subPixelInterpolationOffsetBits, "sub_pixel_interpolation_offset_bits");
    SetInteger(maxFramebufferWidth, "max_framebuffer_width");
    SetInteger(maxFramebufferHeight, "max_framebuffer_height");
    SetInteger(maxFramebufferLayers, "max_framebuffer_layers");
    SetFlags(framebufferColorSampleCounts, "framebuffer_color_sample_counts");
    SetFlags(framebufferDepthSampleCounts, "framebuffer_depth_sample_counts");
    SetFlags(framebufferStencilSampleCounts, "framebuffer_stencil_sample_counts");
    SetFlags(framebufferNoAttachmentsSampleCounts, "framebuffer_no_attachments_sample_counts");
    SetInteger(maxColorAttachments, "max_color_attachments");
    SetFlags(sampledImageColorSampleCounts, "sampled_image_color_sample_counts");
    SetFlags(sampledImageIntegerSampleCounts, "sampled_image_integer_sample_counts");
    SetFlags(sampledImageDepthSampleCounts, "sampled_image_depth_sample_counts");
    SetFlags(sampledImageStencilSampleCounts, "sampled_image_stencil_sample_counts");
    SetFlags(storageImageSampleCounts, "storage_image_sample_counts");
    SetInteger(maxSampleMaskWords, "max_sample_mask_words");
    SetBoolean(timestampComputeAndGraphics, "timestamp_compute_and_graphics");
    SetNumber(timestampPeriod, "timestamp_period");
    SetInteger(maxClipDistances, "max_clip_distances");
    SetInteger(maxCullDistances, "max_cull_distances");
    SetInteger(maxCombinedClipAndCullDistances, "max_combined_clip_and_cull_distances");
    SetInteger(discreteQueuePriorities, "discrete_queue_priorities");
    SetNumberArray(pointSizeRange, "point_size_range", 2);
    SetNumberArray(lineWidthRange, "line_width_range", 2);
    SetNumber(pointSizeGranularity, "point_size_granularity");
    SetNumber(lineWidthGranularity, "line_width_granularity");
    SetBoolean(strictLines, "strict_lines");
    SetBoolean(standardSampleLocations, "standard_sample_locations");
    SetInteger(optimalBufferCopyOffsetAlignment, "optimal_buffer_copy_offset_alignment");
    SetInteger(optimalBufferCopyRowPitchAlignment, "optimal_buffer_copy_row_pitch_alignment");
    SetInteger(nonCoherentAtomSize, "non_coherent_atom_size");
ZPUSH_END

ZPUSH_BEGIN(VkPhysicalDeviceSparseProperties)
    lua_newtable(L);
    SetBoolean(residencyStandard2DBlockShape, "residency_standard_2d_block_shape");
    SetBoolean(residencyStandard2DMultisampleBlockShape, "residency_standard_2d_multisample_block_shape");
    SetBoolean(residencyStandard3DBlockShape, "residency_standard_3d_block_shape");
    SetBoolean(residencyAlignedMipSize, "residency_aligned_mip_size");
    SetBoolean(residencyNonResidentStrict, "residency_non_resident_strict");
ZPUSH_END

/*------------------------------------------------------------------------------*/

static ZPUSH_BEGIN(VkConformanceVersion)
    lua_newtable(L);
    SetInteger(major, "major");
    SetInteger(minor, "minor");
    SetInteger(subminor, "subminor");
    SetInteger(patch, "patch");
ZPUSH_END

LOCALPUSH_BEGIN(VkPhysicalDeviceProperties)
    SetInteger(apiVersion, "api_version");
    SetInteger(driverVersion, "driver_version");
    SetInteger(vendorID, "vendor_id");
    SetInteger(deviceID, "device_id");
    SetEnum(deviceType, "device_type", pushphysicaldevicetype);
    SetString(deviceName, "device_name");
    SetUUID(pipelineCacheUUID, "pipeline_cache_uuid", VK_UUID_SIZE);
    SetStruct(limits, "limits", VkPhysicalDeviceLimits);
    SetStruct(sparseProperties, "sparse_properties", VkPhysicalDeviceSparseProperties);
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDevicePushDescriptorPropertiesKHR)
    SetInteger(maxPushDescriptors, "max_push_descriptors");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT)
    SetInteger(advancedBlendMaxColorAttachments, "advanced_blend_max_color_attachments");
    SetBoolean(advancedBlendIndependentBlend, "advanced_blend_independent_blend");
    SetBoolean(advancedBlendNonPremultipliedSrcColor, "advanced_blend_non_premultiplied_src_color");
    SetBoolean(advancedBlendNonPremultipliedDstColor, "advanced_blend_non_premultiplied_dst_color");
    SetBoolean(advancedBlendCorrelatedOverlap, "advanced_blend_correlated_overlap");
    SetBoolean(advancedBlendAllOperations, "advanced_blend_all_operations");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceSamplerFilterMinmaxProperties)
    SetBoolean(filterMinmaxSingleComponentFormats, "filter_minmax_single_component_formats");
    SetBoolean(filterMinmaxImageComponentMapping, "filter_minmax_image_component_mapping");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceDiscardRectanglePropertiesEXT)
    SetInteger(maxDiscardRectangles, "max_discard_rectangles");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceIDProperties)
    SetUUID(deviceUUID, "device_uuid", VK_UUID_SIZE);
    SetUUID(driverUUID, "driver_uuid", VK_UUID_SIZE);
    SetUUID(deviceLUID, "device_luid", VK_LUID_SIZE);
    SetInteger(deviceNodeMask, "device_node_mask");
    SetBoolean(deviceLUIDValid, "device_luid_valid");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDevicePointClippingProperties)
    SetEnum(pointClippingBehavior, "point_clipping_behavior", pushpointclippingbehavior);
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceSampleLocationsPropertiesEXT)
    SetFlags(sampleLocationSampleCounts, "sample_location_sample_counts");
    SetStruct(maxSampleLocationGridSize, "max_sample_location_grid_size", VkExtent2D);
    SetNumberArray(sampleLocationCoordinateRange, "sample_location_coordinate_range", 2);
    SetInteger(sampleLocationSubPixelBits, "sample_location_sub_pixel_bits");
    SetBoolean(variableSampleLocations, "variable_sample_locations");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceMaintenance3Properties)
    SetInteger(maxPerSetDescriptors, "max_per_set_descriptors");
    SetInteger(maxMemoryAllocationSize, "max_memory_allocation_size");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceSubgroupProperties)
    SetFlags(supportedStages, "supported_stages");
    SetFlags(supportedOperations, "supported_operations");
    SetBoolean(quadOperationsInAllStages, "quad_operations_in_all_stages");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceProtectedMemoryProperties)
    SetBoolean(protectedNoFault, "protected_no_fault");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceConservativeRasterizationPropertiesEXT)
    SetNumber(primitiveOverestimationSize, "primitive_overestimation_size");
    SetNumber(maxExtraPrimitiveOverestimationSize, "max_extra_primitive_overestimation_size");
    SetNumber(extraPrimitiveOverestimationSizeGranularity, "extra_primitive_overestimation_size_granularity");
    SetBoolean(primitiveUnderestimation, "primitive_underestimation");
    SetBoolean(conservativePointAndLineRasterization, "conservative_point_and_line_rasterization");
    SetBoolean(degenerateTrianglesRasterized, "degenerate_triangles_rasterized");
    SetBoolean(degenerateLinesRasterized, "degenerate_lines_rasterized");
    SetBoolean(fullyCoveredFragmentShaderInputVariable, "fully_covered_fragment_shader_input_variable");
    SetBoolean(conservativeRasterizationPostDepthCoverage, "conservative_rasterization_post_depth_coverage");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT)
    SetInteger(maxVertexAttribDivisor, "max_vertex_attrib_divisor");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceInlineUniformBlockPropertiesEXT)
    SetInteger(maxInlineUniformBlockSize, "max_inline_uniform_block_size");
    SetInteger(maxPerStageDescriptorInlineUniformBlocks, "max_per_stage_descriptor_inline_uniform_blocks");
    SetInteger(maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks, "max_per_stage_descriptor_update_after_bind_inline_uniform_blocks");
    SetInteger(maxDescriptorSetInlineUniformBlocks, "max_descriptor_set_inline_uniform_blocks");
    SetInteger(maxDescriptorSetUpdateAfterBindInlineUniformBlocks, "max_descriptor_set_update_after_bind_inline_uniform_blocks");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceDescriptorIndexingProperties)
    SetBoolean(shaderUniformBufferArrayNonUniformIndexingNative, "shader_uniform_buffer_array_non_uniform_indexing_native");
    SetBoolean(shaderSampledImageArrayNonUniformIndexingNative, "shader_sampled_image_array_non_uniform_indexing_native");
    SetBoolean(shaderStorageBufferArrayNonUniformIndexingNative, "shader_storage_buffer_array_non_uniform_indexing_native");
    SetBoolean(shaderStorageImageArrayNonUniformIndexingNative, "shader_storage_image_array_non_uniform_indexing_native");
    SetBoolean(shaderInputAttachmentArrayNonUniformIndexingNative, "shader_input_attachment_array_non_uniform_indexing_native");
    SetBoolean(robustBufferAccessUpdateAfterBind, "robust_buffer_access_update_after_bind");
    SetBoolean(quadDivergentImplicitLod, "quad_divergent_implicit_lod");
    SetInteger(maxPerStageDescriptorUpdateAfterBindSamplers, "max_per_stage_descriptor_update_after_bind_samplers");
    SetInteger(maxPerStageDescriptorUpdateAfterBindUniformBuffers, "max_per_stage_descriptor_update_after_bind_uniform_buffers");
    SetInteger(maxPerStageDescriptorUpdateAfterBindStorageBuffers, "max_per_stage_descriptor_update_after_bind_storage_buffers");
    SetInteger(maxPerStageDescriptorUpdateAfterBindSampledImages, "max_per_stage_descriptor_update_after_bind_sampled_images");
    SetInteger(maxPerStageDescriptorUpdateAfterBindStorageImages, "max_per_stage_descriptor_update_after_bind_storage_images");
    SetInteger(maxPerStageDescriptorUpdateAfterBindInputAttachments, "max_per_stage_descriptor_update_after_bind_input_attachments");
    SetInteger(maxPerStageUpdateAfterBindResources, "max_per_stage_update_after_bind_resources");
    SetInteger(maxDescriptorSetUpdateAfterBindSamplers, "max_descriptor_set_update_after_bind_samplers");
    SetInteger(maxDescriptorSetUpdateAfterBindUniformBuffers, "max_descriptor_set_update_after_bind_uniform_buffers");
    SetInteger(maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, "max_descriptor_set_update_after_bind_uniform_buffers_dynamic");
    SetInteger(maxDescriptorSetUpdateAfterBindStorageBuffers, "max_descriptor_set_update_after_bind_storage_buffers");
    SetInteger(maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, "max_descriptor_set_update_after_bind_storage_buffers_dynamic");
    SetInteger(maxDescriptorSetUpdateAfterBindSampledImages, "max_descriptor_set_update_after_bind_sampled_images");
    SetInteger(maxDescriptorSetUpdateAfterBindStorageImages, "max_descriptor_set_update_after_bind_storage_images");
    SetInteger(maxDescriptorSetUpdateAfterBindInputAttachments, "max_descriptor_set_update_after_bind_input_attachments");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceMultiviewPropertiesKHR)
    SetInteger(maxMultiviewViewCount, "max_multiview_view_count");
    SetInteger(maxMultiviewInstanceIndex, "max_multiview_instance_index");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceExternalMemoryHostPropertiesEXT)
    SetInteger(minImportedHostPointerAlignment, "min_imported_host_pointer_alignment");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceDriverProperties)
    if(p->driverID!=0) SetEnum(driverID, "driver_id", pushdriverid); //@@
    SetString(driverName, "driver_name");
    SetString(driverInfo, "driver_info");
    SetStruct(conformanceVersion, "conformance_version", VkConformanceVersion);
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDevicePCIBusInfoPropertiesEXT)
    SetInteger(pciDomain, "pci_domain");
    SetInteger(pciBus, "pci_bus");
    SetInteger(pciDevice, "pci_device");
    SetInteger(pciFunction, "pci_function");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceTransformFeedbackPropertiesEXT)
    SetInteger(maxTransformFeedbackStreams, "max_transform_feedback_streams");
    SetInteger(maxTransformFeedbackBuffers, "max_transform_feedback_buffers");
    SetInteger(maxTransformFeedbackBufferSize, "max_transform_feedback_buffer_size");
    SetInteger(maxTransformFeedbackStreamDataSize, "max_transform_feedback_stream_data_size");
    SetInteger(maxTransformFeedbackBufferDataSize, "max_transform_feedback_buffer_data_size");
    SetInteger(maxTransformFeedbackBufferDataStride, "max_transform_feedback_buffer_data_stride");
    SetBoolean(transformFeedbackQueries, "transform_feedback_queries");
    SetBoolean(transformFeedbackStreamsLinesTriangles, "transform_feedback_streams_lines_triangles");
    SetBoolean(transformFeedbackRasterizationStreamSelect, "transform_feedback_rasterization_stream_select");
    SetBoolean(transformFeedbackDraw, "transform_feedback_draw");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceFloatControlsProperties)
    SetEnum(denormBehaviorIndependence, "denorm_behavior_independence", pushshaderfloatcontrolsindependence);
    SetEnum(roundingModeIndependence, "rounding_mode_independence", pushshaderfloatcontrolsindependence);
    SetBoolean(shaderSignedZeroInfNanPreserveFloat16, "shader_signed_zero_inf_nan_preserve_float16");
    SetBoolean(shaderSignedZeroInfNanPreserveFloat32, "shader_signed_zero_inf_nan_preserve_float32");
    SetBoolean(shaderSignedZeroInfNanPreserveFloat64, "shader_signed_zero_inf_nan_preserve_float64");
    SetBoolean(shaderDenormPreserveFloat16, "shader_denorm_preserve_float16");
    SetBoolean(shaderDenormPreserveFloat32, "shader_denorm_preserve_float32");
    SetBoolean(shaderDenormPreserveFloat64, "shader_denorm_preserve_float64");
    SetBoolean(shaderDenormFlushToZeroFloat16, "shader_denorm_flush_to_zero_float16");
    SetBoolean(shaderDenormFlushToZeroFloat32, "shader_denorm_flush_to_zero_float32");
    SetBoolean(shaderDenormFlushToZeroFloat64, "shader_denorm_flush_to_zero_float64");
    SetBoolean(shaderRoundingModeRTEFloat16, "shader_rounding_mode_rte_float16");
    SetBoolean(shaderRoundingModeRTEFloat32, "shader_rounding_mode_rte_float32");
    SetBoolean(shaderRoundingModeRTEFloat64, "shader_rounding_mode_rte_float64");
    SetBoolean(shaderRoundingModeRTZFloat16, "shader_rounding_mode_rtz_float16");
    SetBoolean(shaderRoundingModeRTZFloat32, "shader_rounding_mode_rtz_float32");
    SetBoolean(shaderRoundingModeRTZFloat64, "shader_rounding_mode_rtz_float64");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceDepthStencilResolveProperties)
    SetFlags(supportedDepthResolveModes, "supported_depth_resolve_modes");
    SetFlags(supportedStencilResolveModes, "supported_stencil_resolve_modes");
    SetBoolean(independentResolveNone, "independent_resolve_none");
    SetBoolean(independentResolve, "independent_resolve");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceFragmentDensityMapPropertiesEXT)
    SetStruct(minFragmentDensityTexelSize, "min_fragment_density_texel_size", VkExtent2D);
    SetStruct(maxFragmentDensityTexelSize, "max_fragment_density_texel_size", VkExtent2D);
    SetBoolean(fragmentDensityInvocations, "fragment_density_invocations");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceMemoryBudgetPropertiesEXT)
    SetIntegerArray(heapBudget, "heap_budget", VK_MAX_MEMORY_HEAPS);
    SetIntegerArray(heapUsage, "heap_usage", VK_MAX_MEMORY_HEAPS);
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT)
    SetInteger(storageTexelBufferOffsetAlignmentBytes, "storage_texel_buffer_offset_alignment_bytes");
    SetBoolean(storageTexelBufferOffsetSingleTexelAlignment, "storage_texel_buffer_offset_single_texel_alignment");
    SetInteger(uniformTexelBufferOffsetAlignmentBytes, "uniform_texel_buffer_offset_alignment_bytes");
    SetBoolean(uniformTexelBufferOffsetSingleTexelAlignment, "uniform_texel_buffer_offset_single_texel_alignment");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDevicePerformanceQueryPropertiesKHR)
    SetBoolean(allowCommandBufferQueryCopies, "allow_command_buffer_query_copies");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceTimelineSemaphoreProperties)
    SetInteger(maxTimelineSemaphoreValueDifference, "max_timeline_semaphore_value_difference");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceFragmentShadingRatePropertiesKHR)
    SetStruct(minFragmentShadingRateAttachmentTexelSize, "min_fragment_shading_rate_attachment_texel_size", VkExtent2D);
    SetStruct(maxFragmentShadingRateAttachmentTexelSize, "max_fragment_shading_rate_attachment_texel_size", VkExtent2D);
    SetInteger(maxFragmentShadingRateAttachmentTexelSizeAspectRatio, "max_fragment_shading_rate_attachment_texel_size_aspect_ratio");
    SetBoolean(primitiveFragmentShadingRateWithMultipleViewports, "primitive_fragment_shading_rate_with_multiple_viewports");
    SetBoolean(layeredShadingRateAttachments, "layered_shading_rate_attachments");
    SetBoolean(fragmentShadingRateNonTrivialCombinerOps, "fragment_shading_rate_non_trivial_combiner_ops");
    SetStruct(maxFragmentSize, "max_fragment_size", VkExtent2D);
    SetInteger(maxFragmentSizeAspectRatio, "max_fragment_size_aspect_ratio");
    SetInteger(maxFragmentShadingRateCoverageSamples, "max_fragment_shading_rate_coverage_samples");
    SetFlags(maxFragmentShadingRateRasterizationSamples, "max_fragment_shading_rate_rasterization_samples");
    SetBoolean(fragmentShadingRateWithShaderDepthStencilWrites, "fragment_shading_rate_with_shader_depth_stencil_writes");
    SetBoolean(fragmentShadingRateWithSampleMask, "fragment_shading_rate_with_sample_mask");
    SetBoolean(fragmentShadingRateWithShaderSampleMask, "fragment_shading_rate_with_shader_sample_mask");
    SetBoolean(fragmentShadingRateWithConservativeRasterization, "fragment_shading_rate_with_conservative_rasterization");
    SetBoolean(fragmentShadingRateWithFragmentShaderInterlock, "fragment_shading_rate_with_fragment_shader_interlock");
    SetBoolean(fragmentShadingRateWithCustomSampleLocations, "fragment_shading_rate_with_custom_sample_locations");
    SetBoolean(fragmentShadingRateStrictMultiplyCombiner, "fragment_shading_rate_strict_multiply_combiner");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceAccelerationStructurePropertiesKHR)
    SetInteger(maxGeometryCount, "max_geometry_count");
    SetInteger(maxInstanceCount, "max_instance_count");
    SetInteger(maxPrimitiveCount, "max_primitive_count");
    SetInteger(maxPerStageDescriptorAccelerationStructures, "max_per_stage_descriptor_acceleration_structures");
    SetInteger(maxPerStageDescriptorUpdateAfterBindAccelerationStructures, "max_per_stage_descriptor_update_after_bind_acceleration_structures");
    SetInteger(maxDescriptorSetAccelerationStructures, "max_descriptor_set_acceleration_structures");
    SetInteger(maxDescriptorSetUpdateAfterBindAccelerationStructures, "max_descriptor_set_update_after_bind_acceleration_structures");
    SetInteger(minAccelerationStructureScratchOffsetAlignment, "min_acceleration_structure_scratch_offset_alignment");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceRayTracingPipelinePropertiesKHR)
    SetInteger(shaderGroupHandleSize, "shader_group_handle_size");
    SetInteger(maxRayRecursionDepth, "max_ray_recursion_depth");
    SetInteger(maxShaderGroupStride, "max_shader_group_stride");
    SetInteger(shaderGroupBaseAlignment, "shader_group_base_alignment");
    SetInteger(shaderGroupHandleCaptureReplaySize, "shader_group_handle_capture_replay_size");
    SetInteger(maxRayDispatchInvocationCount, "max_ray_dispatch_invocation_count");
    SetInteger(shaderGroupHandleAlignment, "shader_group_handle_alignment");
    SetInteger(maxRayHitAttributeSize, "max_ray_hit_attribute_size");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceSubgroupSizeControlPropertiesEXT)
    SetInteger(minSubgroupSize, "min_subgroup_size");
    SetInteger(maxSubgroupSize, "max_subgroup_size");
    SetInteger(maxComputeWorkgroupSubgroups, "max_compute_workgroup_subgroups");
    SetFlags(requiredSubgroupSizeStages, "required_subgroup_size_stages");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceProvokingVertexPropertiesEXT)
    SetBoolean(provokingVertexModePerPipeline, "provoking_vertex_mode_per_pipeline");
    SetBoolean(transformFeedbackPreservesTriangleFanProvokingVertex, "transform_feedback_preserves_triangle_fan_provoking_vertex");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceLineRasterizationPropertiesEXT)
    SetInteger(lineSubPixelPrecisionBits, "line_sub_pixel_precision_bits");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceRobustness2PropertiesEXT)
    SetInteger(robustStorageBufferAccessSizeAlignment, "robust_storage_buffer_access_size_alignment");
    SetInteger(robustUniformBufferAccessSizeAlignment, "robust_uniform_buffer_access_size_alignment");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceCustomBorderColorPropertiesEXT)
    SetInteger(maxCustomBorderColorSamplers, "max_custom_border_color_samplers");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT)
    SetBoolean(subsampledLoads, "subsampled_loads");
    SetBoolean(subsampledCoarseReconstructionEarlyAccess, "subsampled_coarse_reconstruction_early_access");
    SetInteger(maxSubsampledArrayLayers, "max_subsampled_array_layers");
    SetInteger(maxDescriptorSetSubsampledSamplers, "max_descriptor_set_subsampled_samplers");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceDrmPropertiesEXT)
    SetBoolean(hasPrimary, "has_primary");
    SetBoolean(hasRender, "has_render");
    SetInteger(primaryMajor, "primary_major");
    SetInteger(primaryMinor, "primary_minor");
    SetInteger(renderMajor, "render_major");
    SetInteger(renderMinor, "render_minor");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceMultiDrawPropertiesEXT)
    SetInteger(maxMultiDrawCount, "max_multi_draw_count");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceMaintenance4PropertiesKHR)
    SetInteger(maxBufferSize, "max_buffer_size");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR)
    SetBoolean(integerDotProduct8BitUnsignedAccelerated, "integer_dot_product_8bit_unsigned_accelerated");
    SetBoolean(integerDotProduct8BitSignedAccelerated, "integer_dot_product_8bit_signed_accelerated");
    SetBoolean(integerDotProduct8BitMixedSignednessAccelerated, "integer_dot_product_8bit_mixed_signedness_accelerated");
    SetBoolean(integerDotProduct4x8BitPackedUnsignedAccelerated, "integer_dot_product_4x8bit_packed_unsigned_accelerated");
    SetBoolean(integerDotProduct4x8BitPackedSignedAccelerated, "integer_dot_product_4x8bit_packed_signed_accelerated");
    SetBoolean(integerDotProduct4x8BitPackedMixedSignednessAccelerated, "integer_dot_product_4x8bit_packed_mixed_signedness_accelerated");
    SetBoolean(integerDotProduct16BitUnsignedAccelerated, "integer_dot_product_16bit_unsigned_accelerated");
    SetBoolean(integerDotProduct16BitSignedAccelerated, "integer_dot_product_16bit_signed_accelerated");
    SetBoolean(integerDotProduct16BitMixedSignednessAccelerated, "integer_dot_product_16bit_mixed_signedness_accelerated");
    SetBoolean(integerDotProduct32BitUnsignedAccelerated, "integer_dot_product_32bit_unsigned_accelerated");
    SetBoolean(integerDotProduct32BitSignedAccelerated, "integer_dot_product_32bit_signed_accelerated");
    SetBoolean(integerDotProduct32BitMixedSignednessAccelerated, "integer_dot_product_32bit_mixed_signedness_accelerated");
    SetBoolean(integerDotProduct64BitUnsignedAccelerated, "integer_dot_product_64bit_unsigned_accelerated");
    SetBoolean(integerDotProduct64BitSignedAccelerated, "integer_dot_product_64bit_signed_accelerated");
    SetBoolean(integerDotProduct64BitMixedSignednessAccelerated, "integer_dot_product_64bit_mixed_signedness_accelerated");
    SetBoolean(integerDotProductAccumulatingSaturating8BitUnsignedAccelerated, "integer_dot_product_accumulating_saturating_8bit_unsigned_accelerated");
    SetBoolean(integerDotProductAccumulatingSaturating8BitSignedAccelerated, "integer_dot_product_accumulating_saturating_8bit_signed_accelerated");
    SetBoolean(integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated, "integer_dot_product_accumulating_saturating_8bit_mixed_signedness_accelerated");
    SetBoolean(integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated, "integer_dot_product_accumulating_saturating_4x8bit_packed_unsigned_accelerated");
    SetBoolean(integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated, "integer_dot_product_accumulating_saturating_4x8bit_packed_signed_accelerated");
    SetBoolean(integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated, "integer_dot_product_accumulating_saturating_4x8bit_packed_mixed_signedness_accelerated");
    SetBoolean(integerDotProductAccumulatingSaturating16BitUnsignedAccelerated, "integer_dot_product_accumulating_saturating_16bit_unsigned_accelerated");
    SetBoolean(integerDotProductAccumulatingSaturating16BitSignedAccelerated, "integer_dot_product_accumulating_saturating_16bit_signed_accelerated");
    SetBoolean(integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated, "integer_dot_product_accumulating_saturating_16bit_mixed_signedness_accelerated");
    SetBoolean(integerDotProductAccumulatingSaturating32BitUnsignedAccelerated, "integer_dot_product_accumulating_saturating_32bit_unsigned_accelerated");
    SetBoolean(integerDotProductAccumulatingSaturating32BitSignedAccelerated, "integer_dot_product_accumulating_saturating_32bit_signed_accelerated");
    SetBoolean(integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated, "integer_dot_product_accumulating_saturating_32bit_mixed_signedness_accelerated");
    SetBoolean(integerDotProductAccumulatingSaturating64BitUnsignedAccelerated, "integer_dot_product_accumulating_saturating_64bit_unsigned_accelerated");
    SetBoolean(integerDotProductAccumulatingSaturating64BitSignedAccelerated, "integer_dot_product_accumulating_saturating_64bit_signed_accelerated");
    SetBoolean(integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated, "integer_dot_product_accumulating_saturating_64bit_mixed_signedness_accelerated");
LOCALPUSH_END


ZINIT_BEGIN(VkPhysicalDeviceProperties2)
    EXTENSIONS_BEGIN
        ADDX(PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR, VkPhysicalDevicePushDescriptorPropertiesKHR);
        ADDX(PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT);
        ADDX(PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES, VkPhysicalDeviceSamplerFilterMinmaxProperties);
        ADDX(PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT, VkPhysicalDeviceDiscardRectanglePropertiesEXT);
        ADDX(PHYSICAL_DEVICE_ID_PROPERTIES, VkPhysicalDeviceIDProperties);
        ADDX(PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES, VkPhysicalDevicePointClippingProperties);
        ADDX(PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT, VkPhysicalDeviceSampleLocationsPropertiesEXT);
        ADDX(PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES, VkPhysicalDeviceMaintenance3Properties);
        ADDX(PHYSICAL_DEVICE_SUBGROUP_PROPERTIES, VkPhysicalDeviceSubgroupProperties);
        ADDX(PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES, VkPhysicalDeviceProtectedMemoryProperties);
        ADDX(PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT, VkPhysicalDeviceConservativeRasterizationPropertiesEXT);
        ADDX(PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT);
        ADDX(PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT, VkPhysicalDeviceInlineUniformBlockPropertiesEXT);
        ADDX(PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES, VkPhysicalDeviceDescriptorIndexingProperties);
        ADDX(PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR, VkPhysicalDeviceMultiviewPropertiesKHR);
        ADDX(PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT, VkPhysicalDeviceExternalMemoryHostPropertiesEXT);
        ADDX(PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR, VkPhysicalDeviceDriverProperties);
        ADDX(PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT, VkPhysicalDevicePCIBusInfoPropertiesEXT);
        ADDX(PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT, VkPhysicalDeviceTransformFeedbackPropertiesEXT);

        ADDX(PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES, VkPhysicalDeviceFloatControlsProperties);
        ADDX(PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES, VkPhysicalDeviceDepthStencilResolveProperties);
        ADDX(PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT, VkPhysicalDeviceFragmentDensityMapPropertiesEXT);
        ADDX(PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT, VkPhysicalDeviceMemoryBudgetPropertiesEXT);
        ADDX(PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT, VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT);
        ADDX(PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR, VkPhysicalDevicePerformanceQueryPropertiesKHR);
        ADDX(PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES, VkPhysicalDeviceTimelineSemaphoreProperties);
        ADDX(PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR, VkPhysicalDeviceFragmentShadingRatePropertiesKHR);
        ADDX(PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR, VkPhysicalDeviceAccelerationStructurePropertiesKHR);
        ADDX(PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR, VkPhysicalDeviceRayTracingPipelinePropertiesKHR);
        ADDX(PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT, VkPhysicalDeviceSubgroupSizeControlPropertiesEXT);
        ADDX(PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT, VkPhysicalDeviceProvokingVertexPropertiesEXT);
        ADDX(PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT, VkPhysicalDeviceLineRasterizationPropertiesEXT);
        ADDX(PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT, VkPhysicalDeviceRobustness2PropertiesEXT);
        ADDX(PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT, VkPhysicalDeviceCustomBorderColorPropertiesEXT);
        ADDX(PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT);
        ADDX(PHYSICAL_DEVICE_DRM_PROPERTIES_EXT, VkPhysicalDeviceDrmPropertiesEXT);
        ADDX(PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT, VkPhysicalDeviceMultiDrawPropertiesEXT);
        ADDX(PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR, VkPhysicalDeviceMaintenance4PropertiesKHR);
        ADDX(PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR, VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR);
    EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkPhysicalDeviceProperties)
    lua_newtable(L);
    localpushVkPhysicalDeviceProperties(L, p);
ZPUSH_END

ZPUSH_BEGIN(VkPhysicalDeviceProperties2)
    lua_newtable(L);
    localpushVkPhysicalDeviceProperties(L, &p->properties);
    XPUSH_BEGIN
        XCASE(PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR, VkPhysicalDevicePushDescriptorPropertiesKHR);
        XCASE(PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT);
        XCASE(PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES, VkPhysicalDeviceSamplerFilterMinmaxProperties);
        XCASE(PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT, VkPhysicalDeviceDiscardRectanglePropertiesEXT);
        XCASE(PHYSICAL_DEVICE_ID_PROPERTIES, VkPhysicalDeviceIDProperties);
        XCASE(PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES, VkPhysicalDevicePointClippingProperties);
        XCASE(PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT, VkPhysicalDeviceSampleLocationsPropertiesEXT);
        XCASE(PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES, VkPhysicalDeviceMaintenance3Properties);
        XCASE(PHYSICAL_DEVICE_SUBGROUP_PROPERTIES, VkPhysicalDeviceSubgroupProperties);
        XCASE(PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES, VkPhysicalDeviceProtectedMemoryProperties);
        XCASE(PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT, VkPhysicalDeviceConservativeRasterizationPropertiesEXT);
        XCASE(PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT);
        XCASE(PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT, VkPhysicalDeviceInlineUniformBlockPropertiesEXT);
        XCASE(PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES, VkPhysicalDeviceDescriptorIndexingProperties);
        XCASE(PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR, VkPhysicalDeviceMultiviewPropertiesKHR);
        XCASE(PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT, VkPhysicalDeviceExternalMemoryHostPropertiesEXT);
        XCASE(PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR, VkPhysicalDeviceDriverProperties);
        XCASE(PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT, VkPhysicalDevicePCIBusInfoPropertiesEXT);
        XCASE(PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT, VkPhysicalDeviceTransformFeedbackPropertiesEXT);
        XCASE(PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES, VkPhysicalDeviceFloatControlsProperties);
        XCASE(PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES, VkPhysicalDeviceDepthStencilResolveProperties);
        XCASE(PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT, VkPhysicalDeviceFragmentDensityMapPropertiesEXT);
        XCASE(PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT, VkPhysicalDeviceMemoryBudgetPropertiesEXT);
        XCASE(PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT, VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT);
        XCASE(PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR, VkPhysicalDevicePerformanceQueryPropertiesKHR);
        XCASE(PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES, VkPhysicalDeviceTimelineSemaphoreProperties);
        XCASE(PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR, VkPhysicalDeviceFragmentShadingRatePropertiesKHR);
        XCASE(PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR, VkPhysicalDeviceAccelerationStructurePropertiesKHR);
        XCASE(PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR, VkPhysicalDeviceRayTracingPipelinePropertiesKHR);
        XCASE(PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT, VkPhysicalDeviceSubgroupSizeControlPropertiesEXT);
        XCASE(PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT, VkPhysicalDeviceProvokingVertexPropertiesEXT);
        XCASE(PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT, VkPhysicalDeviceLineRasterizationPropertiesEXT);
        XCASE(PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT, VkPhysicalDeviceRobustness2PropertiesEXT);
        XCASE(PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT, VkPhysicalDeviceCustomBorderColorPropertiesEXT);
        XCASE(PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT);
        XCASE(PHYSICAL_DEVICE_DRM_PROPERTIES_EXT, VkPhysicalDeviceDrmPropertiesEXT);
        XCASE(PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT, VkPhysicalDeviceMultiDrawPropertiesEXT);
        XCASE(PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR, VkPhysicalDeviceMaintenance4PropertiesKHR);
        XCASE(PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR, VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR);
    XPUSH_END
ZPUSH_END

/*------------------------------------------------------------------------------*
 | Group Properties                                                             |
 *------------------------------------------------------------------------------*/

ZINIT_BEGIN(VkPhysicalDeviceGroupPropertiesKHR)
    //EXTENSIONS_BEGIN
    //  ADDX(XXX, Xxx);
    //EXTENSIONS_END
ZINIT_END

//ZPUSH_BEGIN(VkPhysicalDeviceGroupPropertiesKHR)
int zpushVkPhysicalDeviceGroupPropertiesKHR(lua_State *L, const VkPhysicalDeviceGroupPropertiesKHR *p, VkInstance instance) // non-standard
    {
    uint32_t i;
    lua_newtable(L);
    lua_newtable(L);
    for(i = 0; i < p->physicalDeviceCount; i++)
        {
        pushphysical_device(L, p->physicalDevices[i], instance);
        lua_rawseti(L, -2, i+1);
        }
    lua_setfield(L, -2, "physical_devices");
    SetBoolean(subsetAllocation, "subset_allocation");
    //XPUSH_BEGIN
    //XPUSH_END
ZPUSH_END

/*------------------------------------------------------------------------------*
 | Other physical device properties (for standalone get functions)              |
 *------------------------------------------------------------------------------*/

ZINIT_BEGIN(VkPhysicalDeviceFragmentShadingRateKHR)
    //EXTENSIONS_BEGIN
    //  ADDX(XXX, Xxx);
    //EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkPhysicalDeviceFragmentShadingRateKHR)
    lua_newtable(L);
    SetFlags(sampleCounts, "sample_counts");
    SetStruct(fragmentSize, "fragment_size", VkExtent2D);
    //XPUSH_BEGIN
    //XPUSH_END
ZPUSH_END

/*------------------------------------------------------------------------------*/

ZINIT_BEGIN(VkPhysicalDeviceToolPropertiesEXT)
    //EXTENSIONS_BEGIN
    //  ADDX(XXX, Xxx);
    //EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkPhysicalDeviceToolPropertiesEXT)
    lua_newtable(L);
    SetString(name, "name");
    SetString(version, "version");
    SetFlags(purposes, "purposes");
    SetString(description, "description");
    SetString(layer, "layer");
    //XPUSH_BEGIN
    //XPUSH_END
ZPUSH_END

/*-------------------------------------------------------------------------------------*/

ZINIT_BEGIN(VkPerformanceCounterKHR)
    //EXTENSIONS_BEGIN
    //  ADDX(XXX, Xxx);
    //EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkPerformanceCounterKHR)
    lua_newtable(L);
    SetEnum(unit, "unit", pushperformancecounterunit);
    SetEnum(scope, "scope", pushperformancecounterscope);
    SetEnum(storage, "storage", pushperformancecounterstorage);
    SetUUID(uuid, "uuid", VK_UUID_SIZE);
    //XPUSH_BEGIN
    //XPUSH_END
ZPUSH_END

/*-------------------------------------------------------------------------------------*/

ZINIT_BEGIN(VkPerformanceCounterDescriptionKHR)
    //EXTENSIONS_BEGIN
    //  ADDX(XXX, Xxx);
    //EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkPerformanceCounterDescriptionKHR)
    lua_newtable(L);
    SetFlags(flags, "flags");
    SetString(name, "name");
    SetString(category, "category");
    SetString(description, "description");
    //XPUSH_BEGIN
    //XPUSH_END
ZPUSH_END


/*------------------------------------------------------------------------------*
 | Format Properties                                                            |
 *------------------------------------------------------------------------------*/

LOCALPUSH_BEGIN(VkFormatProperties)
    SetFlags(linearTilingFeatures, "linear_tiling_features");
    SetFlags(optimalTilingFeatures, "optimal_tiling_features");
    SetFlags(bufferFeatures, "buffer_features");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkFormatProperties3KHR)
    SetFlags(linearTilingFeatures, "linear_tiling_features");
    SetFlags(optimalTilingFeatures, "optimal_tiling_features");
    SetFlags(bufferFeatures, "buffer_features");
LOCALPUSH_END

ZINIT_BEGIN(VkFormatProperties2)
    EXTENSIONS_BEGIN
      ADDX(FORMAT_PROPERTIES_3_KHR, VkFormatProperties3KHR); // must stay first
    EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkFormatProperties)
    lua_newtable(L);
    localpushVkFormatProperties(L, p);
ZPUSH_END

ZPUSH_BEGIN(VkFormatProperties2)
    /* Ensure that the VkFormatProperties3KHR extension contains the flag values.
     * We must do this because the extension may not be supported, thus ignored, in
     * which case the driver would (or at least should) write only the fields of
     * p->formatProperties, and the extension flags would remain zero. */
    VkFormatProperties3KHR *prop = (VkFormatProperties3KHR*)p->pNext;
    if(prop->sType != VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR) /* paranoia */
        { unexpected(L); return 1; }
    prop->linearTilingFeatures |= (VkFlags64)p->formatProperties.linearTilingFeatures;
    prop->optimalTilingFeatures |= (VkFlags64)p->formatProperties.optimalTilingFeatures;
    prop->bufferFeatures |= (VkFlags64)p->formatProperties.bufferFeatures;
    lua_newtable(L);
    //localpushVkFormatProperties(L, &p->formatProperties);
    XPUSH_BEGIN
        XCASE(FORMAT_PROPERTIES_3_KHR, VkFormatProperties3KHR); // must stay first
    XPUSH_END
ZPUSH_END

/*------------------------------------------------------------------------------*
 | Physical Device Memory Properties                                            |
 *------------------------------------------------------------------------------*/

static int localpushVkMemoryType(lua_State *L, const VkMemoryType *p, uint32_t index)
    {
    lua_newtable(L);
    lua_pushinteger(L, index); lua_setfield(L, -2, "memory_type_index");
    SetFlags(propertyFlags, "property_flags");
    SetInteger(heapIndex, "heap_index");
    return 1;
    }
static int localpushVkMemoryHeap(lua_State *L, const VkMemoryHeap *p, uint32_t index)
    {
    lua_newtable(L);
    lua_pushinteger(L, index); lua_setfield(L, -2, "memory_heap_index");
    SetInteger(size, "size");
    SetFlags(flags, "flags");
    return 1;
    }

LOCALPUSH_BEGIN(VkPhysicalDeviceMemoryProperties)
    uint32_t i, tcount, hcount;
    tcount = (p->memoryTypeCount > VK_MAX_MEMORY_TYPES) ? VK_MAX_MEMORY_TYPES : p->memoryTypeCount;
    hcount = (p->memoryHeapCount > VK_MAX_MEMORY_HEAPS) ? VK_MAX_MEMORY_HEAPS : p->memoryHeapCount;
    lua_newtable(L);
    lua_newtable(L);
    for(i = 0; i < tcount; i++)
        {
        localpushVkMemoryType(L, &(p->memoryTypes[i]), i);
        lua_rawseti(L, -2, i+1);
        }
    lua_setfield(L, -2, "memory_types");
    lua_newtable(L);
    for(i = 0; i < hcount; i++)
        {
        localpushVkMemoryHeap(L, &(p->memoryHeaps[i]), i);
        lua_rawseti(L, -2, i+1);
        }
    lua_setfield(L, -2, "memory_heaps");
LOCALPUSH_END

ZINIT_BEGIN(VkPhysicalDeviceMemoryProperties2)
    //EXTENSIONS_BEGIN
    //  ADDX(XXX, Xxx);
    //EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkPhysicalDeviceMemoryProperties)
    lua_newtable(L);
    localpushVkPhysicalDeviceMemoryProperties(L, p);
ZPUSH_END

ZPUSH_BEGIN(VkPhysicalDeviceMemoryProperties2)
    lua_newtable(L);
    localpushVkPhysicalDeviceMemoryProperties(L, &p->memoryProperties);
    //XPUSH_BEGIN
    //XPUSH_END
ZPUSH_END

/*------------------------------------------------------------------------------*
 | Image Format Properties                                                      |
 *------------------------------------------------------------------------------*/

LOCALPUSH_BEGIN(VkImageFormatProperties)
    SetStruct(maxExtent, "max_extent", VkExtent3D);
    SetInteger(maxMipLevels, "max_mip_levels");
    SetInteger(maxArrayLayers, "max_array_layers");
    SetInteger(sampleCounts, "sample_counts");
    SetInteger(maxResourceSize, "max_resource_size");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkSamplerYcbcrConversionImageFormatProperties)
    SetInteger(combinedImageSamplerDescriptorCount, "combined_image_sampler_descriptor_count");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkExternalImageFormatProperties)
    SetStruct(externalMemoryProperties, "external_memory_properties", VkExternalMemoryProperties);
LOCALPUSH_END
LOCALPUSH_BEGIN(VkFilterCubicImageViewImageFormatPropertiesEXT)
    SetBoolean(filterCubic, "filter_cubic");
    SetBoolean(filterCubicMinmax , "filter_cubic_minmax ");
LOCALPUSH_END

ZINIT_BEGIN(VkImageFormatProperties2)
    EXTENSIONS_BEGIN
        ADDX(SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES, VkSamplerYcbcrConversionImageFormatProperties);
        ADDX(EXTERNAL_IMAGE_FORMAT_PROPERTIES, VkExternalImageFormatProperties);
        ADDX(FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT, VkFilterCubicImageViewImageFormatPropertiesEXT);
    EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkImageFormatProperties)
    lua_newtable(L);
    localpushVkImageFormatProperties(L, p);
ZPUSH_END

ZPUSH_BEGIN(VkImageFormatProperties2)
    lua_newtable(L);
    localpushVkImageFormatProperties(L, &p->imageFormatProperties);
    XPUSH_BEGIN
        XCASE(SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES, VkSamplerYcbcrConversionImageFormatProperties);
        XCASE(EXTERNAL_IMAGE_FORMAT_PROPERTIES, VkExternalImageFormatProperties);
        XCASE(FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT, VkFilterCubicImageViewImageFormatPropertiesEXT);
    XPUSH_END
ZPUSH_END

/*------------------------------------------------------------------------------*
 | Sparse Image Format Properties                                               |
 *------------------------------------------------------------------------------*/

LOCALPUSH_BEGIN(VkSparseImageFormatProperties)
    SetFlags(aspectMask, "aspect_mask");
    SetStruct(imageGranularity, "image_granularity", VkExtent3D);
    SetFlags(flags, "flags");
LOCALPUSH_END

ZINIT_BEGIN(VkSparseImageFormatProperties2)
    //EXTENSIONS_BEGIN
    //  ADDX(XXX, Xxx);
    //EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkSparseImageFormatProperties)
    lua_newtable(L);
    localpushVkSparseImageFormatProperties(L, p);
ZPUSH_END

ZPUSH_BEGIN(VkSparseImageFormatProperties2)
    lua_newtable(L);
    localpushVkSparseImageFormatProperties(L, &p->properties);
    //XPUSH_BEGIN
    //XPUSH_END
ZPUSH_END

/*------------------------------------------------------------------------------*
 | External Buffer/Fence/Semaphore Properties                                   |
 *------------------------------------------------------------------------------*/

ZPUSH_BEGIN(VkExternalBufferPropertiesKHR)
    lua_newtable(L);
    SetStruct(externalMemoryProperties, "external_memory_properties", VkExternalMemoryProperties);
ZPUSH_END

ZINIT_BEGIN(VkExternalBufferPropertiesKHR)
    (void)L; (void)p;
ZINIT_END

ZPUSH_BEGIN(VkExternalFencePropertiesKHR)
    lua_newtable(L);
    SetFlags(exportFromImportedHandleTypes, "export_from_imported_handle_types");
    SetFlags(compatibleHandleTypes, "compatible_handle_types");
    SetFlags(externalFenceFeatures, "external_fence_features");
ZPUSH_END

ZINIT_BEGIN(VkExternalFencePropertiesKHR)
    (void)L; (void)p;
ZINIT_END

ZPUSH_BEGIN(VkExternalSemaphorePropertiesKHR)
    lua_newtable(L);
    SetFlags(exportFromImportedHandleTypes, "export_from_imported_handle_types");
    SetFlags(compatibleHandleTypes, "compatible_handle_types");
    SetFlags(externalSemaphoreFeatures, "external_semaphore_features");
ZPUSH_END

ZINIT_BEGIN(VkExternalSemaphorePropertiesKHR)
    (void)L; (void)p;
ZINIT_END

ZPUSH_BEGIN(VkMultisamplePropertiesEXT)
    lua_newtable(L);
    SetStruct(maxSampleLocationGridSize, "max_sample_location_grid_size", VkExtent2D);
ZPUSH_END

ZINIT_BEGIN(VkMultisamplePropertiesEXT)
    (void)L; (void)p;
ZINIT_END


/*------------------------------------------------------------------------------*
 | Calibrated Timestamps                                                        |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkCalibratedTimestampInfoEXT)
    checktable(arg);
    newstruct(VkCalibratedTimestampInfoEXT);
    GetTimeDomain(timeDomain, "time_domain");
ZCHECK_END
ZCHECKARRAY(VkCalibratedTimestampInfoEXT)

/*------------------------------------------------------------------------------*
 | Surface Capabilities                                                         |
 *------------------------------------------------------------------------------*/

LOCALPUSH_BEGIN(VkSurfaceCapabilitiesKHR)
    SetInteger(minImageCount, "min_image_count");
    SetInteger(maxImageCount, "max_image_count");
    if(p->currentExtent.width != (uint32_t)-1)
        SetStruct(currentExtent, "current_extent", VkExtent2D);
        /* width and height are either both -1 or ~=-1
         * the first case means 'not present', so instead of setting the width and height 
         * table fields with 0xffffffff or -1 (which are not the same, in lua_Integers),
         * we don't set current_extent at all
         */
    SetStruct(minImageExtent, "min_image_extent", VkExtent2D);
    SetStruct(maxImageExtent, "max_image_extent", VkExtent2D);
    SetInteger(maxImageArrayLayers, "max_image_array_layers");
    SetFlags(supportedTransforms, "supported_transforms");
    SetBits(currentTransform, "current_transform");
    SetFlags(supportedCompositeAlpha, "supported_composite_alpha");
    SetFlags(supportedUsageFlags, "supported_usage_flags");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkSharedPresentSurfaceCapabilitiesKHR)
    SetFlags(sharedPresentSupportedUsageFlags, "shared_present_supported_usage_flags");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkSurfaceProtectedCapabilitiesKHR)
    SetFlags(supportsProtected, "supports_protected");
LOCALPUSH_END

ZINIT_BEGIN(VkSurfaceCapabilities2KHR)
    EXTENSIONS_BEGIN
        ADDX(SHARED_PRESENT_SURFACE_CAPABILITIES_KHR, VkSharedPresentSurfaceCapabilitiesKHR);
        ADDX(SURFACE_PROTECTED_CAPABILITIES_KHR, VkSurfaceProtectedCapabilitiesKHR);
    EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkSurfaceCapabilitiesKHR)
    lua_newtable(L);
    localpushVkSurfaceCapabilitiesKHR(L, p);
ZPUSH_END

ZPUSH_BEGIN(VkSurfaceCapabilities2KHR)
    lua_newtable(L);
    localpushVkSurfaceCapabilitiesKHR(L, &p->surfaceCapabilities);
    XPUSH_BEGIN
        XCASE(SHARED_PRESENT_SURFACE_CAPABILITIES_KHR, VkSharedPresentSurfaceCapabilitiesKHR);
        XCASE(SURFACE_PROTECTED_CAPABILITIES_KHR, VkSurfaceProtectedCapabilitiesKHR);
    XPUSH_END
ZPUSH_END

/*------------------------------------------------------------------------------*
 | Surface Format                                                               |
 *------------------------------------------------------------------------------*/

LOCALPUSH_BEGIN(VkSurfaceFormatKHR)
    SetEnum(format, "format", pushformat);
    SetEnum(colorSpace, "color_space", pushcolorspace);
LOCALPUSH_END

ZINIT_BEGIN(VkSurfaceFormat2KHR)
    //EXTENSIONS_BEGIN
    //  ADDX(XXX, Xxx);
    //EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkSurfaceFormatKHR)
    lua_newtable(L);
    localpushVkSurfaceFormatKHR(L, p);
ZPUSH_END

ZPUSH_BEGIN(VkSurfaceFormat2KHR)
    lua_newtable(L);
    localpushVkSurfaceFormatKHR(L, &p->surfaceFormat);
    //XPUSH_BEGIN
    //XPUSH_END
ZPUSH_END

/*------------------------------------------------------------------------------*
 | Surface Info                                                                 |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkPhysicalDeviceSurfaceInfo2KHR)
    checktable(arg);
    newstruct(VkPhysicalDeviceSurfaceInfo2KHR);
    GetSurface(surface, "surface");
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Queue Family Properties                                                      |
 *------------------------------------------------------------------------------*/

//LOCALPUSH_BEGIN(VkQueueFamilyProperties)
static int localpushVkQueueFamilyProperties(lua_State *L, const VkQueueFamilyProperties *p, uint32_t index) {
    lua_pushinteger(L, index); lua_setfield(L, -2, "queue_family_index");
    SetFlags(queueFlags, "queue_flags");
    SetInteger(queueCount, "queue_count");
    SetInteger(timestampValidBits, "timestamp_valid_bits");
    SetStruct(minImageTransferGranularity, "min_image_transfer_granularity", VkExtent3D);
LOCALPUSH_END

LOCALPUSH_BEGIN(VkQueueFamilyGlobalPriorityPropertiesEXT)
    SetEnumList(priorities, "priorities", pushqueueglobalpriority, p->priorityCount);
LOCALPUSH_END

ZINIT_BEGIN(VkQueueFamilyProperties2)
    EXTENSIONS_BEGIN
        ADDX(QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT, VkQueueFamilyGlobalPriorityPropertiesEXT);
    EXTENSIONS_END
ZINIT_END

//ZPUSH_BEGIN(VkQueueFamilyProperties)
int zpushVkQueueFamilyProperties(lua_State *L, const VkQueueFamilyProperties *p, uint32_t index) {
    lua_newtable(L);
    localpushVkQueueFamilyProperties(L, p, index);
ZPUSH_END

//ZPUSH_BEGIN(VkQueueFamilyProperties2)
int zpushVkQueueFamilyProperties2(lua_State *L, const VkQueueFamilyProperties2 *p, uint32_t index) {
    lua_newtable(L);
    localpushVkQueueFamilyProperties(L, &p->queueFamilyProperties, index);
    XPUSH_BEGIN
        XCASE(QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT, VkQueueFamilyGlobalPriorityPropertiesEXT);
    XPUSH_END
ZPUSH_END

/*------------------------------------------------------------------------------*
 | Memory Requirements                                                          |
 *------------------------------------------------------------------------------*/

LOCALPUSH_BEGIN(VkMemoryRequirements)
    SetInteger(size, "size");
    SetInteger(alignment, "alignment");
    SetInteger(memoryTypeBits, "memory_type_bits");
LOCALPUSH_END
LOCALPUSH_BEGIN(VkMemoryDedicatedRequirements)
    SetBoolean(prefersDedicatedAllocation, "prefers_dedicated_allocation");
    SetBoolean(requiresDedicatedAllocation, "requires_dedicated_allocation");
LOCALPUSH_END

ZINIT_BEGIN(VkMemoryRequirements2)
    EXTENSIONS_BEGIN
        ADDX(MEMORY_DEDICATED_REQUIREMENTS, VkMemoryDedicatedRequirements);
    EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkMemoryRequirements)
    lua_newtable(L);
    localpushVkMemoryRequirements(L, p);
ZPUSH_END

ZPUSH_BEGIN(VkMemoryRequirements2)
    lua_newtable(L);
    localpushVkMemoryRequirements(L, &p->memoryRequirements);
    XPUSH_BEGIN
        XCASE(MEMORY_DEDICATED_REQUIREMENTS, VkMemoryDedicatedRequirements);
    XPUSH_END
ZPUSH_END


/*------------------------------------------------------------------------------*
 | Buffer Memory Requirements                                                   |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkBufferMemoryRequirementsInfo2KHR)
    checktable(arg);
    newstruct(VkBufferMemoryRequirementsInfo2KHR);
    /* p->buffer = set by caller */
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Image Memory Requirements                                                    |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkImagePlaneMemoryRequirementsInfoKHR)
    newstruct(VkImagePlaneMemoryRequirementsInfoKHR);
    GetFlags(planeAspect, "plane_aspect");
ZCHECK_END

ZCHECK_BEGIN(VkImageMemoryRequirementsInfo2KHR)
    checktable(arg);
    newstruct(VkImageMemoryRequirementsInfo2KHR);
    /* p->image = set by caller */
    EXTENSIONS_BEGIN
    if(ispresent("plane_aspect"))
        ADD_EXTENSION_INLINE(VkImagePlaneMemoryRequirementsInfoKHR);
    EXTENSIONS_END
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Image Sparse Memory Requirements                                             |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkImageSparseMemoryRequirementsInfo2KHR)
    checktable(arg);
    newstruct(VkImageSparseMemoryRequirementsInfo2KHR);
    /* p->image = set by caller */
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Sparse Image Memory Requirements                                             |
 *------------------------------------------------------------------------------*/

LOCALPUSH_BEGIN(VkSparseImageMemoryRequirements)
    SetStruct(formatProperties, "format_properties", VkSparseImageFormatProperties);
    SetInteger(imageMipTailFirstLod, "image_mip_tail_first_lod");
    SetInteger(imageMipTailSize, "image_mip_tail_size");
    SetInteger(imageMipTailOffset, "image_mip_tail_offset");
    SetInteger(imageMipTailStride, "image_mip_tail_stride");
LOCALPUSH_END

ZINIT_BEGIN(VkSparseImageMemoryRequirements2)
    //EXTENSIONS_BEGIN
    //  ADDX(XXX, Xxx);
    //EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkSparseImageMemoryRequirements)
    lua_newtable(L);
    localpushVkSparseImageMemoryRequirements(L, p);
ZPUSH_END

ZPUSH_BEGIN(VkSparseImageMemoryRequirements2)
    lua_newtable(L);
    localpushVkSparseImageMemoryRequirements(L, &p->memoryRequirements);
    //XPUSH_BEGIN
    //XPUSH_END
ZPUSH_END

/*------------------------------------------------------------------------------*
 | Display Properties                                                           |
 *------------------------------------------------------------------------------*/

LOCALPUSH_BEGIN(VkDisplayPropertiesKHR)
/*  p->display = set by caller */
    SetString(displayName, "display_name");
    SetStruct(physicalDimensions, "physical_dimensions", VkExtent2D);
    SetStruct(physicalResolution, "physical_resolution", VkExtent2D);
    SetFlags(supportedTransforms, "supported_transforms");
    SetBoolean(planeReorderPossible, "plane_reorder_possible");
    SetBoolean(persistentContent, "persistent_content");
LOCALPUSH_END

ZINIT_BEGIN(VkDisplayProperties2KHR)
    //EXTENSIONS_BEGIN
    //  ADDX(, );
    //EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkDisplayPropertiesKHR)
    lua_newtable(L);
    localpushVkDisplayPropertiesKHR(L, p);
ZPUSH_END

ZPUSH_BEGIN(VkDisplayProperties2KHR)
    lua_newtable(L);
    localpushVkDisplayPropertiesKHR(L, &p->displayProperties);
    //XPUSH_BEGIN
    //XCASE(, );
    //XPUSH_END
ZPUSH_END

/*------------------------------------------------------------------------------*
 | Display Plane Properties                                                     |
 *------------------------------------------------------------------------------*/

LOCALPUSH_BEGIN(VkDisplayPlanePropertiesKHR)
/*  p->currentDisplay = set by caller */
    SetInteger(currentStackIndex, "current_stack_index");
LOCALPUSH_END

ZINIT_BEGIN(VkDisplayPlaneProperties2KHR)
    //EXTENSIONS_BEGIN
    //  ADDX(, );
    //EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkDisplayPlanePropertiesKHR)
    lua_newtable(L);
    localpushVkDisplayPlanePropertiesKHR(L, p);
ZPUSH_END

ZPUSH_BEGIN(VkDisplayPlaneProperties2KHR)
    lua_newtable(L);
    localpushVkDisplayPlanePropertiesKHR(L, &p->displayPlaneProperties);
    //XPUSH_BEGIN
    //XCASE(, );
    //XPUSH_END
ZPUSH_END

 
/*------------------------------------------------------------------------------*
 | Display Plane Capabilities                                                    |
 *------------------------------------------------------------------------------*/

LOCALPUSH_BEGIN(VkDisplayPlaneCapabilitiesKHR)
    SetFlags(supportedAlpha, "supported_alpha");
    SetStruct(minSrcPosition, "min_src_position", VkOffset2D);
    SetStruct(maxSrcPosition, "max_src_position", VkOffset2D);
    SetStruct(minSrcExtent, "min_src_extent", VkExtent2D);
    SetStruct(maxSrcExtent, "max_src_extent", VkExtent2D);
    SetStruct(minDstPosition, "min_dst_position", VkOffset2D);
    SetStruct(maxDstPosition, "max_dst_position", VkOffset2D);
    SetStruct(minDstExtent, "min_dst_extent", VkExtent2D);
    SetStruct(maxDstExtent, "max_dst_extent", VkExtent2D);
LOCALPUSH_END

ZINIT_BEGIN(VkDisplayPlaneCapabilities2KHR)
    //EXTENSIONS_BEGIN
    //  ADDX(, );
    //EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkDisplayPlaneCapabilitiesKHR)
    lua_newtable(L);
    localpushVkDisplayPlaneCapabilitiesKHR(L, p);
ZPUSH_END

ZPUSH_BEGIN(VkDisplayPlaneCapabilities2KHR)
    lua_newtable(L);
    localpushVkDisplayPlaneCapabilitiesKHR(L, &p->capabilities);
    //XPUSH_BEGIN
    //XCASE(, );
    //XPUSH_END
ZPUSH_END

/*------------------------------------------------------------------------------*
 | Display Plane Info                                                           |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkDisplayPlaneInfo2KHR)
    checktable(arg);
    newstruct(VkDisplayPlaneInfo2KHR);
/*  p->mode = set by caller */
    GetInteger(planeIndex, "plane_index");
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Display Mode Properties                                                     |
 *------------------------------------------------------------------------------*/

LOCALPUSH_BEGIN(VkDisplayModePropertiesKHR)
/*  p->displayMode = set by caller */
    SetStruct(parameters, "parameters", VkDisplayModeParametersKHR);
    return 1;
LOCALPUSH_END

ZINIT_BEGIN(VkDisplayModeProperties2KHR)
    //EXTENSIONS_BEGIN
    //  ADDX(, );
    //EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkDisplayModePropertiesKHR)
    lua_newtable(L);
    localpushVkDisplayModePropertiesKHR(L, p);
ZPUSH_END

ZPUSH_BEGIN(VkDisplayModeProperties2KHR)
    lua_newtable(L);
    localpushVkDisplayModePropertiesKHR(L, &p->displayModeProperties);
    //XPUSH_BEGIN
    //XCASE(, );
    //XPUSH_END
ZPUSH_END

/*------------------------------------------------------------------------------*
 | Device Group Present Capabilities                                            |
 *------------------------------------------------------------------------------*/

ZINIT_BEGIN(VkDeviceGroupPresentCapabilitiesKHR)
    //EXTENSIONS_BEGIN
    //  ADDX(, );
    //EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkDeviceGroupPresentCapabilitiesKHR)
    lua_newtable(L);
    SetIntegerArray(presentMask, "present_mask", VK_MAX_DEVICE_GROUP_SIZE);
    SetFlags(modes, "modes");
    //XPUSH_BEGIN
    //XCASE(, );
    //XPUSH_END
ZPUSH_END

/*------------------------------------------------------------------------------*
 | Instance                                                                     |
 *------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkValidationFlagsEXT)
    FreeEnumList(pDisabledValidationChecks, validationcheck);
ZCLEAR_END
ZCHECK_BEGIN(VkValidationFlagsEXT)
    newstruct(VkValidationFlagsEXT);
    GetEnumList(pDisabledValidationChecks, disabledValidationCheckCount, validationcheck, "disabled_validation_checks");
ZCHECK_END

static ZCLEAR_BEGIN(VkApplicationInfo)
    if(p->pApplicationName) Free(L, (char*)p->pApplicationName);
    if(p->pEngineName) Free(L, (char*)p->pEngineName);
ZCLEAR_END
ZCHECK_BEGIN(VkApplicationInfo)
    checktable(arg);
    newstruct(VkApplicationInfo);
    GetStringOpt(pApplicationName, "application_name");
    GetInteger(applicationVersion, "application_version");
    GetStringOpt(pEngineName, "engine_name");
    GetInteger(engineVersion, "engine_version");
    GetInteger(apiVersion, "api_version");
ZCHECK_END

static ZCLEAR_BEGIN(VkValidationFeaturesEXT)
    FreeEnumList(pEnabledValidationFeatures, validationfeatureenable);
    FreeEnumList(pDisabledValidationFeatures, validationfeaturedisable);
ZCLEAR_END
ZCHECK_BEGIN(VkValidationFeaturesEXT)
    newstruct(VkValidationFeaturesEXT);
    GetEnumList(pEnabledValidationFeatures, enabledValidationFeatureCount, validationfeatureenable, "enabled_validation_features");
    GetEnumList(pDisabledValidationFeatures, disabledValidationFeatureCount, validationfeaturedisable, "disabled_validation_features");
ZCHECK_END

static ZCLEAR_BEGIN(VkInstanceCreateInfo)
    FreeStructp(pApplicationInfo, VkApplicationInfo);
    FreeStringList(ppEnabledLayerNames, enabledLayerCount);
    FreeStringList(ppEnabledExtensionNames, enabledExtensionCount);
ZCLEAR_END
ZCHECK_BEGIN(VkInstanceCreateInfo)
    checktable(arg);
    newstruct(VkInstanceCreateInfo);
    GetFlags(flags, "flags");
    GetStructp(pApplicationInfo, VkApplicationInfo, "application_info");
    GetStringList(ppEnabledLayerNames, enabledLayerCount, "enabled_layer_names");
    GetStringList(ppEnabledExtensionNames, enabledExtensionCount, "enabled_extension_names");
    EXTENSIONS_BEGIN
    if(ispresent("disabled_validation_checks"))
        ADD_EXTENSION_INLINE(VkValidationFlagsEXT);
    if(ispresent("enabled_validation_features") || ispresent("disabled_validation_features"))
        ADD_EXTENSION_INLINE(VkValidationFeaturesEXT);
    EXTENSIONS_END
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Device                                                                       |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkDeviceQueueGlobalPriorityCreateInfoEXT)
    newstruct(VkDeviceQueueGlobalPriorityCreateInfoEXT);
    GetQueueGlobalPriority(globalPriority, "global_priority");
ZCHECK_END

static ZCLEAR_BEGIN(VkDeviceQueueCreateInfo)
    FreeFloatList(pQueuePriorities);
ZCLEAR_END
ZCHECK_BEGIN(VkDeviceQueueCreateInfo)
    checktable(arg);
    newstruct(VkDeviceQueueCreateInfo);
    GetFlags(flags, "flags");
    GetInteger(queueFamilyIndex, "queue_family_index");
    GetFloatList(pQueuePriorities, queueCount, "queue_priorities");
    EXTENSIONS_BEGIN
    if(ispresent("global_priority"))
        ADD_EXTENSION_INLINE(VkDeviceQueueGlobalPriorityCreateInfoEXT);
    EXTENSIONS_END
ZCHECK_END
ZCHECKARRAY(VkDeviceQueueCreateInfo) 

/*------------------------------------------------------------------------------*
 | Device Queue                                                                 |
 *------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkDeviceGroupDeviceCreateInfoKHR)
    FreeObjectList(pPhysicalDevices);
ZCLEAR_END
ZCHECK_BEGIN(VkDeviceGroupDeviceCreateInfoKHR)
    newstruct(VkDeviceGroupDeviceCreateInfoKHR);
    GetObjectList(pPhysicalDevices, physicalDeviceCount, physical_device, "physical_devices");
ZCHECK_END

static ZCLEAR_BEGIN(VkDeviceCreateInfo)
    FreeList(pQueueCreateInfos, queueCreateInfoCount, VkDeviceQueueCreateInfo);
    FreeStringList(ppEnabledLayerNames, enabledLayerCount);
    FreeStringList(ppEnabledExtensionNames, enabledExtensionCount);
    FreeStructp(pEnabledFeatures, VkPhysicalDeviceFeatures);
ZCLEAR_END

//ZCHECK_BEGIN(VkDeviceCreateInfo)
VkDeviceCreateInfo* zcheckVkDeviceCreateInfo(lua_State *L, int arg, int *err, ud_t *ud) { //non-standard
    VkDeviceCreateInfo *p;
    int arg1;
    checktable(arg);
    newstruct(VkDeviceCreateInfo);
    GetFlags(flags, "flags");
    GetList(pQueueCreateInfos, queueCreateInfoCount, VkDeviceQueueCreateInfo, "queue_create_infos");
    GetStringList(ppEnabledLayerNames, enabledLayerCount, "enabled_layer_names");/* deprecated */
    GetStringList(ppEnabledExtensionNames, enabledExtensionCount, "enabled_extension_names");
    if(!ud->idt->GetPhysicalDeviceFeatures2)
        GetStructp(pEnabledFeatures, VkPhysicalDeviceFeatures, "enabled_features");
    EXTENSIONS_BEGIN
    if(ud->idt->GetPhysicalDeviceFeatures2)
        ADD_EXTENSION_STRUCT("enabled_features", VkPhysicalDeviceFeatures2);
    if(ispresent("physical_devices"))
        ADD_EXTENSION_INLINE(VkDeviceGroupDeviceCreateInfoKHR);
    EXTENSIONS_END
ZCHECK_END

ZCHECK_BEGIN(VkDeviceQueueInfo2)
    checktable(arg);
    newstruct(VkDeviceQueueInfo2);
    GetFlags(flags, "flags");
    GetInteger(queueFamilyIndex, "queue_family_index");
    GetInteger(queueIndex, "queue_index");
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Command Pool                                                                 |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkCommandPoolCreateInfo)
    checktable(arg);
    newstruct(VkCommandPoolCreateInfo);
    GetFlags(flags, "flags");
    GetInteger(queueFamilyIndex, "queue_family_index");
ZCHECK_END

ZCHECK_BEGIN(VkCommandBufferAllocateInfo)
    checktable(arg);
    newstruct(VkCommandBufferAllocateInfo);
    GetCommandBufferLevel(level, "level");
    GetInteger(commandBufferCount, "command_buffer_count");
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Command Buffer                                                               |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkCommandBufferInheritanceConditionalRenderingInfoEXT)
    newstruct(VkCommandBufferInheritanceConditionalRenderingInfoEXT);
    GetBoolean(conditionalRenderingEnable, "conditional_rendering_enable");
ZCHECK_END

static ZCLEAR_BEGIN(VkCommandBufferInheritanceRenderingInfoKHR)
    FreeEnumList(pColorAttachmentFormats, format);
ZCLEAR_END
ZCHECK_BEGIN(VkCommandBufferInheritanceRenderingInfoKHR)
    checktable(arg);
    newstruct(VkCommandBufferInheritanceRenderingInfoKHR);
    GetFlags(flags, "flags");
    GetIntegerOpt(viewMask, "view_mask", 0);
    GetEnumList(pColorAttachmentFormats, colorAttachmentCount, format, "color_attachment_formats");
    GetFormat(depthAttachmentFormat, "depth_attachment_format");
    GetFormat(stencilAttachmentFormat, "stencil_attachment_format");
    GetFlags(rasterizationSamples, "rasterization_samples");
ZCHECK_END

ZCHECK_BEGIN(VkCommandBufferInheritanceInfo)
    checktable(arg);
    newstruct(VkCommandBufferInheritanceInfo);
    GetRenderPassOpt(renderPass, "render_pass");
    GetInteger(subpass, "subpass");
    GetFramebufferOpt(framebuffer, "framebuffer");
    GetBoolean(occlusionQueryEnable, "occlusion_query_enable");
    GetFlags(queryFlags, "query_flags");
    GetFlags(pipelineStatistics, "pipeline_statistics");
    EXTENSIONS_BEGIN
    if(ispresent("conditional_rendering_enable"))
        ADD_EXTENSION_INLINE(VkCommandBufferInheritanceConditionalRenderingInfoEXT);
    ADD_EXTENSION_STRUCT("rendering_info", VkCommandBufferInheritanceRenderingInfoKHR);
    EXTENSIONS_END
ZCHECK_END


ZCHECK_BEGIN(VkDeviceGroupCommandBufferBeginInfoKHR)
    newstruct(VkDeviceGroupCommandBufferBeginInfoKHR);
    GetInteger(deviceMask, "device_mask");
ZCHECK_END
 
static ZCLEAR_BEGIN(VkCommandBufferBeginInfo)
    FreeStructp(pInheritanceInfo, VkCommandBufferInheritanceInfo);
ZCLEAR_END
ZCHECK_BEGIN(VkCommandBufferBeginInfo)
    checktable(arg);
    newstruct(VkCommandBufferBeginInfo);
    GetFlags(flags, "flags");
    GetStructp(pInheritanceInfo, VkCommandBufferInheritanceInfo, "inheritance_info");
    EXTENSIONS_BEGIN
    if(ispresent("device_mask"))
        ADD_EXTENSION_INLINE(VkDeviceGroupCommandBufferBeginInfoKHR);
    EXTENSIONS_END
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Device Memory                                                                |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkMemoryDedicatedAllocateInfoKHR)
    newstruct(VkMemoryDedicatedAllocateInfoKHR);
    GetImageOpt(image, "image");
    GetBufferOpt(buffer, "buffer");
ZCHECK_END

ZCHECK_BEGIN(VkExportMemoryAllocateInfoKHR)
    newstruct(VkExportMemoryAllocateInfoKHR);
    GetFlags(handleTypes, "handle_types");
ZCHECK_END

ZCHECK_BEGIN(VkImportMemoryFdInfoKHR)
    newstruct(VkImportMemoryFdInfoKHR);
    GetBits(handleType, "fd_handle_type", VkExternalMemoryHandleTypeFlagBits);
    GetInteger(fd, "fd");
ZCHECK_END

ZCHECK_BEGIN(VkMemoryAllocateFlagsInfoKHR)
    newstruct(VkMemoryAllocateFlagsInfoKHR);
    GetFlags(flags, "flags");
    GetInteger(deviceMask, "device_mask");
ZCHECK_END

ZCHECK_BEGIN(VkImportMemoryHostPointerInfoEXT)
    newstruct(VkImportMemoryHostPointerInfoEXT);
    GetFlags(handleType, "host_pointer_handle_type");
    GetLightuserdata(pHostPointer, "host_pointer", void*);
ZCHECK_END

ZCHECK_BEGIN(VkMemoryOpaqueCaptureAddressAllocateInfo)
    newstruct(VkMemoryOpaqueCaptureAddressAllocateInfo);
    GetInteger(opaqueCaptureAddress, "opaque_capture_address");
ZCHECK_END

ZCHECK_BEGIN(VkMemoryPriorityAllocateInfoEXT)
    newstruct(VkMemoryPriorityAllocateInfoEXT);
    GetNumber(priority, "priority");
ZCHECK_END

ZCHECK_BEGIN(VkMemoryAllocateInfo)
    checktable(arg);
    newstruct(VkMemoryAllocateInfo);
    GetInteger(allocationSize, "allocation_size");
    GetInteger(memoryTypeIndex, "memory_type_index");
    EXTENSIONS_BEGIN
    if(ispresent("image") || ispresent("buffer"))
        ADD_EXTENSION_INLINE(VkMemoryDedicatedAllocateInfoKHR);
    if(ispresent("handle_types"))
        ADD_EXTENSION_INLINE(VkExportMemoryAllocateInfoKHR);
    if(ispresent("fd_handle_type") || ispresent("fd"))
        ADD_EXTENSION_INLINE(VkImportMemoryFdInfoKHR);
    if(ispresent("flags") || ispresent("device_mask"))
        ADD_EXTENSION_INLINE(VkMemoryAllocateFlagsInfoKHR);
    if(ispresent("host_pointer_handle_type") || ispresent("host_pointer"))
        ADD_EXTENSION_INLINE(VkImportMemoryHostPointerInfoEXT);
    if(ispresent("opaque_capture_address"))
        ADD_EXTENSION_INLINE(VkMemoryOpaqueCaptureAddressAllocateInfo);
    if(ispresent("priority"))
        ADD_EXTENSION_INLINE(VkMemoryPriorityAllocateInfoEXT);
    EXTENSIONS_END
ZCHECK_END

/*------------------------------------------------------------------------------*/

ZPUSH_BEGIN(VkMemoryFdPropertiesKHR)
    lua_newtable(L);
    SetInteger(memoryTypeBits, "memory_type_bits");
ZPUSH_END

ZPUSH_BEGIN(VkMemoryHostPointerPropertiesEXT)
    lua_newtable(L);
    SetInteger(memoryTypeBits, "memory_type_bits");
ZPUSH_END

/*------------------------------------------------------------------------------*/
ZCHECK_BEGIN(VkMemoryGetFdInfoKHR)
    checktable(arg);
    newstruct(VkMemoryGetFdInfoKHR);
    /* p->memory = set by caller */
    GetBits(handleType, "handle_type", VkExternalMemoryHandleTypeFlagBits);
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Buffer                                                                       |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkExternalMemoryBufferCreateInfo)
    newstruct(VkExternalMemoryBufferCreateInfo);
    GetFlags(handleTypes, "handle_types");
ZCHECK_END

ZCHECK_BEGIN(VkBufferOpaqueCaptureAddressCreateInfo)
    newstruct(VkBufferOpaqueCaptureAddressCreateInfo);
    GetInteger(opaqueCaptureAddress, "opaque_capture_address");
ZCHECK_END

static ZCLEAR_BEGIN(VkBufferCreateInfo)
    FreeUint32List(pQueueFamilyIndices);
ZCLEAR_END

ZCHECK_BEGIN(VkBufferCreateInfo)
    checktable(arg);
    newstruct(VkBufferCreateInfo);
    GetFlags(flags, "flags");
    GetInteger(size, "size");
    GetFlags(usage, "usage");
    GetSharingMode(sharingMode, "sharing_mode");
    GetUint32List(pQueueFamilyIndices, queueFamilyIndexCount, "queue_family_indices");
    EXTENSIONS_BEGIN
    if(ispresent("handle_types"))
        ADD_EXTENSION_INLINE(VkExternalMemoryBufferCreateInfo);
    if(ispresent("opaque_capture_address"))
        ADD_EXTENSION_INLINE(VkBufferOpaqueCaptureAddressCreateInfo);
    EXTENSIONS_END
ZCHECK_END

static ZCLEAR_BEGIN(VkDeviceBufferMemoryRequirementsKHR)
    FreeStructp(pCreateInfo, VkBufferCreateInfo);
ZCLEAR_END
ZCHECK_BEGIN(VkDeviceBufferMemoryRequirementsKHR)
    checktable(arg);
    newstruct(VkDeviceBufferMemoryRequirementsKHR);
    GetStructp(pCreateInfo, VkBufferCreateInfo, "create_info");
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Buffer View                                                                  |
 *------------------------------------------------------------------------------*/
    
ZCHECK_BEGIN(VkBufferViewCreateInfo)
    checktable(arg);
    newstruct(VkBufferViewCreateInfo);
    GetFlags(flags, "flags");
/*  p->buffer = set by caller */
    GetFormat(format, "format");
    GetInteger(offset, "offset");
    GetInteger(range, "range");
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Image                                                                        |
 *------------------------------------------------------------------------------*/
    
static ZCLEAR_BEGIN(VkImageFormatListCreateInfo)
    FreeEnumList(pViewFormats, format);
ZCLEAR_END
ZCHECK_BEGIN(VkImageFormatListCreateInfo)
    newstruct(VkImageFormatListCreateInfo);
    GetEnumList(pViewFormats, viewFormatCount, format, "view_formats");
ZCHECK_END

ZCHECK_BEGIN(VkExternalMemoryImageCreateInfoKHR)
    newstruct(VkExternalMemoryImageCreateInfoKHR);
    GetFlags(handleTypes, "handle_types");
ZCHECK_END

ZCHECK_BEGIN(VkImageSwapchainCreateInfoKHR)
    newstruct(VkImageSwapchainCreateInfoKHR);
    GetSwapchain(swapchain, "swapchain");
ZCHECK_END

ZCHECK_BEGIN(VkImageStencilUsageCreateInfo)
    newstruct(VkImageStencilUsageCreateInfo);
    GetFlags(stencilUsage, "stencil_usage");
ZCHECK_END

static ZCLEAR_BEGIN(VkImageCreateInfo)
    FreeUint32List(pQueueFamilyIndices);
ZCLEAR_END
ZCHECK_BEGIN(VkImageCreateInfo)
    checktable(arg);
    newstruct(VkImageCreateInfo);
    GetFlags(flags, "flags");
    GetImageType(imageType, "image_type");
    GetFormat(format, "format");
    GetStructOpt(extent, "extent", VkExtent3D);
    GetIntegerOpt(mipLevels, "mip_levels", 1);
    GetIntegerOpt(arrayLayers, "array_layers", 1);
    GetSamples(samples, "samples");
    GetImageTiling(tiling, "tiling");
    GetFlags(usage, "usage");
    GetImageLayout(initialLayout, "initial_layout");
    GetSharingMode(sharingMode, "sharing_mode");
    GetUint32List(pQueueFamilyIndices, queueFamilyIndexCount, "queue_family_indices");
    EXTENSIONS_BEGIN
    if(ispresent("handle_types"))
        ADD_EXTENSION_INLINE(VkExternalMemoryImageCreateInfoKHR);
    if(ispresent("view_formats"))
        ADD_EXTENSION_INLINE(VkImageFormatListCreateInfo);
    if(ispresent("swapchain"))
        ADD_EXTENSION_INLINE(VkImageSwapchainCreateInfoKHR);
    if(ispresent("stencil_usage"))
        ADD_EXTENSION_INLINE(VkImageStencilUsageCreateInfo);
    EXTENSIONS_END
ZCHECK_END

static ZCLEAR_BEGIN(VkDeviceImageMemoryRequirementsKHR)
    FreeStructp(pCreateInfo, VkImageCreateInfo);
ZCLEAR_END
ZCHECK_BEGIN(VkDeviceImageMemoryRequirementsKHR)
    checktable(arg);
    newstruct(VkDeviceImageMemoryRequirementsKHR);
    GetStructp(pCreateInfo, VkImageCreateInfo, "create_info");
    GetFlags(planeAspect, "plane_aspect");
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Image View                                                                   |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkImageViewUsageCreateInfoKHR)
    newstruct(VkImageViewUsageCreateInfoKHR);
    GetFlags(usage, "usage");
ZCHECK_END

ZCHECK_BEGIN(VkImageViewASTCDecodeModeEXT)
    newstruct(VkImageViewASTCDecodeModeEXT);
    GetFormat(decodeMode, "decode_mode");
ZCHECK_END

ZCHECK_BEGIN(VkImageViewCreateInfo)
    checktable(arg);
    newstruct(VkImageViewCreateInfo);
    GetFlags(flags, "flags");
/*  p->image = set by caller */
    GetImageViewType(viewType, "view_type");
    GetFormat(format, "format");
    GetStructOpt(components, "components", VkComponentMapping);
    GetStructOpt(subresourceRange, "subresource_range", VkImageSubresourceRange);
    EXTENSIONS_BEGIN
    if(ispresent("usage"))
        ADD_EXTENSION_INLINE(VkImageViewUsageCreateInfoKHR);
    if(ispresent("decode_mode"))
        ADD_EXTENSION_INLINE(VkImageViewASTCDecodeModeEXT);
    EXTENSIONS_END
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Descriptor Pool                                                              |
 *------------------------------------------------------------------------------*/
    
ZCHECK_BEGIN(VkDescriptorPoolInlineUniformBlockCreateInfoEXT)
    newstruct(VkDescriptorPoolInlineUniformBlockCreateInfoEXT);
    GetInteger(maxInlineUniformBlockBindings, "max_inline_uniform_block_bindings");
ZCHECK_END

static ZCLEAR_BEGIN(VkDescriptorPoolCreateInfo)
    FreeList(pPoolSizes, poolSizeCount, VkDescriptorPoolSize);
ZCLEAR_END
ZCHECK_BEGIN(VkDescriptorPoolCreateInfo)
    checktable(arg);
    newstruct(VkDescriptorPoolCreateInfo);
    GetFlags(flags, "flags");
    GetInteger(maxSets, "max_sets");
    GetList(pPoolSizes, poolSizeCount, VkDescriptorPoolSize, "pool_sizes");
    EXTENSIONS_BEGIN
    if(ispresent("max_inline_uniform_block_bindings"))
        ADD_EXTENSION_INLINE(VkDescriptorPoolInlineUniformBlockCreateInfoEXT);
    EXTENSIONS_END
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Descriptor Set                                                               |
 *------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkDescriptorSetVariableDescriptorCountAllocateInfo)
    FreeUint32List(pDescriptorCounts);
ZCLEAR_END
ZCHECK_BEGIN(VkDescriptorSetVariableDescriptorCountAllocateInfo)
    newstruct(VkDescriptorSetVariableDescriptorCountAllocateInfo);
    GetUint32List(pDescriptorCounts, descriptorSetCount, "descriptor_counts");
ZCHECK_END

static ZCLEAR_BEGIN(VkDescriptorSetAllocateInfo)
    FreeObjectList(pSetLayouts);
ZCLEAR_END
ZCHECK_BEGIN(VkDescriptorSetAllocateInfo)
    checktable(arg);
    newstruct(VkDescriptorSetAllocateInfo);
    /* p->descriptorPool = set by caller */
    GetObjectList(pSetLayouts, descriptorSetCount, descriptor_set_layout, "set_layouts");
    EXTENSIONS_BEGIN
    if(ispresent("descriptor_counts"))
        ADD_EXTENSION_INLINE(VkDescriptorSetVariableDescriptorCountAllocateInfo);
    EXTENSIONS_END
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Descriptor Set Layout                                                        |
 *------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkDescriptorSetLayoutBindingFlagsCreateInfo)
    FreeFlagsList(pBindingFlags);
ZCLEAR_END
ZCHECK_BEGIN(VkDescriptorSetLayoutBindingFlagsCreateInfo)
    newstruct(VkDescriptorSetLayoutBindingFlagsCreateInfo);
    GetFlagsList(pBindingFlags, bindingCount, "binding_flags");
ZCHECK_END

static ZCLEAR_BEGIN(VkDescriptorSetLayoutCreateInfo)
    FreeList(pBindings, bindingCount, VkDescriptorSetLayoutBinding);
ZCLEAR_END
ZCHECK_BEGIN(VkDescriptorSetLayoutCreateInfo)
    checktable(arg);
    newstruct(VkDescriptorSetLayoutCreateInfo);
    GetFlags(flags, "flags");
    GetListOpt(pBindings, bindingCount, VkDescriptorSetLayoutBinding, "bindings");
    EXTENSIONS_BEGIN
    if(ispresent("binding_flags"))
        ADD_EXTENSION_INLINE(VkDescriptorSetLayoutBindingFlagsCreateInfo);
    EXTENSIONS_END
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Pipeline Layout                                                              |
 *------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkPipelineLayoutCreateInfo)
    FreeObjectList(pSetLayouts);
    FreeList(pPushConstantRanges, pushConstantRangeCount, VkPushConstantRange);
ZCLEAR_END
ZCHECK_BEGIN(VkPipelineLayoutCreateInfo)
    checktable(arg);
    newstruct(VkPipelineLayoutCreateInfo);
    GetFlags(flags, "flags");
    GetObjectList(pSetLayouts, setLayoutCount, descriptor_set_layout, "set_layouts");
    GetListOpt(pPushConstantRanges, pushConstantRangeCount, VkPushConstantRange, "push_constant_ranges");
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Query Pool                                                                   |
 *------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkQueryPoolPerformanceCreateInfoKHR)
    FreeUint32List(pCounterIndices);
ZCLEAR_END
ZCHECK_BEGIN(VkQueryPoolPerformanceCreateInfoKHR)
    checktable(arg);
    newstruct(VkQueryPoolPerformanceCreateInfoKHR);
    GetInteger(queueFamilyIndex, "queue_family_index");
    GetUint32List(pCounterIndices, counterIndexCount, "counter_indices");
ZCHECK_END

ZCHECK_BEGIN(VkQueryPoolCreateInfo)
    checktable(arg);
    newstruct(VkQueryPoolCreateInfo);
    GetFlags(flags, "flags");
    GetQueryType(queryType, "query_type");
    GetInteger(queryCount, "query_count");
    GetFlags(pipelineStatistics, "pipeline_statistics");
    EXTENSIONS_BEGIN
        ADD_EXTENSION_STRUCT("query_pool_performance_info", VkQueryPoolPerformanceCreateInfoKHR);
    EXTENSIONS_END
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Render Pass                                                                  |
 *------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkRenderPassInputAttachmentAspectCreateInfoKHR)
    FreeList(pAspectReferences, aspectReferenceCount, VkInputAttachmentAspectReference);
ZCLEAR_END
ZCHECK_BEGIN(VkRenderPassInputAttachmentAspectCreateInfoKHR)
    newstruct(VkRenderPassInputAttachmentAspectCreateInfoKHR);
    GetList(pAspectReferences, aspectReferenceCount, VkInputAttachmentAspectReference, "input_attachment_aspect_references");
ZCHECK_END

static ZCLEAR_BEGIN(VkRenderPassMultiviewCreateInfoKHR)
    FreeUint32List(pViewMasks);
    FreeInt32List(pViewOffsets);
    FreeUint32List(pCorrelationMasks);
ZCLEAR_END
ZCHECK_BEGIN(VkRenderPassMultiviewCreateInfoKHR)
    newstruct(VkRenderPassMultiviewCreateInfoKHR);
    GetUint32List(pViewMasks, subpassCount, "view_masks");
    GetInt32List(pViewOffsets, dependencyCount, "view_offsets");
    GetUint32List(pCorrelationMasks, correlationMaskCount, "correlation_masks");
ZCHECK_END

ZCHECK_BEGIN(VkRenderPassFragmentDensityMapCreateInfoEXT)
    newstruct(VkRenderPassFragmentDensityMapCreateInfoEXT);
    GetStruct(fragmentDensityMapAttachment, "fragment_density_map_attachment", VkAttachmentReference);
ZCHECK_END

static ZCLEAR_BEGIN(VkRenderPassCreateInfo)
    FreeList(pAttachments, attachmentCount, VkAttachmentDescription);
    FreeList(pSubpasses, subpassCount, VkSubpassDescription);
    FreeList(pDependencies, dependencyCount, VkSubpassDependency);
ZCLEAR_END
ZCHECK_BEGIN(VkRenderPassCreateInfo)
    checktable(arg);
    newstruct(VkRenderPassCreateInfo);
    GetFlags(flags, "flags");
    GetListOpt(pAttachments, attachmentCount, VkAttachmentDescription, "attachments");
    GetList(pSubpasses, subpassCount, VkSubpassDescription, "subpasses");
    GetListOpt(pDependencies, dependencyCount, VkSubpassDependency, "dependencies");
    EXTENSIONS_BEGIN
    if(ispresent("input_attachment_aspect_references"))
        ADD_EXTENSION_INLINE(VkRenderPassInputAttachmentAspectCreateInfoKHR);
    if(ispresent("view_masks") || ispresent("view_offsets") || ispresent("correlation_masks"))
        ADD_EXTENSION_INLINE(VkRenderPassMultiviewCreateInfoKHR);
    if(ispresent("fragment_density_map_attachment"))
        ADD_EXTENSION_INLINE(VkRenderPassFragmentDensityMapCreateInfoEXT);
    EXTENSIONS_END
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Render Pass 2 (VK_KHR_create_renderpass2)                                    |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkAttachmentDescriptionStencilLayout)
    newstruct(VkAttachmentDescriptionStencilLayout);
    GetImageLayout(stencilInitialLayout, "stencil_initial_layout");
    GetImageLayout(stencilFinalLayout, "stencil_final_layout");
ZCHECK_END

ZCHECK_BEGIN(VkAttachmentDescription2)
    checktable(arg);
    newstruct(VkAttachmentDescription2);
    GetFlags(flags, "flags");
    GetFormat(format, "format");
    GetSamples(samples, "samples");
    GetAttachmentLoadOp(loadOp, "load_op");
    GetAttachmentStoreOp(storeOp, "store_op");
    GetAttachmentLoadOp(stencilLoadOp, "stencil_load_op");
    GetAttachmentStoreOp(stencilStoreOp, "stencil_store_op");
    GetImageLayout(initialLayout, "initial_layout");
    GetImageLayout(finalLayout, "final_layout");
    EXTENSIONS_BEGIN
    if(ispresent("stencil_initial_layout") || ispresent("stencil_final_layout"))
        ADD_EXTENSION_INLINE(VkAttachmentDescriptionStencilLayout);
    EXTENSIONS_END
ZCHECK_END
ZCHECKARRAY(VkAttachmentDescription2)

ZCHECK_BEGIN(VkAttachmentReferenceStencilLayout)
    newstruct(VkAttachmentReferenceStencilLayout);
    GetImageLayout(stencilLayout, "stencil_layout");
ZCHECK_END

ZCHECK_BEGIN(VkAttachmentReference2)
    checktable(arg);
    newstruct(VkAttachmentReference2);
    GetAttachment(attachment, "attachment");
    GetImageLayout(layout, "layout");
    GetFlags(aspectMask, "aspect_mask");
    EXTENSIONS_BEGIN
    if(ispresent("stencil_layout"))
        ADD_EXTENSION_INLINE(VkAttachmentReferenceStencilLayout);
    EXTENSIONS_END
ZCHECK_END
ZCHECKARRAY(VkAttachmentReference2)

static ZCLEAR_BEGIN(VkSubpassDescriptionDepthStencilResolve)
    FreeStructp(pDepthStencilResolveAttachment, VkAttachmentReference2);
ZCLEAR_END
ZCHECK_BEGIN(VkSubpassDescriptionDepthStencilResolve)
    newstruct(VkSubpassDescriptionDepthStencilResolve);
    GetFlags(depthResolveMode, "depth_resolve_mode");
    GetFlags(stencilResolveMode, "stencil_resolve_mode");
    GetStructp(pDepthStencilResolveAttachment, VkAttachmentReference2, "depth_stencil_resolve_attachment");
ZCHECK_END

static ZCLEAR_BEGIN(VkFragmentShadingRateAttachmentInfoKHR)
    FreeStructp(pFragmentShadingRateAttachment, VkAttachmentReference2);
ZCLEAR_END
ZCHECK_BEGIN(VkFragmentShadingRateAttachmentInfoKHR)
    newstruct(VkFragmentShadingRateAttachmentInfoKHR);
    GetStructp(pFragmentShadingRateAttachment, VkAttachmentReference2, "fragment_shading_rate_attachment");
    GetStruct(shadingRateAttachmentTexelSize, "shading_rate_attachment_texel_size", VkExtent2D);
ZCHECK_END

static ZCLEAR_BEGIN(VkSubpassDescription2)
    FreeList(pInputAttachments, inputAttachmentCount, VkAttachmentReference2);
    FreeList(pColorAttachments, colorAttachmentCount, VkAttachmentReference2);
    FreeList(pResolveAttachments, colorAttachmentCount, VkAttachmentReference2);
    FreeUint32List(pPreserveAttachments);
    FreeStructp(pDepthStencilAttachment, VkAttachmentReference2);
ZCLEAR_END
ZCHECK_BEGIN(VkSubpassDescription2)
    uint32_t count;
    checktable(arg);
    newstruct(VkSubpassDescription2);
    GetFlags(flags, "flags");
    GetPipelineBindPoint(pipelineBindPoint, "pipeline_bind_point");
    GetInteger(viewMask, "view_mask");
    GetListOpt(pInputAttachments, inputAttachmentCount, VkAttachmentReference2, "input_attachments");
    GetListOpt(pColorAttachments, colorAttachmentCount, VkAttachmentReference2, "color_attachments");
    count = p->colorAttachmentCount;
    GetListOpt(pResolveAttachments, colorAttachmentCount, VkAttachmentReference2, "resolve_attachments");
    if(p->pResolveAttachments && count != p->colorAttachmentCount)
        {
        FreeList(pResolveAttachments, colorAttachmentCount, VkAttachmentReference2);
        p->pResolveAttachments = NULL;
        p->colorAttachmentCount = count;
        *err = ERR_LENGTH; lua_pushstring(L, errstring(*err));
        return p;
        }
    p->colorAttachmentCount = count;
    GetStructp(pDepthStencilAttachment, VkAttachmentReference2, "depth_stencil_attachment");
    GetUint32List(pPreserveAttachments, preserveAttachmentCount, "preserve_attachments");
    EXTENSIONS_BEGIN
    if(ispresent("depth_resolve_mode") || ispresent("stencil_resolve_mode") || ispresent("depth_stencil_resolve_attachment"))
        ADD_EXTENSION_INLINE(VkSubpassDescriptionDepthStencilResolve);
    if(ispresent("fragment_shading_rate_attachment") || ispresent("shading_rate_attachment_texel_size"))
        ADD_EXTENSION_INLINE(VkFragmentShadingRateAttachmentInfoKHR);
    EXTENSIONS_END
ZCHECK_END
ZCHECKARRAY(VkSubpassDescription2)

ZCHECK_BEGIN(VkSubpassDependency2)
    checktable(arg);
    newstruct(VkSubpassDependency2);
    GetSubpass(srcSubpass, "src_subpass");
    GetSubpass(dstSubpass, "dst_subpass");
    GetFlags(srcStageMask, "src_stage_mask");
    GetFlags(dstStageMask, "dst_stage_mask");
    GetFlags(srcAccessMask, "src_access_mask");
    GetFlags(dstAccessMask, "dst_access_mask");
    GetFlags(dependencyFlags, "dependency_flags");
    GetInteger(viewOffset, "view_offset");
    EXTENSIONS_BEGIN
        ADD_EXTENSION_STRUCT("memory_barrier2", VkMemoryBarrier2KHR);
    EXTENSIONS_END
ZCHECK_END
ZCHECKARRAY(VkSubpassDependency2)

static ZCLEAR_BEGIN(VkRenderPassCreateInfo2)
    FreeList(pAttachments, attachmentCount, VkAttachmentDescription2);
    FreeList(pSubpasses, subpassCount, VkSubpassDescription2);
    FreeList(pDependencies, dependencyCount, VkSubpassDependency2);
    FreeUint32List(pCorrelatedViewMasks);
ZCLEAR_END
ZCHECK_BEGIN(VkRenderPassCreateInfo2)
    checktable(arg);
    newstruct(VkRenderPassCreateInfo2);
    GetFlags(flags, "flags");
    GetListOpt(pAttachments, attachmentCount, VkAttachmentDescription2, "attachments");
    GetList(pSubpasses, subpassCount, VkSubpassDescription2, "subpasses");
    GetListOpt(pDependencies, dependencyCount, VkSubpassDependency2, "dependencies");
    GetUint32List(pCorrelatedViewMasks, correlatedViewMaskCount, "correlated_view_masks");
    EXTENSIONS_BEGIN
    if(ispresent("fragment_density_map_attachment"))
        ADD_EXTENSION_INLINE(VkRenderPassFragmentDensityMapCreateInfoEXT);
    EXTENSIONS_END
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Framebuffer                                                                  |
 *------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkFramebufferAttachmentImageInfo)
    FreeEnumList(pViewFormats, format);
ZCLEAR_END
ZCHECK_BEGIN(VkFramebufferAttachmentImageInfo)
    checktable(arg);
    newstruct(VkFramebufferAttachmentImageInfo);
    GetFlags(flags, "flags");
    GetFlags(usage, "usage");
    GetInteger(width, "width");
    GetInteger(height, "height");
    GetInteger(layerCount, "layer_count");
    GetEnumList(pViewFormats, viewFormatCount, format, "view_formats");
ZCHECK_END
ZCHECKARRAY(VkFramebufferAttachmentImageInfo)

static ZCLEAR_BEGIN(VkFramebufferAttachmentsCreateInfo)
    FreeList(pAttachmentImageInfos, attachmentImageInfoCount, VkFramebufferAttachmentImageInfo);
ZCLEAR_END
ZCHECK_BEGIN(VkFramebufferAttachmentsCreateInfo)
    newstruct(VkFramebufferAttachmentsCreateInfo);
    GetListOpt(pAttachmentImageInfos, attachmentImageInfoCount, VkFramebufferAttachmentImageInfo, "attachment_image_infos");
ZCHECK_END

static ZCLEAR_BEGIN(VkFramebufferCreateInfo)
    FreeObjectList(pAttachments);
ZCLEAR_END
ZCHECK_BEGIN(VkFramebufferCreateInfo)
    checktable(arg);
    newstruct(VkFramebufferCreateInfo);
    GetFlags(flags, "flags");
    GetRenderPass(renderPass, "render_pass");
    GetInteger(width, "width");
    GetInteger(height, "height");
    GetIntegerOpt(layers, "layers", 1);
    GetObjectList(pAttachments, attachmentCount, image_view, "attachments");
    EXTENSIONS_BEGIN
    if(ispresent("attachment_image_infos"))
        ADD_EXTENSION_INLINE(VkFramebufferAttachmentsCreateInfo);
    EXTENSIONS_END
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Shader Module                                                                |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkShaderModuleValidationCacheCreateInfoEXT)
    newstruct(VkShaderModuleValidationCacheCreateInfoEXT);
    GetValidationCache(validationCache, "validation_cache");
ZCHECK_END

ZCHECK_BEGIN(VkShaderModuleCreateInfo)
    checktable(arg);
    newstruct(VkShaderModuleCreateInfo);
    GetFlags(flags, "flags");
    /* p->pCode, p->codeSize: retrieved by the caller */
    EXTENSIONS_BEGIN
    if(ispresent("validation_cache"))
        ADD_EXTENSION_INLINE(VkShaderModuleValidationCacheCreateInfoEXT);
    EXTENSIONS_END
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Swapchain                                                                    |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkSwapchainCounterCreateInfoEXT)
    newstruct(VkSwapchainCounterCreateInfoEXT);
    GetFlags(surfaceCounters, "surface_counters");
ZCHECK_END

ZCHECK_BEGIN(VkDeviceGroupSwapchainCreateInfoKHR)
    newstruct(VkDeviceGroupSwapchainCreateInfoKHR);
    GetFlags(modes, "modes");
ZCHECK_END

static ZCLEAR_BEGIN(VkSwapchainCreateInfoKHR)
    FreeUint32List(pQueueFamilyIndices);
ZCLEAR_END
ZCHECK_BEGIN(VkSwapchainCreateInfoKHR)
    checktable(arg);
    newstruct(VkSwapchainCreateInfoKHR);
    GetFlags(flags, "flags");
    GetSurface(surface, "surface");
    GetInteger(minImageCount, "min_image_count");
    GetFormat(imageFormat, "image_format");
    GetColorSpace(imageColorSpace, "image_color_space");
    GetStructOpt(imageExtent, "image_extent", VkExtent2D);
    GetInteger(imageArrayLayers, "image_array_layers");
    GetFlags(imageUsage, "image_usage");
    GetSharingMode(imageSharingMode, "image_sharing_mode");
    GetBits(preTransform, "pre_transform", VkSurfaceTransformFlagBitsKHR);
    GetBits(compositeAlpha, "composite_alpha", VkCompositeAlphaFlagBitsKHR);
    GetPresentMode(presentMode, "present_mode");
    GetBoolean(clipped, "clipped");
    GetSwapchainOpt(oldSwapchain, "old_swapchain");
    GetUint32List(pQueueFamilyIndices, queueFamilyIndexCount, "queue_family_indices");
    EXTENSIONS_BEGIN
    if(ispresent("surface_counters"))
        ADD_EXTENSION_INLINE(VkSwapchainCounterCreateInfoEXT);
    if(ispresent("modes"))
        ADD_EXTENSION_INLINE(VkDeviceGroupSwapchainCreateInfoKHR);
    EXTENSIONS_END
ZCHECK_END
ZCHECKARRAY(VkSwapchainCreateInfoKHR)

/*------------------------------------------------------------------------------*
 | Pipeline Cache                                                               |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkPipelineCacheCreateInfo)
    checktable(arg);
    newstruct(VkPipelineCacheCreateInfo);
    GetFlags(flags, "flags");
    /* p->pInitialData, p->initialDataSize: set (and free'd) by the caller */
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Validation Cache                                                             |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkValidationCacheCreateInfoEXT)
    checktable(arg);
    newstruct(VkValidationCacheCreateInfoEXT);
    GetFlags(flags, "flags");
    /* p->pInitialData, p->initialDataSize: set (and free'd) by the caller */
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Sampler                                                                      |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkSamplerReductionModeCreateInfo)
    newstruct(VkSamplerReductionModeCreateInfo);
    GetSamplerReductionMode(reductionMode, "reduction_mode");
ZCHECK_END

ZCHECK_BEGIN(VkSamplerYcbcrConversionInfoKHR)
    newstruct(VkSamplerYcbcrConversionInfoKHR);
    GetSamplerYcbcrConversion(conversion, "conversion");
ZCHECK_END

ZCHECK_BEGIN(VkSamplerCustomBorderColorCreateInfoEXT)
    newstruct(VkSamplerCustomBorderColorCreateInfoEXT);
    GetStruct(customBorderColor, "custom_border_color", VkClearColorValue);
    GetFormat(format, "custom_border_color_format");
ZCHECK_END

ZCHECK_BEGIN(VkSamplerBorderColorComponentMappingCreateInfoEXT)
    newstruct(VkSamplerBorderColorComponentMappingCreateInfoEXT);
    GetStruct(components, "components", VkComponentMapping);
    GetBoolean(srgb, "srgb");
ZCHECK_END

ZCHECK_BEGIN(VkSamplerCreateInfo)
    checktable(arg);
    newstruct(VkSamplerCreateInfo);
    GetFlags(flags, "flags");
    GetFilter(magFilter, "mag_filter");
    GetFilter(minFilter, "min_filter");
    GetSamplerMipmapMode(mipmapMode, "mipmap_mode");
    GetSamplerAddressMode(addressModeU, "address_mode_u");
    GetSamplerAddressMode(addressModeV, "address_mode_v");
    GetSamplerAddressMode(addressModeW, "address_mode_w");
    GetNumber(mipLodBias, "mip_lod_bias");
    GetBoolean(anisotropyEnable, "anisotropy_enable");
    GetNumber(maxAnisotropy, "max_anisotropy");
    GetBoolean(compareEnable, "compare_enable");
    GetCompareOp(compareOp, "compare_op");
    GetNumber(minLod, "min_lod");
    GetNumber(maxLod, "max_lod");
    GetBorderColor(borderColor, "border_color");
    GetBoolean(unnormalizedCoordinates, "unnormalized_coordinates");
    EXTENSIONS_BEGIN
    if(ispresent("reduction_mode"))
        ADD_EXTENSION_INLINE(VkSamplerReductionModeCreateInfo);
    if(ispresent("conversion"))
        ADD_EXTENSION_INLINE(VkSamplerYcbcrConversionInfoKHR);
    if(ispresent("custom_border_color") || ispresent("custom_border_color_format"))
        ADD_EXTENSION_INLINE(VkSamplerCustomBorderColorCreateInfoEXT);
    if(ispresent("components"))
        ADD_EXTENSION_INLINE(VkSamplerBorderColorComponentMappingCreateInfoEXT);
    EXTENSIONS_END
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Sampler Ycbcr                                                                |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkSamplerYcbcrConversionCreateInfoKHR)
    checktable(arg);
    newstruct(VkSamplerYcbcrConversionCreateInfoKHR);
    GetFormat(format, "format");
    GetSamplerYcbcrModelConversion(ycbcrModel, "ycbcr_model");
    GetSamplerYcbcrRange(ycbcrRange, "ycbcr_range");
    GetStructOpt(components, "components", VkComponentMapping);
    GetChromaLocation(xChromaOffset, "x_chroma_offset");
    GetChromaLocation(yChromaOffset, "y_chroma_offset");
    GetFilter(chromaFilter, "chroma_filter");
    GetBoolean(forceExplicitReconstruction, "force_explicit_reconstruction");
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Event                                                                        |
 *------------------------------------------------------------------------------*/
    
ZCHECK_BEGIN(VkEventCreateInfo)
    checktable(arg);
    newstruct(VkEventCreateInfo);
    GetFlags(flags, "flags");
ZCHECK_END

ZCHECK_BEGIN(VkDeviceEventInfoEXT)
    checktable(arg);
    newstruct(VkDeviceEventInfoEXT);
    GetDeviceEventType(deviceEvent, "device_event");
ZCHECK_END

ZCHECK_BEGIN(VkDisplayEventInfoEXT)
    checktable(arg);
    newstruct(VkDisplayEventInfoEXT);
    GetDisplayEventType(displayEvent, "display_event");
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Fence                                                                        |
 *------------------------------------------------------------------------------*/
    
ZCHECK_BEGIN(VkExportFenceCreateInfoKHR)
    newstruct(VkExportFenceCreateInfoKHR);
    GetFlags(handleTypes, "handle_types");
ZCHECK_END

ZCHECK_BEGIN(VkFenceCreateInfo)
    checktable(arg);
    newstruct(VkFenceCreateInfo);
    GetFlags(flags, "flags");
    EXTENSIONS_BEGIN
    if(ispresent("handle_types"))
        ADD_EXTENSION_INLINE(VkExportFenceCreateInfoKHR);
    EXTENSIONS_END
ZCHECK_END

ZCHECK_BEGIN(VkImportFenceFdInfoKHR)
    checktable(arg);
    newstruct(VkImportFenceFdInfoKHR);
    /* p->fence is set by the caller */
    GetFlags(flags, "flags");
    GetBits(handleType, "handle_type", VkExternalFenceHandleTypeFlagBits);
    GetInteger(fd, "fd");
ZCHECK_END

ZCHECK_BEGIN(VkFenceGetFdInfoKHR)
    checktable(arg);
    newstruct(VkFenceGetFdInfoKHR);
    /* p->fence is set by the caller */
    GetBits(handleType, "handle_type", VkExternalFenceHandleTypeFlagBits);
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Semaphore                                                                    |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkExportSemaphoreCreateInfoKHR)
    newstruct(VkExportSemaphoreCreateInfoKHR);
    GetFlags(handleTypes, "handle_types");
ZCHECK_END

ZCHECK_BEGIN(VkSemaphoreTypeCreateInfo)
    newstruct(VkSemaphoreTypeCreateInfo);
    GetSemaphoreType(semaphoreType, "semaphore_type");
    GetInteger(initialValue, "initial_value");
ZCHECK_END

ZCHECK_BEGIN(VkSemaphoreCreateInfo)
    checktable(arg);
    newstruct(VkSemaphoreCreateInfo);
    GetFlags(flags, "flags");
    EXTENSIONS_BEGIN
    if(ispresent("handle_types"))
        ADD_EXTENSION_INLINE(VkExportSemaphoreCreateInfoKHR);
    if(ispresent("semaphore_type"))
        ADD_EXTENSION_INLINE(VkSemaphoreTypeCreateInfo);
    EXTENSIONS_END
ZCHECK_END

ZCHECK_BEGIN(VkImportSemaphoreFdInfoKHR)
    checktable(arg);
    newstruct(VkImportSemaphoreFdInfoKHR);
    /* p->semaphore is set by the caller */
    GetFlags(flags, "flags");
    GetBits(handleType, "handle_type", VkExternalSemaphoreHandleTypeFlagBits);
    GetInteger(fd, "fd");
ZCHECK_END

ZCHECK_BEGIN(VkSemaphoreGetFdInfoKHR)
    checktable(arg);
    newstruct(VkSemaphoreGetFdInfoKHR);
    /* p->semaphore is set by the caller */
    GetBits(handleType, "handle_type", VkExternalSemaphoreHandleTypeFlagBits);
ZCHECK_END

static ZCLEAR_BEGIN(VkSemaphoreWaitInfo)
    FreeObjectList(pSemaphores);
    FreeUint64List(pValues);
ZCLEAR_END
ZCHECK_BEGIN(VkSemaphoreWaitInfo)
    uint32_t count;
    checktable(arg);
    newstruct(VkSemaphoreWaitInfo);
    GetFlags(flags, "flags");
    GetObjectList(pSemaphores, semaphoreCount, semaphore, "semaphores");
    count = p->semaphoreCount;
    GetUint64List(pValues, semaphoreCount, "values");
    if(count != p->semaphoreCount)
        { *err=ERR_LENGTH; pushfielderror("values"); return p; }
ZCHECK_END

ZCHECK_BEGIN(VkSemaphoreSignalInfo)
    checktable(arg);
    newstruct(VkSemaphoreSignalInfo);
    GetSemaphore(semaphore, "semaphore");
    GetInteger(value, "value");
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Memory Barriers                                                              |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkMemoryBarrier)
    checktable(arg);
    newstruct(VkMemoryBarrier);
    GetFlags(srcAccessMask, "src_access_mask");
    GetFlags(dstAccessMask, "dst_access_mask");
ZCHECK_END
ZCHECKARRAY(VkMemoryBarrier)

ZCHECK_BEGIN(VkMemoryBarrier2KHR)
    checktable(arg);
    newstruct(VkMemoryBarrier2KHR);
    GetFlags(srcStageMask, "src_stage_mask");
    GetFlags(dstStageMask, "dst_stage_mask");
    GetFlags(srcAccessMask, "src_access_mask");
    GetFlags(dstAccessMask, "dst_access_mask");
ZCHECK_END
ZCHECKARRAY(VkMemoryBarrier2KHR)

ZCHECK_BEGIN(VkBufferMemoryBarrier)
    checktable(arg);
    newstruct(VkBufferMemoryBarrier);
    GetFlags(srcAccessMask, "src_access_mask");
    GetFlags(dstAccessMask, "dst_access_mask");
    GetIntegerOpt(srcQueueFamilyIndex, "src_queue_family_index", VK_QUEUE_FAMILY_IGNORED);
    GetIntegerOpt(dstQueueFamilyIndex, "dst_queue_family_index", VK_QUEUE_FAMILY_IGNORED);
    GetBuffer(buffer, "buffer");
    GetInteger(offset, "offset");
    GetInteger(size, "size");
ZCHECK_END
ZCHECKARRAY(VkBufferMemoryBarrier)

ZCHECK_BEGIN(VkImageMemoryBarrier)
    checktable(arg);
    newstruct(VkImageMemoryBarrier);
    GetFlags(srcAccessMask, "src_access_mask");
    GetFlags(dstAccessMask, "dst_access_mask");
    GetImageLayout(oldLayout, "old_layout");
    GetImageLayout(newLayout, "new_layout");
    GetIntegerOpt(srcQueueFamilyIndex, "src_queue_family_index", VK_QUEUE_FAMILY_IGNORED);
    GetIntegerOpt(dstQueueFamilyIndex, "dst_queue_family_index", VK_QUEUE_FAMILY_IGNORED);
    GetImage(image, "image");
    GetStructOpt(subresourceRange, "subresource_range", VkImageSubresourceRange);
ZCHECK_END
ZCHECKARRAY(VkImageMemoryBarrier)

ZCHECK_BEGIN(VkBufferMemoryBarrier2KHR)
    checktable(arg);
    newstruct(VkBufferMemoryBarrier2KHR);
    GetFlags(srcStageMask, "src_stage_mask");
    GetFlags(srcAccessMask, "src_access_mask");
    GetFlags(dstStageMask, "dst_stage_mask");
    GetFlags(dstAccessMask, "dst_access_mask");
    GetIntegerOpt(srcQueueFamilyIndex, "src_queue_family_index", VK_QUEUE_FAMILY_IGNORED);
    GetIntegerOpt(dstQueueFamilyIndex, "dst_queue_family_index", VK_QUEUE_FAMILY_IGNORED);
    GetBuffer(buffer, "buffer");
    GetInteger(offset, "offset");
    GetInteger(size, "size");
ZCHECK_END
ZCHECKARRAY(VkBufferMemoryBarrier2KHR)

ZCHECK_BEGIN(VkImageMemoryBarrier2KHR)
    checktable(arg);
    newstruct(VkImageMemoryBarrier2KHR);
    GetFlags(srcStageMask, "src_stage_mask");
    GetFlags(srcAccessMask, "src_access_mask");
    GetFlags(dstStageMask, "dst_stage_mask");
    GetFlags(dstAccessMask, "dst_access_mask");
    GetImageLayout(oldLayout, "old_layout");
    GetImageLayout(newLayout, "new_layout");
    GetIntegerOpt(srcQueueFamilyIndex, "src_queue_family_index", VK_QUEUE_FAMILY_IGNORED);
    GetIntegerOpt(dstQueueFamilyIndex, "dst_queue_family_index", VK_QUEUE_FAMILY_IGNORED);
    GetImage(image, "image");
    GetStructOpt(subresourceRange, "subresource_range", VkImageSubresourceRange);
ZCHECK_END
ZCHECKARRAY(VkImageMemoryBarrier2KHR)

static ZCLEAR_BEGIN(VkDependencyInfoKHR)
    FreeList(pMemoryBarriers, memoryBarrierCount, VkMemoryBarrier2KHR);
    FreeList(pBufferMemoryBarriers, bufferMemoryBarrierCount, VkBufferMemoryBarrier2KHR);
    FreeList(pImageMemoryBarriers, imageMemoryBarrierCount, VkImageMemoryBarrier2KHR);
ZCLEAR_END
ZCHECK_BEGIN(VkDependencyInfoKHR)
    checktable(arg);
    newstruct(VkDependencyInfoKHR);
    GetFlags(dependencyFlags, "dependency_flags");
    GetList(pMemoryBarriers, memoryBarrierCount, VkMemoryBarrier2KHR, "memory_barriers");
    GetList(pBufferMemoryBarriers, bufferMemoryBarrierCount, VkBufferMemoryBarrier2KHR, "buffer_memory_barriers");
    GetList(pImageMemoryBarriers, imageMemoryBarrierCount, VkImageMemoryBarrier2KHR, "image_memory_barriers");
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Headless Surface                                                             |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkHeadlessSurfaceCreateInfoEXT)
    checktable(arg);
    newstruct(VkHeadlessSurfaceCreateInfoEXT);
    GetFlags(flags, "flags");
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Display Surface                                                              |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkDisplaySurfaceCreateInfoKHR)
    checktable(arg);
    newstruct(VkDisplaySurfaceCreateInfoKHR);
    GetFlags(flags, "flags");
/*  p->displayMode = set by caller */
    GetInteger(planeIndex, "plane_index");
    GetInteger(planeStackIndex, "plane_stack_index");
    GetBits(transform, "transform", VkSurfaceTransformFlagBitsKHR);
    GetNumber(globalAlpha, "global_alpha");
    GetBits(alphaMode, "alpha_mode", VkDisplayPlaneAlphaFlagBitsKHR);
    GetStruct(imageExtent, "image_extent", VkExtent2D);
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Display Mode                                                                 |
 *------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkDisplayModeCreateInfoKHR)
    FreeStruct(parameters, VkDisplayModeParametersKHR);
ZCLEAR_END
ZCHECK_BEGIN(VkDisplayModeCreateInfoKHR)
    checktable(arg);
    newstruct(VkDisplayModeCreateInfoKHR);
    GetFlags(flags, "flags");
    GetStruct(parameters, "parameters", VkDisplayModeParametersKHR);
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Descriptor Update Template                                                   |
 *------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkDescriptorUpdateTemplateCreateInfoKHR)
    FreeList(pDescriptorUpdateEntries, descriptorUpdateEntryCount, VkDescriptorUpdateTemplateEntry);
ZCLEAR_END
ZCHECK_BEGIN(VkDescriptorUpdateTemplateCreateInfoKHR)
    checktable(arg);
    newstruct(VkDescriptorUpdateTemplateCreateInfoKHR);
    GetFlags(flags, "flags");
    GetDescriptorUpdateTemplateType(templateType, "template_type");
    GetDescriptorSetLayoutOpt(descriptorSetLayout, "descriptor_set_layout");
    GetPipelineBindPoint(pipelineBindPoint, "pipeline_bind_point");
    GetPipelineLayoutOpt(pipelineLayout, "pipeline_layout");
    GetFlags(set, "set");
    GetList(pDescriptorUpdateEntries, descriptorUpdateEntryCount, VkDescriptorUpdateTemplateEntry, "descriptor_update_entries");
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Submit Info                                                                  |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkProtectedSubmitInfo)
    newstruct(VkProtectedSubmitInfo);
    GetBoolean(protectedSubmit, "protected_submit");
ZCHECK_END

static ZCLEAR_BEGIN(VkDeviceGroupSubmitInfoKHR)
    FreeUint32List(pWaitSemaphoreDeviceIndices);
    FreeUint32List(pCommandBufferDeviceMasks);
    FreeUint32List(pSignalSemaphoreDeviceIndices);
ZCLEAR_END
ZCHECK_BEGIN(VkDeviceGroupSubmitInfoKHR)
    newstruct(VkDeviceGroupSubmitInfoKHR);
    GetUint32List(pWaitSemaphoreDeviceIndices, waitSemaphoreCount, "wait_semaphore_device_indices");
    GetUint32List(pCommandBufferDeviceMasks, commandBufferCount, "command_buffer_device_masks");
    GetUint32List(pSignalSemaphoreDeviceIndices, signalSemaphoreCount, "signal_semaphore_device_indices");
ZCHECK_END

static ZCLEAR_BEGIN(VkTimelineSemaphoreSubmitInfo)
    FreeUint64List(pWaitSemaphoreValues);
    FreeUint64List(pSignalSemaphoreValues);
ZCLEAR_END
ZCHECK_BEGIN(VkTimelineSemaphoreSubmitInfo)
    newstruct(VkTimelineSemaphoreSubmitInfo);
    GetUint64List(pWaitSemaphoreValues, waitSemaphoreValueCount, "wait_semaphore_values");
    GetUint64List(pSignalSemaphoreValues, signalSemaphoreValueCount, "signal_semaphore_values");
ZCHECK_END

ZCHECK_BEGIN(VkPerformanceQuerySubmitInfoKHR)
    newstruct(VkPerformanceQuerySubmitInfoKHR);
    GetInteger(counterPassIndex, "counter_pass_index");
ZCHECK_END

static ZCLEAR_BEGIN(VkSubmitInfo)
    FreeObjectList(pWaitSemaphores);
    FreeFlagsList(pWaitDstStageMask);
    FreeObjectList(pCommandBuffers);
    FreeObjectList(pSignalSemaphores);
ZCLEAR_END
ZCHECK_BEGIN(VkSubmitInfo)
    uint32_t count;
    checktable(arg);
    newstruct(VkSubmitInfo);
    GetObjectList(pWaitSemaphores, waitSemaphoreCount, semaphore, "wait_semaphores");
    count = p->waitSemaphoreCount;
    GetFlagsList(pWaitDstStageMask, waitSemaphoreCount, "wait_dst_stage_mask");
    if(count != p->waitSemaphoreCount) 
        { *err=ERR_LENGTH; pushfielderror("wait_dst_stage_mask"); return p; }
    GetObjectList(pCommandBuffers, commandBufferCount, command_buffer, "command_buffers");
    GetObjectList(pSignalSemaphores, signalSemaphoreCount, semaphore, "signal_semaphores");
    EXTENSIONS_BEGIN
    if(ispresent("protected_submit"))
        ADD_EXTENSION_INLINE(VkProtectedSubmitInfo);
    if(ispresent("wait_semaphore_device_indices") ||
        ispresent("command_buffer_device_masks") || ispresent("signal_semaphore_device_indices"))
        ADD_EXTENSION_INLINE(VkDeviceGroupSubmitInfoKHR);
    if(ispresent("wait_semaphore_values") || ispresent("signal_semaphore_values"))
        ADD_EXTENSION_INLINE(VkTimelineSemaphoreSubmitInfo);
    if(ispresent("counter_pass_index"))
        ADD_EXTENSION_INLINE(VkPerformanceQuerySubmitInfoKHR);
    EXTENSIONS_END
ZCHECK_END
ZCHECKARRAY(VkSubmitInfo)

ZCHECK_BEGIN(VkSemaphoreSubmitInfoKHR)
    checktable(arg);
    newstruct(VkSemaphoreSubmitInfoKHR);
    GetSemaphore(semaphore, "semaphore");
    GetInteger(value, "value");
    GetFlags(stageMask, "stage_mask");
    GetInteger(deviceIndex, "device_index");
ZCHECK_END
ZCHECKARRAY(VkSemaphoreSubmitInfoKHR)

ZCHECK_BEGIN(VkCommandBufferSubmitInfoKHR)
    checktable(arg);
    newstruct(VkCommandBufferSubmitInfoKHR);
    GetCommandBuffer(commandBuffer, "command_buffer");
    GetIntegerOpt(deviceMask, "device_mask", 0);
ZCHECK_END
ZCHECKARRAY(VkCommandBufferSubmitInfoKHR)

static ZCLEAR_BEGIN(VkSubmitInfo2KHR)
    FreeList(pWaitSemaphoreInfos, waitSemaphoreInfoCount, VkSemaphoreSubmitInfoKHR);
    FreeList(pCommandBufferInfos, commandBufferInfoCount, VkCommandBufferSubmitInfoKHR);
    FreeList(pSignalSemaphoreInfos, signalSemaphoreInfoCount, VkSemaphoreSubmitInfoKHR);
ZCLEAR_END
ZCHECK_BEGIN(VkSubmitInfo2KHR)
    checktable(arg);
    newstruct(VkSubmitInfo2KHR);
    GetFlags(flags, "flags");
    GetList(pWaitSemaphoreInfos, waitSemaphoreInfoCount, VkSemaphoreSubmitInfoKHR, "wait_semaphore_infos");
    GetList(pCommandBufferInfos, commandBufferInfoCount, VkCommandBufferSubmitInfoKHR, "command_buffer_infos");
    GetList(pSignalSemaphoreInfos, signalSemaphoreInfoCount, VkSemaphoreSubmitInfoKHR, "signal_semaphore_infos");
    EXTENSIONS_BEGIN
    if(ispresent("counter_pass_index"))
        ADD_EXTENSION_INLINE(VkPerformanceQuerySubmitInfoKHR);
    EXTENSIONS_END
ZCHECK_END
ZCHECKARRAY(VkSubmitInfo2KHR)

/*------------------------------------------------------------------------------*
 | Present Info                                                                 |
 *------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkPresentRegionsKHR)
    FreeList(pRegions, swapchainCount, VkPresentRegionKHR);
ZCLEAR_END
ZCHECK_BEGIN(VkPresentRegionsKHR)
    newstruct(VkPresentRegionsKHR);
    GetListOpt(pRegions, swapchainCount, VkPresentRegionKHR, "regions");
ZCHECK_END

ZCHECK_BEGIN(VkDisplayPresentInfoKHR)
    newstruct(VkDisplayPresentInfoKHR);
    GetStructOpt(srcRect, "src_rect", VkRect2D);
    GetStructOpt(dstRect, "dst_rect", VkRect2D);
    GetBoolean(persistent, "persistent");
ZCHECK_END

static ZCLEAR_BEGIN(VkDeviceGroupPresentInfoKHR)
    FreeUint32List(pDeviceMasks);
ZCLEAR_END
ZCHECK_BEGIN(VkDeviceGroupPresentInfoKHR)
    newstruct(VkDeviceGroupPresentInfoKHR);
    GetUint32List(pDeviceMasks, swapchainCount, "device_masks");
    GetBits(mode, "mode", VkDeviceGroupPresentModeFlagBitsKHR);
ZCHECK_END

static ZCLEAR_BEGIN(VkPresentIdKHR)
    FreeUint64List(pPresentIds);
ZCLEAR_END
ZCHECK_BEGIN(VkPresentIdKHR)
    newstruct(VkPresentIdKHR);
    GetUint64List(pPresentIds, swapchainCount, "present_ids");
ZCHECK_END

static ZCLEAR_BEGIN(VkPresentInfoKHR)
    FreeObjectList(pWaitSemaphores);
    FreeObjectList(pSwapchains);
    FreeUint32List(pImageIndices);
    if(p->pResults) Free(L, (void*)p->pResults);
ZCLEAR_END
//ZCHECK_BEGIN(VkPresentInfoKHR)
VkPresentInfoKHR* zcheckVkPresentInfoKHR(lua_State *L, int arg, int *err, int results) { //non-standard
    VkPresentInfoKHR *p;
    int arg1;
    uint32_t count;
    checktable(arg);
    newstruct(VkPresentInfoKHR);
    GetObjectList(pWaitSemaphores, waitSemaphoreCount, semaphore, "wait_semaphores");
    GetObjectList(pSwapchains, swapchainCount, swapchain, "swapchains");
    if(results) /* allocate memory for per-swapchain results */
        {
        p->pResults = (VkResult*)MallocNoErr(L, sizeof(VkResult)*(p->swapchainCount));
        if(!p->pResults) { *err=ERR_MEMORY; pusherror(); return p; }
        }
    count = p->swapchainCount;
    GetUint32List(pImageIndices, swapchainCount, "image_indices");
    if(count != p->swapchainCount)
        { *err=ERR_LENGTH; pushfielderror("image_indices"); return p; }
    EXTENSIONS_BEGIN
    if(ispresent("src_rect"))
        ADD_EXTENSION_INLINE(VkDisplayPresentInfoKHR);
    if(ispresent("regions"))
        ADD_EXTENSION_INLINE(VkPresentRegionsKHR);
    if(ispresent("mode") || ispresent("device_masks"))
        ADD_EXTENSION_INLINE(VkDeviceGroupPresentInfoKHR);
    if(ispresent("present_ids"))
        ADD_EXTENSION_INLINE(VkPresentIdKHR);
    EXTENSIONS_END
ZCHECK_END


/*------------------------------------------------------------------------------*
 | Render Pass Begin Info                                                       |
 *------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkRenderPassSampleLocationsBeginInfoEXT)
    FreeList(pAttachmentInitialSampleLocations, attachmentInitialSampleLocationsCount, VkAttachmentSampleLocationsEXT);
    FreeList(pPostSubpassSampleLocations, postSubpassSampleLocationsCount, VkSubpassSampleLocationsEXT);
ZCLEAR_END
ZCHECK_BEGIN(VkRenderPassSampleLocationsBeginInfoEXT)
    newstruct(VkRenderPassSampleLocationsBeginInfoEXT);
    GetListOpt(pAttachmentInitialSampleLocations, attachmentInitialSampleLocationsCount, VkAttachmentSampleLocationsEXT, "attachment_initial_sample_locations");
    GetListOpt(pPostSubpassSampleLocations, postSubpassSampleLocationsCount, VkSubpassSampleLocationsEXT, "post_subpass_sample_locations");
#if 0 //no: validation layer should check this:
    if((p->attachmentInitialSampleLocationsCount + p->postSubpassSampleLocationsCount) == 0)
        { zfree(L, p, 1); *err=ERR_NOTPRESENT; pusherror(); return NULL; }
#endif
ZCHECK_END

static ZCLEAR_BEGIN(VkDeviceGroupRenderPassBeginInfoKHR)
    FreeList(pDeviceRenderAreas, deviceRenderAreaCount, VkRect2D);
ZCLEAR_END
ZCHECK_BEGIN(VkDeviceGroupRenderPassBeginInfoKHR)
    newstruct(VkDeviceGroupRenderPassBeginInfoKHR);
    GetInteger(deviceMask, "device_mask");
    GetListOpt(pDeviceRenderAreas, deviceRenderAreaCount, VkRect2D, "device_render_areas");
ZCHECK_END

static ZCLEAR_BEGIN(VkRenderPassAttachmentBeginInfo)
    FreeObjectList(pAttachments);
ZCLEAR_END
ZCHECK_BEGIN(VkRenderPassAttachmentBeginInfo)
    newstruct(VkRenderPassAttachmentBeginInfo);
    GetObjectList(pAttachments, attachmentCount, image_view, "attachments");
ZCHECK_END

static ZCLEAR_BEGIN(VkRenderPassBeginInfo)
    FreeList(pClearValues, clearValueCount, VkClearValue);
ZCLEAR_END
ZCHECK_BEGIN(VkRenderPassBeginInfo)
    checktable(arg);
    newstruct(VkRenderPassBeginInfo);
    GetRenderPass(renderPass, "render_pass");
    GetFramebuffer(framebuffer, "framebuffer");
    GetStructOpt(renderArea, "render_area", VkRect2D);
    GetListOpt(pClearValues, clearValueCount, VkClearValue, "clear_values");
    EXTENSIONS_BEGIN
    if(ispresent("attachment_initial_sample_locations") || ispresent("post_subpass_sample_locations"))
        ADD_EXTENSION_INLINE(VkRenderPassSampleLocationsBeginInfoEXT);
    if(ispresent("device_mask") || ispresent("device_render_areas"))
        ADD_EXTENSION_INLINE(VkDeviceGroupRenderPassBeginInfoKHR);
    if(ispresent("attachments"))
        ADD_EXTENSION_INLINE(VkRenderPassAttachmentBeginInfo);
    EXTENSIONS_END
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Subpass Begin/End Info                                                       |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkSubpassBeginInfo)
    checktable(arg);
    newstruct(VkSubpassBeginInfo);
    GetSubpassContents(contents, "contents");
ZCHECK_END

ZCHECK_BEGIN(VkSubpassEndInfo)
    checktable(arg);
    newstruct(VkSubpassEndInfo);
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Bind Sparse Info                                                             |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkDeviceGroupBindSparseInfoKHR)
    newstruct(VkDeviceGroupBindSparseInfoKHR);
    GetInteger(resourceDeviceIndex, "resource_device_index");
    GetInteger(memoryDeviceIndex, "memory_device_index");
ZCHECK_END

static ZCLEAR_BEGIN(VkBindSparseInfo)
    FreeObjectList(pWaitSemaphores);
    FreeList(pBufferBinds, bufferBindCount, VkSparseBufferMemoryBindInfo);
    FreeList(pImageOpaqueBinds, imageOpaqueBindCount, VkSparseImageOpaqueMemoryBindInfo);
    FreeList(pImageBinds, imageBindCount, VkSparseImageMemoryBindInfo);
    FreeObjectList(pSignalSemaphores);
ZCLEAR_END
ZCHECK_BEGIN(VkBindSparseInfo)
    checktable(arg);
    newstruct(VkBindSparseInfo);
    GetObjectList(pWaitSemaphores, waitSemaphoreCount, semaphore, "wait_semaphores");
    GetListOpt(pBufferBinds, bufferBindCount, VkSparseBufferMemoryBindInfo, "buffer_binds");
    GetListOpt(pImageOpaqueBinds, imageOpaqueBindCount, VkSparseImageOpaqueMemoryBindInfo, "image_opaque_binds");
    GetListOpt(pImageBinds, imageBindCount, VkSparseImageMemoryBindInfo, "image_binds");
    GetObjectList(pSignalSemaphores, signalSemaphoreCount, semaphore, "signal_semaphores");
    EXTENSIONS_BEGIN
    if(ispresent("resource_device_index") || ispresent("memory_device_index"))
        ADD_EXTENSION_INLINE(VkDeviceGroupBindSparseInfoKHR);
    if(ispresent("wait_semaphore_values") || ispresent("signal_semaphore_values"))
        ADD_EXTENSION_INLINE(VkTimelineSemaphoreSubmitInfo);
    EXTENSIONS_END
ZCHECK_END
ZCHECKARRAY(VkBindSparseInfo)

/*------------------------------------------------------------------------------*
 | Write Descriptor Set                                                         |
 *------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkWriteDescriptorSetInlineUniformBlockEXT)
    if(p->pData) Free(L, (char*)p->pData);
ZCLEAR_END
ZCHECK_BEGIN(VkWriteDescriptorSetInlineUniformBlockEXT)
    size_t len;
    newstruct(VkWriteDescriptorSetInlineUniformBlockEXT);
    GetLString(pData, "inline_uniform_block_data", &len);
    p->dataSize = len;
ZCHECK_END

static ZCLEAR_BEGIN(VkWriteDescriptorSet)
    FreeList(pImageInfo, descriptorCount, VkDescriptorImageInfo);
    FreeList(pBufferInfo, descriptorCount, VkDescriptorBufferInfo);
    FreeObjectList(pTexelBufferView);
ZCLEAR_END
ZCHECK_BEGIN(VkWriteDescriptorSet)
    checktable(arg);
    newstruct(VkWriteDescriptorSet);
    GetDescriptorSet(dstSet, "dst_set");
    GetInteger(dstBinding, "dst_binding");
    GetInteger(dstArrayElement, "dst_array_element");
    GetDescriptorType(descriptorType, "descriptor_type");
    /* image_info, buffer_info and texel_buffer_view are exclusive and their
     * presence depends on p->descriptorType: */
    switch(p->descriptorType)
        {
        case VK_DESCRIPTOR_TYPE_SAMPLER:
        case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER:
        case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
        case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:
        case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
            GetList(pImageInfo, descriptorCount, VkDescriptorImageInfo, "image_info");
            break;
        case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER:
        case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER:
        case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC:
        case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
            GetList(pBufferInfo, descriptorCount, VkDescriptorBufferInfo, "buffer_info");
            break;
        case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER:
        case VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
            GetObjectList(pTexelBufferView, descriptorCount, buffer_view, "texel_buffer_view");
            break;
        case VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT:
            /* data goes in the pNext chain */
            break;
        default:
            unexpected(L); /* unhandled descriptorType ? */
        }
    EXTENSIONS_BEGIN
    if(p->descriptorType == VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT)
        ADD_EXTENSION_INLINE(VkWriteDescriptorSetInlineUniformBlockEXT);
    EXTENSIONS_END
ZCHECK_END
ZCHECKARRAY(VkWriteDescriptorSet)

/*------------------------------------------------------------------------------*
 | Copy Descriptor Set                                                          |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkCopyDescriptorSet)
    checktable(arg);
    newstruct(VkCopyDescriptorSet);
    GetDescriptorSet(srcSet, "src_set");
    GetInteger(srcBinding, "src_binding");
    GetInteger(srcArrayElement, "src_array_element");
    GetDescriptorSet(dstSet, "dst_set");
    GetInteger(dstBinding, "dst_binding");
    GetInteger(dstArrayElement, "dst_array_element");
    GetInteger(descriptorCount, "descriptor_count");
ZCHECK_END
ZCHECKARRAY(VkCopyDescriptorSet)

/*------------------------------------------------------------------------------*
 | Copy Commands typed structs                                                  |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkBufferCopy2KHR)
    checktable(arg);
    newstruct(VkBufferCopy2KHR);
    GetInteger(srcOffset, "src_offset");
    GetInteger(dstOffset, "dst_offset");
    GetInteger(size, "size");
ZCHECK_END
ZCHECKARRAY(VkBufferCopy2KHR)

static ZCLEAR_BEGIN(VkCopyBufferInfo2KHR)
    FreeList(pRegions, regionCount, VkBufferCopy2KHR);
ZCLEAR_END
ZCHECK_BEGIN(VkCopyBufferInfo2KHR)
    checktable(arg);
    newstruct(VkCopyBufferInfo2KHR);
    GetBuffer(srcBuffer, "src_buffer");
    GetBuffer(dstBuffer, "dst_buffer");
    GetList(pRegions, regionCount, VkBufferCopy2KHR, "regions");
ZCHECK_END

ZCHECK_BEGIN(VkImageCopy2KHR)
    checktable(arg);
    newstruct(VkImageCopy2KHR);
    GetStruct(srcSubresource, "src_subresource", VkImageSubresourceLayers);
    GetStructOpt(srcOffset, "src_offset", VkOffset3D);
    GetStruct(dstSubresource, "dst_subresource", VkImageSubresourceLayers);
    GetStructOpt(dstOffset, "dst_offset", VkOffset3D);
    GetStructOpt(extent, "extent", VkExtent3D);
ZCHECK_END
ZCHECKARRAY(VkImageCopy2KHR)

static ZCLEAR_BEGIN(VkCopyImageInfo2KHR)
    FreeList(pRegions, regionCount, VkImageCopy2KHR);
ZCLEAR_END
ZCHECK_BEGIN(VkCopyImageInfo2KHR)
    checktable(arg);
    newstruct(VkCopyImageInfo2KHR);
    GetImage(srcImage, "src_image");
    GetImageLayout(srcImageLayout, "src_image_layout");
    GetImage(dstImage, "dst_image");
    GetImageLayout(dstImageLayout, "dst_image_layout");
    GetList(pRegions, regionCount, VkImageCopy2KHR, "regions");
ZCHECK_END

ZCHECK_BEGIN(VkBufferImageCopy2KHR)
    checktable(arg);
    newstruct(VkBufferImageCopy2KHR);
    GetInteger(bufferOffset, "buffer_offset");
    GetInteger(bufferRowLength, "buffer_row_length");
    GetInteger(bufferImageHeight, "buffer_image_height");
    GetStruct(imageSubresource, "image_subresource", VkImageSubresourceLayers);
    GetStructOpt(imageOffset, "image_offset", VkOffset3D);
    GetStructOpt(imageExtent, "image_extent", VkExtent3D);
ZCHECK_END
ZCHECKARRAY(VkBufferImageCopy2KHR)

static ZCLEAR_BEGIN(VkCopyBufferToImageInfo2KHR)
    FreeList(pRegions, regionCount, VkBufferImageCopy2KHR);
ZCLEAR_END
ZCHECK_BEGIN(VkCopyBufferToImageInfo2KHR)
    checktable(arg);
    newstruct(VkCopyBufferToImageInfo2KHR);
    GetBuffer(srcBuffer, "src_buffer");
    GetImage(dstImage, "dst_image");
    GetImageLayout(dstImageLayout, "dst_image_layout");
    GetList(pRegions, regionCount, VkBufferImageCopy2KHR, "regions");
ZCHECK_END

static ZCLEAR_BEGIN(VkCopyImageToBufferInfo2KHR)
    FreeList(pRegions, regionCount, VkBufferImageCopy2KHR);
ZCLEAR_END
ZCHECK_BEGIN(VkCopyImageToBufferInfo2KHR)
    checktable(arg);
    newstruct(VkCopyImageToBufferInfo2KHR);
    GetImage(srcImage, "src_image");
    GetImageLayout(srcImageLayout, "src_image_layout");
    GetBuffer(dstBuffer, "dst_buffer");
    GetList(pRegions, regionCount, VkBufferImageCopy2KHR, "regions");
ZCHECK_END

ZCHECK_BEGIN(VkImageBlit2KHR)
    checktable(arg);
    newstruct(VkImageBlit2KHR);
    GetStruct(srcSubresource, "src_subresource", VkImageSubresourceLayers);
    GetStructArrayOpt(srcOffsets, "src_offsets", 2, VkOffset3D);
    GetStruct(dstSubresource, "dst_subresource", VkImageSubresourceLayers);
    GetStructArrayOpt(dstOffsets, "dst_offsets", 2, VkOffset3D);
ZCHECK_END
ZCHECKARRAY(VkImageBlit2KHR)

static ZCLEAR_BEGIN(VkBlitImageInfo2KHR)
    FreeList(pRegions, regionCount, VkImageBlit2KHR);
ZCLEAR_END
ZCHECK_BEGIN(VkBlitImageInfo2KHR)
    checktable(arg);
    newstruct(VkBlitImageInfo2KHR);
    GetImage(srcImage, "src_image");
    GetImageLayout(srcImageLayout, "src_image_layout");
    GetImage(dstImage, "dst_image");
    GetImageLayout(dstImageLayout, "dst_image_layout");
    GetList(pRegions, regionCount, VkImageBlit2KHR, "regions");
    GetFilter(filter, "filter");
ZCHECK_END

ZCHECK_BEGIN(VkImageResolve2KHR)
    checktable(arg);
    newstruct(VkImageResolve2KHR);
    GetStruct(srcSubresource, "src_subresource", VkImageSubresourceLayers);
    GetStructOpt(srcOffset, "src_offset", VkOffset3D);
    GetStruct(dstSubresource, "dst_subresource", VkImageSubresourceLayers);
    GetStructOpt(dstOffset, "dst_offset", VkOffset3D);
    GetStructOpt(extent, "extent", VkExtent3D);
ZCHECK_END
ZCHECKARRAY(VkImageResolve2KHR)

static ZCLEAR_BEGIN(VkResolveImageInfo2KHR)
    FreeList(pRegions, regionCount, VkImageResolve2KHR);
ZCLEAR_END
ZCHECK_BEGIN(VkResolveImageInfo2KHR)
    checktable(arg);
    newstruct(VkResolveImageInfo2KHR);
    GetImage(srcImage, "src_image");
    GetImageLayout(srcImageLayout, "src_image_layout");
    GetImage(dstImage, "dst_image");
    GetImageLayout(dstImageLayout, "dst_image_layout");
    GetList(pRegions, regionCount, VkImageResolve2KHR, "regions");
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Bind Buffer Memory                                                           |
 *------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkBindBufferMemoryDeviceGroupInfoKHR)
    FreeUint32List(pDeviceIndices);
ZCLEAR_END
ZCHECK_BEGIN(VkBindBufferMemoryDeviceGroupInfoKHR)
    newstruct(VkBindBufferMemoryDeviceGroupInfoKHR);
    GetUint32List(pDeviceIndices, deviceIndexCount, "device_indices");
ZCHECK_END

ZCHECK_BEGIN(VkBindBufferMemoryInfo)
    checktable(arg);
    newstruct(VkBindBufferMemoryInfo);
    GetBuffer(buffer, "buffer");
    GetDeviceMemory(memory, "memory");
    GetInteger(memoryOffset, "offset");
    EXTENSIONS_BEGIN
    if(ispresent("device_indices"))
        ADD_EXTENSION_INLINE(VkBindBufferMemoryDeviceGroupInfoKHR);
    EXTENSIONS_END
ZCHECK_END
ZCHECKARRAY(VkBindBufferMemoryInfo)

/*------------------------------------------------------------------------------*
 | Bind Image Memory                                                            |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkBindImagePlaneMemoryInfoKHR)
    newstruct(VkBindImagePlaneMemoryInfoKHR);
    GetFlags(planeAspect, "plane_aspect");
ZCHECK_END

static ZCLEAR_BEGIN(VkBindImageMemoryDeviceGroupInfoKHR)
    FreeUint32List(pDeviceIndices);
    FreeList(pSplitInstanceBindRegions, splitInstanceBindRegionCount, VkRect2D);
ZCLEAR_END
ZCHECK_BEGIN(VkBindImageMemoryDeviceGroupInfoKHR)
    newstruct(VkBindImageMemoryDeviceGroupInfoKHR);
    GetUint32List(pDeviceIndices, deviceIndexCount, "device_indices");
    GetListOpt(pSplitInstanceBindRegions, splitInstanceBindRegionCount, VkRect2D, "split_instance_bind_regions");
ZCHECK_END

ZCHECK_BEGIN(VkBindImageMemorySwapchainInfoKHR)
    newstruct(VkBindImageMemorySwapchainInfoKHR);
    GetSwapchain(swapchain, "swapchain");
    GetInteger(imageIndex, "image_index");
ZCHECK_END
ZCHECKARRAY(VkBindImageMemorySwapchainInfoKHR)

ZCHECK_BEGIN(VkBindImageMemoryInfo)
    checktable(arg);
    newstruct(VkBindImageMemoryInfo);
    GetImage(image, "image");
    GetDeviceMemory(memory, "memory");
    GetInteger(memoryOffset, "offset");
    EXTENSIONS_BEGIN
    if(ispresent("plane_aspect"))
        ADD_EXTENSION_INLINE(VkBindImagePlaneMemoryInfoKHR);
    if(ispresent("device_indices") || ispresent("split_instance_bind_regions"))
        ADD_EXTENSION_INLINE(VkBindImageMemoryDeviceGroupInfoKHR);
    if(ispresent("swapchain") || ispresent("image_index"))
        ADD_EXTENSION_INLINE(VkBindImageMemorySwapchainInfoKHR);
    EXTENSIONS_END
ZCHECK_END
ZCHECKARRAY(VkBindImageMemoryInfo)

/*------------------------------------------------------------------------------*
 | Debug Utils                                                                  |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkDebugUtilsMessengerCreateInfoEXT)
    checktable(arg);
    newstruct(VkDebugUtilsMessengerCreateInfoEXT);
    GetFlags(flags, "flags");
    GetFlags(messageSeverity, "message_severity");
    GetFlags(messageType, "message_type");
    /* pfnUserCallback and pUserData are set by the caller */
ZCHECK_END

/*------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkDebugUtilsObjectNameInfoEXT)
    if(p->pObjectName) Free(L, (char*)p->pObjectName);
ZCLEAR_END
ZCHECK_BEGIN(VkDebugUtilsObjectNameInfoEXT)
    checktable(arg);
    newstruct(VkDebugUtilsObjectNameInfoEXT);
    GetObjectType(objectType, "object_type");
    GetHandle(objectHandle, "object_handle");
    GetString(pObjectName, "object_name");
ZCHECK_END
ZPUSH_BEGIN(VkDebugUtilsObjectNameInfoEXT)
    lua_newtable(L);
    SetEnum(objectType, "object_type", pushobjecttype);
    SetHandle(objectHandle, "object_handle");
    SetString(pObjectName, "object_name");
ZPUSH_END
ZCHECKARRAY(VkDebugUtilsObjectNameInfoEXT)

/*------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkDebugUtilsObjectTagInfoEXT)
    if(p->pTag) Free(L, (char*)p->pTag);
ZCLEAR_END
ZCHECK_BEGIN(VkDebugUtilsObjectTagInfoEXT)
    size_t len;
    checktable(arg);
    newstruct(VkDebugUtilsObjectTagInfoEXT);
    GetObjectType(objectType, "object_type");
    GetHandle(objectHandle, "object_handle");
    GetInteger(tagName, "tag_name");
    GetLString(pTag, "tag", &len);
    p->tagSize = len;
ZCHECK_END
ZPUSH_BEGIN(VkDebugUtilsObjectTagInfoEXT)
    lua_newtable(L);
    SetEnum(objectType, "object_type", pushobjecttype);
    SetHandle(objectHandle, "object_handle");
    SetInteger(tagName, "tag_name");
    SetLString(pTag, "tag", p->tagSize);
ZPUSH_END
ZCHECKARRAY(VkDebugUtilsObjectTagInfoEXT)

/*------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkDebugUtilsLabelEXT)
    if(p->pLabelName) Free(L, (char*)p->pLabelName);
ZCLEAR_END
ZCHECK_BEGIN(VkDebugUtilsLabelEXT)
    checktable(arg);
    newstruct(VkDebugUtilsLabelEXT);
    GetString(pLabelName, "label_name");
    GetNumberArray(color, "color", 4);
ZCHECK_END
ZPUSH_BEGIN(VkDebugUtilsLabelEXT)
    lua_newtable(L);
    SetString(pLabelName, "label_name");
    SetNumberArray(color, "color", 4);
ZPUSH_END
ZCHECKARRAY(VkDebugUtilsLabelEXT)

/*------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkDebugUtilsMessengerCallbackDataEXT)
    if(p->pMessageIdName) Free(L, (char*)p->pMessageIdName);
    if(p->pMessage) Free(L, (char*)p->pMessage);
    FreeList(pQueueLabels, queueLabelCount, VkDebugUtilsLabelEXT);
    FreeList(pCmdBufLabels, cmdBufLabelCount, VkDebugUtilsLabelEXT);
    FreeList(pObjects, objectCount, VkDebugUtilsObjectNameInfoEXT);
ZCLEAR_END
ZCHECK_BEGIN(VkDebugUtilsMessengerCallbackDataEXT)
    checktable(arg);
    newstruct(VkDebugUtilsMessengerCallbackDataEXT);
    GetFlags(flags, "flags");
    GetInteger(messageIdNumber, "message_id_number");
#define F "message_id_name"
    arg1 = pushfield(L, arg, F);
    p->pMessageIdName =  GetString_(L, arg1, F, NULL, err, NULL);
    popfield(L, arg1);
    if(*err) { prependfield(F); return p; }
#undef F
#define F "message"
    arg1 = pushfield(L, arg, F);
    p->pMessage =  GetString_(L, arg1, F, NULL, err, NULL);
    popfield(L, arg1);
    if(*err) { prependfield(F); return p; }
#undef F
    GetListOpt(pQueueLabels, queueLabelCount, VkDebugUtilsLabelEXT, "queue_labels");
    GetListOpt(pCmdBufLabels, cmdBufLabelCount, VkDebugUtilsLabelEXT, "cmd_buf_labels");
    GetListOpt(pObjects, objectCount, VkDebugUtilsObjectNameInfoEXT, "objects");
ZCHECK_END
ZPUSH_BEGIN(VkDebugUtilsMessengerCallbackDataEXT)
    uint32_t i;
    lua_newtable(L);
    SetFlags(flags, "flags");
    SetString(pMessageIdName, "message_id_name");
    SetInteger(messageIdNumber, "message_id_number");
    SetString(pMessage, "message");
#define F "queue_labels"
    lua_newtable(L);
    if(p->queueLabelCount > 0 && p->pQueueLabels)
        {
        for(i = 0; i < p->queueLabelCount; i++)
            {
            zpushVkDebugUtilsLabelEXT(L, &p->pQueueLabels[i]);
            lua_rawseti(L, -2, i+1);
            }
        }
    lua_setfield(L, -1, F);
#undef F
#define F "cmd_buf_labels"
    lua_newtable(L);
    if(p->cmdBufLabelCount > 0 && p->pCmdBufLabels)
        {
        for(i = 0; i < p->cmdBufLabelCount; i++)
            {
            zpushVkDebugUtilsLabelEXT(L, &p->pCmdBufLabels[i]);
            lua_rawseti(L, -2, i+1);
            }
        }
    lua_setfield(L, -1, F);
#undef F
#define F "objects"
    lua_newtable(L);
    if(p->objectCount > 0 && p->pObjects)
        {
        for(i = 0; i < p->objectCount; i++)
            {
            zpushVkDebugUtilsObjectNameInfoEXT(L, &p->pObjects[i]);
            lua_rawseti(L, -2, i+1);
            }
        }
    lua_setfield(L, -1, F);
#undef F
ZPUSH_END

/*------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkPipelineInfoKHR)
    checktable(arg);
    newstruct(VkPipelineInfoKHR);
    /* p->pipeline is set by the caller */
ZCHECK_END

ZCHECK_BEGIN(VkPipelineExecutableInfoKHR)
    checktable(arg);
    newstruct(VkPipelineExecutableInfoKHR);
    /* p->pipeline is set by the caller */
    GetInteger(executableIndex, "executable_index");
ZCHECK_END

ZPUSH_BEGIN(VkPipelineExecutablePropertiesKHR)
    lua_newtable(L);
    SetFlags(stages, "stages");
    SetString(name, "name");
    SetString(description, "description");
    SetInteger(subgroupSize, "subgroup_size");
    //XPUSH_BEGIN
    //  XCASE(, );
    //XPUSH_END
ZPUSH_END

ZINIT_BEGIN(VkPipelineExecutablePropertiesKHR)
    //EXTENSIONS_BEGIN
    //  ADDX(XXX, Xxx);
    //EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkPipelineExecutableStatisticKHR)
    lua_newtable(L);
    SetString(name, "name");
    SetString(description, "description");
    SetEnum(format, "format", pushpipelineexecutablestatisticformat);
    switch(p->format)
        {
        case VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR:
            lua_pushboolean(L, p->value.b32); break;
        case VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR:
            lua_pushnumber(L, p->value.f64); break;
        case VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR:
            lua_pushnumber(L, p->value.i64); break;
        case VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR:
        default:
            lua_pushnumber(L, p->value.u64); break;
        }
    lua_setfield(L, -2, "value");
    //XPUSH_BEGIN
    //  XCASE(, );
    //XPUSH_END
ZPUSH_END

ZINIT_BEGIN(VkPipelineExecutableStatisticKHR)
    //EXTENSIONS_BEGIN
    //  ADDX(XXX, Xxx);
    //EXTENSIONS_END
ZINIT_END


ZPUSH_BEGIN(VkPipelineExecutableInternalRepresentationKHR)
    lua_newtable(L);
    SetString(name, "name");
    SetString(description, "description");
    SetBoolean(isText, "is_text");
    SetLString(pData, "data", p->dataSize);
    //XPUSH_BEGIN
    //  XCASE(, );
    //XPUSH_END
ZPUSH_END

ZINIT_BEGIN(VkPipelineExecutableInternalRepresentationKHR)
    //EXTENSIONS_BEGIN
    //  ADDX(XXX, Xxx);
    //EXTENSIONS_END
ZINIT_END

/*------------------------------------------------------------------------------*
 | Miscellanea                                                                  |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkDisplayPowerInfoEXT)
    checktable(arg);
    newstruct(VkDisplayPowerInfoEXT);
    GetDisplayPowerState(powerState, "power_state");
ZCHECK_END

/*------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkConditionalRenderingBeginInfoEXT)
    checktable(arg);
    newstruct(VkConditionalRenderingBeginInfoEXT);
    GetBuffer(buffer, "buffer");
    GetInteger(offset, "offset");
    GetFlags(flags, "flags");
ZCHECK_END

/*------------------------------------------------------------------------------*/

LOCALPUSH_BEGIN(VkDescriptorSetVariableDescriptorCountLayoutSupport)
    SetInteger(maxVariableDescriptorCount, "max_variable_descriptor_count");
LOCALPUSH_END

ZINIT_BEGIN(VkDescriptorSetLayoutSupport)
    EXTENSIONS_BEGIN
      ADDX(DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT, VkDescriptorSetVariableDescriptorCountLayoutSupport);
    EXTENSIONS_END
ZINIT_END

ZPUSH_BEGIN(VkDescriptorSetLayoutSupport)
    lua_newtable(L);
    SetBoolean(supported, "supported");
    XPUSH_BEGIN
        XCASE(DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT, VkDescriptorSetVariableDescriptorCountLayoutSupport);
    XPUSH_END
ZPUSH_END

/*------------------------------------------------------------------------------*/
    
ZCHECK_BEGIN(VkMappedMemoryRange)
    checktable(arg);
    newstruct(VkMappedMemoryRange);
    GetDeviceMemory(memory, "memory");
    GetInteger(offset, "offset");
    GetIntegerOrWholeSize(size, "size");
ZCHECK_END
ZCHECKARRAY(VkMappedMemoryRange)

/*------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkHdrMetadataEXT)
    checktable(arg);
    newstruct(VkHdrMetadataEXT);
    GetStructOpt(displayPrimaryRed, "display_primary_red", VkXYColorEXT);
    GetStructOpt(displayPrimaryGreen, "display_primary_green", VkXYColorEXT);
    GetStructOpt(displayPrimaryBlue, "display_primary_blue", VkXYColorEXT);
    GetStructOpt(whitePoint, "white_point", VkXYColorEXT);
    GetNumber(maxLuminance, "max_luminance");
    GetNumber(minLuminance, "min_luminance");
    GetNumber(maxContentLightLevel, "max_content_light_level");
    GetNumber(maxFrameAverageLightLevel, "max_frame_average_light_level");
ZCHECK_END

ZCHECK_BEGIN(VkPhysicalDeviceExternalBufferInfoKHR)
    checktable(arg);
    newstruct(VkPhysicalDeviceExternalBufferInfoKHR);
    GetFlags(flags, "flags");
    GetFlags(usage, "usage");
    GetBits(handleType, "handle_type", VkExternalMemoryHandleTypeFlagBits);
ZCHECK_END

/*------------------------------------------------------------------------------*/


ZCHECK_BEGIN(VkPhysicalDeviceExternalFenceInfoKHR)
    checktable(arg);
    newstruct(VkPhysicalDeviceExternalFenceInfoKHR);
    GetBits(handleType, "handle_type", VkExternalFenceHandleTypeFlagBits);
ZCHECK_END

/*------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkPhysicalDeviceExternalSemaphoreInfo)
    checktable(arg);
    newstruct(VkPhysicalDeviceExternalSemaphoreInfo);
    GetBits(handleType, "handle_type", VkExternalSemaphoreHandleTypeFlagBits);
    EXTENSIONS_BEGIN
    if(ispresent("semaphore_type"))
        ADD_EXTENSION_INLINE(VkSemaphoreTypeCreateInfo);
    EXTENSIONS_END
ZCHECK_END

/*------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkPhysicalDeviceExternalImageFormatInfoKHR)
    newstruct(VkPhysicalDeviceExternalImageFormatInfoKHR);
    GetBits(handleType, "handle_type", VkExternalMemoryHandleTypeFlagBits);
ZCHECK_END

ZCHECK_BEGIN(VkPhysicalDeviceImageViewImageFormatInfoEXT)
    newstruct(VkPhysicalDeviceImageViewImageFormatInfoEXT);
    GetImageViewType(imageViewType, "image_view_type");
ZCHECK_END

ZCHECK_BEGIN(VkPhysicalDeviceImageFormatInfo2)
    checktable(arg);
    newstruct(VkPhysicalDeviceImageFormatInfo2);
    GetFormat(format, "format");
    GetImageType(type, "type");
    GetImageTiling(tiling, "tiling");
    GetFlags(usage, "usage");
    GetFlags(flags, "flags");
    EXTENSIONS_BEGIN
    if(ispresent("handle_type"))
        ADD_EXTENSION_INLINE(VkPhysicalDeviceExternalImageFormatInfoKHR);
    if(ispresent("stencil_usage"))
        ADD_EXTENSION_INLINE(VkImageStencilUsageCreateInfo);
    if(ispresent("image_view_type"))
        ADD_EXTENSION_INLINE(VkPhysicalDeviceImageViewImageFormatInfoEXT);
    EXTENSIONS_END
ZCHECK_END

ZCHECK_BEGIN(VkPhysicalDeviceSparseImageFormatInfo2)
    checktable(arg);
    newstruct(VkPhysicalDeviceSparseImageFormatInfo2);
    GetFormat(format, "format");
    GetImageType(type, "type");
    GetSamples(samples, "samples");
    GetFlags(usage, "usage");
    GetImageTiling(tiling, "tiling");
ZCHECK_END

/*------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkAcquireNextImageInfoKHR)
    checktable(arg);
    newstruct(VkAcquireNextImageInfoKHR);
/*  GetSwapchain(swapchain, "swapchain"); -> set by the caller */
    GetTimeout(timeout, "timeout");
    GetSemaphoreOpt(semaphore, "semaphore");
    GetFenceOpt(fence, "fence");
    GetInteger(deviceMask, "device_mask");
ZCHECK_END

/*------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkAcquireProfilingLockInfoKHR)
    checktable(arg);
    newstruct(VkAcquireProfilingLockInfoKHR);
    GetFlags(flags, "flags");
    GetTimeout(timeout, "timeout");
ZCHECK_END

/*------------------------------------------------------------------------------*
 | Win32                                                                        |
 *------------------------------------------------------------------------------*/

#ifdef VK_USE_PLATFORM_WIN32_KHR

#if 0 //@@todo VK_KHR_external_semaphore_win32
typedef struct VkExportSemaphoreWin32HandleInfoKHR {
    VkStructureType               sType;
    const void*                   pNext;
    const SECURITY_ATTRIBUTES*    pAttributes;
    DWORD                         dwAccess;
    LPCWSTR                       name;
} VkExportSemaphoreWin32HandleInfoKHR;
#endif

#if 0 //@@todo VK_KHR_external_semaphore_win32
typedef struct VkD3D12FenceSubmitInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           waitSemaphoreValuesCount;
    const uint64_t*    pWaitSemaphoreValues;
    uint32_t           signalSemaphoreValuesCount;
    const uint64_t*    pSignalSemaphoreValues;
} VkD3D12FenceSubmitInfoKHR;
#endif

ZCHECK_BEGIN(VkImportSemaphoreWin32HandleInfoKHR) //@@DOC VK_KHR_external_semaphore_win32
    checktable(arg);
    newstruct(VkImportSemaphoreWin32HandleInfoKHR);
    /* p->semaphore is set by the caller */
    GetFlags(flags, "flags");
    GetBits(handleType, "handle_type", VkExternalSemaphoreHandleTypeFlagBits);
    GetLightuserdata(handle, "handle", HANDLE);
    p->name = NULL; //@@ LPCWSTR name;
ZCHECK_END

ZCHECK_BEGIN(VkSemaphoreGetWin32HandleInfoKHR) //@@DOC VK_KHR_external_semaphore_win32
    checktable(arg);
    newstruct(VkSemaphoreGetWin32HandleInfoKHR);
    p->sType = VK_STRUCTURE_TYPE_;
    /* p->semaphore is set by the caller */
    GetBits(handleType, "handle_type", VkExternalSemaphoreHandleTypeFlagBits);
ZCHECK_END

#endif /* VK_USE_PLATFORM_WIN32_KHR */

/*------------------------------------------------------------------------------*
 | Pipeline Shader Stage                                                        |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT)
    newstruct(VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT);
    GetInteger(requiredSubgroupSize, "required_subgroup_size");
ZCHECK_END

static ZCLEAR_BEGIN(VkPipelineShaderStageCreateInfo)
    if(p->pName) Free(L, (void*)p->pName);
    FreeStructp(pSpecializationInfo, VkSpecializationInfo);
ZCLEAR_END
ZCHECK_BEGIN(VkPipelineShaderStageCreateInfo)
    checktable(arg);
    newstruct(VkPipelineShaderStageCreateInfo);
    GetFlags(flags, "flags");
    GetBits(stage, "stage", VkShaderStageFlagBits);
    GetShaderModule(module, "module");
    GetStringDef(pName, "name", "main");
    GetStructp(pSpecializationInfo, VkSpecializationInfo, "specialization_info");
    EXTENSIONS_BEGIN
    if(ispresent("required_subgroup_size"))
        ADD_EXTENSION_INLINE(VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT);
    EXTENSIONS_END
ZCHECK_END
ZCHECKARRAY(VkPipelineShaderStageCreateInfo)

/*------------------------------------------------------------------------------*
 | Compute Pipeline                                                             |
 *------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkComputePipelineCreateInfo)
    FreeStruct(stage, VkPipelineShaderStageCreateInfo);
    zfreeVkPipelineShaderStageCreateInfo(L, &p->stage, 0);
ZCLEAR_END
ZCHECK_BEGIN(VkComputePipelineCreateInfo)
    checktable(arg);
    newstruct(VkComputePipelineCreateInfo);
    GetFlags(flags, "flags");
    GetPipelineLayout(layout, "layout");
    GetPipelineOpt(basePipelineHandle, "base_pipeline_handle");
    GetIntegerOpt(basePipelineIndex, "base_pipeline_index", -1);
    GetStruct(stage, "stage", VkPipelineShaderStageCreateInfo);
    EXTENSIONS_BEGIN
        ADD_EXTENSION_STRUCT("creation_feedback_state", VkPipelineCreationFeedbackCreateInfoEXT);
    EXTENSIONS_END
ZCHECK_END
ZCHECKARRAY(VkComputePipelineCreateInfo)

/*------------------------------------------------------------------------------*
 | Graphics Pipeline                                                            |
 *------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkPipelineInputAssemblyStateCreateInfo)
    checktable(arg);
    newstruct(VkPipelineInputAssemblyStateCreateInfo);
    GetFlags(flags, "flags");
    GetTopology(topology, "topology");
    GetBoolean(primitiveRestartEnable, "primitive_restart_enable");
ZCHECK_END

/*-------------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkPipelineTessellationDomainOriginStateCreateInfoKHR)
    newstruct(VkPipelineTessellationDomainOriginStateCreateInfoKHR);
    GetTessellationDomainOrigin(domainOrigin, "domain_origin");
ZCHECK_END

ZCHECK_BEGIN(VkPipelineTessellationStateCreateInfo)
    checktable(arg);
    newstruct(VkPipelineTessellationStateCreateInfo);
    GetFlags(flags, "flags");
    GetInteger(patchControlPoints, "patch_control_points");
    EXTENSIONS_BEGIN
    if(ispresent("domain_origin"))
        ADD_EXTENSION_INLINE(VkPipelineTessellationDomainOriginStateCreateInfoKHR);
    EXTENSIONS_END
ZCHECK_END

/*-------------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkPipelineViewportStateCreateInfo)
    FreeList(pViewports, viewportCount, VkViewport);
    FreeList(pScissors, scissorCount, VkRect2D);
ZCLEAR_END
ZCHECK_BEGIN(VkPipelineViewportStateCreateInfo)
    uint32_t viewport_count, scissor_count;
    checktable(arg);
    newstruct(VkPipelineViewportStateCreateInfo);
    GetFlags(flags, "flags");
    /* scissorCount and viewportCount must be equal, and they
     * may be > 0 even if scissors and/or viewports lists are not given */
    GetIntegerOpt(viewportCount, "viewport_count", 1);
    viewport_count = p->viewportCount;
    GetIntegerOpt(scissorCount, "scissor_count", 1);
    scissor_count = p->scissorCount;
    GetListOpt(pViewports, viewportCount, VkViewport, "viewports");
    if(!p->pViewports) p->viewportCount = viewport_count;
    GetListOpt(pScissors, scissorCount, VkRect2D, "scissors");
    if(!p->pScissors) p->scissorCount = scissor_count;
ZCHECK_END

/*-------------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkPipelineRasterizationConservativeStateCreateInfoEXT)
    newstruct(VkPipelineRasterizationConservativeStateCreateInfoEXT);
    GetFlags(flags, "conservative_rasterization_create_flags");
    GetConservativeRasterizationMode(conservativeRasterizationMode, "conservative_rasterization_mode");
    GetNumber(extraPrimitiveOverestimationSize, "extra_primitive_overestimation_size");
ZCHECK_END

ZCHECK_BEGIN(VkPipelineRasterizationStateStreamCreateInfoEXT)
    newstruct(VkPipelineRasterizationStateStreamCreateInfoEXT);
    GetFlags(flags, "rasterization_stream_create_flags");
    GetInteger(rasterizationStream, "rasterization_stream");
ZCHECK_END

ZCHECK_BEGIN(VkPipelineRasterizationDepthClipStateCreateInfoEXT)
    newstruct(VkPipelineRasterizationDepthClipStateCreateInfoEXT);
    GetFlags(flags, "depth_clip_create_flags");
    GetBoolean(depthClipEnable, "depth_clip_enable");
ZCHECK_END

ZCHECK_BEGIN(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT)
    newstruct(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT);
    GetProvokingVertexMode(provokingVertexMode, "provoking_vertex_mode");
ZCHECK_END

ZCHECK_BEGIN(VkPipelineRasterizationLineStateCreateInfoEXT)
    newstruct(VkPipelineRasterizationLineStateCreateInfoEXT);
    GetLineRasterizationMode(lineRasterizationMode, "line_rasterization_mode");
    GetBoolean(stippledLineEnable, "stippled_line_enable");
    GetInteger(lineStippleFactor, "line_stipple_factor");
    GetInteger(lineStipplePattern, "line_stipple_pattern");
ZCHECK_END

ZCHECK_BEGIN(VkPipelineRasterizationStateCreateInfo)
    checktable(arg);
    newstruct(VkPipelineRasterizationStateCreateInfo);
    GetFlags(flags, "flags");
    GetBoolean(depthClampEnable, "depth_clamp_enable");
    GetBoolean(rasterizerDiscardEnable, "rasterizer_discard_enable");
    GetPolygonMode(polygonMode, "polygon_mode");
    GetFlags(cullMode, "cull_mode");
    GetFrontFace(frontFace, "front_face");
    GetBoolean(depthBiasEnable, "depth_bias_enable");
    GetNumber(depthBiasConstantFactor, "depth_bias_constant_factor");
    GetNumber(depthBiasClamp, "depth_bias_clamp");
    GetNumber(depthBiasSlopeFactor, "depth_bias_slope_factor");
    GetNumberDef(lineWidth, "line_width", 1.0);
    EXTENSIONS_BEGIN
    if(ispresent("conservative_rasterization_mode") || ispresent("conservative_rasterization_create_flags") || ispresent("extra_primitive_overestimation_size"))
        ADD_EXTENSION_INLINE(VkPipelineRasterizationConservativeStateCreateInfoEXT);
    if(ispresent("rasterization_stream") || ispresent("rasterization_stream_create_flags"))
        ADD_EXTENSION_INLINE(VkPipelineRasterizationStateStreamCreateInfoEXT);
    if(ispresent("depth_clip_enable") || ispresent("depth_clip_create_flags"))
        ADD_EXTENSION_INLINE(VkPipelineRasterizationDepthClipStateCreateInfoEXT);
    if(ispresent("provoking_vertex_mode"))
        ADD_EXTENSION_INLINE(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT);
    if(ispresent("line_rasterization_mode") || ispresent("stippled_line_enable") || ispresent("line_stipple_factor") || ispresent(""))
        ADD_EXTENSION_INLINE(VkPipelineRasterizationLineStateCreateInfoEXT);
    EXTENSIONS_END
ZCHECK_END

/*-------------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkSampleLocationsInfoEXT)
    FreeList(pSampleLocations, sampleLocationsCount, VkSampleLocationEXT);
ZCLEAR_END
ZCHECK_BEGIN(VkSampleLocationsInfoEXT)
    checktable(arg);
    newstruct(VkSampleLocationsInfoEXT);
    GetBits(sampleLocationsPerPixel, "sample_locations_per_pixel", VkSampleCountFlagBits);
    GetStruct(sampleLocationGridSize, "sample_location_grid_size", VkExtent2D);
    GetList(pSampleLocations, sampleLocationsCount, VkSampleLocationEXT, "sample_locations");
ZCHECK_END

static ZCLEAR_BEGIN(VkPipelineSampleLocationsStateCreateInfoEXT)
    FreeStruct(sampleLocationsInfo, VkSampleLocationsInfoEXT);
ZCLEAR_END
ZCHECK_BEGIN(VkPipelineSampleLocationsStateCreateInfoEXT)
    newstruct(VkPipelineSampleLocationsStateCreateInfoEXT);
    GetBoolean(sampleLocationsEnable, "sample_locations_enable");
    GetStruct(sampleLocationsInfo, "sample_locations_info", VkSampleLocationsInfoEXT);
ZCHECK_END

static ZCLEAR_BEGIN(VkPipelineMultisampleStateCreateInfo)
    FreeUint32List(pSampleMask);
ZCLEAR_END
ZCHECK_BEGIN(VkPipelineMultisampleStateCreateInfo)
    uint32_t count;
    checktable(arg);
    newstruct(VkPipelineMultisampleStateCreateInfo);
    GetFlags(flags, "flags");
    GetSamples(rasterizationSamples, "rasterization_samples");
    GetBoolean(sampleShadingEnable, "sample_shading_enable");
    GetNumber(minSampleShading, "min_sample_shading");
    GetBoolean(alphaToCoverageEnable, "alpha_to_coverage_enable");
    GetBoolean(alphaToOneEnable, "alpha_to_one_enable");
#define F "sample_mask"
    arg1 = pushfield(L, arg, F);
    p->pSampleMask = (VkSampleMask*)checkuint32list(L, arg1, &count, err);
    popfield(L, arg1);
    if(*err < 0) { pushfielderror(F); return p; }
    if((count > 0) && (count != p->rasterizationSamples / 32))
        { *err=ERR_LENGTH; pushfielderror(F); return p; }
#undef F
    EXTENSIONS_BEGIN
    if(ispresent("sample_locations_enable") || ispresent("sample_locations_info"))
        ADD_EXTENSION_INLINE(VkPipelineSampleLocationsStateCreateInfoEXT);
    EXTENSIONS_END
ZCHECK_END

/*-------------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkPipelineVertexInputDivisorStateCreateInfoEXT)
    FreeList(pVertexBindingDivisors, vertexBindingDivisorCount, VkVertexInputBindingDivisorDescriptionEXT);
ZCLEAR_END
ZCHECK_BEGIN(VkPipelineVertexInputDivisorStateCreateInfoEXT)
    newstruct(VkPipelineVertexInputDivisorStateCreateInfoEXT);
    GetListOpt(pVertexBindingDivisors, vertexBindingDivisorCount, VkVertexInputBindingDivisorDescriptionEXT, "vertex_binding_divisors");
ZCHECK_END

static ZCLEAR_BEGIN(VkPipelineVertexInputStateCreateInfo)
    FreeList(pVertexBindingDescriptions, vertexBindingDescriptionCount, VkVertexInputBindingDescription);
    FreeList(pVertexAttributeDescriptions, vertexAttributeDescriptionCount, VkVertexInputAttributeDescription);
ZCLEAR_END
ZCHECK_BEGIN(VkPipelineVertexInputStateCreateInfo)
    checktable(arg);
    newstruct(VkPipelineVertexInputStateCreateInfo);
    GetFlags(flags, "flags");
    GetListOpt(pVertexBindingDescriptions, vertexBindingDescriptionCount, VkVertexInputBindingDescription, "vertex_binding_descriptions");
    GetListOpt(pVertexAttributeDescriptions, vertexAttributeDescriptionCount, VkVertexInputAttributeDescription, "vertex_attribute_descriptions");
    EXTENSIONS_BEGIN
    if(ispresent("vertex_binding_divisors"))
        ADD_EXTENSION_INLINE(VkPipelineVertexInputDivisorStateCreateInfoEXT);
    EXTENSIONS_END
ZCHECK_END

/*-------------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkPipelineDepthStencilStateCreateInfo)
    checktable(arg);
    newstruct(VkPipelineDepthStencilStateCreateInfo);
    GetFlags(flags, "flags");
    GetBoolean(depthTestEnable, "depth_test_enable");
    GetBoolean(depthWriteEnable, "depth_write_enable");
    GetCompareOp(depthCompareOp, "depth_compare_op");
    GetBoolean(depthBoundsTestEnable, "depth_bounds_test_enable");
    GetBoolean(stencilTestEnable, "stencil_test_enable");
    GetStructOpt(front, "front", VkStencilOpState);
    GetStructOpt(back, "back", VkStencilOpState);
    GetNumber(minDepthBounds, "min_depth_bounds");
    GetNumber(maxDepthBounds, "max_depth_bounds");
ZCHECK_END

/*-------------------------------------------------------------------------------------*/

ZCHECK_BEGIN(VkPipelineColorBlendAdvancedStateCreateInfoEXT)
    newstruct(VkPipelineColorBlendAdvancedStateCreateInfoEXT);
    GetBoolean(srcPremultiplied, "src_premultiplied");
    GetBoolean(dstPremultiplied, "dst_premultiplied");
    GetBlendOverlap(blendOverlap, "blend_overlap");
ZCHECK_END

static ZCLEAR_BEGIN(VkPipelineColorWriteCreateInfoEXT)
    FreeBooleanList(pColorWriteEnables);
ZCLEAR_END
ZCHECK_BEGIN(VkPipelineColorWriteCreateInfoEXT)
    newstruct(VkPipelineColorWriteCreateInfoEXT);
    GetBooleanList(pColorWriteEnables, attachmentCount, "color_write_enables");
ZCHECK_END

static ZCLEAR_BEGIN(VkPipelineColorBlendStateCreateInfo)
    FreeList(pAttachments, attachmentCount, VkPipelineColorBlendAttachmentState);
ZCLEAR_END
ZCHECK_BEGIN(VkPipelineColorBlendStateCreateInfo)
    checktable(arg);
    newstruct(VkPipelineColorBlendStateCreateInfo);
    GetFlags(flags, "flags");
    GetBoolean(logicOpEnable, "logic_op_enable");
    GetLogicOp(logicOp, "logic_op");
    GetNumberArray(blendConstants, "blend_constants", 4);
    GetListOpt(pAttachments, attachmentCount, VkPipelineColorBlendAttachmentState, "attachments");
    EXTENSIONS_BEGIN
    if(ispresent("src_premultiplied") || ispresent("dst_premultiplied") || ispresent("blend_overlap"))
        ADD_EXTENSION_INLINE(VkPipelineColorBlendAdvancedStateCreateInfoEXT);
    if(ispresent("color_write_enables"))
        ADD_EXTENSION_INLINE(VkPipelineColorWriteCreateInfoEXT);
    EXTENSIONS_END
ZCHECK_END

/*-------------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkPipelineDynamicStateCreateInfo)
    FreeEnumList(pDynamicStates, dynamicstate);
ZCLEAR_END
ZCHECK_BEGIN(VkPipelineDynamicStateCreateInfo)
    checktable(arg);
    newstruct(VkPipelineDynamicStateCreateInfo);
    GetFlags(flags, "flags");
    GetEnumList(pDynamicStates, dynamicStateCount, dynamicstate, "dynamic_states");
ZCHECK_END

/*-------------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkPipelineDiscardRectangleStateCreateInfoEXT)
    FreeList(pDiscardRectangles, discardRectangleCount, VkRect2D);
ZCLEAR_END
ZCHECK_BEGIN(VkPipelineDiscardRectangleStateCreateInfoEXT)
    checktable(arg);
    newstruct(VkPipelineDiscardRectangleStateCreateInfoEXT);
    GetFlags(flags, "flags");
    GetDiscardRectangleMode(discardRectangleMode, "discard_rectangle_mode");
    GetListOpt(pDiscardRectangles, discardRectangleCount, VkRect2D, "discard_rectangles");
ZCHECK_END

/*-------------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkPipelineCreationFeedbackCreateInfoEXT)
    FreeStructp(pPipelineCreationFeedback, VkPipelineCreationFeedbackEXT);
    FreeList(pPipelineStageCreationFeedbacks, pipelineStageCreationFeedbackCount, VkPipelineCreationFeedbackEXT);
ZCLEAR_END
ZCHECK_BEGIN(VkPipelineCreationFeedbackCreateInfoEXT)
    checktable(arg);
    newstruct(VkPipelineCreationFeedbackCreateInfoEXT);
    GetStructp(pPipelineCreationFeedback, VkPipelineCreationFeedbackEXT, "pipeline_creation_feedback");
    GetList(pPipelineStageCreationFeedbacks, pipelineStageCreationFeedbackCount, VkPipelineCreationFeedbackEXT, "pipeline_stage_creation_feedbacks");
ZCHECK_END

ZCHECK_BEGIN(VkPipelineFragmentShadingRateStateCreateInfoKHR)
    checktable(arg);
    newstruct(VkPipelineFragmentShadingRateStateCreateInfoKHR);
    GetStruct(fragmentSize, "fragment_size", VkExtent2D);
    GetEnumArray(combinerOps, "combiner_ops", 2, testfragmentshadingratecombinerop);
ZCHECK_END

/*-------------------------------------------------------------------------------------*/
ZCHECK_BEGIN(VkRenderingAttachmentInfoKHR)
    checktable(arg);
    newstruct(VkRenderingAttachmentInfoKHR);
    GetImageViewOpt(imageView, "image_view");
    GetImageLayout(imageLayout, "image_layout");
    GetFlags(resolveMode, "resolve_mode");
    GetImageViewOpt(resolveImageView, "resolve_image_view");
    GetImageLayout(resolveImageLayout, "resolve_image_layout");
    GetAttachmentLoadOp(loadOp, "load_op");
    GetAttachmentStoreOp(storeOp, "store_op");
    GetStruct(clearValue, "clear_value", VkClearValue);
ZCHECK_END
ZCHECKARRAY(VkRenderingAttachmentInfoKHR)

ZCHECK_BEGIN(VkRenderingFragmentShadingRateAttachmentInfoKHR)
    checktable(arg);
    newstruct(VkRenderingFragmentShadingRateAttachmentInfoKHR);
    GetImageViewOpt(imageView, "image_view");
    GetImageLayout(imageLayout, "image_layout");
    GetStructOpt(shadingRateAttachmentTexelSize, "texel_size", VkExtent2D);
ZCHECK_END

ZCHECK_BEGIN(VkRenderingFragmentDensityMapAttachmentInfoEXT)
    checktable(arg);
    newstruct(VkRenderingFragmentDensityMapAttachmentInfoEXT);
    GetImageViewOpt(imageView, "image_view");
    GetImageLayout(imageLayout, "image_layout");
ZCHECK_END

static ZCLEAR_BEGIN(VkRenderingInfoKHR)
    FreeList(pColorAttachments, colorAttachmentCount, VkRenderingAttachmentInfoKHR);
    FreeStructp(pDepthAttachment, VkRenderingAttachmentInfoKHR);
    FreeStructp(pStencilAttachment, VkRenderingAttachmentInfoKHR);
ZCLEAR_END
ZCHECK_BEGIN(VkRenderingInfoKHR)
    checktable(arg);
    newstruct(VkRenderingInfoKHR);
    GetFlags(flags, "flags");
    GetStructOpt(renderArea, "render_area", VkRect2D);
    GetIntegerOpt(layerCount, "layer_count", 0);
    GetIntegerOpt(viewMask, "view_mask", 0);
    GetList(pColorAttachments, colorAttachmentCount, VkRenderingAttachmentInfoKHR, "color_attachments");
    GetStructp(pDepthAttachment, VkRenderingAttachmentInfoKHR, "depth_attachment");
    GetStructp(pStencilAttachment, VkRenderingAttachmentInfoKHR, "stencil_attachment");
    EXTENSIONS_BEGIN
        ADD_EXTENSION_STRUCT("fragment_shading_rate", VkRenderingFragmentShadingRateAttachmentInfoKHR);
        ADD_EXTENSION_STRUCT("fragment_density_map", VkRenderingFragmentDensityMapAttachmentInfoEXT);
    EXTENSIONS_END
ZCHECK_END

/*-------------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkPipelineRenderingCreateInfoKHR)
    FreeEnumList(pColorAttachmentFormats, format);
ZCLEAR_END
ZCHECK_BEGIN(VkPipelineRenderingCreateInfoKHR)
    checktable(arg);
    newstruct(VkPipelineRenderingCreateInfoKHR);
    GetIntegerOpt(viewMask, "view_mask", 0);
    GetEnumList(pColorAttachmentFormats, colorAttachmentCount, format, "color_attachment_formats");
    GetFormat(depthAttachmentFormat, "depth_attachment_format");
    GetFormat(stencilAttachmentFormat, "stencil_attachment_format");
ZCHECK_END

/*-------------------------------------------------------------------------------------*/

static ZCLEAR_BEGIN(VkGraphicsPipelineCreateInfo)
    FreeList(pStages, stageCount, VkPipelineShaderStageCreateInfo);
    if(p->pVertexInputState) zfreeVkPipelineVertexInputStateCreateInfo(L, p->pVertexInputState, 1);
    if(p->pInputAssemblyState) zfreeVkPipelineInputAssemblyStateCreateInfo(L, p->pInputAssemblyState, 1);
    if(p->pTessellationState) zfreeVkPipelineTessellationStateCreateInfo(L, p->pTessellationState, 1);
    if(p->pViewportState) zfreeVkPipelineViewportStateCreateInfo(L, p->pViewportState, 1);
    if(p->pRasterizationState) zfreeVkPipelineRasterizationStateCreateInfo(L, p->pRasterizationState, 1);
    if(p->pMultisampleState) zfreeVkPipelineMultisampleStateCreateInfo(L, p->pMultisampleState, 1);
    if(p->pDepthStencilState) zfreeVkPipelineDepthStencilStateCreateInfo(L, p->pDepthStencilState, 1);
    if(p->pColorBlendState) zfreeVkPipelineColorBlendStateCreateInfo(L, p->pColorBlendState, 1);
    if(p->pDynamicState) zfreeVkPipelineDynamicStateCreateInfo(L, p->pDynamicState, 1);
ZCLEAR_END
ZCHECK_BEGIN(VkGraphicsPipelineCreateInfo)
    checktable(arg);
    newstruct(VkGraphicsPipelineCreateInfo);
    GetFlags(flags, "flags");
    GetPipelineLayout(layout, "layout");
    GetRenderPass(renderPass, "render_pass");
    GetInteger(subpass, "subpass");
    GetPipelineOpt(basePipelineHandle, "base_pipeline_handle");
    GetIntegerOpt(basePipelineIndex, "base_pipeline_index", -1);
    GetList(pStages, stageCount, VkPipelineShaderStageCreateInfo, "stages");
#define GET(name_, sname_, VkXxx, mandatory_)  do {            \
    arg1 = pushfield(L, arg, sname_);                        \
    p->name_ = zcheck##VkXxx(L, arg1, err);                  \
    popfield(L, arg1);                                      \
    if(*err<0) { prependfield(sname_); return p; }           \
    else if((mandatory_) && *err==ERR_NOTPRESENT) poperror();\
} while(0)
    GET(pVertexInputState, "vertex_input_state", VkPipelineVertexInputStateCreateInfo, 1);
    GET(pInputAssemblyState, "input_assembly_state", VkPipelineInputAssemblyStateCreateInfo, 1);
    GET(pTessellationState, "tessellation_state", VkPipelineTessellationStateCreateInfo, 0);
    GET(pViewportState, "viewport_state", VkPipelineViewportStateCreateInfo, 0);
    GET(pRasterizationState, "rasterization_state", VkPipelineRasterizationStateCreateInfo, 1);
    GET(pMultisampleState, "multisample_state", VkPipelineMultisampleStateCreateInfo, 0);
    GET(pDepthStencilState, "depth_stencil_state", VkPipelineDepthStencilStateCreateInfo, 0);
    GET(pColorBlendState, "color_blend_state", VkPipelineColorBlendStateCreateInfo, 0);
    GET(pDynamicState, "dynamic_state", VkPipelineDynamicStateCreateInfo, 0);
#undef GET
    EXTENSIONS_BEGIN
        ADD_EXTENSION_STRUCT("discard_rectangle_state", VkPipelineDiscardRectangleStateCreateInfoEXT);
        ADD_EXTENSION_STRUCT("creation_feedback_state", VkPipelineCreationFeedbackCreateInfoEXT);
        ADD_EXTENSION_STRUCT("fragment_shading_rate_state", VkPipelineFragmentShadingRateStateCreateInfoKHR);
        ADD_EXTENSION_STRUCT("rendering_state", VkPipelineRenderingCreateInfoKHR);
    EXTENSIONS_END
ZCHECK_END
ZCHECKARRAY(VkGraphicsPipelineCreateInfo)

/********************************************************************************
 * znew and zfree                                                               *
 ********************************************************************************/
/* The following functions are not meant to be used directly outside this module.
 * The specialized wrappers should be used instead (znewVkXxx() etc.)
 */

void* znew(lua_State *L, VkStructureType sType, size_t sz, int *err)
/* Allocate and initialize a structure of the given size and sType.
 * sType = -1 for structures that do not have the sType and pNext fields
 */
    {
    void *p = MallocNoErr(L, sz);
    if(p==NULL) { *err = ERR_MEMORY; return NULL; }
    if(sType != (VkStructureType)-1)
        ((VkBaseOutStructure*)p)->sType = sType;
    *err = 0;
    return p;
    }

void* znewarray(lua_State *L, VkStructureType sType, size_t sz, uint32_t count, int *err)
/* Same as znew(), but for an array of contiguous structures. */
    {
    void *p = MallocNoErr(L, sz*count);
    if(p==NULL) { *err = ERR_MEMORY; return NULL; }
    if(sType != (VkStructureType)-1)
        {
        uint32_t i;
        uintptr_t pp = (uintptr_t)p;
        for(i=0; i < count; i++)
            {
            ((VkBaseOutStructure*)pp)->sType = sType;
            pp = pp + sz;
            }
        }
    *err = 0;
    return p;
    }

void zfree_untyped(lua_State *L, const void *p, int base, void (*clearfunc)(lua_State *L, const void *p))
    { 
    if(!p) return;
    if(clearfunc) clearfunc(L, (void*)p);
    if(base) Free(L, (void*)p);
    }

void zfreearray_untyped(lua_State *L, const void *p, size_t sz, uint32_t count, int base, void (*clearfunc)(lua_State *L, const void *p))
    {
    size_t i;
    uintptr_t pp = (uintptr_t)p;
    if(!p) return;
    if(clearfunc)
        {
        for(i=0; i<count; i++)
            {
            clearfunc(L, (void*)pp);
            pp = pp + sz;
            }
        }
    if(base) Free(L, (void*)p);
    }

static void zfreeaux(lua_State *L, void *pp); /* forward declaration */

void zfree(lua_State *L, const void *p, int base)
/* Free the structure pointed by p, with all its contents (pNext chain, etc). */
    {
    if(!p) return;
    zfreeaux(L, (void*)p);
    if(base) Free(L, (void*)p);
    }

void zfreearray(lua_State *L, const void *p, size_t sz, uint32_t count, int base)
/* Same as zfree(), but for an array of contiguous structures. */
    {
    size_t i;
    uintptr_t pp = (uintptr_t)p;
    if(!p) return;
    for(i=0; i<count; i++)
        {
        zfreeaux(L, (void*)pp);
        pp = pp + sz;
        }
    if(base) Free(L, (void*)p);
    }

static void zfreeaux(lua_State *L, void *pp)
    {
    VkBaseOutStructure*p = (VkBaseOutStructure*)pp;
    if(p->pNext)
        zfree(L, (void*)p->pNext, 1);
    switch(p->sType)
        {
        /* call the zclear function for structures that need clearing outside the pNext chain */
#define CASE(XXX, VkXxx) case VK_STRUCTURE_TYPE_##XXX: zclear##VkXxx(L, (VkXxx*)pp); break
        CASE(VALIDATION_FLAGS_EXT, VkValidationFlagsEXT);
        CASE(INSTANCE_CREATE_INFO, VkInstanceCreateInfo);
        CASE(APPLICATION_INFO, VkApplicationInfo);
        CASE(BUFFER_CREATE_INFO, VkBufferCreateInfo);
        CASE(DEVICE_CREATE_INFO, VkDeviceCreateInfo);
        CASE(DEVICE_QUEUE_CREATE_INFO, VkDeviceQueueCreateInfo);
        CASE(IMAGE_FORMAT_LIST_CREATE_INFO, VkImageFormatListCreateInfo);
        CASE(IMAGE_CREATE_INFO, VkImageCreateInfo);
        CASE(DESCRIPTOR_POOL_CREATE_INFO, VkDescriptorPoolCreateInfo);
        CASE(DESCRIPTOR_SET_ALLOCATE_INFO, VkDescriptorSetAllocateInfo);
        CASE(DESCRIPTOR_SET_LAYOUT_CREATE_INFO, VkDescriptorSetLayoutCreateInfo);
        CASE(PIPELINE_LAYOUT_CREATE_INFO, VkPipelineLayoutCreateInfo);
        CASE(RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR, VkRenderPassInputAttachmentAspectCreateInfoKHR);
        CASE(RENDER_PASS_CREATE_INFO, VkRenderPassCreateInfo);
        CASE(FRAMEBUFFER_CREATE_INFO, VkFramebufferCreateInfo);
        CASE(SWAPCHAIN_CREATE_INFO_KHR, VkSwapchainCreateInfoKHR);
        CASE(DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR, VkDescriptorUpdateTemplateCreateInfoKHR);
        CASE(SUBMIT_INFO, VkSubmitInfo);
        CASE(PRESENT_REGIONS_KHR, VkPresentRegionsKHR);
        CASE(PRESENT_INFO_KHR, VkPresentInfoKHR);
        CASE(BIND_SPARSE_INFO, VkBindSparseInfo);
        CASE(WRITE_DESCRIPTOR_SET, VkWriteDescriptorSet);
        CASE(DEBUG_UTILS_OBJECT_NAME_INFO_EXT, VkDebugUtilsObjectNameInfoEXT);
        CASE(DEBUG_UTILS_OBJECT_TAG_INFO_EXT, VkDebugUtilsObjectTagInfoEXT);
        CASE(DEBUG_UTILS_LABEL_EXT, VkDebugUtilsLabelEXT);
        CASE(DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT, VkDebugUtilsMessengerCallbackDataEXT);
        CASE(PIPELINE_SHADER_STAGE_CREATE_INFO, VkPipelineShaderStageCreateInfo);
        CASE(COMPUTE_PIPELINE_CREATE_INFO, VkComputePipelineCreateInfo);
        CASE(PIPELINE_VIEWPORT_STATE_CREATE_INFO, VkPipelineViewportStateCreateInfo);
        CASE(SAMPLE_LOCATIONS_INFO_EXT, VkSampleLocationsInfoEXT);
        CASE(PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT, VkPipelineSampleLocationsStateCreateInfoEXT);
        CASE(PIPELINE_MULTISAMPLE_STATE_CREATE_INFO, VkPipelineMultisampleStateCreateInfo);
        CASE(PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO, VkPipelineVertexInputStateCreateInfo);
        CASE(PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT, VkPipelineVertexInputDivisorStateCreateInfoEXT);
        CASE(PIPELINE_COLOR_BLEND_STATE_CREATE_INFO, VkPipelineColorBlendStateCreateInfo);
        CASE(PIPELINE_DYNAMIC_STATE_CREATE_INFO, VkPipelineDynamicStateCreateInfo);
        CASE(PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT, VkPipelineDiscardRectangleStateCreateInfoEXT);
        CASE(GRAPHICS_PIPELINE_CREATE_INFO, VkGraphicsPipelineCreateInfo);
        CASE(RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT, VkRenderPassSampleLocationsBeginInfoEXT);
        CASE(RENDER_PASS_BEGIN_INFO, VkRenderPassBeginInfo);
        CASE(DISPLAY_MODE_CREATE_INFO_KHR, VkDisplayModeCreateInfoKHR);
        CASE(WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT, VkWriteDescriptorSetInlineUniformBlockEXT);
        CASE(DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO, VkDescriptorSetLayoutBindingFlagsCreateInfo);
        CASE(DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO, VkDescriptorSetVariableDescriptorCountAllocateInfo);
        CASE(RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR, VkRenderPassMultiviewCreateInfoKHR);
        CASE(SUBPASS_DESCRIPTION_2_KHR, VkSubpassDescription2);
        CASE(RENDER_PASS_CREATE_INFO_2_KHR, VkRenderPassCreateInfo2);
        CASE(DEVICE_GROUP_DEVICE_CREATE_INFO_KHR, VkDeviceGroupDeviceCreateInfoKHR);
        CASE(DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR, VkDeviceGroupRenderPassBeginInfoKHR);
        CASE(DEVICE_GROUP_SUBMIT_INFO_KHR, VkDeviceGroupSubmitInfoKHR);
        CASE(BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR, VkBindImageMemoryDeviceGroupInfoKHR);
        CASE(BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR, VkBindBufferMemoryDeviceGroupInfoKHR);
        CASE(DEVICE_GROUP_PRESENT_INFO_KHR, VkDeviceGroupPresentInfoKHR);
        CASE(SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE, VkSubpassDescriptionDepthStencilResolve);
        CASE(FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR, VkFragmentShadingRateAttachmentInfoKHR);
        CASE(FRAMEBUFFER_ATTACHMENTS_CREATE_INFO, VkFramebufferAttachmentsCreateInfo);
        CASE(FRAMEBUFFER_ATTACHMENT_IMAGE_INFO, VkFramebufferAttachmentImageInfo);
        CASE(RENDER_PASS_ATTACHMENT_BEGIN_INFO, VkRenderPassAttachmentBeginInfo);
        CASE(TIMELINE_SEMAPHORE_SUBMIT_INFO, VkTimelineSemaphoreSubmitInfo);
        CASE(SEMAPHORE_WAIT_INFO, VkSemaphoreWaitInfo);
        CASE(PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT, VkPipelineCreationFeedbackCreateInfoEXT);
        CASE(COPY_BUFFER_INFO_2_KHR, VkCopyBufferInfo2KHR);
        CASE(COMMAND_BUFFER_BEGIN_INFO, VkCommandBufferBeginInfo);
        CASE(COPY_IMAGE_INFO_2_KHR, VkCopyImageInfo2KHR);
        CASE(COPY_BUFFER_TO_IMAGE_INFO_2_KHR, VkCopyBufferToImageInfo2KHR);
        CASE(COPY_IMAGE_TO_BUFFER_INFO_2_KHR, VkCopyImageToBufferInfo2KHR);
        CASE(BLIT_IMAGE_INFO_2_KHR, VkBlitImageInfo2KHR);
        CASE(RESOLVE_IMAGE_INFO_2_KHR, VkResolveImageInfo2KHR);
        CASE(VALIDATION_FEATURES_EXT, VkValidationFeaturesEXT);
        CASE(PRESENT_ID_KHR, VkPresentIdKHR);
        CASE(PIPELINE_COLOR_WRITE_CREATE_INFO_EXT, VkPipelineColorWriteCreateInfoEXT);
        CASE(DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR, VkDeviceBufferMemoryRequirementsKHR);
        CASE(DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR, VkDeviceImageMemoryRequirementsKHR);
        CASE(RENDERING_INFO_KHR, VkRenderingInfoKHR);
        CASE(PIPELINE_RENDERING_CREATE_INFO_KHR, VkPipelineRenderingCreateInfoKHR);
        CASE(COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR, VkCommandBufferInheritanceRenderingInfoKHR);
        CASE(DEPENDENCY_INFO_KHR, VkDependencyInfoKHR);
        CASE(SUBMIT_INFO_2_KHR, VkSubmitInfo2KHR);
        CASE(QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR, VkQueryPoolPerformanceCreateInfoKHR);
#undef CASE
        default: 
            return;
        }
    }

#if 0 //@@scaffolding 9yy
static ZCLEAR_BEGIN()
ZCLEAR_END
ZCHECK_BEGIN()
    checktable(arg);
    newstruct();
ZCHECK_END
ZCHECKARRAY()
        CASE(, );

#endif

