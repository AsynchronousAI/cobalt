/* ============================================================================== //
// This file is apart of the Cobalt Programming Language. Cobalt is under the MIT //
// License. Read `cobalt.h` for license information.                              //
// ============================================================================== */

/*
This has been compiled using the Cobalt AOT compiler. The source code for this
file can be found in `cobalt23/lib/init.cobalt`. 
*/
#include "aot_header.c"

// source = @init.cobalt
// main function
static
CallInfo *magic_implementation_00(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
    case 132: goto label_132;
    case 133: goto label_133;
    case 134: goto label_134;
    case 135: goto label_135;
    case 136: goto label_136;
    case 137: goto label_137;
    case 138: goto label_138;
    case 139: goto label_139;
    case 140: goto label_140;
    case 141: goto label_141;
    case 142: goto label_142;
    case 143: goto label_143;
    case 144: goto label_144;
    case 145: goto label_145;
    case 146: goto label_146;
    case 147: goto label_147;
    case 148: goto label_148;
    case 149: goto label_149;
    case 150: goto label_150;
    case 151: goto label_151;
    case 152: goto label_152;
    case 153: goto label_153;
    case 154: goto label_154;
    case 155: goto label_155;
    case 156: goto label_156;
    case 157: goto label_157;
    case 158: goto label_158;
    case 159: goto label_159;
    case 160: goto label_160;
    case 161: goto label_161;
    case 162: goto label_162;
    case 163: goto label_163;
    case 164: goto label_164;
    case 165: goto label_165;
    case 166: goto label_166;
    case 167: goto label_167;
    case 168: goto label_168;
    case 169: goto label_169;
    case 170: goto label_170;
    case 171: goto label_171;
    case 172: goto label_172;
    case 173: goto label_173;
    case 174: goto label_174;
    case 175: goto label_175;
    case 176: goto label_176;
    case 177: goto label_177;
    case 178: goto label_178;
    case 179: goto label_179;
    case 180: goto label_180;
    case 181: goto label_181;
    case 182: goto label_182;
    case 183: goto label_183;
  }

  // 0	[1]	VARARGPREP	0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000051);
    ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));
    if (l_unlikely(trap)) {  /* previous "Protect" updated trap */
      luaD_hookcall(L, ci);
      L->oldpc = 1;  /* next opcode will be seen as a "new" line */
    }
    updatebase(ci);  /* function has new base after adjustment */
  }

  // 1	[12]	GETTABUP 	0 0 1	; _ENV "file"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0100000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[12]	SETTABUP 	0 0 0	; _ENV "filesystem"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0000000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 3	[13]	NEWTABLE 	0 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000013);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 4	[13]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 5	[14]	GETTABUP 	1 0 2	; _ENV "package"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[14]	GETFIELD 	1 1 3	; "config"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[14]	SELF     	1 1 4k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x04018094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[14]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 9	[14]	LOADI    	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x80000201);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 10	[14]	CALL     	1 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x020400c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 11	[14]	EQK      	1 5 1	; "\\"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_14
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000580bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 12	[14]	JMP      	1	; to 15
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_14;
  }

  // 13	[14]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 14	[14]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 15	[16]	LOADNIL  	2 2	; 3 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00020108);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 16	[20]	TEST     	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x000000c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 17	[20]	JMP      	4	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_22;
  }

  // 18	[21]	LOADK    	3 5	; "\\"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00028183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 19	[22]	LOADK    	2 6	; "/"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00030103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 20	[23]	LOADK    	4 7	; ";"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00038203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 21	[24]	JMP      	2	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_24;
  }

  // 22	[25]	LOADK    	3 6	; "/"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00030183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 23	[26]	LOADK    	4 8	; ":"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00040203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 24	[32]	CLOSURE  	5 0	; 0x7ff6dba05160
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x000002cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 25	[41]	CLOSURE  	6 1	; 0x7ff6dba04f40
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x0000834f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 26	[35]	SETFIELD 	0 9 6	; "isabs"
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x06090012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 27	[61]	CLOSURE  	6 2	; 0x7ff6dba05a90
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0001034f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 28	[46]	SETFIELD 	0 10 6	; "join"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x060a0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 29	[70]	CLOSURE  	6 3	; 0x7ff6dba05d40
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0001834f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 30	[64]	SETFIELD 	0 11 6	; "home"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x060b0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 31	[82]	CLOSURE  	6 4	; 0x7ff6dba06030
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x0002034f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 32	[76]	SETFIELD 	0 12 6	; "normalize"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x060c0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 33	[84]	GETFIELD 	6 0 13	; "attributes"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x0d00030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 34	[97]	CLOSURE  	7 5	; 0x7ff6dba06300
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x000283cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 35	[85]	SETFIELD 	0 13 7	; "attributes"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x070d0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 36	[101]	CLOSURE  	7 6	; 0x7ff6dba06470
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x000303cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 37	[99]	SETFIELD 	0 14 7	; "exists"
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x070e0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 38	[109]	CLOSURE  	7 7	; 0x7ff6dba06620
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x000383cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 39	[103]	SETFIELD 	0 15 7	; "dirname"
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x070f0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 40	[117]	CLOSURE  	7 8	; 0x7ff6dba069e0
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x000403cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 41	[111]	SETFIELD 	0 16 7	; "basename"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x07100012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 42	[139]	CLOSURE  	7 9	; 0x7ff6dba06ab0
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x000483cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 43	[125]	SETFIELD 	0 17 7	; "mkdirs"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x07110012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 44	[157]	CLOSURE  	7 10	; 0x7ff6dba06ef0
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x000503cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 45	[145]	SETFIELD 	0 18 7	; "rmdirs"
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x07120012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 46	[159]	SETTABUP 	0 19 0	; _ENV "filex"
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x0013000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 47	[161]	CLOSURE  	7 11	; 0x7ff6dba07210
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x000583cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 48	[161]	SETTABUP 	0 20 7	; _ENV "macros"
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x0714000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 49	[187]	CLOSURE  	7 12	; 0x7ff6dba074f0
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x000603cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 50	[163]	SETTABUP 	0 21 7	; _ENV "switch"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0715000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 51	[216]	NEWTABLE 	7 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00000393);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 52	[216]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 53	[216]	SETTABUP 	0 22 7	; _ENV "dead"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x0716000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 54	[232]	CLOSURE  	7 13	; 0x7ff6dba07ae0
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x000683cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 55	[219]	SETTABUP 	0 23 7	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x0717000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 56	[265]	CLOSURE  	7 14	; 0x7ff6dba08080
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x000703cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 57	[234]	SETTABUP 	0 24 7	; _ENV "tabletostring"
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x0718000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 58	[278]	CLOSURE  	7 15	; 0x7ff6dba05700
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x000783cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 59	[266]	SETTABUP 	0 25 7	; _ENV "loadenv"
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x0719000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 60	[281]	NEWTABLE 	7 6 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x00060393);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 61	[281]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 62	[285]	CLOSURE  	8 16	; 0x7ff6dba091b0
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x0008044f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 63	[285]	SETFIELD 	7 27 8	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x081b0392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 64	[288]	CLOSURE  	8 17	; 0x7ff6dba092c0
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x0008844f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 65	[288]	SETFIELD 	7 28 8	; "pos"
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x081c0392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 66	[291]	CLOSURE  	8 18	; 0x7ff6dba095d0
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x0009044f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 67	[291]	SETFIELD 	7 29 8	; "neg"
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x081d0392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 68	[294]	CLOSURE  	8 19	; 0x7ff6dba096a0
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x0009844f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 69	[294]	SETFIELD 	7 30 8	; "posint"
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x081e0392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 70	[297]	CLOSURE  	8 20	; 0x7ff6dba09830
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x000a044f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 71	[297]	SETFIELD 	7 31 8	; "negint"
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x081f0392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 72	[301]	CLOSURE  	8 21	; 0x7ff6dba067e0
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x000a844f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 73	[301]	SETFIELD 	7 32 8	; "pointer"
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x08200392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 74	[309]	CLOSURE  	8 22	; 0x7ff6dba09a40
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x000b044f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 75	[309]	SETFIELD 	7 33 8	; "array"
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x08210392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 76	[317]	CLOSURE  	8 23	; 0x7ff6dba09bd0
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x000b844f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 77	[317]	SETFIELD 	7 34 8	; "matrix"
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x08220392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 78	[321]	CLOSURE  	8 24	; 0x7ff6dba09da0
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x000c044f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 79	[321]	SETFIELD 	7 35 8	; "Vector3"
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x08230392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 80	[325]	CLOSURE  	8 25	; 0x7ff6dba09fb0
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x000c844f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 81	[325]	SETFIELD 	7 36 8	; "Vector2"
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x08240392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 82	[329]	CLOSURE  	8 26	; 0x7ff6dba0a1c0
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x000d044f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 83	[329]	SETFIELD 	7 37 8	; "Color"
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x08250392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 84	[333]	CLOSURE  	8 27	; 0x7ff6dba0a440
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x000d844f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 85	[333]	SETFIELD 	7 38 8	; "Transform"
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x08260392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 86	[337]	CLOSURE  	8 28	; 0x7ff6dba0a680
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x000e044f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 87	[337]	SETFIELD 	7 39 8	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x08270392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 88	[341]	CLOSURE  	8 29	; 0x7ff6dba0a7d0
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x000e844f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 89	[341]	SETFIELD 	7 40 8	; "boolean"
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x08280392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 90	[345]	CLOSURE  	8 30	; 0x7ff6dba0a960
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x000f044f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 91	[345]	SETFIELD 	7 41 8	; "table"
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x08290392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 92	[349]	CLOSURE  	8 31	; 0x7ff6dba0aaf0
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x000f844f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 93	[349]	SETFIELD 	7 42 8	; "function"
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x082a0392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 94	[353]	CLOSURE  	8 32	; 0x7ff6dba090b0
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x0010044f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 95	[353]	SETFIELD 	7 43 8	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x082b0392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 96	[357]	CLOSURE  	8 33	; 0x7ff6dba0af40
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x0010844f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 97	[357]	SETFIELD 	7 44 8	; "thread"
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x082c0392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 98	[361]	CLOSURE  	8 34	; 0x7ff6dba0b090
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x0011044f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 99	[361]	SETFIELD 	7 45 8	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x082d0392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 100	[365]	CLOSURE  	8 35	; 0x7ff6dba0b220
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x0011844f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 101	[365]	SETFIELD 	7 46 8	; "char"
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x082e0392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 102	[370]	CLOSURE  	8 36	; 0x7ff6dba0b3b0
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x0012044f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 103	[370]	SETFIELD 	7 47 8	; "msg"
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x082f0392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 104	[375]	CLOSURE  	8 37	; 0x7ff6dba0b540
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x0012844f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 105	[375]	SETFIELD 	7 48 8	; "complex"
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x08300392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 106	[380]	CLOSURE  	8 38	; 0x7ff6dba0b7a0
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x0013044f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 107	[380]	SETFIELD 	7 49 8	; "directory"
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x08310392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 108	[385]	CLOSURE  	8 39	; 0x7ff6dba0b930
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x0013844f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 109	[385]	SETFIELD 	7 50 8	; "lock"
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x08320392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 110	[389]	CLOSURE  	8 40	; 0x7ff6dba0bac0
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x0014044f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 111	[389]	SETFIELD 	7 51 8	; "protected"
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x08330392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 112	[394]	CLOSURE  	8 41	; 0x7ff6dba0bc50
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x0014844f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 113	[394]	SETFIELD 	7 52 8	; "_LUABOX"
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x08340392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 114	[398]	CLOSURE  	8 42	; 0x7ff6dba0bde0
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x0015044f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 115	[398]	SETFIELD 	7 53 8	; "any"
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x08350392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 116	[402]	CLOSURE  	8 43	; 0x7ff6dba0beb0
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x0015844f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 117	[402]	SETFIELD 	7 54 8	; "thread"
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x08360392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 118	[406]	CLOSURE  	8 44	; 0x7ff6dba0c040
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x0016044f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 119	[406]	SETFIELD 	7 55 8	; "int"
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x08370392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 120	[410]	CLOSURE  	8 45	; 0x7ff6dba0c1d0
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x0016844f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 121	[410]	SETFIELD 	7 56 8	; "float"
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x08380392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 122	[414]	CLOSURE  	8 46	; 0x7ff6dba0c360
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x0017044f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 123	[414]	SETFIELD 	7 57 8	; "double"
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x08390392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 124	[415]	SETTABUP 	0 26 7	; _ENV "types"
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x071a000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 125	[416]	NEWTABLE 	7 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x00000393);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 126	[416]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 127	[416]	SETTABUP 	0 58 7	; _ENV "alltypes"
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x073a000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 128	[418]	GETTABUP 	7 0 59	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x3b00038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 129	[418]	GETTABUP 	8 0 26	; _ENV "types"
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x1a00040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 130	[418]	CALL     	7 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_132
  label_130: {
    aot_vmfetch(0x050203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 131	[418]	TFORPREP 	7 5	; to 138
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_133
  label_131: {
    aot_vmfetch(0x000283cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_137;
  }

  // 132	[419]	GETTABUP 	13 0 60	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 133)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_134
  label_132: {
    aot_vmfetch(0x3c00068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 133	[419]	GETFIELD 	13 13 61	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 134)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_135
  label_133: {
    aot_vmfetch(0x3d0d068e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 134	[419]	GETTABUP 	14 0 58	; _ENV "alltypes"
  #undef  AOT_PC
  #define AOT_PC (code + 135)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_136
  label_134: {
    aot_vmfetch(0x3a00070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 135	[419]	MOVE     	15 11
  #undef  AOT_PC
  #define AOT_PC (code + 136)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_137
  label_135: {
    aot_vmfetch(0x000b0780);
    setobjs2s(L, ra, RB(i));
  }

  // 136	[419]	CALL     	13 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 137)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_138
  label_136: {
    aot_vmfetch(0x010306c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 137	[418]	TFORCALL 	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 138)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_139
  label_137: {
    aot_vmfetch(0x020003cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 138	[418]	TFORLOOP 	7 7	; to 133
  #undef  AOT_PC
  #define AOT_PC (code + 139)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_140
  label_138: {
    aot_vmfetch(0x000383cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_132; /* jump back */
    }
  }

  // 139	[420]	CLOSE    	7
  #undef  AOT_PC
  #define AOT_PC (code + 140)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_141
  label_139: {
    aot_vmfetch(0x000003b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 140	[435]	CLOSURE  	7 47	; 0x7ff6dba0c4f0
  #undef  AOT_PC
  #define AOT_PC (code + 141)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_142
  label_140: {
    aot_vmfetch(0x001783cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 141	[423]	SETTABUP 	0 62 7	; _ENV "deffind"
  #undef  AOT_PC
  #define AOT_PC (code + 142)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_143
  label_141: {
    aot_vmfetch(0x073e000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 142	[450]	CLOSURE  	7 48	; 0x7ff6dba05250
  #undef  AOT_PC
  #define AOT_PC (code + 143)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_144
  label_142: {
    aot_vmfetch(0x001803cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 143	[436]	SETTABUP 	0 63 7	; _ENV "assign"
  #undef  AOT_PC
  #define AOT_PC (code + 144)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_145
  label_143: {
    aot_vmfetch(0x073f000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 144	[462]	CLOSURE  	7 49	; 0x7ff6dba0cc30
  #undef  AOT_PC
  #define AOT_PC (code + 145)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_146
  label_144: {
    aot_vmfetch(0x001883cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 145	[451]	SETTABUP 	0 64 7	; _ENV "findfunctions"
  #undef  AOT_PC
  #define AOT_PC (code + 146)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_147
  label_145: {
    aot_vmfetch(0x0740000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 146	[476]	CLOSURE  	7 50	; 0x7ff6dba0cf90
  #undef  AOT_PC
  #define AOT_PC (code + 147)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_148
  label_146: {
    aot_vmfetch(0x001903cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 147	[463]	SETTABUP 	0 65 7	; _ENV "allassign"
  #undef  AOT_PC
  #define AOT_PC (code + 148)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_149
  label_147: {
    aot_vmfetch(0x0741000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 148	[488]	CLOSURE  	7 51	; 0x7ff6dba0d320
  #undef  AOT_PC
  #define AOT_PC (code + 149)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_150
  label_148: {
    aot_vmfetch(0x001983cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 149	[477]	SETTABUP 	0 66 7	; _ENV "findall"
  #undef  AOT_PC
  #define AOT_PC (code + 150)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_151
  label_149: {
    aot_vmfetch(0x0742000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 150	[514]	CLOSURE  	7 52	; 0x7ff6dba0d630
  #undef  AOT_PC
  #define AOT_PC (code + 151)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_152
  label_150: {
    aot_vmfetch(0x001a03cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 151	[489]	SETTABUP 	0 67 7	; _ENV "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 152)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_153
  label_151: {
    aot_vmfetch(0x0743000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 152	[536]	CLOSURE  	7 53	; 0x7ff6dba0da40
  #undef  AOT_PC
  #define AOT_PC (code + 153)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_154
  label_152: {
    aot_vmfetch(0x001a83cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 153	[515]	SETTABUP 	0 68 7	; _ENV "clean"
  #undef  AOT_PC
  #define AOT_PC (code + 154)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_155
  label_153: {
    aot_vmfetch(0x0744000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 154	[539]	GETTABUP 	7 0 70	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 155)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_156
  label_154: {
    aot_vmfetch(0x4600038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 155	[539]	SETTABUP 	0 69 7	; _ENV "typeof"
  #undef  AOT_PC
  #define AOT_PC (code + 156)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_157
  label_155: {
    aot_vmfetch(0x0745000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 156	[561]	CLOSURE  	7 54	; 0x7ff6dba0e370
  #undef  AOT_PC
  #define AOT_PC (code + 157)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_158
  label_156: {
    aot_vmfetch(0x001b03cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 157	[540]	SETTABUP 	0 71 7	; _ENV "check"
  #undef  AOT_PC
  #define AOT_PC (code + 158)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_159
  label_157: {
    aot_vmfetch(0x0747000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 158	[603]	CLOSURE  	7 55	; 0x7ff6dba0e920
  #undef  AOT_PC
  #define AOT_PC (code + 159)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_160
  label_158: {
    aot_vmfetch(0x001b83cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 159	[564]	SETTABUP 	0 72 7	; _ENV "typecheck"
  #undef  AOT_PC
  #define AOT_PC (code + 160)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_161
  label_159: {
    aot_vmfetch(0x0748000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 160	[610]	CLOSURE  	7 56	; 0x7ff6dba0f2a0
  #undef  AOT_PC
  #define AOT_PC (code + 161)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_162
  label_160: {
    aot_vmfetch(0x001c03cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 161	[604]	SETTABUP 	0 73 7	; _ENV "all"
  #undef  AOT_PC
  #define AOT_PC (code + 162)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_163
  label_161: {
    aot_vmfetch(0x0749000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 162	[612]	NEWTABLE 	7 3 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 163)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_164
  label_162: {
    aot_vmfetch(0x00030393);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 163	[612]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 164)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_165
  label_163: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 164	[613]	GETTABUP 	8 0 73	; _ENV "all"
  #undef  AOT_PC
  #define AOT_PC (code + 165)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_166
  label_164: {
    aot_vmfetch(0x4900040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 165	[613]	SETFIELD 	7 73 8	; "all"
  #undef  AOT_PC
  #define AOT_PC (code + 166)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_167
  label_165: {
    aot_vmfetch(0x08490392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 166	[614]	GETTABUP 	8 0 72	; _ENV "typecheck"
  #undef  AOT_PC
  #define AOT_PC (code + 167)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_168
  label_166: {
    aot_vmfetch(0x4800040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 167	[614]	SETFIELD 	7 75 8	; "check"
  #undef  AOT_PC
  #define AOT_PC (code + 168)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_169
  label_167: {
    aot_vmfetch(0x084b0392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 168	[615]	GETTABUP 	8 0 76	; _ENV "clean"
  #undef  AOT_PC
  #define AOT_PC (code + 169)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_170
  label_168: {
    aot_vmfetch(0x4c00040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 169	[615]	SETFIELD 	7 76 8	; "clean"
  #undef  AOT_PC
  #define AOT_PC (code + 170)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_171
  label_169: {
    aot_vmfetch(0x084c0392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 170	[616]	GETTABUP 	8 0 67	; _ENV "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 171)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_172
  label_170: {
    aot_vmfetch(0x4300040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 171	[616]	SETFIELD 	7 67 8	; "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 172)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_173
  label_171: {
    aot_vmfetch(0x08430392);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 172	[617]	SETTABUP 	0 74 7	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 173)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_174
  label_172: {
    aot_vmfetch(0x074a000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 173	[658]	CLOSURE  	7 57	; 0x7ff6dba0f550
  #undef  AOT_PC
  #define AOT_PC (code + 174)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_175
  label_173: {
    aot_vmfetch(0x001c83cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 174	[643]	SETTABUP 	0 77 7	; _ENV "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 175)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_176
  label_174: {
    aot_vmfetch(0x074d000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 175	[671]	CLOSURE  	7 58	; 0x7ff6dba0f7e0
  #undef  AOT_PC
  #define AOT_PC (code + 176)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_177
  label_175: {
    aot_vmfetch(0x001d03cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 176	[660]	SETTABUP 	0 78 7	; _ENV "find"
  #undef  AOT_PC
  #define AOT_PC (code + 177)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_178
  label_176: {
    aot_vmfetch(0x074e000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 177	[768]	CLOSURE  	7 59	; 0x7ff6dba0fa10
  #undef  AOT_PC
  #define AOT_PC (code + 178)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_179
  label_177: {
    aot_vmfetch(0x001d83cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 178	[768]	SETTABUP 	0 79 7	; _ENV "ext"
  #undef  AOT_PC
  #define AOT_PC (code + 179)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_180
  label_178: {
    aot_vmfetch(0x074f000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 179	[1375]	CLOSURE  	7 60	; 0x7ff6dba0fd10
  #undef  AOT_PC
  #define AOT_PC (code + 180)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_181
  label_179: {
    aot_vmfetch(0x001e03cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 180	[812]	SETTABUP 	0 80 7	; _ENV "process"
  #undef  AOT_PC
  #define AOT_PC (code + 181)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_182
  label_180: {
    aot_vmfetch(0x0750000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 181	[1378]	GETTABUP 	7 0 81	; _ENV "process"
  #undef  AOT_PC
  #define AOT_PC (code + 182)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_183
  label_181: {
    aot_vmfetch(0x5100038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 182	[1378]	RETURN   	7 2 1	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 183)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_182: {
    aot_vmfetch(0x010283c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 183	[1378]	RETURN   	7 1 1	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 184)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_183: {
    aot_vmfetch(0x010183c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 30 - 32
static
CallInfo *magic_implementation_01(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
  }

  // 0	[31]	GETTABUP 	2 0 0	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[31]	GETFIELD 	2 2 1	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0102010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[31]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[31]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 4	[31]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 5	[31]	TAILCALL 	2 4 0	; 3 in
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00040145);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 6	[31]	RETURN   	2 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x00000146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 7	[32]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 35 - 41
static
CallInfo *magic_implementation_02(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
  }

  // 0	[36]	GETUPVAL 	1 0	; windows
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[36]	TEST     	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_25
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x000000c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 2	[36]	JMP      	22	; to 26
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000ab8);
    updatetrap(ci);
    goto label_25;
  }

  // 3	[37]	GETUPVAL 	1 1	; at
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[37]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 5	[37]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 6	[37]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[37]	EQK      	1 0 1	; "/"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000080bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 8	[37]	JMP      	13	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_22;
  }

  // 9	[37]	GETUPVAL 	1 1	; at
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 10	[37]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 11	[37]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 12	[37]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 13	[37]	EQK      	1 1 1	; "\\"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 14	[37]	JMP      	7	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_22;
  }

  // 15	[37]	GETUPVAL 	1 1	; at
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 16	[37]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[37]	LOADI    	3 2
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x80008181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 18	[37]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[37]	EQK      	1 2 1	; ":"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000280bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 20	[37]	JMP      	1	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_22;
  }

  // 21	[37]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 22	[37]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 23	[37]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_34
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 24	[38]	JMP      	9	; to 35
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_34;
  }

  // 25	[39]	GETUPVAL 	1 1	; at
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 26	[39]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 27	[39]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 28	[39]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 29	[39]	EQK      	1 0 1	; "/"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_32
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x000080bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 30	[39]	JMP      	1	; to 33
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_32;
  }

  // 31	[39]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 32	[39]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 33	[39]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_33: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 34	[41]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_34: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 46 - 61
static
CallInfo *magic_implementation_03(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
  }

  // 0	[46]	VARARGPREP	2
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000151);
    ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));
    if (l_unlikely(trap)) {  /* previous "Protect" updated trap */
      luaD_hookcall(L, ci);
      L->oldpc = 1;  /* next opcode will be seen as a "new" line */
    }
    updatebase(ci);  /* function has new base after adjustment */
  }

  // 1	[47]	GETTABUP 	2 0 0	; _ENV "select"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[47]	LOADK    	3 1	; "#"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 3	[47]	VARARG   	4 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000250);
    int n = GETARG_C(i) - 1;  /* required results */
    Protect(luaT_getvarargs(L, ci, ra, n));
  }

  // 4	[47]	CALL     	2 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02000144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[47]	GTI      	2 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_26
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x007f0140);
    op_orderI(L, l_gti, luai_numgt, 1, TM_LT);
  }

  // 6	[47]	JMP      	19	; to 27
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000938);
    updatetrap(ci);
    goto label_26;
  }

  // 7	[48]	GETTABUP 	2 1 2	; lfs "join"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0201010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[48]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[48]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[48]	CALL     	2 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x02030144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 11	[49]	NEWTABLE 	3 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000193);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 12	[49]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 13	[49]	VARARG   	4 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000250);
    int n = GETARG_C(i) - 1;  /* required results */
    Protect(luaT_getvarargs(L, ci, ra, n));
  }

  // 14	[49]	SETLIST  	3 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x000001ce);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 15	[50]	LOADI    	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000201);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 16	[50]	LEN      	5 3
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x000302b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 17	[50]	LOADI    	6 1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x80000301);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 18	[50]	FORPREP  	4 5	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0002824a);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_25; /* skip the loop */
  }

  // 19	[51]	GETTABUP 	8 1 2	; lfs "join"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0201040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 20	[51]	MOVE     	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00020480);
    setobjs2s(L, ra, RB(i));
  }

  // 21	[51]	GETTABLE 	10 3 7
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0703050c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 22	[51]	CALL     	8 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x02030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 23	[51]	MOVE     	2 8
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00080100);
    setobjs2s(L, ra, RB(i));
  }

  // 24	[50]	FORLOOP  	4 6	; to 20
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00030249);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_19; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_19; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 25	[53]	RETURN   	2 2 3	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x03020146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 26	[55]	GETTABUP 	2 1 3	; lfs "isabs"
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x0301010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 27	[55]	MOVE     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00010180);
    setobjs2s(L, ra, RB(i));
  }

  // 28	[55]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 29	[55]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_32
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 30	[55]	JMP      	1	; to 33
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_32;
  }

  // 31	[55]	RETURN   	1 2 3	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x030200c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 32	[56]	GETUPVAL 	2 2	; at
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 33	[56]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 34	[56]	LEN      	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00000234);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 35	[56]	CALL     	2 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x02030144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 36	[57]	GETUPVAL 	3 3	; sep
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00030189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 37	[57]	EQ       	2 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_48
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00038139);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 38	[57]	JMP      	9	; to 49
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_48;
  }

  // 39	[57]	GETUPVAL 	3 4	; other_sep
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00040189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 40	[57]	EQ       	2 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_48
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00038139);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 41	[57]	JMP      	6	; to 49
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_48;
  }

  // 42	[57]	EQK      	2 4 1	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_48
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0004813c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 43	[57]	JMP      	4	; to 49
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_48;
  }

  // 44	[58]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 45	[58]	GETUPVAL 	4 3	; sep
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x00030209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 46	[58]	CONCAT   	3 2
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x000201b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 47	[58]	MOVE     	0 3
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00030000);
    setobjs2s(L, ra, RB(i));
  }

  // 48	[60]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 49	[60]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 50	[60]	CONCAT   	3 2
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x000201b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 51	[60]	RETURN   	3 2 3	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_51: {
    aot_vmfetch(0x030201c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 52	[61]	RETURN   	3 1 3	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_52: {
    aot_vmfetch(0x030101c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 64 - 70
static
CallInfo *magic_implementation_04(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
  }

  // 0	[65]	GETTABUP 	0 0 0	; _ENV "os"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[65]	GETFIELD 	0 0 1	; "getenv"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0100000e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[65]	LOADK    	1 2	; "HOME"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 3	[65]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[66]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 5	[66]	JMP      	16	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x800007b8);
    updatetrap(ci);
    goto label_22;
  }

  // 6	[67]	GETTABUP 	1 0 0	; _ENV "os"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[67]	GETFIELD 	1 1 1	; "getenv"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[67]	LOADK    	2 3	; "USERPROFILE"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00018103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[67]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[67]	TESTSET  	0 1 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00018043);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 11	[67]	JMP      	10	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_22;
  }

  // 12	[67]	GETTABUP 	1 0 0	; _ENV "os"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[67]	GETFIELD 	1 1 1	; "getenv"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 14	[67]	LOADK    	2 4	; "HOMEDRIVE"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00020103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 15	[67]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[67]	GETTABUP 	2 0 0	; _ENV "os"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[67]	GETFIELD 	2 2 1	; "getenv"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0102010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 18	[67]	LOADK    	3 5	; "HOMEPATH"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00028183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 19	[67]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[67]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 21	[67]	MOVE     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00010000);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[69]	RETURN1  	0
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_22: {
    aot_vmfetch(0x00020048);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 23	[70]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_23: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 76 - 82
static
CallInfo *magic_implementation_05(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
  }

  // 0	[77]	GETUPVAL 	1 0	; windows
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[77]	TEST     	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_09
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x000000c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 2	[77]	JMP      	6	; to 10
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_09;
  }

  // 3	[78]	SELF     	1 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[78]	LOADK    	3 1	; "\\"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00008183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[78]	LOADK    	4 2	; "/"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[78]	CALL     	1 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x020400c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[78]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[79]	JMP      	1	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_10;
  }

  // 9	[80]	RETURN1  	0
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x00020048);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 10	[82]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_10: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 85 - 97
static
CallInfo *magic_implementation_06(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
  }

  // 0	[85]	VARARGPREP	1
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x000000d1);
    ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));
    if (l_unlikely(trap)) {  /* previous "Protect" updated trap */
      luaD_hookcall(L, ci);
      L->oldpc = 1;  /* next opcode will be seen as a "new" line */
    }
    updatebase(ci);  /* function has new base after adjustment */
  }

  // 1	[86]	GETTABUP 	1 0 0	; lfs "normalize"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[86]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[86]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[86]	MOVE     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010000);
    setobjs2s(L, ra, RB(i));
  }

  // 5	[87]	GETUPVAL 	1 1	; windows
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[87]	TEST     	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000000c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 7	[87]	JMP      	5	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_13;
  }

  // 8	[93]	SELF     	1 0 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x01008094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 9	[93]	LOADK    	3 2	; "/$"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 10	[93]	LOADK    	4 3	; "/."
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00018203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[93]	CALL     	1 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020400c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[93]	MOVE     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00010000);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[96]	GETUPVAL 	1 2	; _attributes
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 14	[96]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 15	[96]	VARARG   	3 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000001d0);
    int n = GETARG_C(i) - 1;  /* required results */
    Protect(luaT_getvarargs(L, ci, ra, n));
  }

  // 16	[96]	TAILCALL 	1 0 2	; -1 in
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x020000c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 17	[96]	RETURN   	1 0 2	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_17: {
    aot_vmfetch(0x020000c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 18	[97]	RETURN   	1 1 2	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_18: {
    aot_vmfetch(0x020100c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 99 - 101
static
CallInfo *magic_implementation_07(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
  }

  // 0	[100]	GETTABUP 	1 0 0	; lfs "attributes"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[100]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[100]	LOADK    	3 1	; "mode"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 3	[100]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[100]	EQK      	1 2 0	; null
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_07
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000200bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 5	[100]	JMP      	1	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_07;
  }

  // 6	[100]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 7	[100]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 8	[100]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 9	[101]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 103 - 109
static
CallInfo *magic_implementation_08(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
  }

  // 0	[104]	GETTABUP 	1 0 0	; lfs "normalize"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[104]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[104]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[104]	SELF     	1 1 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x01018094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[104]	LOADK    	3 2	; "[^/]+/*$"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[104]	LOADK    	4 3	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00018203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[104]	CALL     	1 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x020400c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[105]	EQK      	1 3 0	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000300bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 8	[105]	JMP      	1	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_10;
  }

  // 9	[106]	RETURN1  	0
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00020048);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 10	[108]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_10: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 11	[109]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 111 - 117
static
CallInfo *magic_implementation_09(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
  }

  // 0	[112]	GETTABUP 	1 0 0	; lfs "normalize"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[112]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[112]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[112]	SELF     	1 1 1k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x01018094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[112]	LOADK    	3 2	; "[^/]+/*$"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[112]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[113]	EQK      	1 3 0	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_09
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000300bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 7	[113]	JMP      	1	; to 10
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_09;
  }

  // 8	[114]	RETURN1  	0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00020048);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 9	[116]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 10	[117]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_10: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 125 - 139
static
CallInfo *magic_implementation_10(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
  }

  // 0	[126]	GETTABUP 	1 0 0	; lfs "normalize"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[126]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[126]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[126]	MOVE     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00010000);
    setobjs2s(L, ra, RB(i));
  }

  // 4	[127]	GETTABUP 	1 0 1	; lfs "exists"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 5	[127]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 6	[127]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[127]	TEST     	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000000c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 8	[127]	JMP      	2	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_11;
  }

  // 9	[128]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 10	[128]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 11	[130]	GETTABUP 	1 0 2	; lfs "dirname"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[130]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[130]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[130]	EQ       	1 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_19
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x000000b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 15	[130]	JMP      	3	; to 20
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_19;
  }

  // 16	[132]	LOADNIL  	1 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00000088);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 17	[132]	LOADK    	2 3	; "mkdir: unable to create root directory"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00018103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 18	[132]	RETURN   	1 3 0	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x000300c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 19	[134]	GETTABUP 	1 0 4	; lfs "mkdirs"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0400008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 20	[134]	GETTABUP 	2 0 2	; lfs "dirname"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0200010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 21	[134]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[134]	CALL     	2 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 23	[134]	CALL     	1 0 3	; all in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x030000c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[135]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_33
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 25	[135]	JMP      	7	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_33;
  }

  // 26	[136]	LOADNIL  	3 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00000188);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 27	[136]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 28	[136]	LOADK    	5 5	; " (creating "
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00028283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 29	[136]	MOVE     	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00000300);
    setobjs2s(L, ra, RB(i));
  }

  // 30	[136]	LOADK    	7 6	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00030383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 31	[136]	CONCAT   	4 4
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x00040235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 32	[136]	RETURN   	3 3 0	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x000301c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 33	[138]	GETTABUP 	3 0 7	; lfs "mkdir"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x0700018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 34	[138]	MOVE     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00000200);
    setobjs2s(L, ra, RB(i));
  }

  // 35	[138]	TAILCALL 	3 2 0	; 1 in
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x000201c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 36	[138]	RETURN   	3 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_36: {
    aot_vmfetch(0x000001c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 37	[139]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_37: {
    aot_vmfetch(0x000101c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 145 - 157
static
CallInfo *magic_implementation_11(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
  }

  // 0	[146]	GETTABUP 	1 0 0	; lfs "dir"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[146]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[146]	CALL     	1 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x050200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[146]	TFORPREP 	1 28	; to 33
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000e00cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_32;
  }

  // 4	[147]	MOVE     	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00000300);
    setobjs2s(L, ra, RB(i));
  }

  // 5	[147]	GETUPVAL 	7 1	; sep
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[147]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 7	[147]	CONCAT   	6 3
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00030335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 8	[148]	EQK      	5 1 1	; "."
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_32
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x000182bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 9	[148]	JMP      	22	; to 33
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x80000ab8);
    updatetrap(ci);
    goto label_32;
  }

  // 10	[148]	EQK      	5 2 1	; ".."
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_32
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000282bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 11	[148]	JMP      	20	; to 33
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x800009b8);
    updatetrap(ci);
    goto label_32;
  }

  // 12	[149]	GETTABUP 	7 0 3	; lfs "attributes"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0300038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[149]	MOVE     	8 6
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00060400);
    setobjs2s(L, ra, RB(i));
  }

  // 14	[149]	LOADK    	9 4	; "mode"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00020483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 15	[149]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[149]	EQK      	7 5 0	; "file"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x000503bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 17	[149]	JMP      	5	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_23;
  }

  // 18	[150]	GETTABUP 	7 2 6	; _ENV "os"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0602038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 19	[150]	GETFIELD 	7 7 7	; "remove"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0707038e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 20	[150]	MOVE     	8 6
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00060400);
    setobjs2s(L, ra, RB(i));
  }

  // 21	[150]	CALL     	7 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_32
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x010203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 22	[151]	JMP      	9	; to 33
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_32;
  }

  // 23	[151]	GETTABUP 	7 0 3	; lfs "attributes"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x0300038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 24	[151]	MOVE     	8 6
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00060400);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[151]	LOADK    	9 4	; "mode"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00020483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 26	[151]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 27	[151]	EQK      	7 8 0	; "directory"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_32
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000803bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 28	[151]	JMP      	3	; to 33
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_32;
  }

  // 29	[152]	GETTABUP 	7 2 9	; _ENV "deletedir"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0902038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 30	[152]	MOVE     	8 6
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00060400);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[152]	CALL     	7 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x010203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[146]	TFORCALL 	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x010000cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 33	[146]	TFORLOOP 	1 30	; to 5
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x000f00cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_04; /* jump back */
    }
  }

  // 34	[155]	CLOSE    	1
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x000000b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 35	[156]	GETTABUP 	1 0 10	; lfs "rmdir"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x0a00008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 36	[156]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 37	[156]	TAILCALL 	1 2 0	; 1 in
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x000280c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 38	[156]	RETURN   	1 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_38: {
    aot_vmfetch(0x000080c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 39	[157]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_39: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 161 - 161
static
CallInfo *magic_implementation_12(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
  }

  // 0	[161]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_00: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 163 - 187
static
CallInfo *magic_implementation_13(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
  }

  // 0	[164]	GETTABUP 	2 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[164]	MOVE     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00010180);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[164]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[164]	EQK      	2 1 1	; "table"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0001813c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[164]	JMP      	3	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_08;
  }

  // 5	[165]	GETTABUP 	2 0 2	; _ENV "error"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[165]	LOADK    	3 3	; "Switch expects a table as the second argument"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[165]	CALL     	2 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x01020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[168]	GETTABLE 	2 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0001010c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 9	[168]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_25
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 10	[168]	JMP      	14	; to 26
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x800006b8);
    updatetrap(ci);
    goto label_25;
  }

  // 11	[169]	GETTABUP 	2 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[169]	GETTABLE 	3 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0001018c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 13	[169]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[169]	EQK      	2 4 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_21
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0004013c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 15	[169]	JMP      	5	; to 22
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_21;
  }

  // 16	[170]	GETTABUP 	2 0 5	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0500010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[170]	GETTABLE 	3 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0001018c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 18	[170]	CALL     	2 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x01020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[171]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_25
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 20	[172]	JMP      	4	; to 26
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_25;
  }

  // 21	[173]	GETTABLE 	2 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0001010c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 22	[173]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 23	[173]	CALL     	2 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x01020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[174]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 25	[177]	GETFIELD 	2 1 6	; "default"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x0601010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 26	[177]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 27	[177]	JMP      	14	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x800006b8);
    updatetrap(ci);
    goto label_42;
  }

  // 28	[178]	GETTABUP 	2 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 29	[178]	GETFIELD 	3 1 6	; "default"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0601018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 30	[178]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 31	[178]	EQK      	2 4 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_38
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x0004013c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 32	[178]	JMP      	5	; to 39
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_38;
  }

  // 33	[179]	GETTABUP 	2 0 5	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x0500010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 34	[179]	GETFIELD 	3 1 6	; "default"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x0601018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 35	[179]	CALL     	2 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x01020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 36	[180]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 37	[181]	JMP      	4	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_42;
  }

  // 38	[182]	GETFIELD 	2 1 6	; "default"
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x0601010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 39	[182]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 40	[182]	CALL     	2 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x01020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 41	[183]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 42	[186]	GETTABUP 	2 0 7	; _ENV "warn"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0700010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[186]	LOADK    	3 8	; "Switch cannot find a case for "
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x00040183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 44	[186]	GETTABUP 	4 0 9	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x0900020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 45	[186]	MOVE     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x00000280);
    setobjs2s(L, ra, RB(i));
  }

  // 46	[186]	CALL     	4 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x02020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 47	[186]	LOADK    	5 10	; " and no default case was provided"
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00050283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 48	[186]	CONCAT   	3 3
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x000301b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 49	[186]	CALL     	2 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_49: {
    aot_vmfetch(0x01020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 50	[187]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_50: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 219 - 232
static
CallInfo *magic_implementation_14(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
  }

  // 0	[220]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[220]	LOADK    	4 1	; "\027[1;31mTypechecker error:\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[220]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[221]	TEST     	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 4	[221]	JMP      	6	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_11;
  }

  // 5	[222]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[222]	LOADK    	4 2	; "\027[1;31m"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[222]	MOVE     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000280);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[222]	LOADK    	6 3	; "\027[0m\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00018303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[222]	CONCAT   	4 3
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00030235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 10	[222]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 11	[224]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[224]	LOADK    	4 4	; "\027[1;31mSnippet:\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00020203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[224]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[225]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 15	[225]	GETTABUP 	4 0 5	; _ENV "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x0500020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 16	[225]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[225]	CALL     	4 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[225]	CALL     	3 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x010001c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[226]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_30
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 20	[226]	JMP      	9	; to 31
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_30;
  }

  // 21	[227]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 22	[227]	LOADK    	4 6	; "\n\027[1;31mTypechecker provided note:\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00030203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 23	[227]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[228]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 25	[228]	LOADK    	4 7	; "\n\027[1;31m"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00038203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 26	[228]	MOVE     	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00020280);
    setobjs2s(L, ra, RB(i));
  }

  // 27	[228]	LOADK    	6 8	; "\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00040303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 28	[228]	CONCAT   	4 3
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00030235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 29	[228]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 30	[230]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 31	[230]	LOADK    	4 9	; "\n\027[1;31mStopping Typechecker.\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x00048203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 32	[230]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 33	[231]	GETTABUP 	3 0 10	; _ENV "os"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x0a00018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 34	[231]	GETFIELD 	3 3 11	; "exit"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x0b03018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 35	[231]	CALL     	3 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_35: {
    aot_vmfetch(0x010101c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 36	[232]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_36: {
    aot_vmfetch(0x000101c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 234 - 265
static
CallInfo *magic_implementation_15(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
  }

  // 0	[236]	LOADK    	1 0	; "{"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[237]	GETTABUP 	2 0 1	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[237]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[237]	CALL     	2 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x05020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[237]	TFORPREP 	2 62	; to 68
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x001f014b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_67;
  }

  // 5	[238]	TEST     	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000083c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 6	[238]	JMP      	1	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_08;
  }

  // 7	[239]	LOADK    	7 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00010383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 8	[241]	GETTABUP 	8 0 3	; _ENV "loadstring"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0300040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 9	[241]	LOADK    	9 4	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00020483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 10	[241]	TESTSET  	10 7 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00078543);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 11	[241]	JMP      	1	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_13;
  }

  // 12	[241]	LOADK    	10 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00010503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[241]	CONCAT   	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000204b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 14	[241]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 15	[241]	TESTSET  	7 8 1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_25
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000883c3);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 16	[241]	JMP      	8	; to 26
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_25;
  }

  // 17	[241]	GETTABUP 	8 0 5	; _ENV "loadenv"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0500040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 18	[241]	LOADK    	9 4	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00020483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 19	[241]	TESTSET  	10 7 1
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00078543);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 20	[241]	JMP      	1	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_22;
  }

  // 21	[241]	LOADK    	10 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00010503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 22	[241]	CONCAT   	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000204b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 23	[241]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[241]	MOVE     	7 8
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00080380);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[242]	GETTABUP 	8 0 6	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x0600040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 26	[244]	CLOSURE  	9 0	; 0x7ff6dba083b0
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x000004cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 27	[253]	CLOSURE  	10 1	; 0x7ff6dba08480
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0000854f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 28	[242]	CALL     	8 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x01030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 29	[255]	GETTABUP 	8 0 7	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0700040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 30	[255]	MOVE     	9 7
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00070480);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[255]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[255]	EQK      	8 8 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x0008043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 33	[255]	JMP      	8	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_42;
  }

  // 34	[256]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 35	[256]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 36	[256]	LOADK    	10 9	; " = \""
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00048503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 37	[256]	MOVE     	11 7
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00070580);
    setobjs2s(L, ra, RB(i));
  }

  // 38	[256]	LOADK    	12 10	; "\","
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00050603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 39	[256]	CONCAT   	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00050435);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 40	[256]	MOVE     	1 8
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_66
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00080080);
    setobjs2s(L, ra, RB(i));
  }

  // 41	[257]	JMP      	24	; to 67
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x80000bb8);
    updatetrap(ci);
    goto label_66;
  }

  // 42	[257]	GETTABUP 	8 0 7	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0700040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[257]	MOVE     	9 7
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x00070480);
    setobjs2s(L, ra, RB(i));
  }

  // 44	[257]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 45	[257]	EQK      	8 11 0	; "table"
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_57
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000b043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 46	[257]	JMP      	10	; to 58
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_57;
  }

  // 47	[258]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 48	[258]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 49	[258]	LOADK    	10 12	; " = "
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00060503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 50	[258]	GETTABUP 	11 0 13	; _ENV "tabletostring"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0d00058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 51	[258]	MOVE     	12 7
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00070600);
    setobjs2s(L, ra, RB(i));
  }

  // 52	[258]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 53	[258]	LOADK    	12 14	; ", "
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00070603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 54	[258]	CONCAT   	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x00050435);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 55	[258]	MOVE     	1 8
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_66
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x00080080);
    setobjs2s(L, ra, RB(i));
  }

  // 56	[259]	JMP      	9	; to 67
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_66;
  }

  // 57	[260]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 58	[260]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 59	[260]	LOADK    	10 12	; " = "
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x00060503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 60	[260]	TESTSET  	11 7 1
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_63
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x000785c3);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 61	[260]	JMP      	1	; to 64
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_63;
  }

  // 62	[260]	LOADK    	11 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x00010583);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 63	[260]	LOADK    	12 15	; ","
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x00078603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 64	[260]	CONCAT   	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x00050435);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 65	[260]	MOVE     	1 8
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x00080080);
    setobjs2s(L, ra, RB(i));
  }

  // 66	[262]	CLOSE    	6
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x00000336);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 67	[237]	TFORCALL 	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x0200014c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 68	[237]	TFORLOOP 	2 64	; to 6
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x0020014d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_05; /* jump back */
    }
  }

  // 69	[262]	CLOSE    	2
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x00000136);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 70	[263]	MOVE     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x00010100);
    setobjs2s(L, ra, RB(i));
  }

  // 71	[263]	LOADK    	3 16	; "}"
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x00080183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 72	[263]	CONCAT   	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x00020135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 73	[263]	MOVE     	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x00020080);
    setobjs2s(L, ra, RB(i));
  }

  // 74	[264]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_74: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 75	[265]	RETURN   	2 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_75: {
    aot_vmfetch(0x00018146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 242 - 244
static
CallInfo *magic_implementation_16(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[243]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[243]	CALL     	0 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x02010044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 2	[243]	SETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x0000000a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 3	[244]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 245 - 253
static
CallInfo *magic_implementation_17(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
  }

  // 0	[246]	GETTABUP 	0 1 0	; _ENV "loadenv"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0001000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[246]	LOADK    	1 1	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[246]	GETUPVAL 	2 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[246]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 4	[246]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[246]	LOADK    	2 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[246]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 7	[246]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[246]	SETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0000000a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 9	[247]	GETTABUP 	0 1 3	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0301000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 10	[249]	CLOSURE  	1 0	; 0x7ff6dba085d0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000000cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 11	[252]	CLOSURE  	2 1	; 0x7ff6dba086a0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0000814f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 12	[247]	CALL     	0 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x01030044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 13	[253]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 247 - 249
static
CallInfo *magic_implementation_18(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[248]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[248]	CALL     	0 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x02010044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 2	[248]	SETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x0000000a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 3	[249]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 250 - 252
static
CallInfo *magic_implementation_19(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
  }

  // 0	[251]	GETTABUP 	1 0 0	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[251]	LOADK    	2 1	; "Error checking value: "
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[251]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[251]	CONCAT   	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00020135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 4	[251]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_04: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[252]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_05: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 266 - 278
static
CallInfo *magic_implementation_20(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
  }

  // 0	[268]	GETTABUP 	2 0 1	; _ENV "tabletostring"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[268]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[268]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[268]	SETTABUP 	0 0 2	; _ENV "envstr"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0200000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 4	[270]	LOADK    	2 2	; "    env = "
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[270]	GETTABUP 	3 0 0	; _ENV "envstr"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[275]	LOADK    	4 3	; "    for (i, v in pairs(env)) {\n      _G[i] = v\n    }\n\n  "
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[275]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[275]	CONCAT   	2 4
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00040135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 9	[275]	MOVE     	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00020080);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[277]	GETTABUP 	2 0 4	; _ENV "loadstring"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 11	[277]	GETTABUP 	3 0 5	; _ENV "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0500018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[277]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[277]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[277]	TAILCALL 	2 0 0	; -1 in
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000145);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 15	[277]	RETURN   	2 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x00000146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 16	[278]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_16: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 282 - 285
static
CallInfo *magic_implementation_21(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[284]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[284]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[284]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[284]	EQK      	1 1 1	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[284]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[284]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[284]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[284]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[285]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 286 - 288
static
CallInfo *magic_implementation_22(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
  }

  // 0	[287]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[287]	GETFIELD 	1 1 1	; "abs"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[287]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[287]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[287]	EQ       	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_07
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000080b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 5	[287]	JMP      	1	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_07;
  }

  // 6	[287]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 7	[287]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 8	[287]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 9	[288]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 289 - 291
static
CallInfo *magic_implementation_23(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
  }

  // 0	[290]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[290]	GETFIELD 	1 1 1	; "abs"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[290]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[290]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[290]	EQ       	1 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_07
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000000b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 5	[290]	JMP      	1	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_07;
  }

  // 6	[290]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 7	[290]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 8	[290]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 9	[291]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 292 - 294
static
CallInfo *magic_implementation_24(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
  }

  // 0	[293]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[293]	GETFIELD 	1 1 1	; "abs"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[293]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[293]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[293]	EQ       	1 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000000b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 5	[293]	JMP      	6	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_12;
  }

  // 6	[293]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[293]	GETFIELD 	1 1 2	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0201008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[293]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[293]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[293]	EQ       	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000080b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 11	[293]	JMP      	1	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_13;
  }

  // 12	[293]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 13	[293]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 14	[293]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 15	[294]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 295 - 297
static
CallInfo *magic_implementation_25(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
  }

  // 0	[296]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[296]	GETFIELD 	1 1 1	; "abs"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[296]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[296]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[296]	EQ       	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000080b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 5	[296]	JMP      	6	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_12;
  }

  // 6	[296]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[296]	GETFIELD 	1 1 2	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0201008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[296]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[296]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[296]	EQ       	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000080b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 11	[296]	JMP      	1	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_13;
  }

  // 12	[296]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 13	[296]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 14	[296]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 15	[297]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 298 - 301
static
CallInfo *magic_implementation_26(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
  }

  // 0	[300]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[300]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[300]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[300]	EQK      	1 1 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_21
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[300]	JMP      	16	; to 22
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800007b8);
    updatetrap(ci);
    goto label_21;
  }

  // 5	[300]	GETTABUP 	1 0 1	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0100008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[300]	GETFIELD 	1 1 2	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0201008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[300]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[300]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 9	[300]	LOADI    	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x80000201);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 10	[300]	CALL     	1 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x020400c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 11	[300]	EQK      	1 3 1	; "&"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000380bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 12	[300]	JMP      	9	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_22;
  }

  // 13	[300]	GETTABUP 	1 0 1	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0100008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 14	[300]	GETFIELD 	1 1 2	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0201008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[300]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[300]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 17	[300]	LOADI    	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x80008201);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 18	[300]	CALL     	1 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x020400c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[300]	EQK      	1 4 1	; "0x"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000480bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 20	[300]	JMP      	1	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_22;
  }

  // 21	[300]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 22	[300]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 23	[300]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_23: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 24	[301]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_24: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 302 - 309
static
CallInfo *magic_implementation_27(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
  }

  // 0	[304]	GETTABUP 	1 0 0	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[304]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[304]	CALL     	1 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x050200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[304]	TFORPREP 	1 7	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000380cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_11;
  }

  // 4	[305]	GETTABUP 	7 0 1	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 5	[305]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 6	[305]	CALL     	7 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x020203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[305]	EQK      	7 2 1	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000283bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 8	[305]	JMP      	2	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_11;
  }

  // 9	[306]	LOADFALSE	7
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000385);
    setbfvalue(s2v(ra));
  }

  // 10	[306]	RETURN   	7 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000283c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 11	[304]	TFORCALL 	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020000cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 12	[304]	TFORLOOP 	1 9	; to 5
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000480cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_04; /* jump back */
    }
  }

  // 13	[308]	CLOSE    	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000000b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 14	[309]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 310 - 317
static
CallInfo *magic_implementation_28(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
  }

  // 0	[312]	GETTABUP 	1 0 0	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[312]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[312]	CALL     	1 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x050200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[312]	TFORPREP 	1 7	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000380cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_11;
  }

  // 4	[313]	GETTABUP 	7 0 1	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 5	[313]	MOVE     	8 6
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00060400);
    setobjs2s(L, ra, RB(i));
  }

  // 6	[313]	CALL     	7 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x020203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[313]	EQK      	7 2 1	; "table"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000283bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 8	[313]	JMP      	2	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_11;
  }

  // 9	[314]	LOADFALSE	7
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000385);
    setbfvalue(s2v(ra));
  }

  // 10	[314]	RETURN   	7 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000283c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 11	[312]	TFORCALL 	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020000cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 12	[312]	TFORLOOP 	1 9	; to 5
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000480cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_04; /* jump back */
    }
  }

  // 13	[316]	CLOSE    	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000000b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 14	[317]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 318 - 321
static
CallInfo *magic_implementation_29(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
  }

  // 0	[320]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[320]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[320]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[320]	EQK      	1 1 0	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[320]	JMP      	8	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_13;
  }

  // 5	[320]	GETTABUP 	1 0 2	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[320]	GETFIELD 	1 1 3	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[320]	GETTABUP 	2 0 4	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[320]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[320]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[320]	LOADK    	3 5	; "^vec3: "
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00028183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[320]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_15
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[320]	JMP      	2	; to 16
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_15;
  }

  // 13	[320]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 14	[320]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 15	[320]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 16	[321]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_16: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 322 - 325
static
CallInfo *magic_implementation_30(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
  }

  // 0	[324]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[324]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[324]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[324]	EQK      	1 1 0	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[324]	JMP      	8	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_13;
  }

  // 5	[324]	GETTABUP 	1 0 2	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[324]	GETFIELD 	1 1 3	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[324]	GETTABUP 	2 0 4	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[324]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[324]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[324]	LOADK    	3 5	; "^vec2: "
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00028183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[324]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_15
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[324]	JMP      	2	; to 16
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_15;
  }

  // 13	[324]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 14	[324]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 15	[324]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 16	[325]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_16: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 326 - 329
static
CallInfo *magic_implementation_31(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
  }

  // 0	[328]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[328]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[328]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[328]	EQK      	1 1 0	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[328]	JMP      	8	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_13;
  }

  // 5	[328]	GETTABUP 	1 0 2	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[328]	GETFIELD 	1 1 3	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[328]	GETTABUP 	2 0 4	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[328]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[328]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[328]	LOADK    	3 5	; "^color: "
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00028183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[328]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_15
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[328]	JMP      	2	; to 16
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_15;
  }

  // 13	[328]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 14	[328]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 15	[328]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 16	[329]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_16: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 330 - 333
static
CallInfo *magic_implementation_32(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
  }

  // 0	[332]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[332]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[332]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[332]	EQK      	1 1 0	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[332]	JMP      	8	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_13;
  }

  // 5	[332]	GETTABUP 	1 0 2	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[332]	GETFIELD 	1 1 3	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[332]	GETTABUP 	2 0 4	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[332]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[332]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[332]	LOADK    	3 5	; "^transform: "
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00028183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[332]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_15
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[332]	JMP      	2	; to 16
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_15;
  }

  // 13	[332]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 14	[332]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 15	[332]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 16	[333]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_16: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 334 - 337
static
CallInfo *magic_implementation_33(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[336]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[336]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[336]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[336]	EQK      	1 1 1	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[336]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[336]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[336]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[336]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[337]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 338 - 341
static
CallInfo *magic_implementation_34(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[340]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[340]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[340]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[340]	EQK      	1 1 1	; "boolean"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[340]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[340]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[340]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[340]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[341]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 342 - 345
static
CallInfo *magic_implementation_35(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[344]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[344]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[344]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[344]	EQK      	1 1 1	; "table"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[344]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[344]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[344]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[344]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[345]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 346 - 349
static
CallInfo *magic_implementation_36(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[348]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[348]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[348]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[348]	EQK      	1 1 1	; "function"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[348]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[348]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[348]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[348]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[349]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 350 - 353
static
CallInfo *magic_implementation_37(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[352]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[352]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[352]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[352]	EQK      	1 1 1	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[352]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[352]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[352]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[352]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[353]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 354 - 357
static
CallInfo *magic_implementation_38(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[356]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[356]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[356]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[356]	EQK      	1 1 1	; "thread"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[356]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[356]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[356]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[356]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[357]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 358 - 361
static
CallInfo *magic_implementation_39(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[360]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[360]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[360]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[360]	EQK      	1 1 1	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[360]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[360]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[360]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[360]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[361]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 362 - 365
static
CallInfo *magic_implementation_40(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
  }

  // 0	[364]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[364]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[364]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[364]	EQK      	1 1 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[364]	JMP      	3	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_08;
  }

  // 5	[364]	LEN      	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000000b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 6	[364]	EQI      	1 1 1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_09
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x008080bd);
    int cond;
    int im = GETARG_sB(i);
    if (ttisinteger(s2v(ra)))
      cond = (ivalue(s2v(ra)) == im);
    else if (ttisfloat(s2v(ra)))
      cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));
    else
      cond = 0;  /* other types cannot be equal to a number */
    docondjump();
  }

  // 7	[364]	JMP      	1	; to 10
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_09;
  }

  // 8	[364]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 9	[364]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 10	[364]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_10: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 11	[365]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 366 - 370
static
CallInfo *magic_implementation_41(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
  }

  // 0	[369]	GETTABUP 	1 0 0	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[369]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[369]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[369]	GETTABUP 	2 0 1	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[369]	GETFIELD 	2 2 2	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0202010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[369]	LOADK    	3 3	; "^message: "
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[369]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[369]	EQ       	1 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000280b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 8	[369]	JMP      	1	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_10;
  }

  // 9	[369]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 10	[369]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 11	[369]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 12	[370]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 371 - 375
static
CallInfo *magic_implementation_42(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
  }

  // 0	[373]	GETTABUP 	1 0 2	; _ENV "pcall"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[373]	CLOSURE  	2 0	; 0x7ff6dba0b690
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0000014f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 2	[373]	CALL     	1 2 3	; 1 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x030200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[373]	SETTABUP 	0 1 2	; _ENV "e"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0201000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 4	[373]	SETTABUP 	0 0 1	; _ENV "s"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 5	[374]	GETTABUP 	1 0 0	; _ENV "s"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[374]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 7	[375]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 373 - 373
static
CallInfo *magic_implementation_43(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
  }

  // 0	[373]	GETTABUP 	0 0 0	; item "__name"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[373]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 2	[373]	JMP      	3	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_06;
  }

  // 3	[373]	GETTABUP 	0 1 1	; _ENV "error"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0101000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[373]	LOADK    	1 2	; "Force error"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[373]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_05: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[373]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 376 - 380
static
CallInfo *magic_implementation_44(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
  }

  // 0	[379]	GETTABUP 	1 0 0	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[379]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[379]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[379]	GETTABUP 	2 0 1	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[379]	GETFIELD 	2 2 2	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0202010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[379]	LOADK    	3 3	; "^directory: "
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[379]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[379]	EQ       	1 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000280b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 8	[379]	JMP      	1	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_10;
  }

  // 9	[379]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 10	[379]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 11	[379]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 12	[380]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 381 - 385
static
CallInfo *magic_implementation_45(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
  }

  // 0	[384]	GETTABUP 	1 0 0	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[384]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[384]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[384]	GETTABUP 	2 0 1	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[384]	GETFIELD 	2 2 2	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0202010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[384]	LOADK    	3 3	; "^lock: "
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[384]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[384]	EQ       	1 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000280b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 8	[384]	JMP      	1	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_10;
  }

  // 9	[384]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 10	[384]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 11	[384]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 12	[385]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 386 - 389
static
CallInfo *magic_implementation_46(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
  }

  // 0	[388]	GETTABUP 	1 0 0	; _ENV "getmetatable"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[388]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[388]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[388]	GETFIELD 	1 1 1	; "__metatable"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[388]	EQK      	1 2 0	; null
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_07
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000200bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 5	[388]	JMP      	1	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_07;
  }

  // 6	[388]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 7	[388]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 8	[388]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 9	[389]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 390 - 394
static
CallInfo *magic_implementation_47(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
  }

  // 0	[393]	GETTABUP 	1 0 0	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[393]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[393]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[393]	GETTABUP 	2 0 1	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[393]	GETFIELD 	2 2 2	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0202010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[393]	LOADK    	3 3	; "^LUABOX: "
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[393]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[393]	EQ       	1 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000280b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 8	[393]	JMP      	1	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_10;
  }

  // 9	[393]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 10	[393]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 11	[393]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 12	[394]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 395 - 398
static
CallInfo *magic_implementation_48(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
  }

  // 0	[397]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 1	[397]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_01: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 2	[398]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 399 - 402
static
CallInfo *magic_implementation_49(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[401]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[401]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[401]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[401]	EQK      	1 1 1	; "thread"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[401]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[401]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[401]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[401]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[402]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 403 - 406
static
CallInfo *magic_implementation_50(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
  }

  // 0	[405]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[405]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[405]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[405]	EQK      	1 1 0	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[405]	JMP      	6	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_11;
  }

  // 5	[405]	GETTABUP 	1 0 2	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[405]	GETFIELD 	1 1 3	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[405]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[405]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[405]	EQ       	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000080b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 10	[405]	JMP      	1	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_12;
  }

  // 11	[405]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 12	[405]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 13	[405]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 14	[406]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 407 - 410
static
CallInfo *magic_implementation_51(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
  }

  // 0	[409]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[409]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[409]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[409]	EQK      	1 1 0	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[409]	JMP      	6	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_11;
  }

  // 5	[409]	GETTABUP 	1 0 2	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[409]	GETFIELD 	1 1 3	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[409]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[409]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[409]	EQ       	1 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000000b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 10	[409]	JMP      	1	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_12;
  }

  // 11	[409]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 12	[409]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 13	[409]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 14	[410]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 411 - 414
static
CallInfo *magic_implementation_52(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
  }

  // 0	[413]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[413]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[413]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[413]	EQK      	1 1 0	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[413]	JMP      	6	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_11;
  }

  // 5	[413]	GETTABUP 	1 0 2	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[413]	GETFIELD 	1 1 3	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[413]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[413]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[413]	EQ       	1 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000000b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 10	[413]	JMP      	1	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_12;
  }

  // 11	[413]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 12	[413]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 13	[413]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 14	[414]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 423 - 435
static
CallInfo *magic_implementation_53(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
  }

  // 0	[425]	LOADK    	1 0	; "^%s*var%s+([^%s]+)%s*:%s*([^%s]+)%s*=%s*([^%s]+)%s*$"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[426]	LOADK    	1 1	; "^%s*var%s+([^%s]+)%s*:%s*([^%s]+)%s*=%s*(.-)%s*$"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[427]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 3	[427]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 4	[428]	SELF     	3 0 2k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[428]	LOADK    	5 3	; "[^\r\n]+"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00018283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[428]	CALL     	3 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x050301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[428]	TFORPREP 	3 20	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000a01cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_28;
  }

  // 8	[429]	SELF     	8 7 4k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x04078414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 9	[429]	MOVE     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00010500);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[429]	CALL     	8 3 4	; 2 in 3 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x04030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 11	[430]	TEST     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_28
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000442);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 12	[430]	JMP      	15	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x80000738);
    updatetrap(ci);
    goto label_28;
  }

  // 13	[430]	TEST     	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_28
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000004c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 14	[430]	JMP      	13	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_28;
  }

  // 15	[430]	TEST     	10 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_28
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000542);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 16	[430]	JMP      	11	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x80000538);
    updatetrap(ci);
    goto label_28;
  }

  // 17	[431]	GETTABUP 	11 0 5	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0500058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 18	[431]	GETFIELD 	11 11 6	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x060b058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[431]	MOVE     	12 2
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00020600);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[431]	NEWTABLE 	13 0 4	; 4
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x04000693);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 21	[431]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 22	[431]	MOVE     	14 8
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00080700);
    setobjs2s(L, ra, RB(i));
  }

  // 23	[431]	MOVE     	15 9
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00090780);
    setobjs2s(L, ra, RB(i));
  }

  // 24	[431]	MOVE     	16 10
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x000a0800);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[431]	MOVE     	17 7
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00070880);
    setobjs2s(L, ra, RB(i));
  }

  // 26	[431]	SETLIST  	13 4 0
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x000406ce);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 27	[431]	CALL     	11 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x010305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 28	[428]	TFORCALL 	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x010001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 29	[428]	TFORLOOP 	3 22	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x000b01cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_08; /* jump back */
    }
  }

  // 30	[433]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 31	[434]	RETURN   	2 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_31: {
    aot_vmfetch(0x00028146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 32	[435]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_32: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 436 - 450
static
CallInfo *magic_implementation_54(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
  }

  // 0	[438]	LOADK    	1 0	; "%s*([^%s]+)%s*:%s*([^%s]+)%s*=%s*([^%s]+)%s*"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[439]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 2	[439]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 3	[440]	SELF     	3 0 1k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x01008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[440]	LOADK    	5 2	; "[^\r\n]+"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[440]	CALL     	3 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x050301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[440]	TFORPREP 	3 26	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000d01cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_33;
  }

  // 7	[441]	SELF     	8 7 3k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x03078414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[441]	MOVE     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010500);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[441]	CALL     	8 3 4	; 2 in 3 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x04030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[442]	TEST     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_33
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000442);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 11	[442]	JMP      	21	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000a38);
    updatetrap(ci);
    goto label_33;
  }

  // 12	[442]	TEST     	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_33
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000004c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 13	[442]	JMP      	19	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x80000938);
    updatetrap(ci);
    goto label_33;
  }

  // 14	[442]	TEST     	10 0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_33
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000542);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 15	[442]	JMP      	17	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000838);
    updatetrap(ci);
    goto label_33;
  }

  // 16	[444]	GETTABUP 	11 0 4	; _ENV "deffind"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0400058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[444]	MOVE     	12 7
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00070600);
    setobjs2s(L, ra, RB(i));
  }

  // 18	[444]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[444]	GETI     	11 11 1
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x010b058d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 20	[444]	TEST     	11 1
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_33
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x000085c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 21	[444]	JMP      	11	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x80000538);
    updatetrap(ci);
    goto label_33;
  }

  // 22	[445]	GETTABUP 	11 0 5	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0500058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 23	[445]	GETFIELD 	11 11 6	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x060b058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 24	[445]	MOVE     	12 2
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00020600);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[445]	NEWTABLE 	13 0 4	; 4
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x04000693);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 26	[445]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 27	[445]	MOVE     	14 8
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00080700);
    setobjs2s(L, ra, RB(i));
  }

  // 28	[445]	MOVE     	15 9
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00090780);
    setobjs2s(L, ra, RB(i));
  }

  // 29	[445]	MOVE     	16 10
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x000a0800);
    setobjs2s(L, ra, RB(i));
  }

  // 30	[445]	MOVE     	17 7
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00070880);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[445]	SETLIST  	13 4 0
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000406ce);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 32	[445]	CALL     	11 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x010305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 33	[440]	TFORCALL 	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x010001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 34	[440]	TFORLOOP 	3 28	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x000e01cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_07; /* jump back */
    }
  }

  // 35	[448]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 36	[449]	RETURN   	2 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_36: {
    aot_vmfetch(0x00028146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 37	[450]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_37: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 451 - 462
static
CallInfo *magic_implementation_55(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
  }

  // 0	[453]	LOADK    	1 0	; "^%s*function%s+([^%s]+)%s*%(([^%s]*)%)%s*$"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[454]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 2	[454]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 3	[455]	SELF     	3 0 1k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x01008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[455]	LOADK    	5 2	; "[^\r\n]+"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[455]	CALL     	3 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x050301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[455]	TFORPREP 	3 17	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000881cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_24;
  }

  // 7	[456]	SELF     	8 7 3k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x03078414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[456]	MOVE     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010500);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[456]	CALL     	8 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x03030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[457]	TEST     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000442);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 11	[457]	JMP      	12	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_24;
  }

  // 12	[457]	TEST     	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000004c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 13	[457]	JMP      	10	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_24;
  }

  // 14	[458]	GETTABUP 	10 0 4	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0400050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 15	[458]	GETFIELD 	10 10 5	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x050a050e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 16	[458]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[458]	NEWTABLE 	12 0 3	; 3
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x03000613);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 18	[458]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 19	[458]	MOVE     	13 8
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00080680);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[458]	MOVE     	14 9
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00090700);
    setobjs2s(L, ra, RB(i));
  }

  // 21	[458]	MOVE     	15 7
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00070780);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[458]	SETLIST  	12 3 0
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0003064e);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 23	[458]	CALL     	10 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x01030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[455]	TFORCALL 	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x010001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 25	[455]	TFORLOOP 	3 19	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x000981cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_07; /* jump back */
    }
  }

  // 26	[460]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 27	[461]	RETURN   	2 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_27: {
    aot_vmfetch(0x00028146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 28	[462]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_28: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 463 - 476
static
CallInfo *magic_implementation_56(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
  }

  // 0	[465]	LOADK    	1 0	; "%s*([^%s]+)%s*=%s*([^%s]+)%s*"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[466]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 2	[466]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 3	[467]	SELF     	3 0 1k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x01008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[467]	LOADK    	5 2	; "[^\r\n]+"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[467]	CALL     	3 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x050301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[467]	TFORPREP 	3 29	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000e81cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_36;
  }

  // 7	[468]	SELF     	8 7 3k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x03078414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[468]	MOVE     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010500);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[468]	CALL     	8 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x03030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[469]	TEST     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_36
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000442);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 11	[469]	JMP      	24	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000bb8);
    updatetrap(ci);
    goto label_36;
  }

  // 12	[469]	TEST     	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_36
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000004c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 13	[469]	JMP      	22	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x80000ab8);
    updatetrap(ci);
    goto label_36;
  }

  // 14	[470]	GETTABUP 	10 0 4	; _ENV "deffind"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0400050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 15	[470]	MOVE     	11 7
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00070580);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[470]	CALL     	10 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x02020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 17	[470]	GETI     	10 10 1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x010a050d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 18	[470]	TEST     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_36
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00008542);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 19	[470]	JMP      	16	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x800007b8);
    updatetrap(ci);
    goto label_36;
  }

  // 20	[470]	GETTABUP 	10 0 5	; _ENV "assign"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0500050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 21	[470]	MOVE     	11 7
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00070580);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[470]	CALL     	10 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x02020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 23	[470]	GETI     	10 10 1
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x010a050d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 24	[470]	TEST     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_36
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00008542);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 25	[470]	JMP      	10	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_36;
  }

  // 26	[471]	GETTABUP 	10 0 6	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x0600050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 27	[471]	GETFIELD 	10 10 7	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x070a050e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 28	[471]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 29	[471]	NEWTABLE 	12 0 3	; 3
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x03000613);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 30	[471]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 31	[471]	MOVE     	13 8
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x00080680);
    setobjs2s(L, ra, RB(i));
  }

  // 32	[471]	MOVE     	14 9
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x00090700);
    setobjs2s(L, ra, RB(i));
  }

  // 33	[471]	MOVE     	15 7
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x00070780);
    setobjs2s(L, ra, RB(i));
  }

  // 34	[471]	SETLIST  	12 3 0
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x0003064e);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 35	[471]	CALL     	10 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x01030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 36	[467]	TFORCALL 	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x010001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 37	[467]	TFORLOOP 	3 31	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x000f81cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_07; /* jump back */
    }
  }

  // 38	[474]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 39	[475]	RETURN   	2 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_39: {
    aot_vmfetch(0x00028146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 40	[476]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_40: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 477 - 488
static
CallInfo *magic_implementation_57(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
  }

  // 0	[479]	LOADK    	1 0	; "%s*=%s*"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[480]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 2	[480]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 3	[481]	SELF     	3 0 1k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x01008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[481]	LOADK    	5 2	; "[^\r\n]+"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[481]	CALL     	3 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x050301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[481]	TFORPREP 	3 17	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000881cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_24;
  }

  // 7	[482]	SELF     	8 7 3k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x03078414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[482]	MOVE     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010500);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[482]	CALL     	8 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x03030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[483]	TEST     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000442);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 11	[483]	JMP      	12	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_24;
  }

  // 12	[483]	TEST     	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000004c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 13	[483]	JMP      	10	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_24;
  }

  // 14	[484]	GETTABUP 	10 0 4	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0400050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 15	[484]	GETFIELD 	10 10 5	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x050a050e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 16	[484]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[484]	NEWTABLE 	12 0 3	; 3
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x03000613);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 18	[484]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 19	[484]	MOVE     	13 8
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00080680);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[484]	MOVE     	14 9
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00090700);
    setobjs2s(L, ra, RB(i));
  }

  // 21	[484]	MOVE     	15 7
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00070780);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[484]	SETLIST  	12 3 0
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0003064e);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 23	[484]	CALL     	10 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x01030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[481]	TFORCALL 	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x010001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 25	[481]	TFORLOOP 	3 19	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x000981cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_07; /* jump back */
    }
  }

  // 26	[486]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 27	[487]	RETURN   	2 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_27: {
    aot_vmfetch(0x00028146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 28	[488]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_28: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 489 - 514
static
CallInfo *magic_implementation_58(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
  }

  // 0	[490]	GETTABUP 	1 0 0	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[490]	GETTABUP 	2 0 1	; _ENV "dead"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[490]	CALL     	1 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x050200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[490]	TFORPREP 	1 48	; to 53
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x001800cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_52;
  }

  // 4	[491]	LOADK    	7 2	; "'DEADVALUESTRTYPECHECK-"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[491]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 6	[491]	LOADK    	9 3	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[491]	CONCAT   	7 3
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000303b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 8	[496]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 9	[497]	LOADK    	9 4	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00020483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 10	[498]	LOADI    	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80000501);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 11	[498]	LEN      	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000005b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 12	[498]	LOADI    	12 1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x80000601);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 13	[498]	FORPREP  	10 37	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0012854a);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_52; /* skip the loop */
  }

  // 14	[499]	SELF     	14 0 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x05008714);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[499]	MOVE     	16 13
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000d0800);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[499]	MOVE     	17 13
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x000d0880);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[499]	CALL     	14 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x02040744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[500]	SELF     	15 7 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x05078794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[500]	MOVE     	17 8
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00080880);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[500]	MOVE     	18 8
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00080900);
    setobjs2s(L, ra, RB(i));
  }

  // 21	[500]	CALL     	15 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x020407c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 22	[500]	EQ       	14 15 0
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_49
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000f0739);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 23	[500]	JMP      	25	; to 50
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x80000c38);
    updatetrap(ci);
    goto label_49;
  }

  // 24	[501]	MOVE     	15 8
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00080780);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[501]	ADDI     	8 8 1
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80080415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 26	[501]	MMBINI   	8 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x0680042f);
    Instruction pi = 0x80080415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 27	[502]	MOVE     	15 9
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00090780);
    setobjs2s(L, ra, RB(i));
  }

  // 28	[502]	MOVE     	16 14
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x000e0800);
    setobjs2s(L, ra, RB(i));
  }

  // 29	[502]	CONCAT   	15 2
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x000207b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 30	[502]	MOVE     	9 15
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x000f0480);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[503]	EQ       	9 7 0
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000704b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 32	[503]	JMP      	18	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x800008b8);
    updatetrap(ci);
    goto label_51;
  }

  // 33	[504]	SELF     	15 0 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x05008794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 34	[504]	LOADI    	17 1
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x80000881);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 35	[504]	LEN      	18 7
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x00070934);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 36	[504]	SUB      	18 13 18
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x120d0923);
    op_arith(L, l_subi, luai_numsub);
  }

  // 37	[504]	MMBIN    	13 18 7	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x071206ae);
    Instruction pi = 0x120d0923; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 38	[504]	CALL     	15 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x020407c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 39	[504]	MOVE     	16 6
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00060800);
    setobjs2s(L, ra, RB(i));
  }

  // 40	[504]	SELF     	17 0 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x05008894);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 41	[504]	ADDI     	19 13 1
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x800d0995);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 42	[504]	MMBINI   	13 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x068006af);
    Instruction pi = 0x800d0995;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 43	[504]	LEN      	20 0
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x00000a34);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 44	[504]	CALL     	17 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x020408c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 45	[504]	CONCAT   	15 3
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000307b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 46	[504]	MOVE     	0 15
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_52
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x000f0000);
    setobjs2s(L, ra, RB(i));
  }

  // 47	[505]	JMP      	4	; to 53
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_52;
  }

  // 48	[507]	JMP      	2	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_51;
  }

  // 49	[508]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 50	[509]	LOADK    	9 4	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x00020483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 51	[498]	FORLOOP  	10 38	; to 15
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00130549);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_14; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_14; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 52	[490]	TFORCALL 	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x020000cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 53	[490]	TFORLOOP 	1 50	; to 5
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x001900cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_04; /* jump back */
    }
  }

  // 54	[512]	CLOSE    	1
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x000000b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 55	[513]	RETURN   	0 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_55: {
    aot_vmfetch(0x00028046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 56	[514]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_56: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 515 - 536
static
CallInfo *magic_implementation_59(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
  }

  // 0	[518]	NEWTABLE 	1 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000093);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 1	[518]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 2	[519]	LOADI    	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x7fff8101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 3	[520]	SETTABUP 	0 0 0	; _ENV "ogstr"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0000000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 4	[521]	GETFIELD 	3 0 1	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[521]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 6	[521]	JMP      	3	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_10;
  }

  // 7	[521]	GETTABUP 	3 0 2	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0200018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[521]	LOADK    	4 3	; "string.gsub is not a found function, Are you sure you provided a string?"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00018203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[521]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[522]	SELF     	3 0 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x01008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[522]	LOADK    	5 4	; "'[^']-'"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00020283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 12	[526]	CLOSURE  	6 0	; 0x7ff6dba0dcc0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0000034f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 13	[522]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[526]	SELF     	3 3 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x01038194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[526]	LOADK    	5 5	; "\"[^\"]-\""
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00028283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 16	[530]	CLOSURE  	6 1	; 0x7ff6dba0de10
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0000834f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 17	[522]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[530]	SELF     	3 3 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x01038194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[530]	LOADK    	5 6	; "%[%[.-%]%]"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00030283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 20	[534]	CLOSURE  	6 2	; 0x7ff6dba0e020
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0001034f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 21	[522]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 22	[534]	MOVE     	0 3
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00030000);
    setobjs2s(L, ra, RB(i));
  }

  // 23	[535]	SELF     	3 0 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x01008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 24	[535]	LOADK    	5 7	; "//.-\n"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00038283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 25	[535]	LOADK    	6 8	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00040303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 26	[535]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 27	[535]	SELF     	3 3 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x01038194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 28	[535]	LOADK    	5 9	; "/%*.-%*/"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00048283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 29	[535]	LOADK    	6 8	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00040303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 30	[535]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 31	[535]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 32	[535]	RETURN   	3 3 0	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_32: {
    aot_vmfetch(0x000381c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 33	[536]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_33: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 522 - 526
static
CallInfo *magic_implementation_60(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
  }

  // 0	[523]	GETUPVAL 	1 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[523]	GETUPVAL 	3 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 2	[523]	ADDI     	3 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80030195);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 3	[523]	MMBINI   	3 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x068001af);
    Instruction pi = 0x80030195;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 4	[523]	SETUPVAL 	3 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0000018a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 5	[524]	GETUPVAL 	2 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[524]	GETUPVAL 	1 1	; dead
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[524]	SETTABLE 	1 2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00020090);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 8	[525]	LOADK    	1 0	; "'DEADVALUESTRTYPECHECK-"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[525]	GETUPVAL 	2 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 10	[525]	LOADK    	3 1	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00008183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[525]	CONCAT   	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000300b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 12	[525]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 13	[526]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 526 - 530
static
CallInfo *magic_implementation_61(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
  }

  // 0	[527]	GETUPVAL 	1 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[527]	GETUPVAL 	3 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 2	[527]	ADDI     	3 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80030195);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 3	[527]	MMBINI   	3 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x068001af);
    Instruction pi = 0x80030195;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 4	[527]	SETUPVAL 	3 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0000018a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 5	[528]	GETUPVAL 	2 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[528]	GETUPVAL 	1 1	; dead
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[528]	SETTABLE 	1 2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00020090);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 8	[529]	LOADK    	1 0	; "'DEADVALUESTRTYPECHECK-"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[529]	GETUPVAL 	2 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 10	[529]	LOADK    	3 1	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00008183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[529]	CONCAT   	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000300b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 12	[529]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 13	[530]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 530 - 534
static
CallInfo *magic_implementation_62(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
  }

  // 0	[531]	GETUPVAL 	1 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[531]	GETUPVAL 	3 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 2	[531]	ADDI     	3 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80030195);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 3	[531]	MMBINI   	3 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x068001af);
    Instruction pi = 0x80030195;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 4	[531]	SETUPVAL 	3 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0000018a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 5	[532]	GETUPVAL 	2 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[532]	GETUPVAL 	1 1	; dead
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[532]	SETTABLE 	1 2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00020090);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 8	[533]	LOADK    	1 0	; "'DEADVALUESTRTYPECHECK-"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[533]	GETUPVAL 	2 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 10	[533]	LOADK    	3 1	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00008183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[533]	CONCAT   	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000300b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 12	[533]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 13	[534]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 540 - 561
static
CallInfo *magic_implementation_63(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
  }

  // 0	[541]	GETTABUP 	5 0 1	; _ENV "loadenv"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0100028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[541]	MOVE     	6 3
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00030300);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[541]	LOADK    	7 2	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 3	[541]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 4	[541]	CONCAT   	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000203b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 5	[541]	CALL     	5 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x030302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[541]	SETTABUP 	0 0 6	; _ENV "err"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0600000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 7	[541]	MOVE     	1 5
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00050080);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[542]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_16
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 9	[542]	JMP      	6	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_16;
  }

  // 10	[543]	GETTABUP 	5 0 3	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0300028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 11	[543]	LOADK    	6 4	; "Check error: "
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00020303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 12	[543]	GETTABUP 	7 0 0	; _ENV "err"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0000038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[543]	CONCAT   	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00020335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 14	[543]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 15	[543]	CALL     	5 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x010302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[545]	GETTABUP 	5 0 5	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0500028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[547]	CLOSURE  	6 0	; 0x7ff6dba0e580
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0000034f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 18	[550]	CLOSURE  	7 1	; 0x7ff6dba0e610
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x000083cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 19	[545]	CALL     	5 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x010302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[551]	GETTABUP 	5 0 6	; _ENV "types"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0600028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 21	[551]	GETTABLE 	5 5 0
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0005028c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 22	[551]	TEST     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_60
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000002c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 23	[551]	JMP      	36	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x800011b8);
    updatetrap(ci);
    goto label_60;
  }

  // 24	[552]	GETTABUP 	5 0 6	; _ENV "types"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0600028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 25	[552]	GETTABLE 	5 5 0
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x0005028c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 26	[552]	MOVE     	6 1
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00010300);
    setobjs2s(L, ra, RB(i));
  }

  // 27	[552]	CALL     	5 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x020202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 28	[552]	TEST     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_33
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x000002c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 29	[552]	JMP      	3	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_33;
  }

  // 30	[553]	LOADTRUE 	5
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00000287);
    setbtvalue(s2v(ra));
  }

  // 31	[553]	RETURN   	5 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_72
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000282c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 32	[554]	JMP      	39	; to 73
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x80001338);
    updatetrap(ci);
    goto label_72;
  }

  // 33	[555]	GETTABUP 	5 0 7	; _ENV "typeof"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x0700028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 34	[555]	MOVE     	6 1
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00010300);
    setobjs2s(L, ra, RB(i));
  }

  // 35	[555]	CALL     	5 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x020202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 36	[555]	EQK      	5 8 0	; "function"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_40
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x000802bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 37	[555]	JMP      	2	; to 41
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_40;
  }

  // 38	[555]	LOADTRUE 	5
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00000287);
    setbtvalue(s2v(ra));
  }

  // 39	[555]	RETURN   	5 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x000282c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 40	[556]	GETTABUP 	5 0 3	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x0300028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 41	[556]	GETTABUP 	6 0 9	; _ENV "core"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x0900030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 42	[556]	GETFIELD 	6 6 10	; "error"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0a06030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 43	[556]	GETFIELD 	6 6 11	; "strerror"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0b06030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 44	[556]	LOADI    	7 111
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x80370381);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 45	[556]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 46	[556]	SELF     	6 6 12k	; "format"
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x0c068314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 47	[556]	MOVE     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00000400);
    setobjs2s(L, ra, RB(i));
  }

  // 48	[556]	GETTABUP 	9 0 13	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x0d00048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 49	[556]	GETTABUP 	10 0 7	; _ENV "typeof"
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x0700050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 50	[556]	MOVE     	11 1
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x00010580);
    setobjs2s(L, ra, RB(i));
  }

  // 51	[556]	CALL     	10 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 52	[556]	CALL     	9 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x020004c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 53	[556]	LOADK    	10 14	; " (and it's descendents)"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00070503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 54	[556]	CONCAT   	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x000204b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 55	[556]	MOVE     	10 2
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x00020500);
    setobjs2s(L, ra, RB(i));
  }

  // 56	[556]	CALL     	6 5 2	; 4 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x02050344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 57	[556]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 58	[556]	CALL     	5 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_72
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x010302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 59	[558]	JMP      	12	; to 73
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_72;
  }

  // 60	[559]	GETTABUP 	5 0 3	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x0300028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 61	[559]	GETTABUP 	6 0 9	; _ENV "core"
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x0900030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 62	[559]	GETFIELD 	6 6 10	; "error"
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x0a06030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 63	[559]	GETFIELD 	6 6 11	; "strerror"
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x0b06030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 64	[559]	LOADI    	7 112
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x80378381);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 65	[559]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 66	[559]	SELF     	6 6 12k	; "format"
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x0c068314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 67	[559]	MOVE     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x00000400);
    setobjs2s(L, ra, RB(i));
  }

  // 68	[559]	CALL     	6 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x02030344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 69	[559]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 70	[559]	LOADK    	8 15	; "Use `cobaltpre -types` to see all types"
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x00078403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 71	[559]	CALL     	5 4 1	; 3 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_71: {
    aot_vmfetch(0x010402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 72	[561]	RETURN   	5 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_72: {
    aot_vmfetch(0x000182c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 545 - 547
static
CallInfo *magic_implementation_64(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[546]	GETUPVAL 	0 0	; value
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[546]	CALL     	0 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x02010044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 2	[546]	SETUPVAL 	0 0	; value
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x0000000a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 3	[547]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 547 - 550
static
CallInfo *magic_implementation_65(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
  }

  // 0	[549]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 1	[549]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_01: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 2	[550]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 564 - 603
static
CallInfo *magic_implementation_66(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
    case 132: goto label_132;
    case 133: goto label_133;
  }

  // 0	[565]	GETTABUP 	1 0 2	; _ENV "clean"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[565]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[565]	CALL     	1 2 3	; 1 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x030200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[565]	SETTABUP 	0 1 2	; _ENV "newdead"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0201000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 4	[565]	SETTABUP 	0 0 1	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 5	[566]	GETTABUP 	1 0 1	; _ENV "newdead"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0100008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[566]	SETTABUP 	0 3 1	; _ENV "dead"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0103000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 7	[567]	GETTABUP 	1 0 4	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0400008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[567]	GETTABUP 	2 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 9	[567]	SELF     	2 2 5k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x05028114);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 10	[567]	LOADK    	4 6	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00030203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[567]	CALL     	2 3 0	; 2 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00030144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[567]	CALL     	1 0 5	; all in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x050000c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 13	[567]	TFORPREP 	1 114	; to 129
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x003900cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_128;
  }

  // 14	[568]	GETTABUP 	7 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0000038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 15	[568]	SELF     	7 7 5k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x05078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 16	[568]	LOADK    	9 6	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00030483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 17	[568]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[568]	GETTABLE 	7 7 5
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0507038c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[568]	TEST     	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000083c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 20	[568]	JMP      	1	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_22;
  }

  // 21	[568]	LOADK    	7 7	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00038383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 22	[568]	SETTABUP 	0 0 7	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0700000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 23	[569]	GETTABUP 	7 0 8	; _ENV "deffind"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x0800038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 24	[569]	GETTABUP 	8 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0000040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 25	[569]	CALL     	7 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x020203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 26	[570]	GETTABUP 	8 0 9	; _ENV "assign"
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x0900040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 27	[570]	GETTABUP 	9 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0000048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 28	[570]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 29	[571]	GETTABUP 	9 0 10	; _ENV "allassign"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0a00048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 30	[571]	GETTABUP 	10 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x0000050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 31	[571]	CALL     	9 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x020204c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[572]	GETTABUP 	10 0 11	; _ENV "findfunctions"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x0b00050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 33	[572]	GETTABUP 	11 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x0000058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 34	[572]	CALL     	10 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x02020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 35	[573]	GETTABUP 	11 0 12	; _ENV "findall"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x0c00058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 36	[573]	GETTABUP 	12 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x0000060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 37	[573]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 38	[575]	NEWTABLE 	12 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00000613);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 39	[575]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 40	[576]	NEWTABLE 	13 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00000693);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 41	[576]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 42	[577]	GETTABUP 	14 0 4	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0400070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[577]	MOVE     	15 7
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x00070780);
    setobjs2s(L, ra, RB(i));
  }

  // 44	[577]	CALL     	14 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x05020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 45	[577]	TFORPREP 	14 31	; to 78
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000f874b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_77;
  }

  // 46	[578]	GETTABUP 	20 0 13	; _ENV "check"
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x0d000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 47	[578]	GETI     	21 19 2
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x02130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 48	[578]	GETI     	22 19 3
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x03130b0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 49	[578]	GETI     	23 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x01130b8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 50	[578]	MOVE     	24 13
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x000d0c00);
    setobjs2s(L, ra, RB(i));
  }

  // 51	[578]	GETI     	25 19 4
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x04130c8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 52	[578]	CALL     	20 6 1	; 5 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x01060a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 53	[579]	GETTABUP 	20 0 16	; _ENV "loadenv"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x10000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 54	[579]	MOVE     	21 13
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x000d0a80);
    setobjs2s(L, ra, RB(i));
  }

  // 55	[579]	LOADK    	22 17	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x00088b03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 56	[579]	GETI     	23 19 3
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x03130b8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 57	[579]	CONCAT   	22 2
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00020b35);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 58	[579]	CALL     	20 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x03030a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 59	[579]	SETTABUP 	0 15 21	; _ENV "err"
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x150f000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 60	[579]	SETTABUP 	0 14 20	; _ENV "value"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x140e000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 61	[580]	GETTABUP 	20 0 14	; _ENV "value"
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x0e000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 62	[580]	TEST     	20 1
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_69
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x00008a42);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 63	[580]	JMP      	5	; to 70
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_69;
  }

  // 64	[581]	GETTABUP 	20 0 18	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x12000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 65	[581]	LOADK    	21 19	; "Check error: "
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x00098a83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 66	[581]	GETTABUP 	22 0 15	; _ENV "err"
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x0f000b0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 67	[581]	CONCAT   	21 2
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x00020ab5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 68	[581]	CALL     	20 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x01020a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 69	[583]	GETI     	20 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x01130a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 70	[583]	GETI     	21 19 2
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x02130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 71	[583]	SETTABLE 	12 20 21
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x15140610);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 72	[584]	GETTABUP 	20 0 20	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x14000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 73	[586]	CLOSURE  	21 0	; 0x7ff6dba0eec0
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x00000acf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 74	[586]	CLOSURE  	22 1	; 0x7ff6dba0f3c0
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x00008b4f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 75	[584]	CALL     	20 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x01030a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 76	[588]	CLOSE    	18
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x00000936);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 77	[577]	TFORCALL 	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x0200074c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 78	[577]	TFORLOOP 	14 33	; to 47
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x0010874d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_46; /* jump back */
    }
  }

  // 79	[588]	CLOSE    	14
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x00000736);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 80	[589]	GETTABUP 	14 0 4	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x0400070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 81	[589]	MOVE     	15 9
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x00090780);
    setobjs2s(L, ra, RB(i));
  }

  // 82	[589]	CALL     	14 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x05020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 83	[589]	TFORPREP 	14 20	; to 105
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x000a074b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_104;
  }

  // 84	[590]	GETI     	20 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x01130a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 85	[590]	GETTABLE 	20 12 20
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x140c0a0c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 86	[590]	TEST     	20 0
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_97
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x00000a42);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 87	[590]	JMP      	9	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_97;
  }

  // 88	[591]	GETTABUP 	20 0 13	; _ENV "check"
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x0d000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 89	[591]	GETI     	21 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x01130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 90	[591]	GETTABLE 	21 12 21
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x150c0a8c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 91	[591]	GETI     	22 19 2
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x02130b0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 92	[591]	GETI     	23 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x01130b8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 93	[591]	MOVE     	24 13
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x000d0c00);
    setobjs2s(L, ra, RB(i));
  }

  // 94	[591]	GETI     	25 19 3
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x03130c8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 95	[591]	CALL     	20 6 1	; 5 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_104
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x01060a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 96	[592]	JMP      	7	; to 105
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_104;
  }

  // 97	[592]	GETI     	20 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x01130a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 98	[592]	GETTABLE 	20 13 20
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x140d0a0c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 99	[592]	TEST     	20 1
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_104
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x00008a42);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 100	[592]	JMP      	3	; to 105
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_104;
  }

  // 101	[593]	GETI     	20 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x01130a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 102	[593]	GETI     	21 19 2
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x02130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 103	[593]	SETTABLE 	13 20 21
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x15140690);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 104	[589]	TFORCALL 	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x0200074c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 105	[589]	TFORLOOP 	14 22	; to 85
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x000b074d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_84; /* jump back */
    }
  }

  // 106	[595]	CLOSE    	14
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x00000736);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 107	[596]	GETTABUP 	14 0 4	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x0400070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 108	[596]	MOVE     	15 8
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x00080780);
    setobjs2s(L, ra, RB(i));
  }

  // 109	[596]	CALL     	14 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x05020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 110	[596]	TFORPREP 	14 13	; to 125
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x0006874b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_124;
  }

  // 111	[597]	GETTABUP 	20 0 13	; _ENV "check"
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x0d000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 112	[597]	GETI     	21 19 2
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x02130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 113	[597]	GETI     	22 19 3
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x03130b0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 114	[597]	GETI     	23 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x01130b8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 115	[597]	MOVE     	24 13
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x000d0c00);
    setobjs2s(L, ra, RB(i));
  }

  // 116	[597]	GETI     	25 19 4
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x04130c8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 117	[597]	CALL     	20 6 1	; 5 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x01060a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 118	[598]	GETI     	20 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x01130a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 119	[598]	GETI     	21 19 3
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x03130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 120	[598]	SETTABLE 	13 20 21
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x15140690);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 121	[599]	GETI     	20 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x01130a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 122	[599]	GETI     	21 19 2
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x02130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 123	[599]	SETTABLE 	12 20 21
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x15140610);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 124	[596]	TFORCALL 	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x0200074c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 125	[596]	TFORLOOP 	14 15	; to 112
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x0007874d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_111; /* jump back */
    }
  }

  // 126	[600]	CLOSE    	14
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x00000736);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 127	[601]	CLOSE    	7
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x000003b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 128	[567]	TFORCALL 	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x020000cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 129	[567]	TFORLOOP 	1 116	; to 15
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x003a00cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_14; /* jump back */
    }
  }

  // 130	[601]	CLOSE    	1
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_132
  label_130: {
    aot_vmfetch(0x000000b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 131	[602]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_133
  label_131: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 132	[602]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 133)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_132: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 133	[603]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 134)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_133: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 584 - 586
static
CallInfo *magic_implementation_67(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
  }

  // 0	[585]	GETUPVAL 	0 1	; def
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00010009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[585]	GETI     	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0100008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[585]	GETUPVAL 	0 0	; knownValues
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[585]	GETTABUP 	2 2 0	; _ENV "value"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0002010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[585]	CALL     	2 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02010144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[585]	SETTABLE 	0 1 2
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_05: {
    aot_vmfetch(0x02010010);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 6	[586]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 586 - 586
static
CallInfo *magic_implementation_68(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
  }

  // 0	[586]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_00: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 604 - 610
static
CallInfo *magic_implementation_69(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
  }

  // 0	[606]	GETTABUP 	0 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[606]	LOADK    	1 1	; "All valid checkable types:"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[606]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[607]	GETTABUP 	0 0 2	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0200000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[607]	GETTABUP 	1 0 3	; _ENV "alltypes"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0300008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 5	[607]	CALL     	0 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x05020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[607]	TFORPREP 	0 5	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0002804b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_12;
  }

  // 7	[608]	GETTABUP 	6 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0000030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[608]	LOADK    	7 4	; "  "
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00020383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[608]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[608]	CONCAT   	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000203b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 11	[608]	CALL     	6 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x01020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[607]	TFORCALL 	0 2
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0200004c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 13	[607]	TFORLOOP 	0 7	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0003804d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_07; /* jump back */
    }
  }

  // 14	[609]	CLOSE    	0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x00000036);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 15	[610]	RETURN   	0 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x00018046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 643 - 658
static
CallInfo *magic_implementation_70(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
  }

  // 0	[645]	LOADK    	3 0	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[646]	LEN      	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00010234);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 2	[647]	LOADI    	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000281);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 3	[648]	LEN      	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000334);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 4	[648]	LE       	5 6 0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_32
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000602bb);
    op_order(L, l_lei, LEnum, lessequalothers);
  }

  // 5	[648]	JMP      	26	; to 33
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000cb8);
    updatetrap(ci);
    goto label_32;
  }

  // 6	[649]	SELF     	6 0 1k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x01008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[649]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[649]	ADD      	9 5 4
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x040504a2);
    op_arith(L, l_addi, luai_numadd);
  }

  // 9	[649]	MMBIN    	5 4 6	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x060402ae);
    Instruction pi = 0x040504a2; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 10	[649]	ADDI     	9 9 -1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x7e090495);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 11	[649]	MMBINI   	9 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x078004af);
    Instruction pi = 0x7e090495;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 12	[649]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 13	[649]	EQ       	6 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00010339);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 14	[649]	JMP      	7	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_22;
  }

  // 15	[650]	MOVE     	6 3
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00030300);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[650]	MOVE     	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00020380);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[650]	CONCAT   	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00020335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 18	[650]	MOVE     	3 6
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00060180);
    setobjs2s(L, ra, RB(i));
  }

  // 19	[651]	ADD      	5 5 4
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x040502a2);
    op_arith(L, l_addi, luai_numadd);
  }

  // 20	[651]	MMBIN    	5 4 6	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_03
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x060402ae);
    Instruction pi = 0x040502a2; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 21	[652]	JMP      	-19	; to 4
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x7ffff638);
    updatetrap(ci);
    goto label_03;
  }

  // 22	[653]	MOVE     	6 3
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00030300);
    setobjs2s(L, ra, RB(i));
  }

  // 23	[653]	SELF     	7 0 1k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x01008394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 24	[653]	MOVE     	9 5
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00050480);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[653]	MOVE     	10 5
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00050500);
    setobjs2s(L, ra, RB(i));
  }

  // 26	[653]	CALL     	7 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x020403c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 27	[653]	CONCAT   	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00020335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 28	[653]	MOVE     	3 6
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00060180);
    setobjs2s(L, ra, RB(i));
  }

  // 29	[654]	ADDI     	5 5 1
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x80050295);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 30	[654]	MMBINI   	5 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_03
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x068002af);
    Instruction pi = 0x80050295;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 31	[656]	JMP      	-29	; to 4
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x7ffff138);
    updatetrap(ci);
    goto label_03;
  }

  // 32	[657]	RETURN1  	3
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_32: {
    aot_vmfetch(0x000201c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 33	[658]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_33: {
    aot_vmfetch(0x00010347);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 660 - 671
static
CallInfo *magic_implementation_71(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
  }

  // 0	[661]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_03
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 1	[661]	JMP      	1	; to 4
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_03;
  }

  // 2	[661]	LOADI    	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 3	[662]	LEN      	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000101b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 4	[663]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 5	[664]	LEN      	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000002b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 6	[664]	LE       	4 5 0
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_26
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0005023b);
    op_order(L, l_lei, LEnum, lessequalothers);
  }

  // 7	[664]	JMP      	18	; to 27
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x800008b8);
    updatetrap(ci);
    goto label_26;
  }

  // 8	[665]	SELF     	5 0 0k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 9	[665]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[665]	ADD      	8 4 3
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x03040422);
    op_arith(L, l_addi, luai_numadd);
  }

  // 11	[665]	MMBIN    	4 3 6	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0603022e);
    Instruction pi = 0x03040422; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 12	[665]	ADDI     	8 8 -1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x7e080415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 13	[665]	MMBINI   	8 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0780042f);
    Instruction pi = 0x7e080415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 14	[665]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 15	[665]	EQ       	5 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000102b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 16	[665]	JMP      	6	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_23;
  }

  // 17	[666]	MOVE     	5 4
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00040280);
    setobjs2s(L, ra, RB(i));
  }

  // 18	[666]	ADD      	6 4 3
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x03040322);
    op_arith(L, l_addi, luai_numadd);
  }

  // 19	[666]	MMBIN    	4 3 6	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0603022e);
    Instruction pi = 0x03040322; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 20	[666]	ADDI     	6 6 -1
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x7e060315);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 21	[666]	MMBINI   	6 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0780032f);
    Instruction pi = 0x7e060315;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 22	[666]	RETURN   	5 3 0	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000302c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 23	[668]	ADDI     	4 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x80040215);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 24	[668]	MMBINI   	4 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_05
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0680022f);
    Instruction pi = 0x80040215;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 25	[669]	JMP      	-21	; to 6
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x7ffff538);
    updatetrap(ci);
    goto label_05;
  }

  // 26	[670]	LOADNIL  	5 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00000288);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 27	[670]	RETURN1  	5
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_27: {
    aot_vmfetch(0x000202c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 28	[671]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_28: {
    aot_vmfetch(0x000102c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 673 - 768
static
CallInfo *magic_implementation_72(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
    case 132: goto label_132;
    case 133: goto label_133;
    case 134: goto label_134;
    case 135: goto label_135;
    case 136: goto label_136;
    case 137: goto label_137;
    case 138: goto label_138;
    case 139: goto label_139;
    case 140: goto label_140;
    case 141: goto label_141;
    case 142: goto label_142;
    case 143: goto label_143;
    case 144: goto label_144;
    case 145: goto label_145;
    case 146: goto label_146;
    case 147: goto label_147;
    case 148: goto label_148;
    case 149: goto label_149;
    case 150: goto label_150;
    case 151: goto label_151;
    case 152: goto label_152;
    case 153: goto label_153;
    case 154: goto label_154;
    case 155: goto label_155;
    case 156: goto label_156;
    case 157: goto label_157;
    case 158: goto label_158;
    case 159: goto label_159;
    case 160: goto label_160;
    case 161: goto label_161;
    case 162: goto label_162;
    case 163: goto label_163;
    case 164: goto label_164;
    case 165: goto label_165;
    case 166: goto label_166;
    case 167: goto label_167;
    case 168: goto label_168;
    case 169: goto label_169;
    case 170: goto label_170;
    case 171: goto label_171;
    case 172: goto label_172;
    case 173: goto label_173;
    case 174: goto label_174;
    case 175: goto label_175;
    case 176: goto label_176;
    case 177: goto label_177;
    case 178: goto label_178;
    case 179: goto label_179;
    case 180: goto label_180;
    case 181: goto label_181;
    case 182: goto label_182;
    case 183: goto label_183;
    case 184: goto label_184;
    case 185: goto label_185;
    case 186: goto label_186;
    case 187: goto label_187;
    case 188: goto label_188;
    case 189: goto label_189;
    case 190: goto label_190;
    case 191: goto label_191;
    case 192: goto label_192;
    case 193: goto label_193;
    case 194: goto label_194;
    case 195: goto label_195;
    case 196: goto label_196;
    case 197: goto label_197;
    case 198: goto label_198;
    case 199: goto label_199;
    case 200: goto label_200;
    case 201: goto label_201;
    case 202: goto label_202;
    case 203: goto label_203;
    case 204: goto label_204;
    case 205: goto label_205;
    case 206: goto label_206;
    case 207: goto label_207;
    case 208: goto label_208;
    case 209: goto label_209;
    case 210: goto label_210;
    case 211: goto label_211;
    case 212: goto label_212;
    case 213: goto label_213;
    case 214: goto label_214;
    case 215: goto label_215;
    case 216: goto label_216;
    case 217: goto label_217;
    case 218: goto label_218;
    case 219: goto label_219;
    case 220: goto label_220;
    case 221: goto label_221;
    case 222: goto label_222;
    case 223: goto label_223;
    case 224: goto label_224;
    case 225: goto label_225;
    case 226: goto label_226;
    case 227: goto label_227;
    case 228: goto label_228;
    case 229: goto label_229;
    case 230: goto label_230;
    case 231: goto label_231;
    case 232: goto label_232;
    case 233: goto label_233;
    case 234: goto label_234;
    case 235: goto label_235;
    case 236: goto label_236;
    case 237: goto label_237;
    case 238: goto label_238;
    case 239: goto label_239;
    case 240: goto label_240;
    case 241: goto label_241;
    case 242: goto label_242;
    case 243: goto label_243;
    case 244: goto label_244;
    case 245: goto label_245;
    case 246: goto label_246;
    case 247: goto label_247;
    case 248: goto label_248;
    case 249: goto label_249;
    case 250: goto label_250;
    case 251: goto label_251;
    case 252: goto label_252;
    case 253: goto label_253;
    case 254: goto label_254;
    case 255: goto label_255;
    case 256: goto label_256;
    case 257: goto label_257;
    case 258: goto label_258;
    case 259: goto label_259;
    case 260: goto label_260;
    case 261: goto label_261;
    case 262: goto label_262;
    case 263: goto label_263;
    case 264: goto label_264;
    case 265: goto label_265;
    case 266: goto label_266;
    case 267: goto label_267;
    case 268: goto label_268;
    case 269: goto label_269;
    case 270: goto label_270;
  }

  // 0	[674]	GETTABUP 	1 0 2	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[674]	GETFIELD 	1 1 3	; "clean"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[674]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[674]	CALL     	1 2 3	; 1 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x030200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[674]	SETTABUP 	0 1 2	; _ENV "dead"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0201000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 5	[674]	SETTABUP 	0 0 1	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0100000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 6	[676]	GETTABUP 	1 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[676]	SELF     	1 1 5k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x05018094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[676]	LOADK    	3 6	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00030183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[676]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[676]	SETTABUP 	0 4 1	; _ENV "lines"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0104000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 11	[679]	GETTABUP 	1 0 7	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0700008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[679]	GETTABUP 	2 0 4	; _ENV "lines"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[679]	CALL     	1 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x050200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[679]	TFORPREP 	1 246	; to 262
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x007b00cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_261;
  }

  // 15	[680]	GETTABUP 	7 0 2	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x0200038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 16	[680]	GETFIELD 	7 7 9	; "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0907038e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 17	[680]	MOVE     	8 6
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00060400);
    setobjs2s(L, ra, RB(i));
  }

  // 18	[680]	GETTABUP 	9 0 1	; _ENV "dead"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0100048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 19	[680]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[680]	SETTABUP 	0 8 7	; _ENV "vclean"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0708000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 21	[682]	LOADK    	7 10	; "var%s+([^%s]+)%s+<pre>%s*=%s*(.-)%s*$"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00050383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 22	[683]	GETTABUP 	8 0 8	; _ENV "vclean"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0800040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 23	[683]	SELF     	8 8 11k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x0b088414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 24	[683]	MOVE     	10 7
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00070500);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[683]	CALL     	8 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x05030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 26	[683]	TFORPREP 	8 70	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x0023044b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_97;
  }

  // 27	[684]	SETTABUP 	0 12 13k	; _ENV "newval" ""
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0d0c800f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 28	[685]	GETTABUP 	14 0 14	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x0e00070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 29	[687]	CLOSURE  	15 0	; 0x7ff6dba0fec0
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x000007cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 30	[689]	CLOSURE  	16 1	; 0x7ff6dba0fff0
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x0000884f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 31	[685]	CALL     	14 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x01030744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[692]	GETTABUP 	14 0 15	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x0f00070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 33	[692]	GETTABUP 	15 0 16	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x1000078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 34	[692]	CALL     	14 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x02020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 35	[692]	EQK      	14 17 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x0011073c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 36	[692]	JMP      	5	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_42;
  }

  // 37	[692]	LOADK    	14 18	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00090703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 38	[692]	GETTABUP 	15 0 16	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x1000078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 39	[692]	LOADK    	16 18	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00090803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 40	[692]	CONCAT   	14 3
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00030735);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 41	[692]	SETTABUP 	0 16 14	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x0e10000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 42	[693]	GETTABUP 	14 0 15	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0f00070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[693]	GETTABUP 	15 0 16	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x1000078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 44	[693]	CALL     	14 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x02020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 45	[693]	EQK      	14 19 0	; "table"
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x0013073c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 46	[693]	JMP      	4	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_51;
  }

  // 47	[693]	GETTABUP 	14 0 20	; _ENV "tabletostring"
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x1400070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 48	[693]	GETTABUP 	15 0 16	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x1000078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 49	[693]	CALL     	14 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x02020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 50	[693]	SETTABUP 	0 16 14	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0e10000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 51	[694]	GETTABUP 	14 0 15	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x0f00070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 52	[694]	GETTABUP 	15 0 16	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x1000078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 53	[694]	CALL     	14 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x02020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 54	[694]	EQK      	14 21 0	; "function"
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_61
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x0015073c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 55	[694]	JMP      	5	; to 62
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_61;
  }

  // 56	[694]	GETTABUP 	14 0 22	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x1600070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 57	[694]	LOADK    	15 23	; "Functions are not supported in <pre> values"
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x000b8783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 58	[694]	MOVE     	16 6
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00060800);
    setobjs2s(L, ra, RB(i));
  }

  // 59	[694]	CALL     	14 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x02030744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 60	[694]	SETTABUP 	0 16 14	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x0e10000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 61	[695]	GETTABUP 	14 0 15	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x0f00070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 62	[695]	GETTABUP 	15 0 16	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x1000078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 63	[695]	CALL     	14 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x02020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 64	[695]	EQK      	14 24 0	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_71
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x0018073c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 65	[695]	JMP      	5	; to 72
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_71;
  }

  // 66	[695]	GETTABUP 	14 0 22	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x1600070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 67	[695]	LOADK    	15 25	; "Userdata is not supported in <pre> values"
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x000c8783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 68	[695]	MOVE     	16 6
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x00060800);
    setobjs2s(L, ra, RB(i));
  }

  // 69	[695]	CALL     	14 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x02030744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 70	[695]	SETTABUP 	0 16 14	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x0e10000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 71	[696]	GETTABUP 	14 0 15	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x0f00070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 72	[696]	GETTABUP 	15 0 16	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x1000078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 73	[696]	CALL     	14 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x02020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 74	[696]	EQK      	14 26 0	; "thread"
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_81
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x001a073c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 75	[696]	JMP      	5	; to 82
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_81;
  }

  // 76	[696]	GETTABUP 	14 0 22	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x1600070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 77	[696]	LOADK    	15 27	; "Threads are not supported in <pre> values"
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x000d8783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 78	[696]	MOVE     	16 6
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x00060800);
    setobjs2s(L, ra, RB(i));
  }

  // 79	[696]	CALL     	14 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x02030744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 80	[696]	SETTABUP 	0 16 14	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x0e10000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 81	[697]	GETTABUP 	14 0 15	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x0f00070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 82	[697]	GETTABUP 	15 0 16	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x1000078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 83	[697]	CALL     	14 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x02020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 84	[697]	EQK      	14 28 0	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_87
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x001c073c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 85	[697]	JMP      	1	; to 88
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_87;
  }

  // 86	[697]	SETTABUP 	0 16 28k	; _ENV "newval" "null"
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x1c10800f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 87	[701]	SELF     	14 6 29k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x1d068714);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 88	[701]	LOADK    	16 10	; "var%s+([^%s]+)%s+<pre>%s*=%s*(.-)%s*$"
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x00050803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 89	[701]	LOADK    	17 30	; "var "
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x000f0883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 90	[701]	MOVE     	18 12
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x000c0900);
    setobjs2s(L, ra, RB(i));
  }

  // 91	[701]	LOADK    	19 31	; " = "
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x000f8983);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 92	[701]	GETTABUP 	20 0 16	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x10000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 93	[701]	CONCAT   	17 4
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x000408b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 94	[701]	CALL     	14 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x02040744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 95	[701]	MOVE     	6 14
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x000e0300);
    setobjs2s(L, ra, RB(i));
  }

  // 96	[702]	CLOSE    	12
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x00000636);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 97	[683]	TFORCALL 	8 2
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x0200044c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 98	[683]	TFORLOOP 	8 72	; to 28
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x0024044d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_27; /* jump back */
    }
  }

  // 99	[702]	CLOSE    	8
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x00000436);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 100	[704]	GETTABUP 	8 0 8	; _ENV "vclean"
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x0800040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 101	[704]	SELF     	8 8 11k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x0b088414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 102	[704]	LOADK    	10 32	; "@[a-zA-Z0-9_]+"
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x00100503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 103	[704]	CALL     	8 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x05030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 104	[704]	TFORPREP 	8 10	; to 116
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x0005044b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_115;
  }

  // 105	[705]	SELF     	13 6 29k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x1d068694);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 106	[705]	MOVE     	15 12
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x000c0780);
    setobjs2s(L, ra, RB(i));
  }

  // 107	[705]	LOADK    	16 33	; "ipairs("
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x00108803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 108	[705]	SELF     	17 12 34k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x220c8894);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 109	[705]	LOADI    	19 2
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x80008981);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 110	[705]	CALL     	17 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x020308c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 111	[705]	LOADK    	18 35	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x00118903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 112	[705]	CONCAT   	16 3
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x00030835);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 113	[705]	CALL     	13 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x020406c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 114	[705]	MOVE     	6 13
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x000d0300);
    setobjs2s(L, ra, RB(i));
  }

  // 115	[704]	TFORCALL 	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x0100044c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 116	[704]	TFORLOOP 	8 12	; to 106
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x0006044d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_105; /* jump back */
    }
  }

  // 117	[706]	CLOSE    	8
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x00000436);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 118	[707]	GETTABUP 	8 0 8	; _ENV "vclean"
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x0800040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 119	[707]	SELF     	8 8 11k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x0b088414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 120	[707]	LOADK    	10 36	; "$[a-zA-Z0-9_]+"
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x00120503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 121	[707]	CALL     	8 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x05030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 122	[707]	TFORPREP 	8 10	; to 134
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x0005044b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_133;
  }

  // 123	[708]	SELF     	13 6 29k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x1d068694);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 124	[708]	MOVE     	15 12
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x000c0780);
    setobjs2s(L, ra, RB(i));
  }

  // 125	[708]	LOADK    	16 37	; "pairs("
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x00128803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 126	[708]	SELF     	17 12 34k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x220c8894);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 127	[708]	LOADI    	19 2
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x80008981);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 128	[708]	CALL     	17 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x020308c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 129	[708]	LOADK    	18 35	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x00118903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 130	[708]	CONCAT   	16 3
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_132
  label_130: {
    aot_vmfetch(0x00030835);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 131	[708]	CALL     	13 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_133
  label_131: {
    aot_vmfetch(0x020406c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 132	[708]	MOVE     	6 13
  #undef  AOT_PC
  #define AOT_PC (code + 133)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_134
  label_132: {
    aot_vmfetch(0x000d0300);
    setobjs2s(L, ra, RB(i));
  }

  // 133	[707]	TFORCALL 	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 134)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_135
  label_133: {
    aot_vmfetch(0x0100044c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 134	[707]	TFORLOOP 	8 12	; to 124
  #undef  AOT_PC
  #define AOT_PC (code + 135)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_136
  label_134: {
    aot_vmfetch(0x0006044d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_123; /* jump back */
    }
  }

  // 135	[709]	CLOSE    	8
  #undef  AOT_PC
  #define AOT_PC (code + 136)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_137
  label_135: {
    aot_vmfetch(0x00000436);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 136	[710]	GETTABUP 	8 0 8	; _ENV "vclean"
  #undef  AOT_PC
  #define AOT_PC (code + 137)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_138
  label_136: {
    aot_vmfetch(0x0800040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 137	[710]	SELF     	8 8 11k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 138)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_139
  label_137: {
    aot_vmfetch(0x0b088414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 138	[710]	LOADK    	10 38	; "&[a-zA-Z0-9_]+"
  #undef  AOT_PC
  #define AOT_PC (code + 139)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_140
  label_138: {
    aot_vmfetch(0x00130503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 139	[710]	CALL     	8 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 140)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_141
  label_139: {
    aot_vmfetch(0x05030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 140	[710]	TFORPREP 	8 10	; to 152
  #undef  AOT_PC
  #define AOT_PC (code + 141)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_142
  label_140: {
    aot_vmfetch(0x0005044b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_151;
  }

  // 141	[711]	SELF     	13 6 29k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 142)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_143
  label_141: {
    aot_vmfetch(0x1d068694);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 142	[711]	MOVE     	15 12
  #undef  AOT_PC
  #define AOT_PC (code + 143)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_144
  label_142: {
    aot_vmfetch(0x000c0780);
    setobjs2s(L, ra, RB(i));
  }

  // 143	[711]	LOADK    	16 39	; "table.unpack("
  #undef  AOT_PC
  #define AOT_PC (code + 144)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_145
  label_143: {
    aot_vmfetch(0x00138803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 144	[711]	SELF     	17 12 34k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 145)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_146
  label_144: {
    aot_vmfetch(0x220c8894);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 145	[711]	LOADI    	19 2
  #undef  AOT_PC
  #define AOT_PC (code + 146)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_147
  label_145: {
    aot_vmfetch(0x80008981);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 146	[711]	CALL     	17 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 147)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_148
  label_146: {
    aot_vmfetch(0x020308c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 147	[711]	LOADK    	18 35	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 148)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_149
  label_147: {
    aot_vmfetch(0x00118903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 148	[711]	CONCAT   	16 3
  #undef  AOT_PC
  #define AOT_PC (code + 149)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_150
  label_148: {
    aot_vmfetch(0x00030835);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 149	[711]	CALL     	13 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 150)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_151
  label_149: {
    aot_vmfetch(0x020406c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 150	[711]	MOVE     	6 13
  #undef  AOT_PC
  #define AOT_PC (code + 151)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_152
  label_150: {
    aot_vmfetch(0x000d0300);
    setobjs2s(L, ra, RB(i));
  }

  // 151	[710]	TFORCALL 	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 152)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_153
  label_151: {
    aot_vmfetch(0x0100044c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 152	[710]	TFORLOOP 	8 12	; to 142
  #undef  AOT_PC
  #define AOT_PC (code + 153)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_154
  label_152: {
    aot_vmfetch(0x0006044d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_141; /* jump back */
    }
  }

  // 153	[712]	CLOSE    	8
  #undef  AOT_PC
  #define AOT_PC (code + 154)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_155
  label_153: {
    aot_vmfetch(0x00000436);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 154	[715]	SELF     	8 6 11k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 155)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_156
  label_154: {
    aot_vmfetch(0x0b068414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 155	[715]	LOADK    	10 40	; "[a-zA-Z0-9_]+~[^%s]+"
  #undef  AOT_PC
  #define AOT_PC (code + 156)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_157
  label_155: {
    aot_vmfetch(0x00140503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 156	[715]	CALL     	8 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 157)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_158
  label_156: {
    aot_vmfetch(0x05030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 157	[715]	TFORPREP 	8 28	; to 187
  #undef  AOT_PC
  #define AOT_PC (code + 158)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_159
  label_157: {
    aot_vmfetch(0x000e044b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_186;
  }

  // 158	[722]	SELF     	13 12 34k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 159)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_160
  label_158: {
    aot_vmfetch(0x220c8694);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 159	[722]	LOADI    	15 1
  #undef  AOT_PC
  #define AOT_PC (code + 160)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_161
  label_159: {
    aot_vmfetch(0x80000781);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 160	[722]	SELF     	16 12 42k	; "find"
  #undef  AOT_PC
  #define AOT_PC (code + 161)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_162
  label_160: {
    aot_vmfetch(0x2a0c8814);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 161	[722]	LOADK    	18 43	; "~"
  #undef  AOT_PC
  #define AOT_PC (code + 162)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_163
  label_161: {
    aot_vmfetch(0x00158903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 162	[722]	CALL     	16 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 163)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_164
  label_162: {
    aot_vmfetch(0x02030844);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 163	[722]	ADDI     	16 16 -1
  #undef  AOT_PC
  #define AOT_PC (code + 164)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_165
  label_163: {
    aot_vmfetch(0x7e100815);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 164	[722]	MMBINI   	16 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 165)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_166
  label_164: {
    aot_vmfetch(0x0780082f);
    Instruction pi = 0x7e100815;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 165	[722]	CALL     	13 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 166)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_167
  label_165: {
    aot_vmfetch(0x020406c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 166	[722]	SETTABUP 	0 41 13	; _ENV "arg1"
  #undef  AOT_PC
  #define AOT_PC (code + 167)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_168
  label_166: {
    aot_vmfetch(0x0d29000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 167	[723]	SELF     	13 12 34k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 168)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_169
  label_167: {
    aot_vmfetch(0x220c8694);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 168	[723]	SELF     	15 12 42k	; "find"
  #undef  AOT_PC
  #define AOT_PC (code + 169)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_170
  label_168: {
    aot_vmfetch(0x2a0c8794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 169	[723]	LOADK    	17 43	; "~"
  #undef  AOT_PC
  #define AOT_PC (code + 170)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_171
  label_169: {
    aot_vmfetch(0x00158883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 170	[723]	CALL     	15 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 171)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_172
  label_170: {
    aot_vmfetch(0x020307c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 171	[723]	ADDI     	15 15 1
  #undef  AOT_PC
  #define AOT_PC (code + 172)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_173
  label_171: {
    aot_vmfetch(0x800f0795);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 172	[723]	MMBINI   	15 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 173)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_174
  label_172: {
    aot_vmfetch(0x068007af);
    Instruction pi = 0x800f0795;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 173	[723]	CALL     	13 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 174)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_175
  label_173: {
    aot_vmfetch(0x020306c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 174	[723]	SETTABUP 	0 44 13	; _ENV "arg2"
  #undef  AOT_PC
  #define AOT_PC (code + 175)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_176
  label_174: {
    aot_vmfetch(0x0d2c000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 175	[724]	GETTABUP 	13 0 29	; _ENV "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 176)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_177
  label_175: {
    aot_vmfetch(0x1d00068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 176	[724]	MOVE     	14 6
  #undef  AOT_PC
  #define AOT_PC (code + 177)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_178
  label_176: {
    aot_vmfetch(0x00060700);
    setobjs2s(L, ra, RB(i));
  }

  // 177	[724]	MOVE     	15 12
  #undef  AOT_PC
  #define AOT_PC (code + 178)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_179
  label_177: {
    aot_vmfetch(0x000c0780);
    setobjs2s(L, ra, RB(i));
  }

  // 178	[724]	LOADK    	16 45	; "_.global(\""
  #undef  AOT_PC
  #define AOT_PC (code + 179)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_180
  label_178: {
    aot_vmfetch(0x00168803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 179	[724]	GETTABUP 	17 0 41	; _ENV "arg1"
  #undef  AOT_PC
  #define AOT_PC (code + 180)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_181
  label_179: {
    aot_vmfetch(0x2900088b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 180	[724]	LOADK    	18 46	; "\", "
  #undef  AOT_PC
  #define AOT_PC (code + 181)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_182
  label_180: {
    aot_vmfetch(0x00170903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 181	[724]	GETTABUP 	19 0 44	; _ENV "arg2"
  #undef  AOT_PC
  #define AOT_PC (code + 182)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_183
  label_181: {
    aot_vmfetch(0x2c00098b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 182	[724]	LOADK    	20 35	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 183)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_184
  label_182: {
    aot_vmfetch(0x00118a03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 183	[724]	CONCAT   	16 5
  #undef  AOT_PC
  #define AOT_PC (code + 184)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_185
  label_183: {
    aot_vmfetch(0x00050835);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 184	[724]	CALL     	13 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 185)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_186
  label_184: {
    aot_vmfetch(0x020406c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 185	[724]	MOVE     	6 13
  #undef  AOT_PC
  #define AOT_PC (code + 186)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_187
  label_185: {
    aot_vmfetch(0x000d0300);
    setobjs2s(L, ra, RB(i));
  }

  // 186	[715]	TFORCALL 	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 187)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_188
  label_186: {
    aot_vmfetch(0x0100044c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 187	[715]	TFORLOOP 	8 30	; to 159
  #undef  AOT_PC
  #define AOT_PC (code + 188)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_189
  label_187: {
    aot_vmfetch(0x000f044d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_158; /* jump back */
    }
  }

  // 188	[725]	CLOSE    	8
  #undef  AOT_PC
  #define AOT_PC (code + 189)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_190
  label_188: {
    aot_vmfetch(0x00000436);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 189	[738]	SELF     	8 6 11k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 190)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_191
  label_189: {
    aot_vmfetch(0x0b068414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 190	[738]	LOADK    	10 47	; "f'(.-)'"
  #undef  AOT_PC
  #define AOT_PC (code + 191)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_192
  label_190: {
    aot_vmfetch(0x00178503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 191	[738]	CALL     	8 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 192)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_193
  label_191: {
    aot_vmfetch(0x05030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 192	[738]	TFORPREP 	8 33	; to 227
  #undef  AOT_PC
  #define AOT_PC (code + 193)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_194
  label_192: {
    aot_vmfetch(0x0010844b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_226;
  }

  // 193	[740]	GETTABUP 	13 0 2	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 194)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_195
  label_193: {
    aot_vmfetch(0x0200068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 194	[740]	GETFIELD 	13 13 9	; "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 195)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_196
  label_194: {
    aot_vmfetch(0x090d068e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 195	[740]	SELF     	14 6 29k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 196)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_197
  label_195: {
    aot_vmfetch(0x1d068714);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 196	[740]	LOADK    	16 47	; "f'(.-)'"
  #undef  AOT_PC
  #define AOT_PC (code + 197)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_198
  label_196: {
    aot_vmfetch(0x00178803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 197	[740]	LOADK    	17 48	; "string.format('"
  #undef  AOT_PC
  #define AOT_PC (code + 198)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_199
  label_197: {
    aot_vmfetch(0x00180883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 198	[740]	MOVE     	18 12
  #undef  AOT_PC
  #define AOT_PC (code + 199)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_200
  label_198: {
    aot_vmfetch(0x000c0900);
    setobjs2s(L, ra, RB(i));
  }

  // 199	[740]	LOADK    	19 49	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 200)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_201
  label_199: {
    aot_vmfetch(0x00188983);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 200	[740]	CONCAT   	17 3
  #undef  AOT_PC
  #define AOT_PC (code + 201)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_202
  label_200: {
    aot_vmfetch(0x000308b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 201	[740]	CALL     	14 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 202)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_203
  label_201: {
    aot_vmfetch(0x02040744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 202	[740]	GETTABUP 	15 0 1	; _ENV "dead"
  #undef  AOT_PC
  #define AOT_PC (code + 203)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_204
  label_202: {
    aot_vmfetch(0x0100078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 203	[740]	CALL     	13 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 204)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_205
  label_203: {
    aot_vmfetch(0x020306c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 204	[740]	MOVE     	6 13
  #undef  AOT_PC
  #define AOT_PC (code + 205)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_206
  label_204: {
    aot_vmfetch(0x000d0300);
    setobjs2s(L, ra, RB(i));
  }

  // 205	[742]	SELF     	13 6 11k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 206)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_207
  label_205: {
    aot_vmfetch(0x0b068694);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 206	[742]	LOADK    	15 50	; "{(.-)}"
  #undef  AOT_PC
  #define AOT_PC (code + 207)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_208
  label_206: {
    aot_vmfetch(0x00190783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 207	[742]	CALL     	13 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 208)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_209
  label_207: {
    aot_vmfetch(0x050306c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 208	[742]	TFORPREP 	13 10	; to 220
  #undef  AOT_PC
  #define AOT_PC (code + 209)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_210
  label_208: {
    aot_vmfetch(0x000506cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_219;
  }

  // 209	[744]	MOVE     	18 6
  #undef  AOT_PC
  #define AOT_PC (code + 210)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_211
  label_209: {
    aot_vmfetch(0x00060900);
    setobjs2s(L, ra, RB(i));
  }

  // 210	[744]	LOADK    	19 51	; ", "
  #undef  AOT_PC
  #define AOT_PC (code + 211)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_212
  label_210: {
    aot_vmfetch(0x00198983);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 211	[744]	MOVE     	20 17
  #undef  AOT_PC
  #define AOT_PC (code + 212)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_213
  label_211: {
    aot_vmfetch(0x00110a00);
    setobjs2s(L, ra, RB(i));
  }

  // 212	[744]	CONCAT   	18 3
  #undef  AOT_PC
  #define AOT_PC (code + 213)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_214
  label_212: {
    aot_vmfetch(0x00030935);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 213	[744]	MOVE     	6 18
  #undef  AOT_PC
  #define AOT_PC (code + 214)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_215
  label_213: {
    aot_vmfetch(0x00120300);
    setobjs2s(L, ra, RB(i));
  }

  // 214	[746]	SELF     	18 6 29k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 215)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_216
  label_214: {
    aot_vmfetch(0x1d068914);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 215	[746]	LOADK    	20 50	; "{(.-)}"
  #undef  AOT_PC
  #define AOT_PC (code + 216)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_217
  label_215: {
    aot_vmfetch(0x00190a03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 216	[746]	LOADK    	21 52	; "%%s"
  #undef  AOT_PC
  #define AOT_PC (code + 217)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_218
  label_216: {
    aot_vmfetch(0x001a0a83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 217	[746]	CALL     	18 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 218)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_219
  label_217: {
    aot_vmfetch(0x02040944);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 218	[746]	MOVE     	6 18
  #undef  AOT_PC
  #define AOT_PC (code + 219)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_220
  label_218: {
    aot_vmfetch(0x00120300);
    setobjs2s(L, ra, RB(i));
  }

  // 219	[742]	TFORCALL 	13 1
  #undef  AOT_PC
  #define AOT_PC (code + 220)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_221
  label_219: {
    aot_vmfetch(0x010006cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 220	[742]	TFORLOOP 	13 12	; to 210
  #undef  AOT_PC
  #define AOT_PC (code + 221)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_222
  label_220: {
    aot_vmfetch(0x000606cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_209; /* jump back */
    }
  }

  // 221	[747]	CLOSE    	13
  #undef  AOT_PC
  #define AOT_PC (code + 222)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_223
  label_221: {
    aot_vmfetch(0x000006b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 222	[750]	MOVE     	13 6
  #undef  AOT_PC
  #define AOT_PC (code + 223)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_224
  label_222: {
    aot_vmfetch(0x00060680);
    setobjs2s(L, ra, RB(i));
  }

  // 223	[750]	LOADK    	14 35	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 224)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_225
  label_223: {
    aot_vmfetch(0x00118703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 224	[750]	CONCAT   	13 2
  #undef  AOT_PC
  #define AOT_PC (code + 225)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_226
  label_224: {
    aot_vmfetch(0x000206b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 225	[750]	MOVE     	6 13
  #undef  AOT_PC
  #define AOT_PC (code + 226)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_227
  label_225: {
    aot_vmfetch(0x000d0300);
    setobjs2s(L, ra, RB(i));
  }

  // 226	[738]	TFORCALL 	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 227)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_228
  label_226: {
    aot_vmfetch(0x0100044c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 227	[738]	TFORLOOP 	8 35	; to 194
  #undef  AOT_PC
  #define AOT_PC (code + 228)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_229
  label_227: {
    aot_vmfetch(0x0011844d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_193; /* jump back */
    }
  }

  // 228	[751]	CLOSE    	8
  #undef  AOT_PC
  #define AOT_PC (code + 229)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_230
  label_228: {
    aot_vmfetch(0x00000436);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 229	[753]	SELF     	8 6 11k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 230)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_231
  label_229: {
    aot_vmfetch(0x0b068414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 230	[753]	LOADK    	10 53	; "f[[(.*)]]"
  #undef  AOT_PC
  #define AOT_PC (code + 231)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_232
  label_230: {
    aot_vmfetch(0x001a8503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 231	[753]	CALL     	8 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 232)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_233
  label_231: {
    aot_vmfetch(0x05030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 232	[753]	TFORPREP 	8 18	; to 252
  #undef  AOT_PC
  #define AOT_PC (code + 233)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_234
  label_232: {
    aot_vmfetch(0x0009044b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_251;
  }

  // 233	[754]	GETTABUP 	13 0 54	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 234)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_235
  label_233: {
    aot_vmfetch(0x3600068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 234	[754]	LOADK    	14 55	; "\027[1;31mPreprocessor error:\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 235)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_236
  label_234: {
    aot_vmfetch(0x001b8703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 235	[754]	CALL     	13 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 236)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_237
  label_235: {
    aot_vmfetch(0x010206c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 236	[755]	GETTABUP 	13 0 54	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 237)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_238
  label_236: {
    aot_vmfetch(0x3600068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 237	[755]	LOADK    	14 56	; "\027[1;31mError with the 'f[[' preprocessor command.\027[0m\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 238)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_239
  label_237: {
    aot_vmfetch(0x001c0703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 238	[755]	CALL     	13 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 239)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_240
  label_238: {
    aot_vmfetch(0x010206c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 239	[756]	GETTABUP 	13 0 57	; _ENV "errorin"
  #undef  AOT_PC
  #define AOT_PC (code + 240)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_241
  label_239: {
    aot_vmfetch(0x3900068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 240	[756]	TEST     	13 0
  #undef  AOT_PC
  #define AOT_PC (code + 241)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_245
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_242
  label_240: {
    aot_vmfetch(0x000006c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 241	[756]	JMP      	3	; to 246
  #undef  AOT_PC
  #define AOT_PC (code + 242)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_243
  label_241: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_245;
  }

  // 242	[757]	GETTABUP 	13 0 54	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 243)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_244
  label_242: {
    aot_vmfetch(0x3600068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 243	[757]	LOADK    	14 58	; "\027[1;31mMultiline formatted strings are not supported.\027[0m\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 244)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_245
  label_243: {
    aot_vmfetch(0x001d0703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 244	[757]	CALL     	13 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 245)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_246
  label_244: {
    aot_vmfetch(0x010206c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 245	[759]	GETTABUP 	13 0 54	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 246)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_247
  label_245: {
    aot_vmfetch(0x3600068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 246	[759]	LOADK    	14 59	; "\027[1;31mStopping preprocessor.\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 247)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_248
  label_246: {
    aot_vmfetch(0x001d8703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 247	[759]	CALL     	13 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 248)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_249
  label_247: {
    aot_vmfetch(0x010206c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 248	[760]	GETTABUP 	13 0 60	; _ENV "os"
  #undef  AOT_PC
  #define AOT_PC (code + 249)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_250
  label_248: {
    aot_vmfetch(0x3c00068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 249	[760]	GETFIELD 	13 13 61	; "exit"
  #undef  AOT_PC
  #define AOT_PC (code + 250)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_251
  label_249: {
    aot_vmfetch(0x3d0d068e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 250	[760]	CALL     	13 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 251)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_252
  label_250: {
    aot_vmfetch(0x010106c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 251	[753]	TFORCALL 	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 252)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_253
  label_251: {
    aot_vmfetch(0x0100044c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 252	[753]	TFORLOOP 	8 20	; to 234
  #undef  AOT_PC
  #define AOT_PC (code + 253)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_254
  label_252: {
    aot_vmfetch(0x000a044d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_233; /* jump back */
    }
  }

  // 253	[761]	CLOSE    	8
  #undef  AOT_PC
  #define AOT_PC (code + 254)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_255
  label_253: {
    aot_vmfetch(0x00000436);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 254	[763]	GETTABUP 	8 0 4	; _ENV "lines"
  #undef  AOT_PC
  #define AOT_PC (code + 255)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_256
  label_254: {
    aot_vmfetch(0x0400040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 255	[763]	GETTABUP 	9 0 2	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 256)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_257
  label_255: {
    aot_vmfetch(0x0200048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 256	[763]	GETFIELD 	9 9 9	; "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 257)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_258
  label_256: {
    aot_vmfetch(0x0909048e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 257	[763]	MOVE     	10 6
  #undef  AOT_PC
  #define AOT_PC (code + 258)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_259
  label_257: {
    aot_vmfetch(0x00060500);
    setobjs2s(L, ra, RB(i));
  }

  // 258	[763]	CALL     	9 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 259)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_260
  label_258: {
    aot_vmfetch(0x020204c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 259	[763]	SETTABLE 	8 5 9
  #undef  AOT_PC
  #define AOT_PC (code + 260)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_261
  label_259: {
    aot_vmfetch(0x09050410);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 260	[764]	CLOSE    	5
  #undef  AOT_PC
  #define AOT_PC (code + 261)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_262
  label_260: {
    aot_vmfetch(0x000002b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 261	[679]	TFORCALL 	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 262)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_263
  label_261: {
    aot_vmfetch(0x020000cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 262	[679]	TFORLOOP 	1 248	; to 16
  #undef  AOT_PC
  #define AOT_PC (code + 263)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_264
  label_262: {
    aot_vmfetch(0x007c00cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_15; /* jump back */
    }
  }

  // 263	[764]	CLOSE    	1
  #undef  AOT_PC
  #define AOT_PC (code + 264)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_265
  label_263: {
    aot_vmfetch(0x000000b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 264	[767]	GETTABUP 	1 0 19	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 265)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_266
  label_264: {
    aot_vmfetch(0x1300008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 265	[767]	GETFIELD 	1 1 62	; "concat"
  #undef  AOT_PC
  #define AOT_PC (code + 266)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_267
  label_265: {
    aot_vmfetch(0x3e01008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 266	[767]	GETTABUP 	2 0 4	; _ENV "lines"
  #undef  AOT_PC
  #define AOT_PC (code + 267)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_268
  label_266: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 267	[767]	LOADK    	3 6	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 268)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_269
  label_267: {
    aot_vmfetch(0x00030183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 268	[767]	TAILCALL 	1 3 0	; 2 in
  #undef  AOT_PC
  #define AOT_PC (code + 269)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_270
  label_268: {
    aot_vmfetch(0x000380c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 269	[767]	RETURN   	1 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 270)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_269: {
    aot_vmfetch(0x000080c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 270	[768]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 271)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_270: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 685 - 687
static
CallInfo *magic_implementation_73(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
  }

  // 0	[686]	GETTABUP 	0 0 1	; _ENV "loadstring"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0100000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[686]	LOADK    	1 2	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00010083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[686]	GETUPVAL 	2 1	; match2
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[686]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 4	[686]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[686]	CALL     	0 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02010044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[686]	SETTABUP 	0 0 0	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x0000000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 7	[687]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 687 - 689
static
CallInfo *magic_implementation_74(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
  }

  // 0	[688]	GETTABUP 	1 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[688]	LOADK    	2 1	; "Error rendering <pre> value: "
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[688]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[688]	CONCAT   	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00020135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 4	[688]	GETUPVAL 	3 1	; v
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 5	[688]	CALL     	1 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_05: {
    aot_vmfetch(0x010300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[689]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 812 - 1375
static
CallInfo *magic_implementation_75(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
    case 132: goto label_132;
    case 133: goto label_133;
    case 134: goto label_134;
    case 135: goto label_135;
    case 136: goto label_136;
    case 137: goto label_137;
    case 138: goto label_138;
    case 139: goto label_139;
    case 140: goto label_140;
    case 141: goto label_141;
    case 142: goto label_142;
    case 143: goto label_143;
    case 144: goto label_144;
    case 145: goto label_145;
    case 146: goto label_146;
    case 147: goto label_147;
    case 148: goto label_148;
    case 149: goto label_149;
    case 150: goto label_150;
    case 151: goto label_151;
    case 152: goto label_152;
    case 153: goto label_153;
    case 154: goto label_154;
    case 155: goto label_155;
    case 156: goto label_156;
    case 157: goto label_157;
    case 158: goto label_158;
    case 159: goto label_159;
    case 160: goto label_160;
    case 161: goto label_161;
    case 162: goto label_162;
    case 163: goto label_163;
    case 164: goto label_164;
    case 165: goto label_165;
    case 166: goto label_166;
    case 167: goto label_167;
    case 168: goto label_168;
    case 169: goto label_169;
    case 170: goto label_170;
    case 171: goto label_171;
    case 172: goto label_172;
    case 173: goto label_173;
    case 174: goto label_174;
    case 175: goto label_175;
    case 176: goto label_176;
    case 177: goto label_177;
    case 178: goto label_178;
    case 179: goto label_179;
    case 180: goto label_180;
    case 181: goto label_181;
    case 182: goto label_182;
    case 183: goto label_183;
    case 184: goto label_184;
    case 185: goto label_185;
    case 186: goto label_186;
    case 187: goto label_187;
    case 188: goto label_188;
    case 189: goto label_189;
    case 190: goto label_190;
    case 191: goto label_191;
    case 192: goto label_192;
    case 193: goto label_193;
    case 194: goto label_194;
    case 195: goto label_195;
    case 196: goto label_196;
    case 197: goto label_197;
    case 198: goto label_198;
    case 199: goto label_199;
    case 200: goto label_200;
    case 201: goto label_201;
    case 202: goto label_202;
    case 203: goto label_203;
    case 204: goto label_204;
    case 205: goto label_205;
    case 206: goto label_206;
    case 207: goto label_207;
    case 208: goto label_208;
    case 209: goto label_209;
    case 210: goto label_210;
    case 211: goto label_211;
    case 212: goto label_212;
    case 213: goto label_213;
    case 214: goto label_214;
    case 215: goto label_215;
    case 216: goto label_216;
    case 217: goto label_217;
    case 218: goto label_218;
    case 219: goto label_219;
    case 220: goto label_220;
    case 221: goto label_221;
    case 222: goto label_222;
    case 223: goto label_223;
    case 224: goto label_224;
    case 225: goto label_225;
    case 226: goto label_226;
    case 227: goto label_227;
    case 228: goto label_228;
    case 229: goto label_229;
    case 230: goto label_230;
    case 231: goto label_231;
    case 232: goto label_232;
    case 233: goto label_233;
    case 234: goto label_234;
    case 235: goto label_235;
    case 236: goto label_236;
    case 237: goto label_237;
    case 238: goto label_238;
    case 239: goto label_239;
    case 240: goto label_240;
    case 241: goto label_241;
    case 242: goto label_242;
    case 243: goto label_243;
    case 244: goto label_244;
    case 245: goto label_245;
    case 246: goto label_246;
    case 247: goto label_247;
    case 248: goto label_248;
    case 249: goto label_249;
    case 250: goto label_250;
    case 251: goto label_251;
    case 252: goto label_252;
    case 253: goto label_253;
    case 254: goto label_254;
    case 255: goto label_255;
    case 256: goto label_256;
    case 257: goto label_257;
    case 258: goto label_258;
    case 259: goto label_259;
    case 260: goto label_260;
    case 261: goto label_261;
    case 262: goto label_262;
    case 263: goto label_263;
    case 264: goto label_264;
    case 265: goto label_265;
    case 266: goto label_266;
    case 267: goto label_267;
    case 268: goto label_268;
    case 269: goto label_269;
    case 270: goto label_270;
    case 271: goto label_271;
    case 272: goto label_272;
    case 273: goto label_273;
    case 274: goto label_274;
    case 275: goto label_275;
    case 276: goto label_276;
    case 277: goto label_277;
    case 278: goto label_278;
    case 279: goto label_279;
    case 280: goto label_280;
    case 281: goto label_281;
    case 282: goto label_282;
    case 283: goto label_283;
    case 284: goto label_284;
    case 285: goto label_285;
    case 286: goto label_286;
    case 287: goto label_287;
    case 288: goto label_288;
    case 289: goto label_289;
    case 290: goto label_290;
    case 291: goto label_291;
    case 292: goto label_292;
    case 293: goto label_293;
    case 294: goto label_294;
    case 295: goto label_295;
    case 296: goto label_296;
    case 297: goto label_297;
    case 298: goto label_298;
    case 299: goto label_299;
    case 300: goto label_300;
    case 301: goto label_301;
    case 302: goto label_302;
    case 303: goto label_303;
    case 304: goto label_304;
    case 305: goto label_305;
    case 306: goto label_306;
    case 307: goto label_307;
    case 308: goto label_308;
    case 309: goto label_309;
    case 310: goto label_310;
    case 311: goto label_311;
    case 312: goto label_312;
    case 313: goto label_313;
    case 314: goto label_314;
    case 315: goto label_315;
    case 316: goto label_316;
    case 317: goto label_317;
    case 318: goto label_318;
    case 319: goto label_319;
    case 320: goto label_320;
    case 321: goto label_321;
    case 322: goto label_322;
    case 323: goto label_323;
    case 324: goto label_324;
    case 325: goto label_325;
    case 326: goto label_326;
    case 327: goto label_327;
    case 328: goto label_328;
    case 329: goto label_329;
    case 330: goto label_330;
    case 331: goto label_331;
    case 332: goto label_332;
    case 333: goto label_333;
    case 334: goto label_334;
    case 335: goto label_335;
    case 336: goto label_336;
    case 337: goto label_337;
    case 338: goto label_338;
    case 339: goto label_339;
    case 340: goto label_340;
    case 341: goto label_341;
    case 342: goto label_342;
    case 343: goto label_343;
    case 344: goto label_344;
    case 345: goto label_345;
    case 346: goto label_346;
    case 347: goto label_347;
    case 348: goto label_348;
    case 349: goto label_349;
    case 350: goto label_350;
    case 351: goto label_351;
    case 352: goto label_352;
    case 353: goto label_353;
  }

  // 0	[812]	VARARGPREP	4
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000251);
    ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));
    if (l_unlikely(trap)) {  /* previous "Protect" updated trap */
      luaD_hookcall(L, ci);
      L->oldpc = 1;  /* next opcode will be seen as a "new" line */
    }
    updatebase(ci);  /* function has new base after adjustment */
  }

  // 1	[816]	EQK      	3 0 1	; "-types"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_07
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x000081bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 2	[816]	JMP      	4	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_07;
  }

  // 3	[816]	EQK      	0 0 0	; "-types"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0000003c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[816]	JMP      	6	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_11;
  }

  // 5	[816]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 6	[816]	JMP      	4	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_11;
  }

  // 7	[817]	GETTABUP 	4 0 1	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0100020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[817]	GETFIELD 	4 4 2	; "all"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0204020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 9	[817]	CALL     	4 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x01010244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[818]	RETURN   	4 1 5	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x05018246);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 11	[819]	NEWTABLE 	4 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000213);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 12	[819]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 13	[819]	VARARG   	5 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000002d0);
    int n = GETARG_C(i) - 1;  /* required results */
    Protect(luaT_getvarargs(L, ci, ra, n));
  }

  // 14	[819]	SETLIST  	4 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0000024e);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 15	[819]	NEWTABLE 	5 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000293);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 16	[819]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 17	[819]	EQ       	4 5 0
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00050239);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 18	[819]	JMP      	3	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_22;
  }

  // 19	[820]	GETTABUP 	4 0 3	; _ENV "error"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0300020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 20	[820]	LOADK    	5 4	; "No arguments or invalid flags provided."
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00020283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 21	[820]	CALL     	4 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x01020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 22	[824]	GETTABUP 	4 0 5	; _ENV "macros"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0500020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 23	[824]	CALL     	4 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x01010244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[827]	LOADNIL  	4 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00000208);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 25	[828]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_29
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 26	[828]	JMP      	2	; to 30
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_29;
  }

  // 27	[828]	MOVE     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_30
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00000280);
    setobjs2s(L, ra, RB(i));
  }

  // 28	[828]	JMP      	1	; to 31
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_30;
  }

  // 29	[828]	LOADNIL  	5 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00000288);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 30	[829]	EQK      	1 6 0	; "file"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_63
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x000600bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 31	[829]	JMP      	31	; to 64
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x80000f38);
    updatetrap(ci);
    goto label_63;
  }

  // 32	[830]	GETTABUP 	6 0 7	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x0700030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 33	[830]	GETFIELD 	6 6 8	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x0806030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 34	[830]	MOVE     	7 0
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00000380);
    setobjs2s(L, ra, RB(i));
  }

  // 35	[830]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 36	[831]	TEST     	6 1
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_48
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00008342);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 37	[831]	JMP      	10	; to 49
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_48;
  }

  // 38	[832]	GETTABUP 	7 0 3	; _ENV "error"
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x0300038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 39	[832]	GETTABUP 	8 0 9	; _ENV "core"
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x0900040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 40	[832]	GETFIELD 	8 8 3	; "error"
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x0308040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 41	[832]	GETFIELD 	8 8 10	; "strerror"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x0a08040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 42	[832]	LOADI    	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x80008481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 43	[832]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 44	[832]	LOADK    	9 11	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x00058483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 45	[832]	MOVE     	10 0
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x00000500);
    setobjs2s(L, ra, RB(i));
  }

  // 46	[832]	CONCAT   	8 3
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x00030435);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 47	[832]	CALL     	7 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x010203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 48	[834]	SELF     	7 6 12k	; "read"
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x0c068394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 49	[834]	LOADK    	9 13	; "*all"
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00068483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 50	[834]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 51	[834]	MOVE     	4 7
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00070200);
    setobjs2s(L, ra, RB(i));
  }

  // 52	[835]	SELF     	7 6 14k	; "close"
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x0e068394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 53	[835]	CALL     	7 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x010203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 54	[836]	TEST     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_63
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x00008242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 55	[836]	JMP      	7	; to 64
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_63;
  }

  // 56	[837]	GETTABUP 	7 0 3	; _ENV "error"
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x0300038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 57	[837]	GETTABUP 	8 0 9	; _ENV "core"
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x0900040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 58	[837]	GETFIELD 	8 8 3	; "error"
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x0308040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 59	[837]	GETFIELD 	8 8 10	; "strerror"
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x0a08040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 60	[837]	LOADI    	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x80008481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 61	[837]	CALL     	8 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x00020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 62	[837]	CALL     	7 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x010003c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 63	[842]	TEST     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_66
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x00008242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 64	[842]	JMP      	1	; to 67
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_66;
  }

  // 65	[842]	MOVE     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x00000200);
    setobjs2s(L, ra, RB(i));
  }

  // 66	[843]	GETTABUP 	6 0 1	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x0100030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 67	[843]	GETFIELD 	6 6 15	; "check"
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x0f06030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 68	[843]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 69	[843]	CALL     	6 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x01020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 70	[844]	GETTABUP 	6 0 16	; _ENV "ext"
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x1000030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 71	[844]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 72	[844]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 73	[844]	MOVE     	4 6
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x00060200);
    setobjs2s(L, ra, RB(i));
  }

  // 74	[847]	NEWTABLE 	6 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x00000313);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 75	[847]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 76	[848]	SELF     	7 4 17k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x11048394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 77	[848]	LOADK    	9 18	; "[^\r\n]+"
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x00090483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 78	[848]	CALL     	7 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x050303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 79	[848]	TFORPREP 	7 4	; to 85
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x000203cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_84;
  }

  // 80	[849]	LEN      	12 6
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x00060634);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 81	[849]	ADDI     	12 12 1
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x800c0615);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 82	[849]	MMBINI   	12 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x0680062f);
    Instruction pi = 0x800c0615;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 83	[849]	SETTABLE 	6 12 11
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x0b0c0310);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 84	[848]	TFORCALL 	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x010003cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 85	[848]	TFORLOOP 	7 6	; to 81
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x000303cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_80; /* jump back */
    }
  }

  // 86	[850]	CLOSE    	7
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x000003b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 87	[859]	CLOSURE  	7 0	; 0x7ff6dba10a40
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x000003cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 88	[852]	SETTABUP 	0 19 7	; _ENV "getname"
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x0713000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 89	[862]	NEWTABLE 	7 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x00000393);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 90	[862]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 91	[863]	GETTABUP 	8 0 20	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x1400040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 92	[863]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 93	[863]	CALL     	8 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x05020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 94	[863]	TFORPREP 	8 34	; to 130
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x0011044b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_129;
  }

  // 95	[864]	SELF     	14 13 21k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x150d8714);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 96	[864]	LOADI    	16 1
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x80000801);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 97	[864]	LOADI    	17 1
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x80000881);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 98	[864]	CALL     	14 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x02040744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 99	[865]	LOADI    	15 1
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x80000781);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 100	[867]	EQK      	14 11 1	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_104
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x000b873c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 101	[867]	JMP      	2	; to 105
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_104;
  }

  // 102	[867]	EQK      	14 22 0	; "\t"
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_113
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x0016073c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 103	[867]	JMP      	9	; to 114
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_113;
  }

  // 104	[868]	MOVE     	16 15
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x000f0800);
    setobjs2s(L, ra, RB(i));
  }

  // 105	[868]	ADDI     	15 15 1
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x800f0795);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 106	[868]	MMBINI   	15 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x068007af);
    Instruction pi = 0x800f0795;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 107	[869]	SELF     	16 13 21k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x150d8814);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 108	[869]	MOVE     	18 15
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x000f0900);
    setobjs2s(L, ra, RB(i));
  }

  // 109	[869]	MOVE     	19 15
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x000f0980);
    setobjs2s(L, ra, RB(i));
  }

  // 110	[869]	CALL     	16 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x02040844);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 111	[869]	MOVE     	14 16
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_100
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x00100700);
    setobjs2s(L, ra, RB(i));
  }

  // 112	[870]	JMP      	-13	; to 101
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x7ffff938);
    updatetrap(ci);
    goto label_100;
  }

  // 113	[872]	EQK      	14 23 0	; "#"
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_129
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x0017073c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 114	[872]	JMP      	14	; to 130
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x800006b8);
    updatetrap(ci);
    goto label_129;
  }

  // 115	[873]	SELF     	16 13 21k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x150d8814);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 116	[873]	MOVE     	18 15
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x000f0900);
    setobjs2s(L, ra, RB(i));
  }

  // 117	[873]	LEN      	19 13
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x000d09b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 118	[873]	CALL     	16 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x02040844);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 119	[873]	MOVE     	13 16
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x00100680);
    setobjs2s(L, ra, RB(i));
  }

  // 120	[875]	GETTABUP 	16 0 24	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x1800080b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 121	[875]	GETFIELD 	16 16 25	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x1910080e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 122	[875]	MOVE     	17 7
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x00070880);
    setobjs2s(L, ra, RB(i));
  }

  // 123	[875]	NEWTABLE 	18 0 2	; 2
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x02000913);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 124	[875]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 125	[875]	MOVE     	19 12
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x000c0980);
    setobjs2s(L, ra, RB(i));
  }

  // 126	[875]	MOVE     	20 13
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x000d0a00);
    setobjs2s(L, ra, RB(i));
  }

  // 127	[875]	SETLIST  	18 2 0
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x0002094e);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 128	[875]	CALL     	16 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x01030844);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 129	[863]	TFORCALL 	8 2
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x0200044c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 130	[863]	TFORLOOP 	8 36	; to 96
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_132
  label_130: {
    aot_vmfetch(0x0012044d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_95; /* jump back */
    }
  }

  // 131	[877]	CLOSE    	8
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_133
  label_131: {
    aot_vmfetch(0x00000436);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 132	[880]	NEWTABLE 	8 3 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 133)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_134
  label_132: {
    aot_vmfetch(0x00030413);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 133	[880]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 134)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_135
  label_133: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 134	[881]	SETFIELD 	8 26 27k	; "cobalt" true
  #undef  AOT_PC
  #define AOT_PC (code + 135)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_136
  label_134: {
    aot_vmfetch(0x1b1a8412);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 135	[882]	SETFIELD 	8 28 29k	; "cobaltversion" "23"
  #undef  AOT_PC
  #define AOT_PC (code + 136)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_137
  label_135: {
    aot_vmfetch(0x1d1c8412);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 136	[883]	SETFIELD 	8 30 31k	; "edition" "standard"
  #undef  AOT_PC
  #define AOT_PC (code + 137)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_138
  label_136: {
    aot_vmfetch(0x1f1e8412);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 137	[884]	SETFIELD 	8 32 33k	; "cplusplus" false
  #undef  AOT_PC
  #define AOT_PC (code + 138)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_139
  label_137: {
    aot_vmfetch(0x21208412);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 138	[887]	GETTABUP 	9 0 24	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 139)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_140
  label_138: {
    aot_vmfetch(0x1800048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 139	[887]	GETFIELD 	9 9 35	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 140)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_141
  label_139: {
    aot_vmfetch(0x2309048e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 140	[887]	VARARG   	10 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 141)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_142
  label_140: {
    aot_vmfetch(0x00000550);
    int n = GETARG_C(i) - 1;  /* required results */
    Protect(luaT_getvarargs(L, ci, ra, n));
  }

  // 141	[887]	CALL     	9 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 142)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_143
  label_141: {
    aot_vmfetch(0x020004c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 142	[887]	SETTABUP 	0 34 9	; _ENV "envitems"
  #undef  AOT_PC
  #define AOT_PC (code + 143)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_144
  label_142: {
    aot_vmfetch(0x0922000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 143	[888]	NEWTABLE 	9 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 144)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_145
  label_143: {
    aot_vmfetch(0x00000493);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 144	[888]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 145)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_146
  label_144: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 145	[888]	SETTABUP 	0 36 9	; _ENV "inenv"
  #undef  AOT_PC
  #define AOT_PC (code + 146)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_147
  label_145: {
    aot_vmfetch(0x0924000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 146	[889]	GETTABUP 	9 0 20	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 147)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_148
  label_146: {
    aot_vmfetch(0x1400048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 147	[889]	GETTABUP 	10 0 34	; _ENV "envitems"
  #undef  AOT_PC
  #define AOT_PC (code + 148)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_149
  label_147: {
    aot_vmfetch(0x2200050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 148	[889]	CALL     	9 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 149)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_150
  label_148: {
    aot_vmfetch(0x050204c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 149	[889]	TFORPREP 	9 22	; to 173
  #undef  AOT_PC
  #define AOT_PC (code + 150)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_151
  label_149: {
    aot_vmfetch(0x000b04cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_172;
  }

  // 150	[890]	GETTABUP 	15 0 37	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 151)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_152
  label_150: {
    aot_vmfetch(0x2500078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 151	[890]	MOVE     	16 14
  #undef  AOT_PC
  #define AOT_PC (code + 152)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_153
  label_151: {
    aot_vmfetch(0x000e0800);
    setobjs2s(L, ra, RB(i));
  }

  // 152	[890]	CALL     	15 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 153)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_154
  label_152: {
    aot_vmfetch(0x020207c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 153	[890]	EQK      	15 38 0	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 154)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_156
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_155
  label_153: {
    aot_vmfetch(0x002607bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 154	[890]	JMP      	1	; to 157
  #undef  AOT_PC
  #define AOT_PC (code + 155)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_174
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_156
  label_154: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_156;
  }

  // 155	[891]	JMP      	18	; to 175
  #undef  AOT_PC
  #define AOT_PC (code + 156)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_157
  label_155: {
    aot_vmfetch(0x800008b8);
    updatetrap(ci);
    goto label_174;
  }

  // 156	[893]	SELF     	15 14 39k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 157)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_158
  label_156: {
    aot_vmfetch(0x270e8794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 157	[893]	LOADK    	17 40	; "-"
  #undef  AOT_PC
  #define AOT_PC (code + 158)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_159
  label_157: {
    aot_vmfetch(0x00140883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 158	[893]	LOADK    	18 41	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 159)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_160
  label_158: {
    aot_vmfetch(0x00148903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 159	[893]	CALL     	15 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 160)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_161
  label_159: {
    aot_vmfetch(0x020407c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 160	[893]	SELF     	15 15 42k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 161)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_162
  label_160: {
    aot_vmfetch(0x2a0f8794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 161	[893]	LOADK    	17 43	; "="
  #undef  AOT_PC
  #define AOT_PC (code + 162)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_163
  label_161: {
    aot_vmfetch(0x00158883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 162	[893]	CALL     	15 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 163)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_164
  label_162: {
    aot_vmfetch(0x020307c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 163	[894]	GETTABUP 	16 0 36	; _ENV "inenv"
  #undef  AOT_PC
  #define AOT_PC (code + 164)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_165
  label_163: {
    aot_vmfetch(0x2400080b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 164	[894]	GETI     	17 15 1
  #undef  AOT_PC
  #define AOT_PC (code + 165)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_166
  label_164: {
    aot_vmfetch(0x010f088d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 165	[894]	GETTABUP 	18 0 44	; _ENV "loadstring"
  #undef  AOT_PC
  #define AOT_PC (code + 166)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_167
  label_165: {
    aot_vmfetch(0x2c00090b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 166	[894]	LOADK    	19 45	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 167)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_168
  label_166: {
    aot_vmfetch(0x00168983);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 167	[894]	GETI     	20 15 2
  #undef  AOT_PC
  #define AOT_PC (code + 168)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_169
  label_167: {
    aot_vmfetch(0x020f0a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 168	[894]	CONCAT   	19 2
  #undef  AOT_PC
  #define AOT_PC (code + 169)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_170
  label_168: {
    aot_vmfetch(0x000209b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 169	[894]	CALL     	18 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 170)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_171
  label_169: {
    aot_vmfetch(0x02020944);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 170	[894]	CALL     	18 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 171)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_172
  label_170: {
    aot_vmfetch(0x02010944);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 171	[894]	SETTABLE 	16 17 18
  #undef  AOT_PC
  #define AOT_PC (code + 172)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_173
  label_171: {
    aot_vmfetch(0x12110810);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 172	[889]	TFORCALL 	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 173)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_174
  label_172: {
    aot_vmfetch(0x020004cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 173	[889]	TFORLOOP 	9 24	; to 151
  #undef  AOT_PC
  #define AOT_PC (code + 174)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_175
  label_173: {
    aot_vmfetch(0x000c04cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_150; /* jump back */
    }
  }

  // 174	[895]	CLOSE    	9
  #undef  AOT_PC
  #define AOT_PC (code + 175)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_176
  label_174: {
    aot_vmfetch(0x000004b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 175	[898]	GETTABUP 	9 0 20	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 176)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_177
  label_175: {
    aot_vmfetch(0x1400048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 176	[898]	GETTABUP 	10 0 36	; _ENV "inenv"
  #undef  AOT_PC
  #define AOT_PC (code + 177)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_178
  label_176: {
    aot_vmfetch(0x2400050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 177	[898]	CALL     	9 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 178)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_179
  label_177: {
    aot_vmfetch(0x050204c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 178	[898]	TFORPREP 	9 11	; to 191
  #undef  AOT_PC
  #define AOT_PC (code + 179)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_180
  label_178: {
    aot_vmfetch(0x000584cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_190;
  }

  // 179	[899]	GETTABUP 	15 0 37	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 180)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_181
  label_179: {
    aot_vmfetch(0x2500078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 180	[899]	MOVE     	16 14
  #undef  AOT_PC
  #define AOT_PC (code + 181)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_182
  label_180: {
    aot_vmfetch(0x000e0800);
    setobjs2s(L, ra, RB(i));
  }

  // 181	[899]	CALL     	15 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 182)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_183
  label_181: {
    aot_vmfetch(0x020207c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 182	[899]	EQK      	15 46 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 183)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_189
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_184
  label_182: {
    aot_vmfetch(0x002e07bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 183	[899]	JMP      	5	; to 190
  #undef  AOT_PC
  #define AOT_PC (code + 184)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_185
  label_183: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_189;
  }

  // 184	[899]	LOADK    	15 47	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 185)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_186
  label_184: {
    aot_vmfetch(0x00178783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 185	[899]	MOVE     	16 14
  #undef  AOT_PC
  #define AOT_PC (code + 186)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_187
  label_185: {
    aot_vmfetch(0x000e0800);
    setobjs2s(L, ra, RB(i));
  }

  // 186	[899]	LOADK    	17 47	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 187)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_188
  label_186: {
    aot_vmfetch(0x00178883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 187	[899]	CONCAT   	15 3
  #undef  AOT_PC
  #define AOT_PC (code + 188)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_189
  label_187: {
    aot_vmfetch(0x000307b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 188	[899]	MOVE     	14 15
  #undef  AOT_PC
  #define AOT_PC (code + 189)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_190
  label_188: {
    aot_vmfetch(0x000f0700);
    setobjs2s(L, ra, RB(i));
  }

  // 189	[900]	SETTABLE 	8 13 14
  #undef  AOT_PC
  #define AOT_PC (code + 190)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_191
  label_189: {
    aot_vmfetch(0x0e0d0410);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 190	[898]	TFORCALL 	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 191)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_192
  label_190: {
    aot_vmfetch(0x020004cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 191	[898]	TFORLOOP 	9 13	; to 180
  #undef  AOT_PC
  #define AOT_PC (code + 192)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_193
  label_191: {
    aot_vmfetch(0x000684cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_179; /* jump back */
    }
  }

  // 192	[901]	CLOSE    	9
  #undef  AOT_PC
  #define AOT_PC (code + 193)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_194
  label_192: {
    aot_vmfetch(0x000004b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 193	[902]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 194)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_195
  label_193: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 194	[903]	NEWTABLE 	10 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 195)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_196
  label_194: {
    aot_vmfetch(0x00000513);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 195	[903]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 196)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_197
  label_195: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 196	[904]	LOADTRUE 	11
  #undef  AOT_PC
  #define AOT_PC (code + 197)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_198
  label_196: {
    aot_vmfetch(0x00000587);
    setbtvalue(s2v(ra));
  }

  // 197	[905]	LOADFALSE	12
  #undef  AOT_PC
  #define AOT_PC (code + 198)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_199
  label_197: {
    aot_vmfetch(0x00000605);
    setbfvalue(s2v(ra));
  }

  // 198	[929]	CLOSURE  	13 1	; 0x7ff6dba112b0
  #undef  AOT_PC
  #define AOT_PC (code + 199)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_200
  label_198: {
    aot_vmfetch(0x000086cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 199	[907]	SETTABUP 	0 48 13	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 200)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_201
  label_199: {
    aot_vmfetch(0x0d30000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 200	[930]	GETTABUP 	13 0 49	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 201)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_202
  label_200: {
    aot_vmfetch(0x3100068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 201	[930]	MOVE     	14 6
  #undef  AOT_PC
  #define AOT_PC (code + 202)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_203
  label_201: {
    aot_vmfetch(0x00060700);
    setobjs2s(L, ra, RB(i));
  }

  // 202	[930]	CALL     	13 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 203)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_204
  label_202: {
    aot_vmfetch(0x050206c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 203	[930]	TFORPREP 	13 107	; to 312
  #undef  AOT_PC
  #define AOT_PC (code + 204)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_205
  label_203: {
    aot_vmfetch(0x003586cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_311;
  }

  // 204	[934]	LOADI    	19 1
  #undef  AOT_PC
  #define AOT_PC (code + 205)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_206
  label_204: {
    aot_vmfetch(0x80000981);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 205	[934]	LEN      	20 18
  #undef  AOT_PC
  #define AOT_PC (code + 206)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_207
  label_205: {
    aot_vmfetch(0x00120a34);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 206	[934]	LOADI    	21 1
  #undef  AOT_PC
  #define AOT_PC (code + 207)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_208
  label_206: {
    aot_vmfetch(0x80000a81);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 207	[934]	FORPREP  	19 26	; to 235
  #undef  AOT_PC
  #define AOT_PC (code + 208)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_209
  label_207: {
    aot_vmfetch(0x000d09ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_235; /* skip the loop */
  }

  // 208	[935]	SELF     	23 18 21k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 209)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_210
  label_208: {
    aot_vmfetch(0x15128b94);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 209	[935]	MOVE     	25 22
  #undef  AOT_PC
  #define AOT_PC (code + 210)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_211
  label_209: {
    aot_vmfetch(0x00160c80);
    setobjs2s(L, ra, RB(i));
  }

  // 210	[935]	MOVE     	26 22
  #undef  AOT_PC
  #define AOT_PC (code + 211)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_212
  label_210: {
    aot_vmfetch(0x00160d00);
    setobjs2s(L, ra, RB(i));
  }

  // 211	[935]	CALL     	23 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 212)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_213
  label_211: {
    aot_vmfetch(0x02040bc4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 212	[936]	EQK      	23 50 0	; "/"
  #undef  AOT_PC
  #define AOT_PC (code + 213)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_223
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_214
  label_212: {
    aot_vmfetch(0x00320bbc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 213	[936]	JMP      	9	; to 224
  #undef  AOT_PC
  #define AOT_PC (code + 214)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_215
  label_213: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_223;
  }

  // 214	[936]	SELF     	24 18 21k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 215)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_216
  label_214: {
    aot_vmfetch(0x15128c14);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 215	[936]	ADDI     	26 22 1
  #undef  AOT_PC
  #define AOT_PC (code + 216)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_217
  label_215: {
    aot_vmfetch(0x80160d15);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 216	[936]	MMBINI   	22 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 217)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_218
  label_216: {
    aot_vmfetch(0x06800b2f);
    Instruction pi = 0x80160d15;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 217	[936]	ADDI     	27 22 1
  #undef  AOT_PC
  #define AOT_PC (code + 218)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_219
  label_217: {
    aot_vmfetch(0x80160d95);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 218	[936]	MMBINI   	22 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 219)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_220
  label_218: {
    aot_vmfetch(0x06800b2f);
    Instruction pi = 0x80160d95;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 219	[936]	CALL     	24 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 220)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_221
  label_219: {
    aot_vmfetch(0x02040c44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 220	[936]	EQK      	24 51 0	; "*"
  #undef  AOT_PC
  #define AOT_PC (code + 221)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_223
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_222
  label_220: {
    aot_vmfetch(0x00330c3c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 221	[936]	JMP      	1	; to 224
  #undef  AOT_PC
  #define AOT_PC (code + 222)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_223
  label_221: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_223;
  }

  // 222	[937]	LOADTRUE 	12
  #undef  AOT_PC
  #define AOT_PC (code + 223)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_224
  label_222: {
    aot_vmfetch(0x00000607);
    setbtvalue(s2v(ra));
  }

  // 223	[939]	EQK      	23 51 0	; "*"
  #undef  AOT_PC
  #define AOT_PC (code + 224)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_234
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_225
  label_223: {
    aot_vmfetch(0x00330bbc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 224	[939]	JMP      	9	; to 235
  #undef  AOT_PC
  #define AOT_PC (code + 225)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_226
  label_224: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_234;
  }

  // 225	[939]	SELF     	24 18 21k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 226)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_227
  label_225: {
    aot_vmfetch(0x15128c14);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 226	[939]	ADDI     	26 22 1
  #undef  AOT_PC
  #define AOT_PC (code + 227)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_228
  label_226: {
    aot_vmfetch(0x80160d15);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 227	[939]	MMBINI   	22 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 228)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_229
  label_227: {
    aot_vmfetch(0x06800b2f);
    Instruction pi = 0x80160d15;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 228	[939]	ADDI     	27 22 1
  #undef  AOT_PC
  #define AOT_PC (code + 229)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_230
  label_228: {
    aot_vmfetch(0x80160d95);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 229	[939]	MMBINI   	22 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 230)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_231
  label_229: {
    aot_vmfetch(0x06800b2f);
    Instruction pi = 0x80160d95;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 230	[939]	CALL     	24 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 231)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_232
  label_230: {
    aot_vmfetch(0x02040c44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 231	[939]	EQK      	24 50 0	; "/"
  #undef  AOT_PC
  #define AOT_PC (code + 232)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_234
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_233
  label_231: {
    aot_vmfetch(0x00320c3c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 232	[939]	JMP      	1	; to 235
  #undef  AOT_PC
  #define AOT_PC (code + 233)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_234
  label_232: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_234;
  }

  // 233	[940]	LOADFALSE	12
  #undef  AOT_PC
  #define AOT_PC (code + 234)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_235
  label_233: {
    aot_vmfetch(0x00000605);
    setbfvalue(s2v(ra));
  }

  // 234	[934]	FORLOOP  	19 27	; to 209
  #undef  AOT_PC
  #define AOT_PC (code + 235)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_236
  label_234: {
    aot_vmfetch(0x000d89c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_208; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_208; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 235	[943]	TEST     	12 0
  #undef  AOT_PC
  #define AOT_PC (code + 236)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_238
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_237
  label_235: {
    aot_vmfetch(0x00000642);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 236	[943]	JMP      	1	; to 239
  #undef  AOT_PC
  #define AOT_PC (code + 237)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_311
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_238
  label_236: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_238;
  }

  // 237	[944]	JMP      	73	; to 312
  #undef  AOT_PC
  #define AOT_PC (code + 238)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_239
  label_237: {
    aot_vmfetch(0x80002438);
    updatetrap(ci);
    goto label_311;
  }

  // 238	[946]	LOADFALSE	19
  #undef  AOT_PC
  #define AOT_PC (code + 239)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_240
  label_238: {
    aot_vmfetch(0x00000985);
    setbfvalue(s2v(ra));
  }

  // 239	[947]	GETTABUP 	20 0 49	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 240)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_241
  label_239: {
    aot_vmfetch(0x31000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 240	[947]	MOVE     	21 7
  #undef  AOT_PC
  #define AOT_PC (code + 241)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_242
  label_240: {
    aot_vmfetch(0x00070a80);
    setobjs2s(L, ra, RB(i));
  }

  // 241	[947]	CALL     	20 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 242)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_243
  label_241: {
    aot_vmfetch(0x05020a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 242	[947]	TFORPREP 	20 6	; to 250
  #undef  AOT_PC
  #define AOT_PC (code + 243)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_244
  label_242: {
    aot_vmfetch(0x00030a4b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_249;
  }

  // 243	[948]	GETI     	26 25 1
  #undef  AOT_PC
  #define AOT_PC (code + 244)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_245
  label_243: {
    aot_vmfetch(0x01190d0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 244	[948]	EQ       	26 17 0
  #undef  AOT_PC
  #define AOT_PC (code + 245)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_249
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_246
  label_244: {
    aot_vmfetch(0x00110d39);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 245	[948]	JMP      	3	; to 250
  #undef  AOT_PC
  #define AOT_PC (code + 246)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_247
  label_245: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_249;
  }

  // 246	[949]	MOVE     	18 25
  #undef  AOT_PC
  #define AOT_PC (code + 247)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_248
  label_246: {
    aot_vmfetch(0x00190900);
    setobjs2s(L, ra, RB(i));
  }

  // 247	[950]	LOADTRUE 	19
  #undef  AOT_PC
  #define AOT_PC (code + 248)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_251
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_249
  label_247: {
    aot_vmfetch(0x00000987);
    setbtvalue(s2v(ra));
  }

  // 248	[951]	JMP      	2	; to 252
  #undef  AOT_PC
  #define AOT_PC (code + 249)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_250
  label_248: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_251;
  }

  // 249	[947]	TFORCALL 	20 2
  #undef  AOT_PC
  #define AOT_PC (code + 250)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_251
  label_249: {
    aot_vmfetch(0x02000a4c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 250	[947]	TFORLOOP 	20 8	; to 244
  #undef  AOT_PC
  #define AOT_PC (code + 251)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_252
  label_250: {
    aot_vmfetch(0x00040a4d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_243; /* jump back */
    }
  }

  // 251	[953]	CLOSE    	20
  #undef  AOT_PC
  #define AOT_PC (code + 252)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_253
  label_251: {
    aot_vmfetch(0x00000a36);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 252	[954]	TEST     	19 1
  #undef  AOT_PC
  #define AOT_PC (code + 253)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_258
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_254
  label_252: {
    aot_vmfetch(0x000089c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 253	[954]	JMP      	4	; to 259
  #undef  AOT_PC
  #define AOT_PC (code + 254)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_255
  label_253: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_258;
  }

  // 254	[955]	TEST     	11 1
  #undef  AOT_PC
  #define AOT_PC (code + 255)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_311
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_256
  label_254: {
    aot_vmfetch(0x000085c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 255	[955]	JMP      	55	; to 312
  #undef  AOT_PC
  #define AOT_PC (code + 256)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_257
  label_255: {
    aot_vmfetch(0x80001b38);
    updatetrap(ci);
    goto label_311;
  }

  // 256	[956]	SETTABLE 	9 17 52k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 257)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_311
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_258
  label_256: {
    aot_vmfetch(0x34118490);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 257	[958]	JMP      	53	; to 312
  #undef  AOT_PC
  #define AOT_PC (code + 258)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_259
  label_257: {
    aot_vmfetch(0x80001a38);
    updatetrap(ci);
    goto label_311;
  }

  // 258	[970]	CLOSURE  	20 2	; 0x7ff6dba10b90
  #undef  AOT_PC
  #define AOT_PC (code + 259)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_260
  label_258: {
    aot_vmfetch(0x00010a4f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 259	[962]	SETTABUP 	0 53 20	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 260)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_261
  label_259: {
    aot_vmfetch(0x1435000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 260	[973]	GETI     	20 18 2
  #undef  AOT_PC
  #define AOT_PC (code + 261)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_262
  label_260: {
    aot_vmfetch(0x02120a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 261	[973]	SELF     	20 20 21k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 262)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_263
  label_261: {
    aot_vmfetch(0x15148a14);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 262	[973]	LOADI    	22 2
  #undef  AOT_PC
  #define AOT_PC (code + 263)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_264
  label_262: {
    aot_vmfetch(0x80008b01);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 263	[973]	LOADI    	23 2
  #undef  AOT_PC
  #define AOT_PC (code + 264)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_265
  label_263: {
    aot_vmfetch(0x80008b81);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 264	[973]	CALL     	20 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 265)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_266
  label_264: {
    aot_vmfetch(0x02040a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 265	[973]	EQK      	20 54 0	; "!"
  #undef  AOT_PC
  #define AOT_PC (code + 266)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_270
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_267
  label_265: {
    aot_vmfetch(0x00360a3c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 266	[973]	JMP      	3	; to 271
  #undef  AOT_PC
  #define AOT_PC (code + 267)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_268
  label_266: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_270;
  }

  // 267	[974]	GETI     	20 18 1
  #undef  AOT_PC
  #define AOT_PC (code + 268)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_269
  label_267: {
    aot_vmfetch(0x01120a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 268	[974]	SETTABLE 	9 20 52k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 269)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_270
  label_268: {
    aot_vmfetch(0x34148490);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 269	[975]	RETURN   	20 1 5	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 270)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_271
  label_269: {
    aot_vmfetch(0x05018a46);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 270	[978]	GETTABUP 	20 0 55	; _ENV "switch"
  #undef  AOT_PC
  #define AOT_PC (code + 271)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_272
  label_270: {
    aot_vmfetch(0x37000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 271	[978]	GETI     	21 18 2
  #undef  AOT_PC
  #define AOT_PC (code + 272)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_273
  label_271: {
    aot_vmfetch(0x02120a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 272	[978]	SELF     	21 21 56k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 273)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_274
  label_272: {
    aot_vmfetch(0x38158a94);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 273	[978]	LOADK    	23 57	; "%S+"
  #undef  AOT_PC
  #define AOT_PC (code + 274)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_275
  label_273: {
    aot_vmfetch(0x001c8b83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 274	[978]	CALL     	21 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 275)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_276
  label_274: {
    aot_vmfetch(0x02030ac4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 275	[978]	NEWTABLE 	22 5 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 276)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_277
  label_275: {
    aot_vmfetch(0x00050b13);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 276	[978]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 277)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_278
  label_276: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 277	[993]	CLOSURE  	23 3	; 0x7ff6dba11960
  #undef  AOT_PC
  #define AOT_PC (code + 278)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_279
  label_277: {
    aot_vmfetch(0x00018bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 278	[993]	SETFIELD 	22 58 23	; "#open"
  #undef  AOT_PC
  #define AOT_PC (code + 279)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_280
  label_278: {
    aot_vmfetch(0x173a0b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 279	[1041]	CLOSURE  	23 4	; 0x7ff6dba11ee0
  #undef  AOT_PC
  #define AOT_PC (code + 280)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_281
  label_279: {
    aot_vmfetch(0x00020bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 280	[1041]	SETFIELD 	22 59 23	; "#define"
  #undef  AOT_PC
  #define AOT_PC (code + 281)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_282
  label_280: {
    aot_vmfetch(0x173b0b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 281	[1089]	CLOSURE  	23 5	; 0x7ff6dba12110
  #undef  AOT_PC
  #define AOT_PC (code + 282)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_283
  label_281: {
    aot_vmfetch(0x00028bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 282	[1089]	SETFIELD 	22 60 23	; "##line"
  #undef  AOT_PC
  #define AOT_PC (code + 283)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_284
  label_282: {
    aot_vmfetch(0x173c0b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 283	[1139]	CLOSURE  	23 6	; 0x7ff6dba12f40
  #undef  AOT_PC
  #define AOT_PC (code + 284)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_285
  label_283: {
    aot_vmfetch(0x00030bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 284	[1139]	SETFIELD 	22 61 23	; "##include"
  #undef  AOT_PC
  #define AOT_PC (code + 285)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_286
  label_284: {
    aot_vmfetch(0x173d0b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 285	[1176]	CLOSURE  	23 7	; 0x7ff6dba136f0
  #undef  AOT_PC
  #define AOT_PC (code + 286)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_287
  label_285: {
    aot_vmfetch(0x00038bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 286	[1176]	SETFIELD 	22 62 23	; "#if"
  #undef  AOT_PC
  #define AOT_PC (code + 287)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_288
  label_286: {
    aot_vmfetch(0x173e0b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 287	[1213]	CLOSURE  	23 8	; 0x7ff6db905ec0
  #undef  AOT_PC
  #define AOT_PC (code + 288)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_289
  label_287: {
    aot_vmfetch(0x00040bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 288	[1213]	SETFIELD 	22 63 23	; "#ifdef"
  #undef  AOT_PC
  #define AOT_PC (code + 289)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_290
  label_288: {
    aot_vmfetch(0x173f0b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 289	[1250]	CLOSURE  	23 9	; 0x7ff6db906820
  #undef  AOT_PC
  #define AOT_PC (code + 290)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_291
  label_289: {
    aot_vmfetch(0x00048bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 290	[1250]	SETFIELD 	22 64 23	; "#ifndef"
  #undef  AOT_PC
  #define AOT_PC (code + 291)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_292
  label_290: {
    aot_vmfetch(0x17400b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 291	[1290]	CLOSURE  	23 10	; 0x7ff6db906fc0
  #undef  AOT_PC
  #define AOT_PC (code + 292)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_293
  label_291: {
    aot_vmfetch(0x00050bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 292	[1290]	SETFIELD 	22 65 23	; "#elif"
  #undef  AOT_PC
  #define AOT_PC (code + 293)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_294
  label_292: {
    aot_vmfetch(0x17410b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 293	[1294]	CLOSURE  	23 11	; 0x7ff6dbb04720
  #undef  AOT_PC
  #define AOT_PC (code + 294)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_295
  label_293: {
    aot_vmfetch(0x00058bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 294	[1294]	SETFIELD 	22 66 23	; "#else"
  #undef  AOT_PC
  #define AOT_PC (code + 295)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_296
  label_294: {
    aot_vmfetch(0x17420b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 295	[1299]	CLOSURE  	23 12	; 0x7ff6dbb04830
  #undef  AOT_PC
  #define AOT_PC (code + 296)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_297
  label_295: {
    aot_vmfetch(0x00060bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 296	[1299]	SETFIELD 	22 67 23	; "#endif"
  #undef  AOT_PC
  #define AOT_PC (code + 297)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_298
  label_296: {
    aot_vmfetch(0x17430b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 297	[1309]	CLOSURE  	23 13	; 0x7ff6dbb04980
  #undef  AOT_PC
  #define AOT_PC (code + 298)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_299
  label_297: {
    aot_vmfetch(0x00068bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 298	[1309]	SETFIELD 	22 68 23	; "#undef"
  #undef  AOT_PC
  #define AOT_PC (code + 299)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_300
  label_298: {
    aot_vmfetch(0x17440b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 299	[1315]	CLOSURE  	23 14	; 0x7ff6dbb04b10
  #undef  AOT_PC
  #define AOT_PC (code + 300)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_301
  label_299: {
    aot_vmfetch(0x00070bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 300	[1315]	SETFIELD 	22 69 23	; "#error"
  #undef  AOT_PC
  #define AOT_PC (code + 301)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_302
  label_300: {
    aot_vmfetch(0x17450b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 301	[1320]	CLOSURE  	23 15	; 0x7ff6dbb04dd0
  #undef  AOT_PC
  #define AOT_PC (code + 302)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_303
  label_301: {
    aot_vmfetch(0x00078bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 302	[1320]	SETFIELD 	22 70 23	; "#warning"
  #undef  AOT_PC
  #define AOT_PC (code + 303)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_304
  label_302: {
    aot_vmfetch(0x17460b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 303	[1323]	CLOSURE  	23 16	; 0x7ff6dbb050f0
  #undef  AOT_PC
  #define AOT_PC (code + 304)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_305
  label_303: {
    aot_vmfetch(0x00080bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 304	[1323]	SETFIELD 	22 71 23	; "#config"
  #undef  AOT_PC
  #define AOT_PC (code + 305)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_306
  label_304: {
    aot_vmfetch(0x17470b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 305	[1327]	CLOSURE  	23 17	; 0x7ff6dbb051c0
  #undef  AOT_PC
  #define AOT_PC (code + 306)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_307
  label_305: {
    aot_vmfetch(0x00088bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 306	[1327]	SETFIELD 	22 72 23	; "#ext"
  #undef  AOT_PC
  #define AOT_PC (code + 307)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_308
  label_306: {
    aot_vmfetch(0x17480b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 307	[1347]	CLOSURE  	23 18	; 0x7ff6dbb05310
  #undef  AOT_PC
  #define AOT_PC (code + 308)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_309
  label_307: {
    aot_vmfetch(0x00090bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 308	[1347]	SETFIELD 	22 73 23	; "default"
  #undef  AOT_PC
  #define AOT_PC (code + 309)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_310
  label_308: {
    aot_vmfetch(0x17490b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 309	[978]	CALL     	20 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 310)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_311
  label_309: {
    aot_vmfetch(0x01030a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 310	[1350]	CLOSE    	17
  #undef  AOT_PC
  #define AOT_PC (code + 311)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_312
  label_310: {
    aot_vmfetch(0x000008b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 311	[930]	TFORCALL 	13 2
  #undef  AOT_PC
  #define AOT_PC (code + 312)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_313
  label_311: {
    aot_vmfetch(0x020006cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 312	[930]	TFORLOOP 	13 109	; to 205
  #undef  AOT_PC
  #define AOT_PC (code + 313)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_314
  label_312: {
    aot_vmfetch(0x003686cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_204; /* jump back */
    }
  }

  // 313	[1353]	LEN      	13 10
  #undef  AOT_PC
  #define AOT_PC (code + 314)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_315
  label_313: {
    aot_vmfetch(0x000a06b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 314	[1353]	GTI      	13 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 315)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_319
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_316
  label_314: {
    aot_vmfetch(0x007f06c0);
    op_orderI(L, l_gti, luai_numgt, 1, TM_LT);
  }

  // 315	[1353]	JMP      	3	; to 320
  #undef  AOT_PC
  #define AOT_PC (code + 316)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_317
  label_315: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_319;
  }

  // 316	[1354]	GETTABUP 	13 0 74	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 317)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_318
  label_316: {
    aot_vmfetch(0x4a00068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 317	[1354]	LOADK    	14 75	; "Missing #endif(s)"
  #undef  AOT_PC
  #define AOT_PC (code + 318)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_319
  label_317: {
    aot_vmfetch(0x00258703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 318	[1354]	CALL     	13 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 319)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_320
  label_318: {
    aot_vmfetch(0x010206c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 319	[1356]	LOADNIL  	6 1	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 320)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_321
  label_319: {
    aot_vmfetch(0x00010308);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 320	[1358]	LOADNIL  	0 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 321)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_322
  label_320: {
    aot_vmfetch(0x00000008);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 321	[1359]	LOADK    	13 76	; "/* Preprocessed with the built in Cobalt preprocessor */\n\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 322)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_323
  label_321: {
    aot_vmfetch(0x00260683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 322	[1360]	GETTABUP 	14 0 77	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 323)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_324
  label_322: {
    aot_vmfetch(0x4d00070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 323	[1360]	MOVE     	15 9
  #undef  AOT_PC
  #define AOT_PC (code + 324)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_325
  label_323: {
    aot_vmfetch(0x00090780);
    setobjs2s(L, ra, RB(i));
  }

  // 324	[1360]	CALL     	14 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 325)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_326
  label_324: {
    aot_vmfetch(0x05020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 325	[1360]	TFORPREP 	14 8	; to 335
  #undef  AOT_PC
  #define AOT_PC (code + 326)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_327
  label_325: {
    aot_vmfetch(0x0004074b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_334;
  }

  // 326	[1361]	EQK      	19 78 0	; null
  #undef  AOT_PC
  #define AOT_PC (code + 327)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_329
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_328
  label_326: {
    aot_vmfetch(0x004e09bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 327	[1361]	JMP      	1	; to 330
  #undef  AOT_PC
  #define AOT_PC (code + 328)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_334
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_329
  label_327: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_329;
  }

  // 328	[1362]	JMP      	5	; to 335
  #undef  AOT_PC
  #define AOT_PC (code + 329)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_330
  label_328: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_334;
  }

  // 329	[1364]	MOVE     	20 13
  #undef  AOT_PC
  #define AOT_PC (code + 330)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_331
  label_329: {
    aot_vmfetch(0x000d0a00);
    setobjs2s(L, ra, RB(i));
  }

  // 330	[1364]	MOVE     	21 19
  #undef  AOT_PC
  #define AOT_PC (code + 331)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_332
  label_330: {
    aot_vmfetch(0x00130a80);
    setobjs2s(L, ra, RB(i));
  }

  // 331	[1364]	LOADK    	22 79	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 332)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_333
  label_331: {
    aot_vmfetch(0x00278b03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 332	[1364]	CONCAT   	20 3
  #undef  AOT_PC
  #define AOT_PC (code + 333)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_334
  label_332: {
    aot_vmfetch(0x00030a35);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 333	[1364]	MOVE     	13 20
  #undef  AOT_PC
  #define AOT_PC (code + 334)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_335
  label_333: {
    aot_vmfetch(0x00140680);
    setobjs2s(L, ra, RB(i));
  }

  // 334	[1360]	TFORCALL 	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 335)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_336
  label_334: {
    aot_vmfetch(0x0200074c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 335	[1360]	TFORLOOP 	14 10	; to 327
  #undef  AOT_PC
  #define AOT_PC (code + 336)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_337
  label_335: {
    aot_vmfetch(0x0005074d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_326; /* jump back */
    }
  }

  // 336	[1365]	CLOSE    	14
  #undef  AOT_PC
  #define AOT_PC (code + 337)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_338
  label_336: {
    aot_vmfetch(0x00000736);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 337	[1366]	LOADNIL  	9 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 338)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_339
  label_337: {
    aot_vmfetch(0x00000488);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 338	[1367]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 339)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_350
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_340
  label_338: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 339	[1367]	JMP      	10	; to 351
  #undef  AOT_PC
  #define AOT_PC (code + 340)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_341
  label_339: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_350;
  }

  // 340	[1369]	GETTABUP 	14 0 80	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 341)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_342
  label_340: {
    aot_vmfetch(0x5000070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 341	[1369]	GETFIELD 	14 14 81	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 342)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_343
  label_341: {
    aot_vmfetch(0x510e070e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 342	[1369]	MOVE     	15 3
  #undef  AOT_PC
  #define AOT_PC (code + 343)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_344
  label_342: {
    aot_vmfetch(0x00030780);
    setobjs2s(L, ra, RB(i));
  }

  // 343	[1369]	LOADK    	16 82	; "w"
  #undef  AOT_PC
  #define AOT_PC (code + 344)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_345
  label_343: {
    aot_vmfetch(0x00290803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 344	[1369]	CALL     	14 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 345)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_346
  label_344: {
    aot_vmfetch(0x02030744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 345	[1370]	SELF     	15 14 83k	; "write"
  #undef  AOT_PC
  #define AOT_PC (code + 346)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_347
  label_345: {
    aot_vmfetch(0x530e8794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 346	[1370]	MOVE     	17 13
  #undef  AOT_PC
  #define AOT_PC (code + 347)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_348
  label_346: {
    aot_vmfetch(0x000d0880);
    setobjs2s(L, ra, RB(i));
  }

  // 347	[1370]	CALL     	15 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 348)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_349
  label_347: {
    aot_vmfetch(0x010307c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 348	[1371]	SELF     	15 14 84k	; "close"
  #undef  AOT_PC
  #define AOT_PC (code + 349)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_350
  label_348: {
    aot_vmfetch(0x540e8794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 349	[1371]	CALL     	15 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 350)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_351
  label_349: {
    aot_vmfetch(0x010207c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 350	[1373]	GETTABUP 	14 0 85	; _ENV "collectgarbage"
  #undef  AOT_PC
  #define AOT_PC (code + 351)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_352
  label_350: {
    aot_vmfetch(0x5500070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 351	[1373]	CALL     	14 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 352)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_353
  label_351: {
    aot_vmfetch(0x01010744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 352	[1374]	RETURN   	13 2 5	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 353)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_352: {
    aot_vmfetch(0x050286c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 353	[1375]	RETURN   	14 1 5	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 354)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_353: {
    aot_vmfetch(0x05018746);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 852 - 859
static
CallInfo *magic_implementation_76(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
  }

  // 0	[853]	GETUPVAL 	0 0	; ogstr
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[853]	TEST     	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 2	[853]	JMP      	9	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_12;
  }

  // 3	[855]	GETTABUP 	0 1 0	; _ENV "filex"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0001000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[855]	GETFIELD 	0 0 1	; "join"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100000e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[855]	GETTABUP 	1 1 2	; _ENV "filesystem"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0201008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[855]	GETFIELD 	1 1 3	; "currentdir"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[855]	CALL     	1 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x020100c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[855]	GETUPVAL 	2 0	; ogstr
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 9	[855]	TAILCALL 	0 3 0	; 2 in
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00030045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 10	[855]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 11	[856]	JMP      	10	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_22;
  }

  // 12	[857]	GETTABUP 	0 1 4	; _ENV "debug"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0401000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[857]	GETFIELD 	0 0 5	; "getinfo"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0500000e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 14	[857]	LOADI    	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80008081);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 15	[857]	LOADK    	2 6	; "S"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00030103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 16	[857]	CALL     	0 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x02030044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 17	[857]	GETFIELD 	0 0 7	; "source"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0700000e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 18	[857]	SELF     	0 0 8k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x08008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[857]	LOADI    	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x80008101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 20	[857]	TAILCALL 	0 3 0	; 2 in
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00030045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 21	[857]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_21: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 22	[859]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_22: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 907 - 929
static
CallInfo *magic_implementation_77(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
  }

  // 0	[908]	LOADK    	1 0	; "{"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[909]	GETTABUP 	2 0 1	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[909]	GETUPVAL 	3 1	; env
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[909]	CALL     	2 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x05020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[909]	TFORPREP 	2 26	; to 32
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000d014b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_31;
  }

  // 5	[910]	GETTABUP 	8 0 2	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[910]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 7	[910]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[910]	EQK      	8 3 0	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_16
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0003043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 9	[910]	JMP      	6	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_16;
  }

  // 10	[911]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 11	[911]	MOVE     	9 7
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00070480);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[911]	LOADK    	10 4	; ","
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00020503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[911]	CONCAT   	8 3
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00030435);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 14	[911]	MOVE     	1 8
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_31
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00080080);
    setobjs2s(L, ra, RB(i));
  }

  // 15	[912]	JMP      	15	; to 32
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000738);
    updatetrap(ci);
    goto label_31;
  }

  // 16	[912]	GETTABUP 	8 0 2	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0200040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[912]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 18	[912]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[912]	EQK      	8 5 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_31
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0005043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 20	[912]	JMP      	10	; to 32
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_31;
  }

  // 21	[913]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[913]	LOADK    	9 6	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00030483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 23	[913]	MOVE     	10 6
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00060500);
    setobjs2s(L, ra, RB(i));
  }

  // 24	[913]	LOADK    	11 7	; "\": "
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00038583);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 25	[913]	GETTABUP 	12 0 8	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x0800060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 26	[913]	MOVE     	13 7
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00070680);
    setobjs2s(L, ra, RB(i));
  }

  // 27	[913]	CALL     	12 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x02020644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 28	[913]	LOADK    	13 4	; ","
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00020683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 29	[913]	CONCAT   	8 6
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00060435);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 30	[913]	MOVE     	1 8
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00080080);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[909]	TFORCALL 	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x0200014c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 32	[909]	TFORLOOP 	2 28	; to 6
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x000e014d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_05; /* jump back */
    }
  }

  // 33	[915]	CLOSE    	2
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x00000136);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 34	[916]	MOVE     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00010100);
    setobjs2s(L, ra, RB(i));
  }

  // 35	[916]	LOADK    	3 9	; "}"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x00048183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 36	[916]	CONCAT   	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00020135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 37	[916]	MOVE     	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00020080);
    setobjs2s(L, ra, RB(i));
  }

  // 38	[917]	GETTABUP 	2 0 10	; _ENV "loadstring"
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x0a00010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 39	[918]	LOADK    	3 11	; "// Cobalt execution environment: Ignore.\n            env = "
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00058183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 40	[918]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 41	[928]	LOADK    	5 12	; ";\n            for (i, v in pairs(env)){\n                _ENV[i] = v\n            }\n            core = import(\"core\")\n            function defined(val){\n                // check if it is in env, if it return the value\n                if (env[val] != null && env[val] != false) {\n                    return env[val]\n                }\n            }"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x00060283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 42	[928]	MOVE     	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x00000300);
    setobjs2s(L, ra, RB(i));
  }

  // 43	[928]	CONCAT   	3 4
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x000401b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 44	[917]	TAILCALL 	2 2 0	; 1 in
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x00028145);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 45	[928]	RETURN   	2 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_45: {
    aot_vmfetch(0x00008146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 46	[929]	RETURN   	2 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_46: {
    aot_vmfetch(0x00018146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 962 - 970
static
CallInfo *magic_implementation_78(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
  }

  // 0	[963]	GETTABUP 	1 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[963]	LOADK    	2 1	; "\027[1;31mPreprocessor error:\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[963]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[964]	GETTABUP 	1 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[964]	LOADK    	2 2	; "\027[1;31mError with the '"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[964]	GETUPVAL 	3 1	; v
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[964]	GETI     	3 3 2
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0203018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 7	[964]	LOADK    	4 3	; "' preprocessor command.\027[0m\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00018203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 8	[964]	CONCAT   	2 3
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00030135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 9	[964]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[965]	TEST     	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_18
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 11	[965]	JMP      	6	; to 19
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_18;
  }

  // 12	[966]	GETTABUP 	1 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[966]	LOADK    	2 4	; "\027[1;31m"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00020103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 14	[966]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 15	[966]	LOADK    	4 5	; "\027[0m\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00028203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 16	[966]	CONCAT   	2 3
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00030135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 17	[966]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[968]	GETTABUP 	1 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 19	[968]	LOADK    	2 6	; "\027[1;31mStopping preprocessor.\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00030103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 20	[968]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 21	[969]	GETTABUP 	1 0 7	; _ENV "os"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0700008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 22	[969]	GETFIELD 	1 1 8	; "exit"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0801008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 23	[969]	CALL     	1 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_23: {
    aot_vmfetch(0x010100c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[970]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_24: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 979 - 993
static
CallInfo *magic_implementation_79(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
  }

  // 0	[984]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[984]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[984]	SELF     	0 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[984]	LOADK    	2 1	; "#open "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[984]	LOADK    	3 2	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[984]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[985]	GETUPVAL 	1 1	; env
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[985]	GETTABLE 	1 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0001008c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[986]	EQK      	1 3 0	; null
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_16
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x000300bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 9	[986]	JMP      	6	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_16;
  }

  // 10	[987]	GETTABUP 	2 2 4	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0402010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 11	[987]	LOADK    	3 5	; "Macro '"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00028183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 12	[987]	MOVE     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000200);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[987]	LOADK    	5 6	; "' is not defined"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00030283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 14	[987]	CONCAT   	3 3
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x000301b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 15	[987]	CALL     	2 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x01020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[989]	GETUPVAL 	2 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 17	[989]	GETI     	3 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0102018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 18	[989]	GETUPVAL 	2 3	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00030109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 19	[989]	LOADK    	4 7	; "var "
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00038203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 20	[989]	GETTABUP 	5 2 8	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0802028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 21	[989]	MOVE     	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00000300);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[989]	CALL     	5 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x020202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 23	[989]	LOADK    	6 9	; " = "
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00048303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 24	[989]	GETTABUP 	7 2 10	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0a02038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 25	[989]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 26	[989]	CALL     	7 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x020203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 27	[989]	EQK      	7 11 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000b03bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 28	[989]	JMP      	13	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_42;
  }

  // 29	[989]	GETUPVAL 	7 4	; str
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00040389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 30	[989]	SELF     	7 7 12k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x0c078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 31	[989]	LOADI    	9 1
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x80000481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 32	[989]	LOADI    	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x80000501);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 33	[989]	CALL     	7 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x020403c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 34	[989]	EQK      	7 13 0	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x000d03bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 35	[989]	JMP      	6	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_42;
  }

  // 36	[989]	GETUPVAL 	7 4	; str
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00040389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 37	[989]	SELF     	7 7 12k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x0c078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 38	[989]	LOADI    	9 -1
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x7fff0481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 39	[989]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 40	[989]	EQK      	7 13 1	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_55
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x000d83bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 41	[989]	JMP      	13	; to 56
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_55;
  }

  // 42	[989]	GETUPVAL 	7 4	; str
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x00040389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 43	[989]	SELF     	7 7 12k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0c078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 44	[989]	LOADI    	9 1
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x80000481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 45	[989]	LOADI    	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x80000501);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 46	[989]	CALL     	7 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x020403c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 47	[989]	EQK      	7 14 0	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_60
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x000e03bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 48	[989]	JMP      	11	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x80000538);
    updatetrap(ci);
    goto label_60;
  }

  // 49	[989]	GETUPVAL 	7 4	; str
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00040389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 50	[989]	SELF     	7 7 12k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0c078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 51	[989]	LOADI    	9 -1
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x7fff0481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 52	[989]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 53	[989]	EQK      	7 14 0	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_60
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x000e03bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 54	[989]	JMP      	5	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_60;
  }

  // 55	[989]	LOADK    	7 13	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x00068383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 56	[989]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 57	[989]	LOADK    	9 13	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00068483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 58	[989]	CONCAT   	7 3
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_64
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x000303b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 59	[989]	JMP      	4	; to 65
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_64;
  }

  // 60	[989]	GETTABUP 	8 2 8	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x0802040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 61	[989]	MOVE     	9 1
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x00010480);
    setobjs2s(L, ra, RB(i));
  }

  // 62	[989]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 63	[989]	MOVE     	7 8
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x00080380);
    setobjs2s(L, ra, RB(i));
  }

  // 64	[989]	CONCAT   	4 4
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x00040235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 65	[989]	SETTABLE 	2 3 4
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x04030110);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 66	[992]	LOADNIL  	2 1	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x00010108);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 67	[992]	MOVE     	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x00030080);
    setobjs2s(L, ra, RB(i));
  }

  // 68	[992]	MOVE     	0 2
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_68: {
    aot_vmfetch(0x00020000);
    setobjs2s(L, ra, RB(i));
  }

  // 69	[993]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_69: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 994 - 1041
static
CallInfo *magic_implementation_80(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
  }

  // 0	[996]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[996]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[996]	SELF     	0 0 0k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[996]	LOADK    	2 1	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[996]	CALL     	0 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02030044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[998]	GETI     	1 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 6	[999]	GETTABUP 	2 1 2	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0201010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[999]	GETFIELD 	2 2 3	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0302010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[999]	MOVE     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010180);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[999]	LOADI    	4 -1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x7fff0201);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 10	[999]	CALL     	2 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x02030144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 11	[999]	EQK      	2 4 0	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_88
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0004013c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 12	[999]	JMP      	75	; to 89
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x80002538);
    updatetrap(ci);
    goto label_88;
  }

  // 13	[1006]	GETTABUP 	2 1 2	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0201010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 14	[1006]	GETFIELD 	2 2 0	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0002010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[1006]	GETUPVAL 	3 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 16	[1006]	GETI     	3 3 2
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0203018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 17	[1006]	LOADK    	4 1	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00008203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 18	[1006]	CALL     	2 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x02030144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[1007]	GETI     	3 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0202018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 20	[1007]	SELF     	3 3 0k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00038194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 21	[1007]	LOADK    	5 5	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00028283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 22	[1007]	CALL     	3 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x020301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 23	[1007]	GETI     	3 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x0103018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 24	[1008]	GETI     	4 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0202020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 25	[1008]	SELF     	4 4 0k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00048214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 26	[1008]	LOADK    	6 5	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00028303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 27	[1008]	CALL     	4 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x02030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 28	[1008]	GETI     	4 4 2
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x0204020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 29	[1008]	SELF     	4 4 6k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x06048214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 30	[1008]	LOADK    	6 7	; "%)"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00038303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 31	[1008]	LOADK    	7 8	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x00040383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 32	[1008]	CALL     	4 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x02040244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 33	[1008]	SELF     	4 4 0k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x00048214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 34	[1008]	LOADK    	6 9	; ","
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00048303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 35	[1008]	CALL     	4 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x02030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 36	[1009]	GETI     	5 2 3
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x0302028d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 37	[1010]	LOADI    	6 4
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x80018301);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 38	[1010]	LEN      	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x000203b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 39	[1010]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 40	[1010]	FORPREP  	6 5	; to 47
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x0002834a);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_47; /* skip the loop */
  }

  // 41	[1011]	MOVE     	10 5
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x00050500);
    setobjs2s(L, ra, RB(i));
  }

  // 42	[1011]	LOADK    	11 1	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x00008583);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 43	[1011]	GETTABLE 	12 2 9
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0902060c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 44	[1011]	CONCAT   	10 3
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x00030535);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 45	[1011]	MOVE     	5 10
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000a0280);
    setobjs2s(L, ra, RB(i));
  }

  // 46	[1010]	FORLOOP  	6 6	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x00030349);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_41; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_41; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 47	[1013]	GETTABUP 	6 1 10	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x0a01030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 48	[1013]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 49	[1013]	CALL     	6 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x05020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 50	[1013]	TFORPREP 	6 5	; to 57
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0002834b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_56;
  }

  // 51	[1014]	SELF     	12 11 6k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x060b8614);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 52	[1014]	LOADK    	14 1	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x00008703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 53	[1014]	LOADK    	15 8	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00040783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 54	[1014]	CALL     	12 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x02040644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 55	[1014]	SETTABLE 	4 10 12
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x0c0a0210);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 56	[1013]	TFORCALL 	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x0200034c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 57	[1013]	TFORLOOP 	6 7	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x0003834d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_51; /* jump back */
    }
  }

  // 58	[1015]	CLOSE    	6
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00000336);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 59	[1017]	LOADK    	6 11	; "function("
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x00058303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 60	[1017]	GETTABUP 	7 1 12	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x0c01038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 61	[1017]	GETFIELD 	7 7 13	; "concat"
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x0d07038e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 62	[1017]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 63	[1017]	LOADK    	9 9	; ","
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x00048483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 64	[1017]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 65	[1017]	LOADK    	8 14	; "){ return "
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x00070403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 66	[1017]	MOVE     	9 5
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x00050480);
    setobjs2s(L, ra, RB(i));
  }

  // 67	[1017]	LOADK    	10 15	; "; }"
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x00078503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 68	[1017]	CONCAT   	6 5
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x00050335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 69	[1018]	LOADK    	7 16	; "var "
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x00080383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 70	[1018]	MOVE     	8 3
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x00030400);
    setobjs2s(L, ra, RB(i));
  }

  // 71	[1018]	LOADK    	9 17	; " = "
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x00088483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 72	[1018]	MOVE     	10 6
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x00060500);
    setobjs2s(L, ra, RB(i));
  }

  // 73	[1018]	CONCAT   	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x000403b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 74	[1021]	GETUPVAL 	8 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x00000409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 75	[1021]	GETI     	9 8 1
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x0108048d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 76	[1021]	GETUPVAL 	8 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x00020409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 77	[1021]	SETTABLE 	8 9 7
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x07090410);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 78	[1022]	GETUPVAL 	8 3	; env
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x00030409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 79	[1022]	SETTABLE 	8 1 6
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x06010410);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 80	[1025]	LOADNIL  	8 5	; 6 out
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x00050408);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 81	[1025]	MOVE     	5 13
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x000d0280);
    setobjs2s(L, ra, RB(i));
  }

  // 82	[1025]	MOVE     	4 12
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x000c0200);
    setobjs2s(L, ra, RB(i));
  }

  // 83	[1025]	MOVE     	7 11
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x000b0380);
    setobjs2s(L, ra, RB(i));
  }

  // 84	[1025]	MOVE     	6 10
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x000a0300);
    setobjs2s(L, ra, RB(i));
  }

  // 85	[1025]	MOVE     	3 9
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x00090180);
    setobjs2s(L, ra, RB(i));
  }

  // 86	[1025]	MOVE     	2 8
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_131
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x00080100);
    setobjs2s(L, ra, RB(i));
  }

  // 87	[1026]	JMP      	43	; to 132
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x80001538);
    updatetrap(ci);
    goto label_131;
  }

  // 88	[1028]	LOADNIL  	2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x00000108);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 89	[1029]	GETTABUP 	3 1 18	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x1201018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 90	[1029]	LOADK    	4 19	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x00098203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 91	[1029]	GETI     	5 0 3
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x0300028d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 92	[1029]	CONCAT   	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x00020235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 93	[1029]	TEST     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_96
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x00008242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 94	[1029]	JMP      	1	; to 97
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_96;
  }

  // 95	[1029]	LOADK    	4 20	; "false"
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x000a0203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 96	[1029]	CALL     	3 2 3	; 1 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x030201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 97	[1030]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_103
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 98	[1030]	JMP      	4	; to 104
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_103;
  }

  // 99	[1031]	GETTABUP 	5 1 21	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x1501028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 100	[1031]	MOVE     	6 4
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x00040300);
    setobjs2s(L, ra, RB(i));
  }

  // 101	[1031]	CALL     	5 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_106
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x010202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 102	[1032]	JMP      	3	; to 107
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_106;
  }

  // 103	[1033]	MOVE     	5 3
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x00030280);
    setobjs2s(L, ra, RB(i));
  }

  // 104	[1033]	CALL     	5 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x020102c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 105	[1033]	MOVE     	2 5
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x00050100);
    setobjs2s(L, ra, RB(i));
  }

  // 106	[1036]	GETUPVAL 	5 3	; env
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x00030289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 107	[1036]	SETTABLE 	5 1 2
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x02010290);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 108	[1038]	GETUPVAL 	5 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x00000289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 109	[1038]	GETI     	6 5 1
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x0105030d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 110	[1038]	GETUPVAL 	5 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x00020289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 111	[1038]	LOADK    	7 16	; "var "
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x00080383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 112	[1038]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 113	[1038]	LOADK    	9 17	; " = "
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x00088483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 114	[1038]	GETTABUP 	10 1 22	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x1601050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 115	[1038]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 116	[1038]	CALL     	10 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x02020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 117	[1038]	EQK      	10 2 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_124
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x0002053c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 118	[1038]	JMP      	5	; to 125
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_124;
  }

  // 119	[1038]	LOADK    	10 23	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x000b8503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 120	[1038]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 121	[1038]	LOADK    	12 23	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x000b8603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 122	[1038]	CONCAT   	10 3
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_128
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x00030535);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 123	[1038]	JMP      	4	; to 129
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_128;
  }

  // 124	[1038]	GETTABUP 	11 1 24	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x1801058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 125	[1038]	MOVE     	12 2
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x00020600);
    setobjs2s(L, ra, RB(i));
  }

  // 126	[1038]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 127	[1038]	MOVE     	10 11
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x000b0500);
    setobjs2s(L, ra, RB(i));
  }

  // 128	[1038]	CONCAT   	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x000403b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 129	[1038]	SETTABLE 	5 6 7
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x07060290);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 130	[1039]	RETURN   	5 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_130: {
    aot_vmfetch(0x000182c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 131	[1041]	RETURN   	2 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_131: {
    aot_vmfetch(0x00018146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1042 - 1089
static
CallInfo *magic_implementation_81(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
  }

  // 0	[1048]	GETTABUP 	0 0 0	; _ENV "warn"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1048]	LOADK    	1 1	; "Using #line is not recommended, Use import() instead"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[1048]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1049]	GETUPVAL 	0 1	; v
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00010009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[1049]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 5	[1049]	SELF     	0 0 2k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 6	[1049]	LOADK    	2 3	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[1049]	CALL     	0 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x02030044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[1050]	GETI     	1 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0200008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 9	[1051]	LOADNIL  	2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000108);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 10	[1052]	GETI     	3 0 3
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0300018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 11	[1052]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_17
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 12	[1052]	JMP      	4	; to 18
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_17;
  }

  // 13	[1053]	GETTABUP 	3 0 4	; _ENV "getname"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0400018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 14	[1053]	CALL     	3 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x020101c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 15	[1053]	MOVE     	2 3
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00030100);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[1054]	JMP      	7	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_24;
  }

  // 17	[1055]	GETTABUP 	3 0 5	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0500018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 18	[1055]	GETFIELD 	3 3 6	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0603018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[1055]	GETI     	4 0 3
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0300020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 20	[1055]	LOADI    	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x80008281);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 21	[1055]	LOADI    	6 -2
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x7ffe8301);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 22	[1055]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 23	[1055]	MOVE     	2 3
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00030100);
    setobjs2s(L, ra, RB(i));
  }

  // 24	[1057]	GETTABUP 	3 0 7	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0700018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 25	[1057]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 26	[1057]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 27	[1058]	GETTABUP 	3 0 8	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0800018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 28	[1058]	GETFIELD 	3 3 9	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x0903018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 29	[1058]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 30	[1058]	CALL     	3 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x020201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 31	[1059]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_57
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 32	[1059]	JMP      	24	; to 58
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x80000bb8);
    updatetrap(ci);
    goto label_57;
  }

  // 33	[1060]	GETTABUP 	4 0 4	; _ENV "getname"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x0400020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 34	[1060]	CALL     	4 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x02010244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 35	[1061]	SELF     	5 4 10k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x0a048294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 36	[1061]	LOADK    	7 11	; "(.*/)"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00058383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 37	[1061]	CALL     	5 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x020302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 38	[1062]	EQK      	5 12 0	; null
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_41
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x000c02bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 39	[1062]	JMP      	1	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_41;
  }

  // 40	[1063]	LOADK    	5 13	; "./"
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00068283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 41	[1065]	GETTABUP 	6 0 8	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x0800030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 42	[1065]	GETFIELD 	6 6 9	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0906030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 43	[1065]	MOVE     	7 5
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x00050380);
    setobjs2s(L, ra, RB(i));
  }

  // 44	[1065]	MOVE     	8 2
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x00020400);
    setobjs2s(L, ra, RB(i));
  }

  // 45	[1065]	CONCAT   	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000203b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 46	[1065]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 47	[1065]	MOVE     	3 6
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00060180);
    setobjs2s(L, ra, RB(i));
  }

  // 48	[1066]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_57
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 49	[1066]	JMP      	7	; to 58
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_57;
  }

  // 50	[1067]	GETTABUP 	6 0 14	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0e00030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 51	[1067]	LOADK    	7 15	; "File '"
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00078383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 52	[1067]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 53	[1067]	MOVE     	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00020480);
    setobjs2s(L, ra, RB(i));
  }

  // 54	[1067]	LOADK    	10 16	; "' not found"
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x00080503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 55	[1067]	CONCAT   	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x000403b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 56	[1067]	CALL     	6 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x01020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 57	[1071]	SELF     	4 3 17k	; "read"
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x11038214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 58	[1071]	LOADK    	6 18	; "*all"
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00090303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 59	[1071]	CALL     	4 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x02030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 60	[1072]	SELF     	5 3 19k	; "close"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x13038294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 61	[1072]	CALL     	5 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x010202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 62	[1074]	GETTABUP 	5 0 20	; _ENV "process"
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x1400028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 63	[1074]	MOVE     	6 4
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x00040300);
    setobjs2s(L, ra, RB(i));
  }

  // 64	[1074]	LOADNIL  	7 1	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x00010388);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 65	[1074]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 66	[1074]	MOVE     	4 5
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x00050200);
    setobjs2s(L, ra, RB(i));
  }

  // 67	[1076]	SELF     	5 4 2k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x02048294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 68	[1076]	LOADK    	7 21	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x000a8383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 69	[1076]	CALL     	5 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x020302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 70	[1076]	MOVE     	0 5
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x00050000);
    setobjs2s(L, ra, RB(i));
  }

  // 71	[1077]	LOADK    	5 22	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x000b0283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 72	[1078]	GETTABUP 	6 0 23	; _ENV "tonumber"
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x1700030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 73	[1078]	MOVE     	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x00010380);
    setobjs2s(L, ra, RB(i));
  }

  // 74	[1078]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 75	[1078]	LEN      	7 0
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x000003b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 76	[1078]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 77	[1078]	FORPREP  	6 5	; to 84
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x0002834a);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_84; /* skip the loop */
  }

  // 78	[1079]	MOVE     	10 5
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x00050500);
    setobjs2s(L, ra, RB(i));
  }

  // 79	[1079]	GETTABLE 	11 0 9
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x0900058c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 80	[1079]	LOADK    	12 21	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x000a8603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 81	[1079]	CONCAT   	10 3
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x00030535);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 82	[1079]	MOVE     	5 10
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x000a0280);
    setobjs2s(L, ra, RB(i));
  }

  // 83	[1078]	FORLOOP  	6 6	; to 79
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x00030349);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_78; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_78; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 84	[1081]	GETUPVAL 	6 1	; v
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x00010309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 85	[1081]	GETI     	7 6 1
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x0106038d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 86	[1081]	GETUPVAL 	6 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x00020309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 87	[1081]	SETTABLE 	6 7 5
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x05070310);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 88	[1084]	LOADNIL  	3 2	; 3 out
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x00020188);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 89	[1087]	LOADNIL  	0 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x00000008);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 90	[1088]	LOADNIL  	6 1	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x00010308);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 91	[1088]	MOVE     	1 7
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x00070080);
    setobjs2s(L, ra, RB(i));
  }

  // 92	[1088]	SETTABUP 	0 24 6	; _ENV "file"
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_92: {
    aot_vmfetch(0x0618000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 93	[1089]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_93: {
    aot_vmfetch(0x00010347);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1090 - 1139
static
CallInfo *magic_implementation_82(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
  }

  // 0	[1091]	GETTABUP 	0 0 0	; _ENV "warn"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1091]	LOADK    	1 1	; "Using #include is not recommended, Use import() instead"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[1091]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1093]	GETUPVAL 	0 1	; v
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00010009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[1093]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 5	[1093]	SELF     	0 0 2k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 6	[1093]	LOADK    	2 3	; "#include \""
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[1093]	LOADK    	3 4	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00020183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 8	[1093]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[1094]	MOVE     	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000080);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[1097]	LOADI    	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80000101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 11	[1097]	LEN      	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000001b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 12	[1097]	LOADI    	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x80000201);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 13	[1097]	FORPREP  	2 13	; to 28
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0006814a);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_28; /* skip the loop */
  }

  // 14	[1098]	SELF     	6 0 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x05008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[1098]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[1098]	MOVE     	9 5
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00050480);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[1098]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[1099]	EQK      	6 6 0	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_27
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0006033c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 19	[1099]	JMP      	7	; to 28
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_27;
  }

  // 20	[1100]	SELF     	7 0 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x05008394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 21	[1100]	LOADI    	9 1
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x80000481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 22	[1100]	ADDI     	10 5 -1
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x7e050515);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 23	[1100]	MMBINI   	5 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x078002af);
    Instruction pi = 0x7e050515;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 24	[1100]	CALL     	7 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x020403c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 25	[1100]	MOVE     	0 7
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_28
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00070000);
    setobjs2s(L, ra, RB(i));
  }

  // 26	[1101]	JMP      	1	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_28;
  }

  // 27	[1097]	FORLOOP  	2 14	; to 15
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00070149);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_14; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_14; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 28	[1105]	LOADNIL  	2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00000108);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 29	[1106]	GETTABUP 	3 0 7	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0700018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 30	[1106]	GETTABUP 	4 0 8	; _ENV "package"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x0800020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 31	[1106]	GETFIELD 	4 4 9	; "searchers"
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x0904020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 32	[1106]	CALL     	3 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x050201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 33	[1106]	TFORPREP 	3 26	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x000d01cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_60;
  }

  // 34	[1107]	GETTABUP 	9 0 10	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x0a00048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 35	[1107]	GETFIELD 	9 9 11	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x0b09048e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 36	[1107]	MOVE     	10 8
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00080500);
    setobjs2s(L, ra, RB(i));
  }

  // 37	[1107]	MOVE     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00000580);
    setobjs2s(L, ra, RB(i));
  }

  // 38	[1107]	CALL     	10 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 39	[1107]	CALL     	9 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x020004c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 40	[1107]	LEN      	9 9
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x000904b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 41	[1107]	EQI      	9 2 0
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_60
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x008104bd);
    int cond;
    int im = GETARG_sB(i);
    if (ttisinteger(s2v(ra)))
      cond = (ivalue(s2v(ra)) == im);
    else if (ttisfloat(s2v(ra)))
      cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));
    else
      cond = 0;  /* other types cannot be equal to a number */
    docondjump();
  }

  // 42	[1107]	JMP      	17	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x80000838);
    updatetrap(ci);
    goto label_60;
  }

  // 43	[1107]	GETTABUP 	9 0 10	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0a00048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 44	[1107]	GETFIELD 	9 9 11	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x0b09048e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 45	[1107]	MOVE     	10 8
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x00080500);
    setobjs2s(L, ra, RB(i));
  }

  // 46	[1107]	MOVE     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x00000580);
    setobjs2s(L, ra, RB(i));
  }

  // 47	[1107]	CALL     	10 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 48	[1107]	CALL     	9 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x020004c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 49	[1107]	GETI     	9 9 1
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x0109048d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 50	[1107]	EQK      	9 12 1	; null
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_60
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x000c84bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 51	[1107]	JMP      	8	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_60;
  }

  // 52	[1108]	GETTABUP 	9 0 10	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x0a00048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 53	[1108]	GETFIELD 	9 9 11	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x0b09048e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 54	[1108]	MOVE     	10 8
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x00080500);
    setobjs2s(L, ra, RB(i));
  }

  // 55	[1108]	MOVE     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x00000580);
    setobjs2s(L, ra, RB(i));
  }

  // 56	[1108]	CALL     	10 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x00020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 57	[1108]	CALL     	9 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x020004c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 58	[1108]	MOVE     	2 9
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_62
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00090100);
    setobjs2s(L, ra, RB(i));
  }

  // 59	[1109]	JMP      	2	; to 63
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_62;
  }

  // 60	[1106]	TFORCALL 	3 2
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x020001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 61	[1106]	TFORLOOP 	3 28	; to 35
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x000e01cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_34; /* jump back */
    }
  }

  // 62	[1111]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 63	[1112]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_88
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 64	[1112]	JMP      	23	; to 89
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x80000b38);
    updatetrap(ci);
    goto label_88;
  }

  // 65	[1113]	GETTABUP 	3 0 13	; _ENV "getname"
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x0d00018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 66	[1113]	CALL     	3 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x020101c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 67	[1114]	SELF     	4 3 14k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x0e038214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 68	[1114]	LOADK    	6 15	; "(.*/)"
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x00078303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 69	[1114]	CALL     	4 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x02030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 70	[1115]	EQK      	4 12 0	; null
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_73
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x000c023c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 71	[1115]	JMP      	1	; to 74
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_73;
  }

  // 72	[1116]	LOADK    	4 16	; "./"
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x00080203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 73	[1119]	GETTABUP 	5 0 17	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x1100028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 74	[1119]	GETFIELD 	5 5 18	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x1205028e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 75	[1119]	MOVE     	6 4
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x00040300);
    setobjs2s(L, ra, RB(i));
  }

  // 76	[1119]	MOVE     	7 0
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x00000380);
    setobjs2s(L, ra, RB(i));
  }

  // 77	[1119]	CONCAT   	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x00020335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 78	[1119]	CALL     	5 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x020202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 79	[1119]	MOVE     	2 5
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x00050100);
    setobjs2s(L, ra, RB(i));
  }

  // 80	[1120]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_88
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 81	[1120]	JMP      	6	; to 89
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_88;
  }

  // 82	[1121]	GETTABUP 	5 0 19	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x1300028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 83	[1121]	LOADK    	6 20	; "File '"
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x000a0303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 84	[1121]	MOVE     	7 0
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x00000380);
    setobjs2s(L, ra, RB(i));
  }

  // 85	[1121]	LOADK    	8 21	; "' not found"
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x000a8403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 86	[1121]	CONCAT   	6 3
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x00030335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 87	[1121]	CALL     	5 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x010202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 88	[1124]	GETTABUP 	3 0 22	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x1600018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 89	[1124]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 90	[1124]	CALL     	3 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x020201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 91	[1124]	EQK      	3 23 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_99
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x001701bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 92	[1124]	JMP      	6	; to 100
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_99;
  }

  // 93	[1125]	GETTABUP 	3 0 17	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x1100018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 94	[1125]	GETFIELD 	3 3 18	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x1203018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 95	[1125]	GETI     	4 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x0202020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 96	[1125]	CALL     	3 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x020201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 97	[1125]	MOVE     	0 3
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_100
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x00030000);
    setobjs2s(L, ra, RB(i));
  }

  // 98	[1126]	JMP      	1	; to 101
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_100;
  }

  // 99	[1127]	MOVE     	0 2
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x00020000);
    setobjs2s(L, ra, RB(i));
  }

  // 100	[1129]	SELF     	3 0 24k	; "read"
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x18008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 101	[1129]	LOADK    	5 25	; "*all"
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x000c8283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 102	[1129]	CALL     	3 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x020301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 103	[1130]	SELF     	4 0 26k	; "close"
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x1a008214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 104	[1130]	CALL     	4 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x01020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 105	[1134]	GETUPVAL 	4 1	; v
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x00010209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 106	[1134]	GETI     	5 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x0104028d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 107	[1134]	GETUPVAL 	4 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x00020209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 108	[1134]	GETTABUP 	6 0 28	; _ENV "process"
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x1c00030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 109	[1134]	MOVE     	7 3
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x00030380);
    setobjs2s(L, ra, RB(i));
  }

  // 110	[1134]	LOADNIL  	8 1	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x00010408);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 111	[1134]	CALL     	6 4 3	; 3 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x03040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 112	[1134]	SETTABUP 	0 27 7	; _ENV "newincludes"
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x071b000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 113	[1134]	SETTABLE 	4 5 6
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x06050210);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 114	[1136]	LOADNIL  	0 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x00000008);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 115	[1137]	LOADNIL  	2 1	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_115: {
    aot_vmfetch(0x00010108);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 116	[1139]	RETURN   	4 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_116: {
    aot_vmfetch(0x00018246);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1140 - 1176
static
CallInfo *magic_implementation_83(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
  }

  // 0	[1145]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1145]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[1145]	SELF     	0 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[1145]	LOADK    	2 1	; "#if "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1145]	LOADK    	3 2	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[1145]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[1147]	LOADI    	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000081);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 7	[1147]	LEN      	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000134);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 8	[1147]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 9	[1147]	FORPREP  	1 13	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_24; /* skip the loop */
  }

  // 10	[1148]	SELF     	5 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x03008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[1148]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[1148]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[1148]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[1149]	EQK      	5 4 0	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x000402bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 15	[1149]	JMP      	7	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_23;
  }

  // 16	[1150]	SELF     	6 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 17	[1150]	ADDI     	8 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x80040415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 18	[1150]	MMBINI   	4 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0680022f);
    Instruction pi = 0x80040415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 19	[1150]	LEN      	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000004b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 20	[1150]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 21	[1150]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[1151]	JMP      	1	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_24;
  }

  // 23	[1147]	FORLOOP  	1 14	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_10; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_10; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 24	[1154]	LEN      	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x000000b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 25	[1154]	LOADI    	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80000101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 26	[1154]	LOADI    	3 -1
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x7fff0181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 27	[1154]	FORPREP  	1 13	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_42; /* skip the loop */
  }

  // 28	[1155]	SELF     	5 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x03008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 29	[1155]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 30	[1155]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[1155]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[1156]	EQK      	5 5 0	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_41
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x000502bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 33	[1156]	JMP      	7	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_41;
  }

  // 34	[1157]	SELF     	6 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 35	[1157]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 36	[1157]	ADDI     	9 4 -1
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x7e040495);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 37	[1157]	MMBINI   	4 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x0780022f);
    Instruction pi = 0x7e040495;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 38	[1157]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 39	[1157]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 40	[1158]	JMP      	1	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_42;
  }

  // 41	[1154]	FORLOOP  	1 14	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_28; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_28; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 42	[1162]	GETTABUP 	1 1 6	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0601008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[1164]	CLOSURE  	2 0	; 0x7ff6db905a40
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0000014f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 44	[1166]	CLOSURE  	3 1	; 0x7ff6db905cf0
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x000081cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 45	[1162]	CALL     	1 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x030300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 46	[1167]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 47	[1167]	JMP      	3	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_51;
  }

  // 48	[1168]	GETTABUP 	3 1 7	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x0701018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 49	[1168]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 50	[1168]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 51	[1171]	GETUPVAL 	3 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 52	[1171]	GETI     	4 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x0103020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 53	[1171]	GETUPVAL 	3 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00020189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 54	[1171]	SETTABLE 	3 4 8k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x08048190);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 55	[1172]	GETTABUP 	3 1 9	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x0901018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 56	[1172]	GETFIELD 	3 3 10	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x0a03018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 57	[1172]	GETUPVAL 	4 3	; activeifs
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00030209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 58	[1172]	MOVE     	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00020280);
    setobjs2s(L, ra, RB(i));
  }

  // 59	[1172]	CALL     	3 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x010301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 60	[1175]	SETUPVAL 	2 4	; run
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_60: {
    aot_vmfetch(0x0004010a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 61	[1176]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_61: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1162 - 1164
static
CallInfo *magic_implementation_84(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
  }

  // 0	[1163]	GETTABUP 	0 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1163]	LOADK    	1 1	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[1163]	GETUPVAL 	2 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[1163]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 4	[1163]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[1163]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_20
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 6	[1163]	JMP      	13	; to 21
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_20;
  }

  // 7	[1163]	GETTABUP 	0 0 2	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0200000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[1163]	LOADK    	1 3	; "Failed to check condition\n"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00018083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[1163]	GETTABUP 	2 0 4	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 10	[1163]	GETFIELD 	2 2 5	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0502010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[1163]	GETTABUP 	3 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[1163]	LOADK    	4 1	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00008203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[1163]	GETUPVAL 	5 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00010289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 14	[1163]	CONCAT   	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00020235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 15	[1163]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[1163]	CALL     	2 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x02000144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 17	[1163]	GETI     	2 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0202010d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 18	[1163]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 19	[1163]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[1163]	TAILCALL 	0 1 0	; 0 in
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00010045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 21	[1163]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_21: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 22	[1164]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_22: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1164 - 1166
static
CallInfo *magic_implementation_85(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1165]	GETTABUP 	1 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1165]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1165]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1166]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1177 - 1213
static
CallInfo *magic_implementation_86(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
  }

  // 0	[1182]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1182]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[1182]	SELF     	0 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[1182]	LOADK    	2 1	; "#if "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1182]	LOADK    	3 2	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[1182]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[1184]	LOADI    	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000081);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 7	[1184]	LEN      	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000134);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 8	[1184]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 9	[1184]	FORPREP  	1 13	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_24; /* skip the loop */
  }

  // 10	[1185]	SELF     	5 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x03008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[1185]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[1185]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[1185]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[1186]	EQK      	5 4 0	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x000402bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 15	[1186]	JMP      	7	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_23;
  }

  // 16	[1187]	SELF     	6 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 17	[1187]	ADDI     	8 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x80040415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 18	[1187]	MMBINI   	4 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0680022f);
    Instruction pi = 0x80040415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 19	[1187]	LEN      	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000004b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 20	[1187]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 21	[1187]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[1188]	JMP      	1	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_24;
  }

  // 23	[1184]	FORLOOP  	1 14	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_10; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_10; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 24	[1191]	LEN      	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x000000b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 25	[1191]	LOADI    	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80000101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 26	[1191]	LOADI    	3 -1
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x7fff0181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 27	[1191]	FORPREP  	1 13	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_42; /* skip the loop */
  }

  // 28	[1192]	SELF     	5 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x03008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 29	[1192]	GETUPVAL 	7 1	; i
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00010389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 30	[1192]	GETUPVAL 	8 1	; i
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00010409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 31	[1192]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[1193]	EQK      	5 5 0	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_41
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x000502bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 33	[1193]	JMP      	7	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_41;
  }

  // 34	[1194]	SELF     	6 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 35	[1194]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 36	[1194]	ADDI     	9 4 -1
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x7e040495);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 37	[1194]	MMBINI   	4 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x0780022f);
    Instruction pi = 0x7e040495;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 38	[1194]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 39	[1194]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 40	[1195]	JMP      	1	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_42;
  }

  // 41	[1191]	FORLOOP  	1 14	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_28; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_28; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 42	[1199]	GETTABUP 	1 2 6	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0602008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[1201]	CLOSURE  	2 0	; 0x7ff6db906050
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0000014f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 44	[1203]	CLOSURE  	3 1	; 0x7ff6db9065d0
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x000081cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 45	[1199]	CALL     	1 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x030300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 46	[1204]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 47	[1204]	JMP      	3	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_51;
  }

  // 48	[1205]	GETTABUP 	3 2 7	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x0702018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 49	[1205]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 50	[1205]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 51	[1208]	GETUPVAL 	3 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 52	[1208]	GETI     	4 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x0103020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 53	[1208]	GETUPVAL 	3 3	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00030189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 54	[1208]	SETTABLE 	3 4 8k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x08048190);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 55	[1209]	GETTABUP 	3 2 9	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x0902018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 56	[1209]	GETFIELD 	3 3 10	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x0a03018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 57	[1209]	GETUPVAL 	4 4	; activeifs
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00040209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 58	[1209]	MOVE     	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00020280);
    setobjs2s(L, ra, RB(i));
  }

  // 59	[1209]	CALL     	3 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x010301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 60	[1212]	SETUPVAL 	2 5	; run
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_60: {
    aot_vmfetch(0x0005010a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 61	[1213]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_61: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1199 - 1201
static
CallInfo *magic_implementation_87(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
  }

  // 0	[1200]	GETTABUP 	0 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1200]	LOADK    	1 1	; "return defined(\""
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[1200]	GETUPVAL 	2 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[1200]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 4	[1200]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[1200]	LOADK    	2 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[1200]	LOADK    	3 3	; "\")"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[1200]	CONCAT   	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000300b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 8	[1200]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[1200]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_30
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 10	[1200]	JMP      	19	; to 31
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80000938);
    updatetrap(ci);
    goto label_30;
  }

  // 11	[1200]	GETTABUP 	0 0 4	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0400000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[1200]	LOADK    	1 5	; "Failed to check condition\n"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00028083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[1200]	GETTABUP 	2 0 6	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0600010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 14	[1200]	GETFIELD 	2 2 7	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0702010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[1200]	GETTABUP 	3 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 16	[1200]	LOADK    	4 8	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00040203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 17	[1200]	GETUPVAL 	5 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00010289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 18	[1200]	TEST     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_21
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x000082c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 19	[1200]	JMP      	1	; to 22
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_21;
  }

  // 20	[1200]	LOADK    	5 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00010283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 21	[1200]	CONCAT   	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00020235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 22	[1200]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 23	[1200]	CALL     	2 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x02000144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[1200]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_27
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 25	[1200]	JMP      	1	; to 28
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_27;
  }

  // 26	[1200]	LOADK    	2 9	; "Failed to error"
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00048103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 27	[1200]	GETI     	2 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0202010d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 28	[1200]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 29	[1200]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 30	[1200]	TAILCALL 	0 1 0	; 0 in
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00010045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 31	[1200]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_31: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 32	[1201]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_32: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1201 - 1203
static
CallInfo *magic_implementation_88(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1202]	GETTABUP 	1 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1202]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1202]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1203]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1214 - 1250
static
CallInfo *magic_implementation_89(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
  }

  // 0	[1219]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1219]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[1219]	SELF     	0 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[1219]	LOADK    	2 1	; "#if "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1219]	LOADK    	3 2	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[1219]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[1221]	LOADI    	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000081);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 7	[1221]	LEN      	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000134);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 8	[1221]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 9	[1221]	FORPREP  	1 13	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_24; /* skip the loop */
  }

  // 10	[1222]	SELF     	5 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x03008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[1222]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[1222]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[1222]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[1223]	EQK      	5 4 0	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x000402bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 15	[1223]	JMP      	7	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_23;
  }

  // 16	[1224]	SELF     	6 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 17	[1224]	ADDI     	8 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x80040415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 18	[1224]	MMBINI   	4 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0680022f);
    Instruction pi = 0x80040415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 19	[1224]	LEN      	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000004b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 20	[1224]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 21	[1224]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[1225]	JMP      	1	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_24;
  }

  // 23	[1221]	FORLOOP  	1 14	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_10; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_10; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 24	[1228]	LEN      	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x000000b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 25	[1228]	LOADI    	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80000101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 26	[1228]	LOADI    	3 -1
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x7fff0181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 27	[1228]	FORPREP  	1 13	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_42; /* skip the loop */
  }

  // 28	[1229]	SELF     	5 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x03008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 29	[1229]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 30	[1229]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[1229]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[1230]	EQK      	5 5 0	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_41
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x000502bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 33	[1230]	JMP      	7	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_41;
  }

  // 34	[1231]	SELF     	6 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 35	[1231]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 36	[1231]	ADDI     	9 4 -1
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x7e040495);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 37	[1231]	MMBINI   	4 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x0780022f);
    Instruction pi = 0x7e040495;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 38	[1231]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 39	[1231]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 40	[1232]	JMP      	1	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_42;
  }

  // 41	[1228]	FORLOOP  	1 14	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_28; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_28; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 42	[1236]	GETTABUP 	1 1 6	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0601008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[1238]	CLOSURE  	2 0	; 0x7ff6db906970
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0000014f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 44	[1240]	CLOSURE  	3 1	; 0x7ff6db906df0
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x000081cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 45	[1236]	CALL     	1 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x030300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 46	[1241]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 47	[1241]	JMP      	3	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_51;
  }

  // 48	[1242]	GETTABUP 	3 1 7	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x0701018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 49	[1242]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 50	[1242]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 51	[1245]	GETUPVAL 	3 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 52	[1245]	GETI     	4 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x0103020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 53	[1245]	GETUPVAL 	3 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00020189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 54	[1245]	SETTABLE 	3 4 8k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x08048190);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 55	[1246]	GETTABUP 	3 1 9	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x0901018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 56	[1246]	GETFIELD 	3 3 10	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x0a03018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 57	[1246]	GETUPVAL 	4 3	; activeifs
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00030209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 58	[1246]	MOVE     	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00020280);
    setobjs2s(L, ra, RB(i));
  }

  // 59	[1246]	CALL     	3 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x010301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 60	[1249]	SETUPVAL 	2 4	; run
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_60: {
    aot_vmfetch(0x0004010a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 61	[1250]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_61: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1236 - 1238
static
CallInfo *magic_implementation_90(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
  }

  // 0	[1237]	GETTABUP 	0 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1237]	LOADK    	1 1	; "return !defined(\""
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[1237]	GETUPVAL 	2 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[1237]	LOADK    	3 2	; "\")"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1237]	CONCAT   	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000300b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 5	[1237]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[1237]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_21
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 7	[1237]	JMP      	13	; to 22
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_21;
  }

  // 8	[1237]	GETTABUP 	0 0 3	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0300000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 9	[1237]	LOADK    	1 4	; "Failed to check condition\n"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00020083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 10	[1237]	GETTABUP 	2 0 5	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0500010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 11	[1237]	GETFIELD 	2 2 6	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0602010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 12	[1237]	GETTABUP 	3 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[1237]	LOADK    	4 7	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00038203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 14	[1237]	GETUPVAL 	5 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00010289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 15	[1237]	CONCAT   	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00020235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 16	[1237]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 17	[1237]	CALL     	2 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x02000144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[1237]	GETI     	2 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0202010d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 19	[1237]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 20	[1237]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 21	[1237]	TAILCALL 	0 1 0	; 0 in
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00010045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 22	[1237]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_22: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 23	[1238]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_23: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1238 - 1240
static
CallInfo *magic_implementation_91(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1239]	GETTABUP 	1 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1239]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1239]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1240]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1251 - 1290
static
CallInfo *magic_implementation_92(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
  }

  // 0	[1254]	GETUPVAL 	0 0	; run
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1254]	TEST     	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 2	[1254]	JMP      	5	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_08;
  }

  // 3	[1255]	GETUPVAL 	0 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00020009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[1255]	GETI     	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 5	[1255]	GETUPVAL 	0 1	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[1255]	SETTABLE 	0 1 0k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018010);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 7	[1256]	RETURN   	0 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00018046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[1259]	GETUPVAL 	0 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00020009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 9	[1259]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 10	[1259]	SELF     	0 0 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x01008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[1259]	LOADK    	2 2	; "#elif "
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00010103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 12	[1259]	LOADK    	3 3	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[1259]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[1261]	LOADI    	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80000081);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 15	[1261]	LEN      	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000134);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 16	[1261]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 17	[1261]	FORPREP  	1 13	; to 32
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_32; /* skip the loop */
  }

  // 18	[1262]	SELF     	5 0 4k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x04008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[1262]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[1262]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 21	[1262]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 22	[1263]	EQK      	5 5 0	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_31
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000502bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 23	[1263]	JMP      	7	; to 32
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_31;
  }

  // 24	[1264]	SELF     	6 0 4k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x04008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 25	[1264]	ADDI     	8 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80040415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 26	[1264]	MMBINI   	4 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x0680022f);
    Instruction pi = 0x80040415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 27	[1264]	LEN      	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000004b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 28	[1264]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 29	[1264]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_32
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 30	[1265]	JMP      	1	; to 33
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_32;
  }

  // 31	[1261]	FORLOOP  	1 14	; to 19
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_18; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_18; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 32	[1268]	LEN      	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x000000b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 33	[1268]	LOADI    	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x80000101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 34	[1268]	LOADI    	3 -1
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x7fff0181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 35	[1268]	FORPREP  	1 13	; to 50
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_50; /* skip the loop */
  }

  // 36	[1269]	SELF     	5 0 4k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x04008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 37	[1269]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 38	[1269]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 39	[1269]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 40	[1270]	EQK      	5 6 0	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_49
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x000602bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 41	[1270]	JMP      	7	; to 50
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_49;
  }

  // 42	[1271]	SELF     	6 0 4k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x04008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 43	[1271]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 44	[1271]	ADDI     	9 4 -1
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x7e040495);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 45	[1271]	MMBINI   	4 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x0780022f);
    Instruction pi = 0x7e040495;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 46	[1271]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 47	[1271]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_50
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 48	[1272]	JMP      	1	; to 51
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_50;
  }

  // 49	[1268]	FORLOOP  	1 14	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_36; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_36; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 50	[1276]	GETTABUP 	1 3 7	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0703008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 51	[1278]	CLOSURE  	2 0	; 0x7ff6dbb040a0
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x0000014f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 52	[1280]	CLOSURE  	3 1	; 0x7ff6dbb04310
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x000081cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 53	[1276]	CALL     	1 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x030300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 54	[1281]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_59
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 55	[1281]	JMP      	3	; to 60
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_59;
  }

  // 56	[1282]	GETTABUP 	3 3 8	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x0803018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 57	[1282]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 58	[1282]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 59	[1285]	GETUPVAL 	3 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x00020189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 60	[1285]	GETI     	4 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x0103020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 61	[1285]	GETUPVAL 	3 1	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x00010189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 62	[1285]	SETTABLE 	3 4 0k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x00048190);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 63	[1286]	GETTABUP 	3 3 9	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x0903018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 64	[1286]	GETFIELD 	3 3 10	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x0a03018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 65	[1286]	GETUPVAL 	4 4	; activeifs
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x00040209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 66	[1286]	MOVE     	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x00020280);
    setobjs2s(L, ra, RB(i));
  }

  // 67	[1286]	CALL     	3 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x010301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 68	[1289]	SETUPVAL 	2 0	; run
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_68: {
    aot_vmfetch(0x0000010a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 69	[1290]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_69: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1276 - 1278
static
CallInfo *magic_implementation_93(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
  }

  // 0	[1277]	GETTABUP 	0 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1277]	LOADK    	1 1	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[1277]	GETUPVAL 	2 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[1277]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 4	[1277]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[1277]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_20
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 6	[1277]	JMP      	13	; to 21
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_20;
  }

  // 7	[1277]	GETTABUP 	0 0 2	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0200000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[1277]	LOADK    	1 3	; "Failed to check condition\n"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00018083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[1277]	GETTABUP 	2 0 4	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 10	[1277]	GETFIELD 	2 2 5	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0502010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[1277]	GETTABUP 	3 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[1277]	LOADK    	4 1	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00008203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[1277]	GETUPVAL 	5 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00010289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 14	[1277]	CONCAT   	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00020235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 15	[1277]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[1277]	CALL     	2 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x02000144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 17	[1277]	GETI     	2 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0202010d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 18	[1277]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 19	[1277]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[1277]	TAILCALL 	0 1 0	; 0 in
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00010045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 21	[1277]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_21: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 22	[1278]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_22: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1278 - 1280
static
CallInfo *magic_implementation_94(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1279]	GETTABUP 	1 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1279]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1279]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1280]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1291 - 1294
static
CallInfo *magic_implementation_95(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
  }

  // 0	[1292]	GETUPVAL 	0 0	; run
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1292]	NOT      	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000033);
    TValue *rb = vRB(i);
    if (l_isfalse(rb))
      setbtvalue(s2v(ra));
    else
      setbfvalue(s2v(ra));
  }

  // 2	[1292]	SETUPVAL 	0 0	; run
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0000000a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 3	[1293]	GETUPVAL 	0 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00020009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[1293]	GETI     	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 5	[1293]	GETUPVAL 	0 1	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[1293]	SETTABLE 	0 1 0k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x00018010);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 7	[1294]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1295 - 1299
static
CallInfo *magic_implementation_96(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
  }

  // 0	[1296]	GETUPVAL 	0 0	; activeifs
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1296]	LEN      	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x000000b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 2	[1296]	GETUPVAL 	0 0	; activeifs
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[1296]	SETTABLE 	0 1 0k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00018010);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 4	[1297]	GETUPVAL 	0 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00020009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 5	[1297]	GETI     	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0100008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 6	[1297]	GETUPVAL 	0 1	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[1297]	SETTABLE 	0 1 0k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00018010);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 8	[1298]	LOADTRUE 	0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000007);
    setbtvalue(s2v(ra));
  }

  // 9	[1298]	SETUPVAL 	0 3	; run
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x0003000a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 10	[1299]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_10: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1300 - 1309
static
CallInfo *magic_implementation_97(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
  }

  // 0	[1302]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1302]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[1302]	SELF     	0 0 0k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[1302]	LOADK    	2 1	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1302]	CALL     	0 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02030044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[1304]	GETI     	1 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 6	[1306]	GETUPVAL 	2 1	; env
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[1306]	SETTABLE 	2 1 2k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x02018110);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 8	[1308]	GETUPVAL 	2 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 9	[1308]	GETI     	3 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0102018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 10	[1308]	GETUPVAL 	2 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 11	[1308]	SETTABLE 	2 3 2k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x02038110);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 12	[1309]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1310 - 1315
static
CallInfo *magic_implementation_98(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
  }

  // 0	[1311]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1311]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[1311]	SELF     	0 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[1311]	LOADK    	2 1	; "#error "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1311]	LOADK    	3 2	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[1311]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[1312]	GETTABUP 	1 1 3	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[1312]	LOADK    	2 4	; "\027[1;31mRaised error:\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00020103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 8	[1312]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[1313]	GETTABUP 	1 1 3	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0301008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 10	[1313]	LOADK    	2 5	; "\027[1;31m"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00028103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[1313]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[1313]	LOADK    	4 6	; "\027[0m\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00030203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[1313]	CONCAT   	2 3
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00030135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 14	[1313]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 15	[1314]	MOVE     	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000080);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[1314]	LOADK    	2 7	; "Ending preprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00038103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 17	[1314]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_17: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[1315]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_18: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1316 - 1320
static
CallInfo *magic_implementation_99(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
  }

  // 0	[1317]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1317]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[1317]	SELF     	0 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[1317]	LOADK    	2 1	; "#warning "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1317]	LOADK    	3 2	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[1317]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[1318]	GETTABUP 	1 1 3	; _ENV "warn"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[1318]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[1318]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[1319]	GETUPVAL 	1 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 10	[1319]	GETI     	2 1 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0101010d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 11	[1319]	GETUPVAL 	1 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 12	[1319]	SETTABLE 	1 2 4k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x04028090);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 13	[1320]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1321 - 1323
static
CallInfo *magic_implementation_100(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1322]	GETTABUP 	0 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1322]	LOADK    	1 1	; "Config is not supported"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[1322]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1323]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1324 - 1327
static
CallInfo *magic_implementation_101(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1326]	GETTABUP 	0 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1326]	LOADK    	1 1	; "Extensions are not supported"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[1326]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1327]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1328 - 1347
static
CallInfo *magic_implementation_102(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
  }

  // 0	[1329]	GETUPVAL 	1 0	; run
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1329]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 2	[1329]	JMP      	5	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_08;
  }

  // 3	[1330]	GETUPVAL 	1 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[1330]	GETI     	2 1 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0101010d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 5	[1330]	GETUPVAL 	1 1	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[1330]	SETTABLE 	1 2 0k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00028090);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 7	[1331]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[1335]	GETUPVAL 	1 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 9	[1335]	GETI     	1 1 2
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0201008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 10	[1335]	SELF     	1 1 1k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x01018094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[1335]	LOADI    	3 2
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80008181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 12	[1335]	GETUPVAL 	4 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00020209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 13	[1335]	GETI     	4 4 2
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0204020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 14	[1335]	LEN      	4 4
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00040234);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 15	[1335]	CALL     	1 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x020400c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[1337]	GETTABUP 	2 3 2	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0203010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[1339]	CLOSURE  	3 0	; 0x7ff6dbb054e0
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x000001cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 18	[1341]	CLOSURE  	4 1	; 0x7ff6dbb05690
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0000824f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 19	[1337]	CALL     	2 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x03030144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[1342]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_26
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 21	[1342]	JMP      	4	; to 27
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_26;
  }

  // 22	[1343]	GETTABUP 	4 3 3	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0303020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 23	[1343]	MOVE     	5 3
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00030280);
    setobjs2s(L, ra, RB(i));
  }

  // 24	[1343]	CALL     	4 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_30
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x01020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 25	[1344]	JMP      	4	; to 31
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_30;
  }

  // 26	[1345]	GETUPVAL 	4 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00020209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 27	[1345]	GETI     	5 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0104028d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 28	[1345]	GETUPVAL 	4 1	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00010209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 29	[1345]	SETTABLE 	4 5 3
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_29: {
    aot_vmfetch(0x03050210);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 30	[1347]	RETURN   	4 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_30: {
    aot_vmfetch(0x00018246);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1337 - 1339
static
CallInfo *magic_implementation_103(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
  }

  // 0	[1338]	GETTABUP 	0 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1338]	GETUPVAL 	1 1	; code
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 2	[1338]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1338]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 4	[1338]	JMP      	3	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_08;
  }

  // 5	[1338]	GETTABUP 	0 0 1	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0100000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[1338]	LOADK    	1 2	; "Failed to load preprocessor command"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[1338]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[1338]	TAILCALL 	0 1 0	; 0 in
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 9	[1338]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 10	[1339]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_10: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1339 - 1341
static
CallInfo *magic_implementation_104(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1340]	GETTABUP 	1 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1340]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1340]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1341]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

static AotCompiledFunction AOT_FUNCTIONS[] = {
  magic_implementation_00,
  magic_implementation_01,
  magic_implementation_02,
  magic_implementation_03,
  magic_implementation_04,
  magic_implementation_05,
  magic_implementation_06,
  magic_implementation_07,
  magic_implementation_08,
  magic_implementation_09,
  magic_implementation_10,
  magic_implementation_11,
  magic_implementation_12,
  magic_implementation_13,
  magic_implementation_14,
  magic_implementation_15,
  magic_implementation_16,
  magic_implementation_17,
  magic_implementation_18,
  magic_implementation_19,
  magic_implementation_20,
  magic_implementation_21,
  magic_implementation_22,
  magic_implementation_23,
  magic_implementation_24,
  magic_implementation_25,
  magic_implementation_26,
  magic_implementation_27,
  magic_implementation_28,
  magic_implementation_29,
  magic_implementation_30,
  magic_implementation_31,
  magic_implementation_32,
  magic_implementation_33,
  magic_implementation_34,
  magic_implementation_35,
  magic_implementation_36,
  magic_implementation_37,
  magic_implementation_38,
  magic_implementation_39,
  magic_implementation_40,
  magic_implementation_41,
  magic_implementation_42,
  magic_implementation_43,
  magic_implementation_44,
  magic_implementation_45,
  magic_implementation_46,
  magic_implementation_47,
  magic_implementation_48,
  magic_implementation_49,
  magic_implementation_50,
  magic_implementation_51,
  magic_implementation_52,
  magic_implementation_53,
  magic_implementation_54,
  magic_implementation_55,
  magic_implementation_56,
  magic_implementation_57,
  magic_implementation_58,
  magic_implementation_59,
  magic_implementation_60,
  magic_implementation_61,
  magic_implementation_62,
  magic_implementation_63,
  magic_implementation_64,
  magic_implementation_65,
  magic_implementation_66,
  magic_implementation_67,
  magic_implementation_68,
  magic_implementation_69,
  magic_implementation_70,
  magic_implementation_71,
  magic_implementation_72,
  magic_implementation_73,
  magic_implementation_74,
  magic_implementation_75,
  magic_implementation_76,
  magic_implementation_77,
  magic_implementation_78,
  magic_implementation_79,
  magic_implementation_80,
  magic_implementation_81,
  magic_implementation_82,
  magic_implementation_83,
  magic_implementation_84,
  magic_implementation_85,
  magic_implementation_86,
  magic_implementation_87,
  magic_implementation_88,
  magic_implementation_89,
  magic_implementation_90,
  magic_implementation_91,
  magic_implementation_92,
  magic_implementation_93,
  magic_implementation_94,
  magic_implementation_95,
  magic_implementation_96,
  magic_implementation_97,
  magic_implementation_98,
  magic_implementation_99,
  magic_implementation_100,
  magic_implementation_101,
  magic_implementation_102,
  magic_implementation_103,
  magic_implementation_104,
  NULL
};

static const char AOT_MODULE_SOURCE_CODE[] = {
   47,  47,  32,  66, 117, 105, 108, 116,  32, 105, 110,  32, 112, 114, 101, 112,
  114, 111,  99, 101, 115, 115, 111, 114,  32, 102, 111, 114,  32,  99, 111,  98,
   97, 108, 116,  10,  47,  47,  32,  84, 104, 101,  32, 112, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 101, 114,  32, 105, 115,  32, 110, 111, 116,  32,  97,
  112,  97, 114, 116,  32, 111, 102,  32, 116, 104, 101,  32,  99, 111, 109, 112,
  105, 108, 101, 114,  10,  47,  47,  32,  97, 110, 100,  32, 110, 101, 101, 100,
  115,  32, 116, 111,  32,  98, 101,  32,  98, 117, 105, 108, 116,  32, 117, 115,
  105, 110, 103,  32,  96,  99, 109,  97, 107, 101,  32,  46,  32,  38,  38,  32,
  109,  97, 107, 101,  96,  32,  97, 110, 100,  10,  47,  47,  32, 117, 115, 101,
  100,  32,  98, 101, 102, 111, 114, 101,  32,  99, 111, 109, 112, 105, 108, 105,
  110, 103,  32, 116, 104, 101,  32, 115, 111, 117, 114,  99, 101,  32,  99, 111,
  100, 101,  10,  10,  47,  47,  32,  84, 104, 101,  32, 112, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 111, 114,  32, 114, 101, 112, 108,  97,  99, 101, 115,
   32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32, 100, 105,
  114, 101,  99, 116, 105, 118, 101, 115,  32, 119, 105, 116, 104,  10,  47,  47,
   32,  99, 111,  98,  97, 108, 116,  32,  99, 111, 100, 101,  32, 100, 101, 112,
  101, 110, 100, 105, 110, 103,  32, 111, 110,  32, 115, 121, 115, 116, 101, 109,
   32,  97, 110, 100,  32, 111, 116, 104, 101, 114,  32, 102,  97,  99, 116, 111,
  114, 115,  10,  10,  47,  47,  32,  78, 111, 116,  32, 117, 115, 101, 100,  32,
  100, 105, 114, 101,  99, 116, 108, 121,  44,  32, 114,  97, 116, 104, 101, 114,
   32,  99, 111, 109, 112, 105, 108, 101, 100,  32, 116, 111,  32,  67,  32,  97,
  110, 100,  32, 105, 110,  99, 108, 117, 100, 101, 100,  32, 105, 110,  32, 115,
  111, 117, 114,  99, 101,  46,  10,  10,  47,  47,  32,  73,  78,  73,  84,  10,
  102, 105, 108, 101, 115, 121, 115, 116, 101, 109,  32,  61,  32, 102, 105, 108,
  101,  32,  47,  47,  32,  70, 105, 108, 101,  32, 108, 105,  98, 114,  97, 114,
  121,  32, 102, 111, 114,  32,  99, 111,  98,  97, 108, 116,  10, 118,  97, 114,
   32, 108, 102, 115,  32,  61,  32, 123, 125,  59,  10, 118,  97, 114,  32, 119,
  105, 110, 100, 111, 119, 115,  32,  61,  32, 112,  97,  99, 107,  97, 103, 101,
   46,  99, 111, 110, 102, 105, 103,  45,  62, 115, 117,  98,  40,  49,  44,  49,
   41,  32,  61,  61,  32,  34,  92,  92,  34,  59,  10,  10, 118,  97, 114,  32,
  111, 116, 104, 101, 114,  95, 115, 101, 112,  59,  10, 118,  97, 114,  32, 115,
  101, 112,  59,  10, 118,  97, 114,  32, 100, 105, 114, 115, 101, 112,  59,  10,
   10, 105, 102,  40,  32, 119, 105, 110, 100, 111, 119, 115,  32,  41,  32, 123,
   10,   9, 115, 101, 112,  32,  61,  32,  39,  92,  92,  39,  59,  10,   9, 111,
  116, 104, 101, 114,  95, 115, 101, 112,  32,  61,  32,  39,  47,  39,  59,  10,
    9, 100, 105, 114, 115, 101, 112,  32,  61,  32,  39,  59,  39,  59,  10, 125,
   32, 101, 108, 115, 101,  32, 123,  10,   9, 115, 101, 112,  32,  61,  32,  39,
   47,  39,  59,  10,   9, 100, 105, 114, 115, 101, 112,  32,  61,  32,  39,  58,
   39,  59,  10, 125,  10,  10,  10, 118,  97, 114,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  32,  97, 116,  40, 115,  44, 105,  41,  32, 123,  10,   9, 114,
  101, 116, 117, 114, 110,  32, 115, 116, 114, 105, 110, 103,  46, 115, 117,  98,
   40, 115,  44, 105,  44, 105,  41,  59,  10, 125,  10,  10,  47,  47,  45,  32,
  114, 101, 116, 117, 114, 110, 115,  32, 105, 102,  32, 116, 104, 101,  32, 112,
   97, 116, 104,  32, 105, 115,  32,  97, 110,  32,  97,  98, 115, 111, 108, 117,
  116, 101,  32, 112,  97, 116, 104,  10, 102, 117, 110,  99, 116, 105, 111, 110,
   32, 108, 102, 115,  46, 105, 115,  97,  98, 115,  40, 112,  97, 116, 104,  41,
   32, 123,  10,   9, 105, 102,  40,  32, 119, 105, 110, 100, 111, 119, 115,  32,
   41,  32, 123,  10,   9,   9, 114, 101, 116, 117, 114, 110,  32,  97, 116,  40,
  112,  97, 116, 104,  44,  32,  49,  41,  32,  61,  61,  32,  39,  47,  39,  32,
  124, 124,  32,  97, 116,  40, 112,  97, 116, 104,  44,  32,  49,  41,  32,  61,
   61,  32,  39,  92,  92,  39,  32, 124, 124,  32,  97, 116,  40, 112,  97, 116,
  104,  44,  32,  50,  41,  32,  61,  61,  39,  58,  39,  59,  10,   9, 125,  32,
  101, 108, 115, 101,  32, 123,  10,   9,   9, 114, 101, 116, 117, 114, 110,  32,
   97, 116,  40, 112,  97, 116, 104,  44,  32,  49,  41,  32,  61,  61,  32,  39,
   47,  39,  59,  10,   9, 125,  10, 125,  10,  10,  47,  47,  32, 114, 101, 116,
  117, 114, 110,  32, 116, 104, 101,  32, 112,  97, 116, 104,  32, 114, 101, 115,
  117, 108, 116, 105, 110, 103,  32, 102, 114, 111, 109,  32,  99, 111, 109,  98,
  105, 110, 105, 110, 103,  32, 116, 104, 101,  32, 105, 110, 100, 105, 118, 105,
  100, 117,  97, 108,  32, 112,  97, 116, 104, 115,  46,  10,  47,  47,  32, 105,
  102,  32, 116, 104, 101,  32, 115, 101,  99, 111, 110, 100,  32,  40, 111, 114,
   32, 108,  97, 116, 101, 114,  41,  32, 112,  97, 116, 104,  32, 105, 115,  32,
   97,  98, 115, 111, 108, 117, 116, 101,  44,  32, 119, 101,  32, 114, 101, 116,
  117, 114, 110,  32, 116, 104, 101,  32, 108,  97, 115, 116,  32,  97,  98, 115,
  111, 108, 117, 116, 101,  32, 112,  97, 116, 104,  32,  40, 106, 111, 105, 110,
  101, 100,  32, 119, 105, 116, 104,  32,  97, 110, 121,  32, 110, 111, 110,  45,
   97,  98, 115, 111, 108, 117, 116, 101,  32, 112,  97, 116, 104, 115,  32, 102,
  111, 108, 108, 111, 119, 105, 110, 103,  41,  46,  10,  47,  47,  32, 101, 109,
  112, 116, 121,  32, 101, 108, 101, 109, 101, 110, 116, 115,  32,  40, 101, 120,
   99, 101, 112, 116,  32, 116, 104, 101,  32, 108,  97, 115, 116,  41,  32, 119,
  105, 108, 108,  32,  98, 101,  32, 105, 103, 110, 111, 114, 101, 100,  46,  10,
  102, 117, 110,  99, 116, 105, 111, 110,  32, 108, 102, 115,  46, 106, 111, 105,
  110,  40, 112,  97, 116, 104,  49,  44,  32, 112,  97, 116, 104,  50,  44,  46,
   46,  46,  41,  32, 123,  10,   9, 105, 102,  40,  32, 115, 101, 108, 101,  99,
  116,  40,  39,  35,  39,  44,  32,  46,  46,  46,  41,  32,  62,  32,  48,  32,
   41,  32, 123,  10,   9,   9, 118,  97, 114,  32, 112,  32,  61,  32, 108, 102,
  115,  46, 106, 111, 105, 110,  40, 112,  97, 116, 104,  49,  44,  32, 112,  97,
  116, 104,  50,  41,  59,  10,   9,   9, 118,  97, 114,  32,  97, 114, 103, 115,
   32,  61,  32, 123,  46,  46,  46, 125,  59,  10,   9,   9, 102, 111, 114,  40,
   32, 105,  32,  61,  32,  49,  44,  35,  97, 114, 103, 115,  32,  41,  32, 123,
   10,   9,   9,   9, 112,  32,  61,  32, 108, 102, 115,  46, 106, 111, 105, 110,
   40, 112,  44,  32,  97, 114, 103, 115,  91, 105,  93,  41,  59,  10,   9,   9,
  125,  10,   9,   9, 114, 101, 116, 117, 114, 110,  32, 112,  59,  10,   9, 125,
   10,   9, 105, 102,  40,  32, 108, 102, 115,  46, 105, 115,  97,  98, 115,  40,
  112,  97, 116, 104,  50,  41,  32,  41,  32, 123,  32, 114, 101, 116, 117, 114,
  110,  32, 112,  97, 116, 104,  50,  59,  32, 125,  10,   9, 118,  97, 114,  32,
  101, 110, 100,  99,  32,  61,  32,  97, 116,  40, 112,  97, 116, 104,  49,  44,
   32,  35, 112,  97, 116, 104,  49,  41,  59,  10,   9, 105, 102,  40,  32, 101,
  110, 100,  99,  32,  33,  61,  32, 115, 101, 112,  32,  38,  38,  32, 101, 110,
  100,  99,  32,  33,  61,  32, 111, 116, 104, 101, 114,  95, 115, 101, 112,  32,
   38,  38,  32, 101, 110, 100,  99,  32,  33,  61,  32,  34,  34,  32,  41,  32,
  123,  10,   9,   9, 112,  97, 116, 104,  49,  32,  61,  32, 112,  97, 116, 104,
   49,  32,  46,  46,  32, 115, 101, 112,  59,  10,   9, 125,  10,   9, 114, 101,
  116, 117, 114, 110,  32, 112,  97, 116, 104,  49,  32,  46,  46,  32, 112,  97,
  116, 104,  50,  59,  10, 125,  10,  10,  47,  47,  32,  82, 101, 116, 117, 114,
  110, 115,  32, 116, 104, 101,  32, 117, 115, 101, 114, 115,  32, 104, 111, 109,
  101,  32, 100, 105, 114, 101,  99, 116, 111, 114, 121,  10, 102, 117, 110,  99,
  116, 105, 111, 110,  32, 108, 102, 115,  46, 104, 111, 109, 101,  40,  41,  32,
  123,  10,   9, 118,  97, 114,  32, 104, 111, 109, 101,  32,  61,  32, 111, 115,
   46, 103, 101, 116, 101, 110, 118,  40,  39,  72,  79,  77,  69,  39,  41,  59,
   10,   9, 105, 102,  40,  32,  33,  32, 104, 111, 109, 101,  32,  41,  32, 123,
   10,   9,   9, 104, 111, 109, 101,  32,  61,  32, 111, 115,  46, 103, 101, 116,
  101, 110, 118,  40,  39,  85,  83,  69,  82,  80,  82,  79,  70,  73,  76,  69,
   39,  41,  32, 124, 124,  32,  40, 111, 115,  46, 103, 101, 116, 101, 110, 118,
   40,  39,  72,  79,  77,  69,  68,  82,  73,  86,  69,  39,  41,  32,  46,  46,
   32, 111, 115,  46, 103, 101, 116, 101, 110, 118,  40,  39,  72,  79,  77,  69,
   80,  65,  84,  72,  39,  41,  41,  59,  10,   9, 125,  10,   9, 114, 101, 116,
  117, 114, 110,  32, 104, 111, 109, 101,  59,  10, 125,  10,  10,  47,  47,  32,
   87, 101,  32, 109,  97, 107, 101,  32, 116, 104, 101,  32, 115, 105, 109, 112,
  108, 105, 102, 121, 105, 110, 103,  32,  97, 115, 115, 117, 109, 112, 116, 105,
  111, 110,  32, 105, 110,  32, 116, 104, 101, 115, 101,  32, 102, 117, 110,  99,
  116, 105, 111, 110, 115,  32, 116, 104,  97, 116,  32, 112,  97, 116, 104,  32,
  115, 101, 112,  97, 114,  97, 116, 111, 114, 115,  10,  47,  47,  32,  97, 114,
  101,  32,  97, 108, 119,  97, 121, 115,  32, 102, 111, 114, 119,  97, 114, 100,
   32, 115, 108,  97, 115, 104, 101, 115,  46,  32,  84, 104, 105, 115,  32, 105,
  115,  32, 116, 114, 117, 101,  32, 111, 110,  32,  42, 110, 105, 120,  32,  97,
  110, 100,  32,  42, 115, 104, 111, 117, 108, 100,  42,  32,  98, 101,  32, 116,
  114, 117, 101,  32, 111, 110,  10,  47,  47,  32, 119, 105, 110, 100, 111, 119,
  115,  44,  32,  98, 117, 116,  32, 121, 111, 117,  32,  99,  97, 110,  32, 110,
  101, 118, 101, 114,  32, 116, 101, 108, 108,  32, 119, 104,  97, 116,  32,  97,
   32, 117, 115, 101, 114,  32, 119, 105, 108, 108,  32, 112, 117, 116,  32, 105,
  110, 116, 111,  32,  97,  32,  99, 111, 110, 102, 105, 103,  32, 102, 105, 108,
  101,  10,  47,  47,  32, 115, 111, 109, 101, 119, 104, 101, 114, 101,  46,  32,
   84, 104, 105, 115,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32, 101, 110,
  102, 111, 114,  99, 101, 115,  32, 116, 104, 105, 115,  46,  10, 102, 117, 110,
   99, 116, 105, 111, 110,  32, 108, 102, 115,  46, 110, 111, 114, 109,  97, 108,
  105, 122, 101,  40, 112,  97, 116, 104,  41,  32, 123,  10,   9, 105, 102,  40,
   32, 119, 105, 110, 100, 111, 119, 115,  32,  41,  32, 123,  10,   9,   9, 114,
  101, 116, 117, 114, 110,  32,  40, 112,  97, 116, 104,  45,  62, 103, 115, 117,
   98,  40,  34,  92,  92,  34,  44,  32,  34,  47,  34,  41,  41,  59,  10,   9,
  125,  32, 101, 108, 115, 101,  32, 123,  10,   9,   9, 114, 101, 116, 117, 114,
  110,  32, 112,  97, 116, 104,  59,  10,   9, 125,  10, 125,  10,  10, 118,  97,
  114,  32,  95,  97, 116, 116, 114, 105,  98, 117, 116, 101, 115,  32,  61,  32,
  108, 102, 115,  46,  97, 116, 116, 114, 105,  98, 117, 116, 101, 115,  59,  10,
  102, 117, 110,  99, 116, 105, 111, 110,  32, 108, 102, 115,  46,  97, 116, 116,
  114, 105,  98, 117, 116, 101, 115,  40, 112,  97, 116, 104,  44,  32,  46,  46,
   46,  41,  32, 123,  10,   9, 112,  97, 116, 104,  32,  61,  32, 108, 102, 115,
   46, 110, 111, 114, 109,  97, 108, 105, 122, 101,  40, 112,  97, 116, 104,  41,
   59,  10,   9, 105, 102,  40,  32, 119, 105, 110, 100, 111, 119, 115,  32,  41,
   32, 123,  10,   9,   9,  47,  47,  32,  87, 105, 110, 100, 111, 119, 115,  32,
  115, 116,  97, 116,  40,  41,  32, 105, 115,  32, 107, 105, 110, 100,  32, 111,
  102,  32,  97, 119, 102, 117, 108,  46,  32,  73, 102,  32, 116, 104, 101,  32,
  112,  97, 116, 104,  32, 104,  97, 115,  32,  97,  32, 116, 114,  97, 105, 108,
  105, 110, 103,  32, 115, 108,  97, 115, 104,  44,  32, 105, 116,  10,   9,   9,
   47,  47,  32, 119, 105, 108, 108,  32,  97, 108, 119,  97, 121, 115,  32, 102,
   97, 105, 108,  46,  32,  69, 120,  99, 101, 112, 116,  32, 111, 110,  32, 100,
  114, 105, 118, 101,  32, 114, 111, 111, 116,  32, 100, 105, 114, 101,  99, 116,
  111, 114, 105, 101, 115,  44,  32, 119, 104, 105,  99, 104,  32,  42, 114, 101,
  113, 117, 105, 114, 101,  42,  32,  97,  10,   9,   9,  47,  47,  32, 116, 114,
   97, 105, 108, 105, 110, 103,  32, 115, 108,  97, 115, 104,  46,  32,  84, 104,
   97, 110, 107, 102, 117, 108, 108, 121,  44,  32,  97, 112, 112, 101, 110, 100,
  105, 110, 103,  32,  97,  32,  34,  46,  34,  32, 119, 105, 108, 108,  32,  97,
  108, 119,  97, 121, 115,  32, 119, 111, 114, 107,  32, 105, 102,  32, 116, 104,
  101,  10,   9,   9,  47,  47,  32, 116,  97, 114, 103, 101, 116,  32, 105, 115,
   32,  97,  32, 100, 105, 114, 101,  99, 116, 111, 114, 121,  59,  32,  97, 110,
  100,  32, 105, 102,  32, 105, 116,  39, 115,  32, 110, 111, 116,  44,  32, 102,
   97, 105, 108, 105, 110, 103,  32, 111, 110,  32, 112,  97, 116, 104, 115,  32,
  119, 105, 116, 104,  32, 116, 114,  97, 105, 108, 105, 110, 103,  10,   9,   9,
   47,  47,  32, 115, 108,  97, 115, 104, 101, 115,  32, 105, 115,  32,  99, 111,
  110, 115, 105, 115, 116, 101, 110, 116,  32, 119, 105, 116, 104,  32, 111, 116,
  104, 101, 114,  32,  79,  83, 101, 115,  46,  10,   9,   9, 112,  97, 116, 104,
   32,  61,  32, 112,  97, 116, 104,  45,  62, 103, 115, 117,  98,  40,  34,  47,
   36,  34,  44,  32,  34,  47,  46,  34,  41,  59,  10,   9, 125,  10,  10,   9,
  114, 101, 116, 117, 114, 110,  32,  95,  97, 116, 116, 114, 105,  98, 117, 116,
  101, 115,  40, 112,  97, 116, 104,  44,  32,  46,  46,  46,  41,  59,  10, 125,
   10,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 108, 102, 115,  46, 101,
  120, 105, 115, 116, 115,  40, 112,  97, 116, 104,  41,  32, 123,  10,   9, 114,
  101, 116, 117, 114, 110,  32, 108, 102, 115,  46,  97, 116, 116, 114, 105,  98,
  117, 116, 101, 115,  40, 112,  97, 116, 104,  44,  32,  34, 109, 111, 100, 101,
   34,  41,  32,  33,  61,  32, 110, 117, 108, 108,  59,  10, 125,  10,  10, 102,
  117, 110,  99, 116, 105, 111, 110,  32, 108, 102, 115,  46, 100, 105, 114, 110,
   97, 109, 101,  40, 111, 108, 100, 112,  97, 116, 104,  41,  32, 123,  10,   9,
  118,  97, 114,  32, 112,  97, 116, 104,  32,  61,  32, 108, 102, 115,  46, 110,
  111, 114, 109,  97, 108, 105, 122, 101,  40, 111, 108, 100, 112,  97, 116, 104,
   41,  45,  62, 103, 115, 117,  98,  40,  34,  91,  94,  47,  93,  43,  47,  42,
   36,  34,  44,  32,  34,  34,  41,  59,  10,   9, 105, 102,  40,  32, 112,  97,
  116, 104,  32,  61,  61,  32,  34,  34,  32,  41,  32, 123,  10,   9,   9, 114,
  101, 116, 117, 114, 110,  32, 111, 108, 100, 112,  97, 116, 104,  59,  10,   9,
  125,  10,   9, 114, 101, 116, 117, 114, 110,  32, 112,  97, 116, 104,  59,  10,
  125,  10,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 108, 102, 115,  46,
   98,  97, 115, 101, 110,  97, 109, 101,  40, 111, 108, 100, 112,  97, 116, 104,
   41,  32, 123,  10,   9, 118,  97, 114,  32, 112,  97, 116, 104,  32,  61,  32,
  108, 102, 115,  46, 110, 111, 114, 109,  97, 108, 105, 122, 101,  40, 111, 108,
  100, 112,  97, 116, 104,  41,  45,  62, 109,  97, 116,  99, 104,  40,  34,  91,
   94,  47,  93,  43,  47,  42,  36,  34,  41,  59,  10,   9, 105, 102,  40,  32,
  112,  97, 116, 104,  32,  61,  61,  32,  34,  34,  32,  41,  32, 123,  10,   9,
    9, 114, 101, 116, 117, 114, 110,  32, 111, 108, 100, 112,  97, 116, 104,  59,
   10,   9, 125,  10,   9, 114, 101, 116, 117, 114, 110,  32, 112,  97, 116, 104,
   59,  10, 125,  10,  10,  47,  47,  32,  82, 101,  99, 117, 114, 115, 105, 118,
  101,  32, 100, 105, 114, 101,  99, 116, 111, 114, 121,  32,  99, 114, 101,  97,
  116, 105, 111, 110,  32,  97,  32, 108,  97,  32, 109, 107, 100, 105, 114,  32,
   45, 112,  46,  32,  85, 110, 108, 105, 107, 101,  32, 108, 102, 115,  46, 109,
  107, 100, 105, 114,  44,  32, 116, 104, 105, 115,  32, 119, 105, 108, 108,  10,
   47,  47,  32,  99, 114, 101,  97, 116, 101,  32, 109, 105, 115, 115, 105, 110,
  103,  32, 105, 110, 116, 101, 114, 109, 101, 100, 105,  97, 116, 101,  32, 100,
  105, 114, 101,  99, 116, 111, 114, 105, 101, 115,  44,  32,  97, 110, 100,  32,
  119, 105, 108, 108,  32, 110, 111, 116,  32, 102,  97, 105, 108,  32, 105, 102,
   32, 116, 104, 101,  10,  47,  47,  32, 100, 101, 115, 116, 105, 110,  97, 116,
  105, 111, 110,  32, 100, 105, 114, 101,  99, 116, 111, 114, 121,  32,  97, 108,
  114, 101,  97, 100, 121,  32, 101, 120, 105, 115, 116, 115,  46,  10,  47,  47,
   32,  73, 116,  32,  97, 115, 115, 117, 109, 101, 115,  32, 116, 104,  97, 116,
   32, 116, 104, 101,  32, 100, 105, 114, 101,  99, 116, 111, 114, 121,  32, 115,
  101, 112,  97, 114,  97, 116, 111, 114,  32, 105, 115,  32,  39,  47,  39,  32,
   97, 110, 100,  32, 116, 104,  97, 116,  32, 116, 104, 101,  32, 112,  97, 116,
  104,  32, 105, 115,  32, 118,  97, 108, 105, 100,  10,  47,  47,  32, 102, 111,
  114,  32, 116, 104, 101,  32,  79,  83,  32, 105, 116,  39, 115,  32, 114, 117,
  110, 110, 105, 110, 103,  32, 111, 110,  44,  32, 101,  46, 103,  46,  32, 110,
  111,  32, 116, 114,  97, 105, 108, 105, 110, 103,  32, 115, 108,  97, 115, 104,
  101, 115,  32, 111, 110,  32, 119, 105, 110, 100, 111, 119, 115,  32,  45,  45,
   32, 105, 116,  39, 115,  32, 117, 112,  10,  47,  47,  32, 116, 111,  32, 116,
  104, 101,  32,  99,  97, 108, 108, 101, 114,  32, 116, 111,  32, 101, 110, 115,
  117, 114, 101,  32, 116, 104, 105, 115,  33,  10, 102, 117, 110,  99, 116, 105,
  111, 110,  32, 108, 102, 115,  46, 109, 107, 100, 105, 114, 115,  40, 112,  97,
  116, 104,  41,  32, 123,  10,   9, 112,  97, 116, 104,  32,  61,  32, 108, 102,
  115,  46, 110, 111, 114, 109,  97, 108, 105, 122, 101,  40, 112,  97, 116, 104,
   41,  59,  10,   9, 105, 102,  40,  32, 108, 102, 115,  46, 101, 120, 105, 115,
  116, 115,  40, 112,  97, 116, 104,  41,  32,  41,  32, 123,  10,   9,   9, 114,
  101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  59,  10,   9, 125,  10,   9,
  105, 102,  40,  32, 108, 102, 115,  46, 100, 105, 114, 110,  97, 109, 101,  40,
  112,  97, 116, 104,  41,  32,  61,  61,  32, 112,  97, 116, 104,  32,  41,  32,
  123,  10,   9,   9,  47,  47,  32,  87, 101,  39, 114, 101,  32,  98, 101, 105,
  110, 103,  32,  97, 115, 107, 101, 100,  32, 116, 111,  32,  99, 114, 101,  97,
  116, 101,  32, 116, 104, 101,  32, 114, 111, 111, 116,  32, 100, 105, 114, 101,
   99, 116, 111, 114, 121,  33,  10,   9,   9, 114, 101, 116, 117, 114, 110,  32,
  110, 117, 108, 108,  44,  34, 109, 107, 100, 105, 114,  58,  32, 117, 110,  97,
   98, 108, 101,  32, 116, 111,  32,  99, 114, 101,  97, 116, 101,  32, 114, 111,
  111, 116,  32, 100, 105, 114, 101,  99, 116, 111, 114, 121,  34,  59,  10,   9,
  125,  10,   9, 118,  97, 114,  32, 114,  44, 101, 114, 114,  32,  61,  32, 108,
  102, 115,  46, 109, 107, 100, 105, 114, 115,  40, 108, 102, 115,  46, 100, 105,
  114, 110,  97, 109, 101,  40, 112,  97, 116, 104,  41,  41,  59,  10,   9, 105,
  102,  40,  32,  33,  32, 114,  32,  41,  32, 123,  10,   9,   9, 114, 101, 116,
  117, 114, 110,  32, 110, 117, 108, 108,  44, 101, 114, 114,  46,  46,  34,  32,
   40,  99, 114, 101,  97, 116, 105, 110, 103,  32,  34,  46,  46, 112,  97, 116,
  104,  46,  46,  34,  41,  34,  59,  10,   9, 125,  10,   9, 114, 101, 116, 117,
  114, 110,  32, 108, 102, 115,  46, 109, 107, 100, 105, 114,  40, 112,  97, 116,
  104,  41,  59,  10, 125,  10,  10,  10,  47,  47,  32,  82, 101,  99, 117, 114,
  115, 105, 118, 101,  32, 100, 105, 114, 101,  99, 116, 111, 114, 121,  32, 100,
  101, 108, 101, 116, 105, 111, 110,  46,  32,  85, 110, 108, 105, 107, 101,  32,
  108, 102, 115,  46, 114, 109, 100, 105, 114,  44,  32, 116, 104, 105, 115,  32,
  119, 105, 108, 108,  10,  47,  47,  32, 100, 101, 108, 101, 116, 101,  32,  97,
  108, 108,  32, 102, 105, 108, 101, 115,  32, 114, 101,  99, 117, 114, 115, 105,
  118, 108, 121,  44,  32,  97, 110, 100,  32, 119, 105, 108, 108,  32, 110, 111,
  116,  32, 102,  97, 105, 108,  32, 105, 102,  32, 116, 104, 101,  10,  47,  47,
   32, 100, 105, 114, 101,  99, 116, 111, 114, 121,  32, 105, 115,  32, 110, 111,
  116,  32, 101, 109, 112, 116, 121,  46,  10, 102, 117, 110,  99, 116, 105, 111,
  110,  32, 108, 102, 115,  46, 114, 109, 100, 105, 114, 115,  40, 112,  97, 116,
  104,  41,  32, 123,  10,   9, 102, 111, 114,  40,  32, 102, 105, 108, 101,  32,
  105, 110,  32, 108, 102, 115,  46, 100, 105, 114,  40, 112,  97, 116, 104,  41,
   32,  41,  32, 123,  10,   9,   9, 118,  97, 114,  32, 102, 105, 108, 101,  95,
  112,  97, 116, 104,  32,  61,  32, 112,  97, 116, 104,  32,  46,  46,  32, 115,
  101, 112,  32,  46,  46,  32, 102, 105, 108, 101,  59,  10,   9,   9, 105, 102,
   40,  32, 102, 105, 108, 101,  32,  33,  61,  32,  34,  46,  34,  32,  38,  38,
   32, 102, 105, 108, 101,  32,  33,  61,  32,  34,  46,  46,  34,  32,  41,  32,
  123,  10,   9,   9,   9, 105, 102,  40,  32, 108, 102, 115,  46,  97, 116, 116,
  114, 105,  98, 117, 116, 101, 115,  40, 102, 105, 108, 101,  95, 112,  97, 116,
  104,  44,  32,  39, 109, 111, 100, 101,  39,  41,  32,  61,  61,  32,  39, 102,
  105, 108, 101,  39,  32,  41,  32, 123,  10,   9,   9,   9,   9, 111, 115,  46,
  114, 101, 109, 111, 118, 101,  40, 102, 105, 108, 101,  95, 112,  97, 116, 104,
   41,  59,  10,   9,   9,   9, 125,  32, 101, 108, 115, 101,  32, 105, 102,  40,
   32, 108, 102, 115,  46,  97, 116, 116, 114, 105,  98, 117, 116, 101, 115,  40,
  102, 105, 108, 101,  95, 112,  97, 116, 104,  44,  32,  39, 109, 111, 100, 101,
   39,  41,  32,  61,  61,  32,  39, 100, 105, 114, 101,  99, 116, 111, 114, 121,
   39,  32,  41,  32, 123,  10,   9,   9,   9,   9, 100, 101, 108, 101, 116, 101,
  100, 105, 114,  40, 102, 105, 108, 101,  95, 112,  97, 116, 104,  41,  59,  10,
    9,   9,   9, 125,  10,   9,   9, 125,  10,   9, 125,  10,   9, 114, 101, 116,
  117, 114, 110,  32, 108, 102, 115,  46, 114, 109, 100, 105, 114,  40, 112,  97,
  116, 104,  41,  59,  10, 125,  10,  10, 102, 105, 108, 101, 120,  32,  61,  32,
  108, 102, 115,  32,  47,  47,  32,  69, 120, 116, 101, 110, 100, 101, 100,  32,
   70, 105, 108, 101,  32, 108, 105,  98, 114,  97, 114, 121,  32, 102, 111, 114,
   32,  99, 111,  98,  97, 108, 116,  10,  10, 109,  97,  99, 114, 111, 115,  32,
   61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123, 125,  32,  47,
   47,  32,  99, 111, 114, 101,  46, 109,  97,  99, 114, 111, 115,  10,  10, 102,
  117, 110,  99, 116, 105, 111, 110,  32, 115, 119, 105, 116,  99, 104,  40, 118,
   97, 108, 117, 101,  44,  32,  99,  97, 115, 101, 115,  41, 123,  10,  32,  32,
   32,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40,  99,  97, 115, 101, 115,
   41,  32,  33,  61,  32,  34, 116,  97,  98, 108, 101,  34,  41, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114,  40,  34,  83, 119,
  105, 116,  99, 104,  32, 101, 120, 112, 101,  99, 116, 115,  32,  97,  32, 116,
   97,  98, 108, 101,  32,  97, 115,  32, 116, 104, 101,  32, 115, 101,  99, 111,
  110, 100,  32,  97, 114, 103, 117, 109, 101, 110, 116,  34,  41,  10,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32,  10,  32,  32,  32,  32, 105, 102,  40,
   99,  97, 115, 101, 115,  91, 118,  97, 108, 117, 101,  93,  41, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40,
   99,  97, 115, 101, 115,  91, 118,  97, 108, 117, 101,  93,  41,  32,  61,  61,
   32,  34, 115, 116, 114, 105, 110, 103,  34,  41, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,  99,  97,
  115, 101, 115,  91, 118,  97, 108, 117, 101,  93,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99,  97, 115, 101,
  115,  91, 118,  97, 108, 117, 101,  93,  40, 118,  97, 108, 117, 101,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117,
  114, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32, 105, 102,  40,  99,  97, 115, 101, 115,  91,
   34, 100, 101, 102,  97, 117, 108, 116,  34,  93,  41, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40,  99,  97,
  115, 101, 115,  91,  34, 100, 101, 102,  97, 117, 108, 116,  34,  93,  41,  32,
   61,  61,  32,  34, 115, 116, 114, 105, 110, 103,  34,  41, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,
   99,  97, 115, 101, 115,  91,  34, 100, 101, 102,  97, 117, 108, 116,  34,  93,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101,
  116, 117, 114, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101,
  108, 115, 101,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  99,  97, 115, 101, 115,  91,  34, 100, 101, 102,  97, 117, 108, 116,
   34,  93,  40, 118,  97, 108, 117, 101,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32, 119,  97, 114, 110,  40,  34,  83, 119, 105, 116,  99, 104,  32,  99,  97,
  110, 110, 111, 116,  32, 102, 105, 110, 100,  32,  97,  32,  99,  97, 115, 101,
   32, 102, 111, 114,  32,  34,  32,  46,  46,  32, 116, 111, 115, 116, 114, 105,
  110, 103,  40, 118,  97, 108, 117, 101,  41,  32,  46,  46,  32,  34,  32,  97,
  110, 100,  32, 110, 111,  32, 100, 101, 102,  97, 117, 108, 116,  32,  99,  97,
  115, 101,  32, 119,  97, 115,  32, 112, 114, 111, 118, 105, 100, 101, 100,  34,
   41,  10, 125,  10,  10,  10,  47,  47,  32,  83,  69,  67,  84,  73,  79,  78,
   32,  49,  58,  32,  84,  89,  80,  69,  67,  72,  69,  67,  75,  69,  82,  10,
   10,  47,  42,  32,  84,  79,  68,  79,  58,  10,  32,  45,  32,  65, 108, 108,
  111, 119,  32,  99, 117, 115, 116, 111, 109,  32, 116, 121, 112, 101, 115,  10,
   32,  45,  32,  70, 117, 110,  99, 116, 105, 111, 110, 115,  32,  99,  97, 110,
   32, 104,  97, 118, 101,  32,  97, 114, 103, 117, 109, 101, 110, 116, 115,  32,
  116, 111,  32,  98, 101,  32, 116, 121, 112, 101,  99, 104, 101,  99, 107, 101,
  100,  10,  32,  45,  32,  71, 101, 110, 101, 114, 105,  99, 115,  10,  32,  45,
   32,  70, 105, 120,  32, 105, 115, 115, 117, 101,  32, 119, 104, 101, 114, 101,
   32, 116, 121, 112, 101,  32,  99,  97, 110,  32,  98, 101,  32,  99, 104,  97,
  110, 103, 101, 100,  32,  97, 102, 116, 101, 114,  32, 100, 101, 102, 105, 110,
  105, 116, 111, 110,  10,  42,  47,  10,  10,  47,  42,  32,  83,  89,  83,  84,
   69,  77,  58,  10,  32,  84, 104, 101,  32, 115, 121, 115, 116, 101, 109,  32,
  114, 101, 109, 111, 118, 101, 115,  32,  97, 108, 108,  32,  99, 111, 109, 109,
  101, 110, 116, 115,  32,  97, 110, 100,  32,  99, 108, 101,  97, 114, 115,  32,
  115, 116, 114, 105, 110, 103, 115,  32,  97, 110, 100,  32, 115,  97, 118, 101,
  115,  32, 105, 116,  32, 116, 111,  32,  97,  32, 116,  97,  98, 108, 101,  32,
  111, 102,  32,  34, 100, 101,  97, 100,  34,  32, 115, 116, 114, 105, 110, 103,
  115,  44,  32,  10,  32, 116, 104, 101, 110,  32, 105, 116,  32, 108, 111, 111,
  107, 115,  32, 102, 111, 114,  32, 100, 101, 102, 105, 110, 105, 116, 105, 111,
  110, 115,  32,  96, 118,  97, 114,  32, 120,  58,  32, 121,  32,  61,  32, 122,
   96,  32, 116, 111,  32, 115, 116, 111, 114, 101,  32, 105, 110,  32,  97,  32,
   99,  97,  99, 104, 101,  32,  97, 110, 100,  32,  97, 115, 115, 105, 103, 110,
  109, 101, 110, 116, 115,  32,  96, 120,  58,  32, 121,  32,  61,  32, 122,  96,
   32,  97, 110, 100,  32, 101, 118, 101, 110,  32,  10,  32, 110, 111, 114, 109,
   97, 108,  32,  97, 115, 115, 105, 103, 110, 109, 101, 110, 116, 115,  32,  96,
   97,  32,  61,  32, 122,  96,  32, 112,  97, 116, 116, 101, 114, 110, 115,  44,
   32,  97, 110, 100,  32, 116, 104, 101, 110,  32, 105, 116,  32,  99, 104, 101,
   99, 107, 115,  32, 116, 104, 101,  32, 116, 121, 112, 101, 115,  32, 111, 102,
   32, 116, 104, 101,  32, 118,  97, 108, 117, 101, 115,  32, 119, 105, 116, 104,
   32,  10,  32, 116, 104, 101,  32,  34, 100, 101,  97, 100,  34,  32, 115, 116,
  114, 105, 110, 103, 115,  32, 114, 101,  98, 111, 114, 110,  46,  10,  10,  32,
   73, 116,  32, 105, 115,  32, 115, 105, 109, 112, 108, 101,  32,  97, 110, 100,
   32, 115, 104, 111, 114, 116,  44,  32, 105, 116,  32, 105, 115,  32, 105, 110,
   32,  66,  69,  84,  65,  32,  98, 117, 116,  32, 105, 115, 115, 117, 101, 115,
   32, 119, 105, 108, 108,  32,  98, 101,  32, 114,  97, 114, 101,  32, 105, 116,
   32, 104,  97, 115,  32,  98, 101, 101, 110,  32, 116, 101, 115, 116, 101, 100,
   32, 111, 110,  32, 101, 118, 101, 110,  32, 116, 104, 105, 115,  32,  10,  32,
  102, 105, 108, 101,  32,  97, 110, 100,  32, 105, 116,  32, 119, 111, 114, 107,
  115,  32, 102, 105, 110, 101,  46,  10,  10,  32,  73, 102,  32, 121, 111, 117,
   32, 100, 111,  32, 110, 111, 116,  32, 117, 115, 101,  32, 116, 104, 101,  32,
  116, 121, 112, 101,  99, 104, 101,  99, 107, 101, 114,  32, 116, 121, 112, 101,
   32,  97, 110, 110, 111, 116,  97, 116, 105, 111, 110, 115,  32,  97, 114, 101,
   32, 115, 117, 112, 112, 111, 114, 116, 101, 100,  32,  98, 121,  32, 116, 104,
  101,  32, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 114,  32,  98, 117,
  116,  32, 119, 111, 110, 116,  10,  32, 104,  97, 118, 101,  32,  97, 110, 121,
   32, 118,  97, 108, 117, 101,  46,  32,  66, 117, 116,  32, 116, 104, 101,  32,
  115,  97, 109, 101,  32,  99,  97, 110, 110, 111, 116,  32,  98, 101,  32, 115,
   97, 105, 100,  32, 102, 111, 114,  32, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  32, 100, 105, 114, 101,  99, 116, 105, 118, 101, 115,  44,
   32, 116, 104, 101, 121,  32,  97, 114, 101,  32, 110, 111, 116,  32, 115, 117,
  112, 112, 111, 114, 116, 101, 100,  32,  10,  32, 105, 110,  32, 116, 104, 101,
   32, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 114,  46,  10,  10,  32,
   73, 102,  32, 116, 104, 101,  32, 116, 121, 112, 101,  99, 104, 101,  99, 107,
  101, 114,  32, 102,  97, 105, 108, 115,  32, 116, 111,  32,  99, 104, 101,  99,
  107,  32, 105, 116,  32, 119, 105, 108, 108,  32, 105, 103, 110, 111, 114, 101,
   46,  10,  42,  47,  10,  10,  47,  47,  32,  71,  76,  79,  66,  65,  76,  83,
   10, 100, 101,  97, 100,  32,  61,  32, 123, 125,  10,  10,  47,  47,  32,  69,
   82,  82,  79,  82,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 116, 121,
  112, 101, 114, 114, 111, 114,  40, 101, 114, 114, 111, 114, 105, 110,  44,  32,
  108, 105, 110, 101,  44,  32, 110, 111, 116, 101,  41, 123,  10,  32,  32, 112,
  114, 105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49, 109,  84,
  121, 112, 101,  99, 104, 101,  99, 107, 101, 114,  32, 101, 114, 114, 111, 114,
   58,  92,  50,  55,  91,  48, 109,  34,  41,  10,  32,  32, 105, 102,  32,  40,
  101, 114, 114, 111, 114, 105, 110,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32, 112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49,
  109,  34,  46,  46, 101, 114, 114, 111, 114, 105, 110,  46,  46,  34,  92,  50,
   55,  91,  48, 109,  92, 110,  92, 110,  34,  41,  10,  32,  32, 125,  10,  32,
   32, 112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49,
  109,  83, 110, 105, 112, 112, 101, 116,  58,  92,  50,  55,  91,  48, 109,  34,
   41,  10,  32,  32, 112, 114, 105, 110, 116,  40, 114, 101, 118, 105, 118, 101,
   40, 108, 105, 110, 101,  41,  41,  10,  32,  32, 105, 102,  32,  40, 110, 111,
  116, 101,  41, 123,  10,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,  34,
   92, 110,  92,  50,  55,  91,  49,  59,  51,  49, 109,  84, 121, 112, 101,  99,
  104, 101,  99, 107, 101, 114,  32, 112, 114, 111, 118, 105, 100, 101, 100,  32,
  110, 111, 116, 101,  58,  92,  50,  55,  91,  48, 109,  34,  41,  10,  32,  32,
   32,  32, 112, 114, 105, 110, 116,  40,  34,  92, 110,  92,  50,  55,  91,  49,
   59,  51,  49, 109,  34,  46,  46, 110, 111, 116, 101,  46,  46,  34,  92,  50,
   55,  91,  48, 109,  34,  41,  10,  32,  32, 125,  10,  32,  32, 112, 114, 105,
  110, 116,  40,  34,  92, 110,  92,  50,  55,  91,  49,  59,  51,  49, 109,  83,
  116, 111, 112, 112, 105, 110, 103,  32,  84, 121, 112, 101,  99, 104, 101,  99,
  107, 101, 114,  46,  92,  50,  55,  91,  48, 109,  34,  41,  10,  32,  32, 111,
  115,  46, 101, 120, 105, 116,  40,  41,  10, 125,  10,  47,  47,  32,  76,  79,
   65,  68,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 116,  97,  98, 108,
  101, 116, 111, 115, 116, 114, 105, 110, 103,  40, 116,  98, 108,  41, 123,  10,
   32,  32,  47,  47,  32,  67, 111, 110, 118, 101, 114, 116, 115,  32,  97,  32,
  116,  97,  98, 108, 101,  32, 116, 111,  32,  97,  32, 115, 116, 114, 105, 110,
  103,  10,  32,  32, 118,  97, 114,  32, 114, 101, 115, 117, 108, 116,  32,  61,
   32,  34, 123,  34,  10,  32,  32, 102, 111, 114,  32,  40, 105,  44,  32, 118,
   32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 116,  98, 108,  41,  41,  32,
  123,  10,  32,  32,  32,  32, 105, 102,  32,  40,  33, 118,  41, 123,  10,  32,
   32,  32,  32,  32,  32, 118,  32,  61,  32,  34, 110, 117, 108, 108,  34,  10,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 118,  32,  61,  32,  40, 108,
  111,  97, 100, 115, 116, 114, 105, 110, 103,  40,  34, 114, 101, 116, 117, 114,
  110,  32,  34,  46,  46,  40, 118,  32, 124, 124,  32,  34, 110, 117, 108, 108,
   34,  41,  41,  32, 124, 124,  32, 108, 111,  97, 100, 101, 110, 118,  40,  34,
  114, 101, 116, 117, 114, 110,  32,  34,  46,  46,  40, 118,  32, 124, 124,  32,
   34, 110, 117, 108, 108,  34,  41,  41,  41,  10,  32,  32,  32,  32, 120, 112,
   99,  97, 108, 108,  40, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,
   10,  32,  32,  32,  32,  32,  32, 118,  32,  61,  32, 118,  40,  41,  10,  32,
   32,  32,  32, 125,  44,  32,  10,  32,  32,  32,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32, 118,  32,  61,
   32, 108, 111,  97, 100, 101, 110, 118,  40,  34, 114, 101, 116, 117, 114, 110,
   32,  34,  46,  46,  40, 118,  32, 124, 124,  32,  34, 110, 117, 108, 108,  34,
   41,  41,  10,  32,  32,  32,  32,  32,  32, 120, 112,  99,  97, 108, 108,  40,
  102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 118,  32,  61,  32, 118,  40,  41,  10,  32,  32,  32,  32,
   32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40, 101, 114, 114,  41, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 116, 121, 112, 101, 114, 114, 111, 114,  40,  34,  69, 114, 114, 111,
  114,  32,  99, 104, 101,  99, 107, 105, 110, 103,  32, 118,  97, 108, 117, 101,
   58,  32,  34,  46,  46, 101, 114, 114,  41,  10,  32,  32,  32,  32,  32,  32,
  125,  41,  10,  32,  32,  32,  32, 125,  41,  10,  10,  32,  32,  32,  32, 105,
  102,  32,  40, 116, 121, 112, 101,  40, 118,  41,  32,  61,  61,  32,  34, 115,
  116, 114, 105, 110, 103,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
  114, 101, 115, 117, 108, 116,  32,  61,  32, 114, 101, 115, 117, 108, 116,  46,
   46, 105,  46,  46,  34,  32,  61,  32,  92,  34,  34,  46,  46, 118,  46,  46,
   34,  92,  34,  44,  34,  10,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,
   32, 105, 102,  32,  40, 116, 121, 112, 101,  40, 118,  41,  32,  61,  61,  32,
   34, 116,  97,  98, 108, 101,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32, 114, 101, 115, 117, 108, 116,  32,  61,  32, 114, 101, 115, 117, 108, 116,
   46,  46, 105,  46,  46,  34,  32,  61,  32,  34,  46,  46, 116,  97,  98, 108,
  101, 116, 111, 115, 116, 114, 105, 110, 103,  40, 118,  41,  46,  46,  34,  44,
   32,  34,  10,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,
   32,  32,  32,  32,  32,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32, 114,
  101, 115, 117, 108, 116,  46,  46, 105,  46,  46,  34,  32,  61,  32,  34,  46,
   46,  40, 118,  32, 124, 124,  32,  34, 110, 117, 108, 108,  34,  41,  46,  46,
   34,  44,  34,  10,  32,  32,  32,  32, 125,  10,  32,  32, 125,  10,  32,  32,
  114, 101, 115, 117, 108, 116,  32,  61,  32, 114, 101, 115, 117, 108, 116,  46,
   46,  34, 125,  34,  10,  32,  32, 114, 101, 116, 117, 114, 110,  32, 114, 101,
  115, 117, 108, 116,  10, 125,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32,
  108, 111,  97, 100, 101, 110, 118,  40, 101, 110, 118,  44,  32, 115, 116, 114,
   41, 123,  10,  32,  32,  47,  47,  32,  85, 115, 101, 115,  32, 108, 111,  97,
  100, 115, 116, 114, 105, 110, 103,  44,  32,  98, 117, 116,  32, 116, 104, 101,
   32, 101, 110, 118, 105, 111, 117, 114, 109, 101, 110, 116,  32,  99,  97, 110,
   32,  98, 101,  32, 112, 114, 111, 118, 105, 100, 101, 100,  46,  32, 101, 110,
  118,  32, 105, 115,  32,  97,  32, 116,  97,  98, 108, 101,  46,  10,  32,  32,
  101, 110, 118, 115, 116, 114,  32,  61,  32, 116,  97,  98, 108, 101, 116, 111,
  115, 116, 114, 105, 110, 103,  40, 101, 110, 118,  41,  10,  32,  32, 115, 116,
  114,  32,  61,  32,  91,  91,  10,  32,  32,  32,  32, 101, 110, 118,  32,  61,
   32,  93,  93,  46,  46, 101, 110, 118, 115, 116, 114,  46,  46,  91,  91,  10,
   32,  32,  32,  32, 102, 111, 114,  32,  40, 105,  44,  32, 118,  32, 105, 110,
   32, 112,  97, 105, 114, 115,  40, 101, 110, 118,  41,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  95,  71,  91, 105,  93,  32,  61,  32, 118,  10,  32,
   32,  32,  32, 125,  10,  10,  32,  32,  93,  93,  46,  46, 115, 116, 114,  10,
   10,  32,  32, 114, 101, 116, 117, 114, 110,  32, 108, 111,  97, 100, 115, 116,
  114, 105, 110, 103,  40, 114, 101, 118, 105, 118, 101,  40, 115, 116, 114,  41,
   41,  59,  10, 125,  10,  10,  47,  47,  32,  84,  89,  80,  69,  83,  10, 116,
  121, 112, 101, 115,  32,  61,  32, 123,  10,  32,  32,  34, 115, 116, 114, 105,
  110, 103,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116,
  101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99,
  107,  32, 105, 102,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97,  32, 115,
  116, 114, 105, 110, 103,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34,
  115, 116, 114, 105, 110, 103,  34,  10,  32,  32, 125,  44,  10,  32,  32,  34,
  112, 111, 115,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105,
  116, 101, 109,  41, 123,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32, 109,  97, 116, 104,  46,  97,  98, 115,  40, 105, 116, 101, 109,  41,  32,
   61,  61,  32, 105, 116, 101, 109,  10,  32,  32, 125,  44,  10,  32,  32,  34,
  110, 101, 103,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105,
  116, 101, 109,  41, 123,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32, 109,  97, 116, 104,  46,  97,  98, 115,  40, 105, 116, 101, 109,  41,  32,
   33,  61,  32, 105, 116, 101, 109,  10,  32,  32, 125,  44,  10,  32,  32,  34,
  112, 111, 115, 105, 110, 116,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32, 114, 101, 116,
  117, 114, 110,  32, 109,  97, 116, 104,  46,  97,  98, 115,  40, 105, 116, 101,
  109,  41,  32,  61,  61,  32, 105, 116, 101, 109,  32,  38,  38,  32, 109,  97,
  116, 104,  46, 102, 108, 111, 111, 114,  40, 105, 116, 101, 109,  41,  32,  61,
   61,  32, 105, 116, 101, 109,  10,  32,  32, 125,  44,  10,  32,  32,  34, 110,
  101, 103, 105, 110, 116,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,
   40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32, 114, 101, 116, 117,
  114, 110,  32, 109,  97, 116, 104,  46,  97,  98, 115,  40, 105, 116, 101, 109,
   41,  32,  33,  61,  32, 105, 116, 101, 109,  32,  38,  38,  32, 109,  97, 116,
  104,  46, 102, 108, 111, 111, 114,  40, 105, 116, 101, 109,  41,  32,  61,  61,
   32, 105, 116, 101, 109,  10,  32,  32, 125,  44,  10,  32,  32,  34, 112, 111,
  105, 110, 116, 101, 114,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,
   40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67,
  104, 101,  99, 107,  32, 105, 102,  32, 116, 104, 101,  32, 105, 116, 101, 109,
   32, 105, 115,  32,  97,  32, 115, 116, 114, 105, 110, 103,  32, 119, 104, 105,
   99, 104,  32, 105, 115,  32, 112,  97, 114, 115, 101, 100,  32, 108, 105, 107,
  101,  32,  97,  32, 112, 111, 105, 110, 116, 101, 114,  10,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,
   41,  32,  61,  61,  32,  34, 115, 116, 114, 105, 110, 103,  34,  32,  38,  38,
   32,  40, 115, 116, 114, 105, 110, 103,  46, 115, 117,  98,  40, 105, 116, 101,
  109,  44,  32,  49,  44,  32,  49,  41,  32,  61,  61,  32,  34,  38,  34,  32,
  124, 124,  32, 115, 116, 114, 105, 110, 103,  46, 115, 117,  98,  40, 105, 116,
  101, 109,  44,  32,  49,  44,  32,  50,  41,  32,  61,  61,  32,  34,  48, 120,
   34,  41,  10,  32,  32, 125,  44,  10,  32,  32,  34,  97, 114, 114,  97, 121,
   34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,
   41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  77,  97, 107, 101,  32, 115,
  117, 114, 101,  32, 116, 104,  97, 116,  32,  97, 108, 108,  32, 116, 104, 101,
   32, 105, 110, 100, 101, 120, 101, 115,  32,  97, 114, 101,  32, 105, 110, 116,
  101, 103, 101, 114, 115,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105,
   44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 105, 116, 101,
  109,  41,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,
  116, 121, 112, 101,  40, 105,  41,  32,  33,  61,  32,  34, 110, 117, 109,  98,
  101, 114,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  10,  32,  32,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  32,  32, 125,  44,  10,  32,
   32,  34, 109,  97, 116, 114, 105, 120,  34,  58,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,
   47,  32,  67, 104, 101,  99, 107,  32, 105, 102,  32,  97, 108, 108,  32, 116,
  104, 101,  32, 118,  97, 108, 117, 101, 115,  32,  97, 114, 101,  32,  97,  32,
  116,  97,  98, 108, 101,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105,
   44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 105, 116, 101,
  109,  41,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,
  116, 121, 112, 101,  40, 118,  41,  32,  33,  61,  32,  34, 116,  97,  98, 108,
  101,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101,
  116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  10,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32, 125,  10,  32,  32, 125,  44,  10,  32,  32,
   34,  86, 101,  99, 116, 111, 114,  51,  34,  58,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,
   47,  32,  85, 115, 101, 115,  32, 116, 104, 101,  32,  96,  86, 101,  99, 116,
  111, 114,  51,  96,  32,  99, 108,  97, 115, 115,  32,  97, 110, 100,  32,  99,
  104, 101,  99, 107,  32, 105, 102,  32, 116, 111, 115, 116, 114, 105, 110, 103,
   40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34, 118, 101,  99,  51,  58,
   32,  60, 112, 111, 105, 110, 116, 101, 114,  62,  34,  10,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,
   41,  32,  61,  61,  32,  34, 117, 115, 101, 114, 100,  97, 116,  97,  34,  32,
   38,  38,  32, 115, 116, 114, 105, 110, 103,  46, 109,  97, 116,  99, 104,  40,
  116, 111, 115, 116, 114, 105, 110, 103,  40, 105, 116, 101, 109,  41,  44,  32,
   34,  94, 118, 101,  99,  51,  58,  32,  34,  41,  10,  32,  32, 125,  44,  10,
   32,  32,  34,  86, 101,  99, 116, 111, 114,  50,  34,  58,  32, 102, 117, 110,
   99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,
   32,  47,  47,  32,  85, 115, 101, 115,  32, 116, 104, 101,  32,  96,  86, 101,
   99, 116, 111, 114,  50,  96,  32,  99, 108,  97, 115, 115,  32,  97, 110, 100,
   32,  99, 104, 101,  99, 107,  32, 105, 102,  32, 116, 111, 115, 116, 114, 105,
  110, 103,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34, 118, 101,  99,
   50,  58,  32,  60, 112, 111, 105, 110, 116, 101, 114,  62,  34,  10,  32,  32,
   32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116,
  101, 109,  41,  32,  61,  61,  32,  34, 117, 115, 101, 114, 100,  97, 116,  97,
   34,  32,  38,  38,  32, 115, 116, 114, 105, 110, 103,  46, 109,  97, 116,  99,
  104,  40, 116, 111, 115, 116, 114, 105, 110, 103,  40, 105, 116, 101, 109,  41,
   44,  32,  34,  94, 118, 101,  99,  50,  58,  32,  34,  41,  10,  32,  32, 125,
   44,  10,  32,  32,  34,  67, 111, 108, 111, 114,  34,  58,  32, 102, 117, 110,
   99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,
   32,  47,  47,  32,  85, 115, 101, 115,  32, 116, 104, 101,  32,  96,  67, 111,
  108, 111, 114,  96,  32,  99, 108,  97, 115, 115,  32,  97, 110, 100,  32,  99,
  104, 101,  99, 107,  32, 105, 102,  32, 116, 111, 115, 116, 114, 105, 110, 103,
   40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34,  99, 111, 108, 111, 114,
   58,  32,  60, 112, 111, 105, 110, 116, 101, 114,  62,  34,  10,  32,  32,  32,
   32, 114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101,
  109,  41,  32,  61,  61,  32,  34, 117, 115, 101, 114, 100,  97, 116,  97,  34,
   32,  38,  38,  32, 115, 116, 114, 105, 110, 103,  46, 109,  97, 116,  99, 104,
   40, 116, 111, 115, 116, 114, 105, 110, 103,  40, 105, 116, 101, 109,  41,  44,
   32,  34,  94,  99, 111, 108, 111, 114,  58,  32,  34,  41,  10,  32,  32, 125,
   44,  10,  32,  32,  34,  84, 114,  97, 110, 115, 102, 111, 114, 109,  34,  58,
   32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,
   10,  32,  32,  32,  32,  47,  47,  32,  85, 115, 101, 115,  32, 116, 104, 101,
   32,  96,  84, 114,  97, 110, 115, 102, 111, 114, 109,  96,  32,  99, 108,  97,
  115, 115,  32,  97, 110, 100,  32,  99, 104, 101,  99, 107,  32, 105, 102,  32,
  116, 111, 115, 116, 114, 105, 110, 103,  40, 105, 116, 101, 109,  41,  32,  61,
   61,  32,  34, 116, 114,  97, 110, 115, 102, 111, 114, 109,  58,  32,  60, 112,
  111, 105, 110, 116, 101, 114,  62,  34,  10,  32,  32,  32,  32, 114, 101, 116,
  117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,
   61,  32,  34, 117, 115, 101, 114, 100,  97, 116,  97,  34,  32,  38,  38,  32,
  115, 116, 114, 105, 110, 103,  46, 109,  97, 116,  99, 104,  40, 116, 111, 115,
  116, 114, 105, 110, 103,  40, 105, 116, 101, 109,  41,  44,  32,  34,  94, 116,
  114,  97, 110, 115, 102, 111, 114, 109,  58,  32,  34,  41,  10,  32,  32, 125,
   44,  10,  32,  32,  34, 110, 117, 109,  98, 101, 114,  34,  58,  32, 102, 117,
  110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,
   32,  32,  47,  47,  32,  67, 104, 101,  99, 107,  32, 105, 102,  32, 105, 116,
  101, 109,  32, 105, 115,  32,  97,  32, 110, 117, 109,  98, 101, 114,  10,  32,
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105,
  116, 101, 109,  41,  32,  61,  61,  32,  34, 110, 117, 109,  98, 101, 114,  34,
   10,  32,  32, 125,  44,  10,  32,  32,  34,  98, 111, 111, 108, 101,  97, 110,
   34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,
   41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99, 107,  32,
  105, 102,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97,  32,  98, 111, 111,
  108, 101,  97, 110,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,
  116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34,  98,
  111, 111, 108, 101,  97, 110,  34,  10,  32,  32, 125,  44,  10,  32,  32,  34,
  116,  97,  98, 108, 101,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,
   40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67,
  104, 101,  99, 107,  32, 105, 102,  32, 105, 116, 101, 109,  32, 105, 115,  32,
   97,  32, 116,  97,  98, 108, 101,  10,  32,  32,  32,  32, 114, 101, 116, 117,
  114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,
   32,  34, 116,  97,  98, 108, 101,  34,  10,  32,  32, 125,  44,  10,  32,  32,
   34, 102, 117, 110,  99, 116, 105, 111, 110,  34,  58,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,
   47,  47,  32,  67, 104, 101,  99, 107,  32, 105, 102,  32, 105, 116, 101, 109,
   32, 105, 115,  32,  97,  32, 102, 117, 110,  99, 116, 105, 111, 110,  10,  32,
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105,
  116, 101, 109,  41,  32,  61,  61,  32,  34, 102, 117, 110,  99, 116, 105, 111,
  110,  34,  10,  32,  32, 125,  44,  10,  32,  32,  34, 117, 115, 101, 114, 100,
   97, 116,  97,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105,
  116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,
   99, 107,  32, 105, 102,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97,  32,
  117, 115, 101, 114, 100,  97, 116,  97,  10,  32,  32,  32,  32, 114, 101, 116,
  117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,
   61,  32,  34, 117, 115, 101, 114, 100,  97, 116,  97,  34,  10,  32,  32, 125,
   44,  10,  32,  32,  34, 116, 104, 114, 101,  97, 100,  34,  58,  32, 102, 117,
  110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,
   32,  32,  47,  47,  32,  67, 104, 101,  99, 107,  32, 105, 102,  32, 105, 116,
  101, 109,  32, 105, 115,  32,  97,  32, 116, 104, 114, 101,  97, 100,  10,  32,
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105,
  116, 101, 109,  41,  32,  61,  61,  32,  34, 116, 104, 114, 101,  97, 100,  34,
   10,  32,  32, 125,  44,  10,  32,  32,  34, 110, 117, 108, 108,  34,  58,  32,
  102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,
   32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99, 107,  32, 105, 102,  32,
  105, 116, 101, 109,  32, 105, 115,  32, 110, 117, 108, 108,  10,  32,  32,  32,
   32, 114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101,
  109,  41,  32,  61,  61,  32,  34, 110, 117, 108, 108,  34,  10,  32,  32, 125,
   44,  10,  32,  32,  34,  99, 104,  97, 114,  34,  58,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,
   47,  47,  32,  67, 104, 101,  99, 107,  32, 105, 102,  32, 116, 104, 101,  32,
  105, 116, 101, 109,  32, 105, 115,  32,  97,  32, 115, 116, 114, 105, 110, 103,
   32,  97, 110, 100,  32,  49,  32,  99, 104,  97, 114,  97,  99, 116, 101, 114,
   32, 108, 111, 110, 103,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34,
  115, 116, 114, 105, 110, 103,  34,  32,  38,  38,  32,  35, 105, 116, 101, 109,
   32,  61,  61,  32,  49,  59,  10,  32,  32, 125,  44,  10,  32,  32,  34, 109,
  115, 103,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116,
  101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99,
  107,  32, 105, 102,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 105, 116,
  101, 109,  41,  32,  61,  61,  32,  34, 109, 101, 115, 115,  97, 103, 101,  58,
   32,  60, 112, 111, 105, 110, 116, 101, 114,  62,  34,  10,  32,  32,  32,  32,
   47,  47,  32, 109, 101, 115, 115,  97, 103, 101, 115,  32,  97, 114, 101,  32,
  117, 115, 101, 100,  32, 105, 110,  32, 116, 104, 101,  32,  77, 101, 115, 115,
   97, 103, 101,  32, 108, 105,  98, 114,  97, 114, 121,  32, 102, 111, 114,  32,
   99, 111, 109, 109, 117, 110, 105,  99,  97, 116, 105, 111, 110,  32,  98, 101,
  116, 119, 101, 101, 110,  32, 116, 104, 114, 101,  97, 100, 115,  10,  32,  32,
   32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 111, 115, 116, 114, 105, 110,
  103,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32, 115, 116, 114, 105, 110,
  103,  46, 109,  97, 116,  99, 104,  40,  34,  94, 109, 101, 115, 115,  97, 103,
  101,  58,  32,  34,  41,  10,  32,  32, 125,  44,  10,  32,  32,  34,  99, 111,
  109, 112, 108, 101, 120,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,
   40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  84,
  114, 121,  32, 116, 111,  32, 103, 101, 116,  32, 105, 116, 101, 109,  46,  95,
   95, 110,  97, 109, 101,  44,  32, 105, 102,  32, 105, 116,  32, 105, 115,  32,
   34,  99, 111, 109, 112, 108, 101, 120,  32, 110, 117, 109,  98, 101, 114,  34,
   32, 116, 104, 101, 110,  32, 105, 116,  32, 105, 115,  32,  97,  32,  99, 111,
  109, 112, 108, 101, 120,  32, 110, 117, 109,  98, 101, 114,  10,  32,  32,  32,
   32, 115,  44,  32, 101,  32,  61,  32, 112,  99,  97, 108, 108,  40, 102, 117,
  110,  99, 116, 105, 111, 110,  40,  41, 123,  32, 105, 102,  32,  40,  33, 105,
  116, 101, 109,  46,  95,  95, 110,  97, 109, 101,  41, 123, 101, 114, 114, 111,
  114,  40,  34,  70, 111, 114,  99, 101,  32, 101, 114, 114, 111, 114,  34,  41,
  125,  32, 125,  41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,
  115,  10,  32,  32, 125,  44,  10,  32,  32,  34, 100, 105, 114, 101,  99, 116,
  111, 114, 121,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105,
  116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  70, 111, 114,
   32,  96, 102, 105, 108, 101,  96,  32, 100, 105, 114, 101,  99, 116, 111, 114,
  121,  32, 116, 121, 112, 101,  10,  32,  32,  32,  32,  47,  47,  32, 114, 101,
  116, 117, 114, 110,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 105, 116,
  101, 109,  41,  32,  61,  61,  32,  34, 100, 105, 114, 101,  99, 116, 111, 114,
  121,  58,  32,  60, 112, 111, 105, 110, 116, 101, 114,  62,  34,  10,  32,  32,
   32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 111, 115, 116, 114, 105, 110,
  103,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32, 115, 116, 114, 105, 110,
  103,  46, 109,  97, 116,  99, 104,  40,  34,  94, 100, 105, 114, 101,  99, 116,
  111, 114, 121,  58,  32,  34,  41,  10,  32,  32, 125,  44,  10,  32,  32,  34,
  108, 111,  99, 107,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,
  105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  70, 111,
  114,  32,  96, 102, 105, 108, 101,  96,  32, 108, 111,  99, 107,  32, 116, 121,
  112, 101,  10,  32,  32,  32,  32,  47,  47,  32, 114, 101, 116, 117, 114, 110,
   32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 105, 116, 101, 109,  41,  32,
   61,  61,  32,  34, 108, 111,  99, 107,  58,  32,  60, 112, 111, 105, 110, 116,
  101, 114,  62,  34,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,
  116, 111, 115, 116, 114, 105, 110, 103,  40, 105, 116, 101, 109,  41,  32,  61,
   61,  32, 115, 116, 114, 105, 110, 103,  46, 109,  97, 116,  99, 104,  40,  34,
   94, 108, 111,  99, 107,  58,  32,  34,  41,  10,  32,  32, 125,  44,  10,  32,
   32,  34, 112, 114, 111, 116, 101,  99, 116, 101, 100,  34,  58,  32, 102, 117,
  110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,
   32,  32,  47,  47,  32, 114, 101, 116, 117, 114, 110,  32, 103, 101, 116, 109,
  101, 116,  97, 116,  97,  98, 108, 101,  40, 105, 116, 101, 109,  41,  46,  95,
   95, 109, 101, 116,  97, 116,  97,  98, 108, 101,  32,  33,  61,  32, 110, 105,
  108,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 103, 101, 116,
  109, 101, 116,  97, 116,  97,  98, 108, 101,  40, 105, 116, 101, 109,  41,  46,
   95,  95, 109, 101, 116,  97, 116,  97,  98, 108, 101,  32,  33,  61,  32, 110,
  117, 108, 108,  10,  32,  32, 125,  44,  10,  32,  32,  34,  95,  76,  85,  65,
   66,  79,  88,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105,
  116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,
   99, 107,  32, 105, 102,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 105,
  116, 101, 109,  41,  32,  61,  61,  32,  34,  76,  85,  65,  66,  79,  88,  58,
   32,  60, 112, 111, 105, 110, 116, 101, 114,  62,  34,  10,  32,  32,  32,  32,
   47,  47,  32, 116, 104, 105, 115,  32, 115, 104, 111, 117, 108, 100, 110, 116,
   32,  98, 101,  32, 117, 115, 101, 100,  32, 102, 111, 114,  32,  97, 118, 101,
  114,  97, 103, 101,  32,  99, 111, 100, 101,  44,  32,  76,  85,  65,  66,  79,
   88,  32, 105, 115,  32, 105, 110, 116, 101, 114, 110,  97, 108,  10,  32,  32,
   32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 111, 115, 116, 114, 105, 110,
  103,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32, 115, 116, 114, 105, 110,
  103,  46, 109,  97, 116,  99, 104,  40,  34,  94,  76,  85,  65,  66,  79,  88,
   58,  32,  34,  41,  10,  32,  32, 125,  44,  10,  32,  32,  34,  97, 110, 121,
   34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,
   41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99, 107,  32,
  105, 102,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97, 110, 121,  32, 116,
  121, 112, 101,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116,
  114, 117, 101,  10,  32,  32, 125,  44,  10,  32,  32,  34, 116, 104, 114, 101,
   97, 100,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116,
  101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99,
  107,  32, 105, 102,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97,  32, 116,
  104, 114, 101,  97, 100,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34,
  116, 104, 114, 101,  97, 100,  34,  10,  32,  32, 125,  44,  10,  32,  32,  34,
  105, 110, 116,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105,
  116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,
   99, 107,  32, 105, 102,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97, 110,
   32, 105, 110, 116, 101, 103, 101, 114,  10,  32,  32,  32,  32, 114, 101, 116,
  117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,
   61,  32,  34, 110, 117, 109,  98, 101, 114,  34,  32,  38,  38,  32, 109,  97,
  116, 104,  46, 102, 108, 111, 111, 114,  40, 105, 116, 101, 109,  41,  32,  61,
   61,  32, 105, 116, 101, 109,  10,  32,  32, 125,  44,  10,  32,  32,  34, 102,
  108, 111,  97, 116,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,
  105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104,
  101,  99, 107,  32, 105, 102,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97,
   32, 102, 108, 111,  97, 116,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114,
  110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,
   34, 110, 117, 109,  98, 101, 114,  34,  32,  38,  38,  32, 109,  97, 116, 104,
   46, 102, 108, 111, 111, 114,  40, 105, 116, 101, 109,  41,  32,  33,  61,  32,
  105, 116, 101, 109,  10,  32,  32, 125,  44,  10,  32,  32,  34, 100, 111, 117,
   98, 108, 101,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105,
  116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,
   99, 107,  32, 105, 102,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97,  32,
  100, 111, 117,  98, 108, 101,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114,
  110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,
   34, 110, 117, 109,  98, 101, 114,  34,  32,  38,  38,  32, 109,  97, 116, 104,
   46, 102, 108, 111, 111, 114,  40, 105, 116, 101, 109,  41,  32,  33,  61,  32,
  105, 116, 101, 109,  10,  32,  32, 125,  44,  10, 125,  59,  10,  97, 108, 108,
  116, 121, 112, 101, 115,  32,  61,  32,  91,  93,  10,  10, 102, 111, 114,  32,
   40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 116,
  121, 112, 101, 115,  41,  41,  32, 123,  10,  32,  32, 116,  97,  98, 108, 101,
   46, 105, 110, 115, 101, 114, 116,  40,  97, 108, 108, 116, 121, 112, 101, 115,
   44,  32, 105,  41,  10, 125,  10,  10,  47,  47,  32,  80,  65,  82,  83,  69,
   82,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 100, 101, 102, 102, 105,
  110, 100,  40, 115, 116, 114,  41,  32, 123,  10,  32,  32,  32,  32,  47,  47,
   32,  84,  97, 107, 101, 115,  32, 105, 110,  32,  99, 111, 100, 101,  32,  97,
  110, 100,  32, 108, 111, 111, 107, 115,  32, 102, 111, 114,  32, 100, 101, 102,
  105, 110, 105, 116, 105, 111, 110, 115,  32, 119, 105, 116, 104,  32,  97, 110,
  110, 111, 116,  97, 116, 105, 111, 110, 115,  10,  32,  32,  32,  32, 118,  97,
  114,  32, 112,  97, 116, 116, 101, 114, 110,  32,  61,  32,  34,  94,  37, 115,
   42, 118,  97, 114,  37, 115,  43,  40,  91,  94,  37, 115,  93,  43,  41,  37,
  115,  42,  58,  37, 115,  42,  40,  91,  94,  37, 115,  93,  43,  41,  37, 115,
   42,  61,  37, 115,  42,  40,  91,  94,  37, 115,  93,  43,  41,  37, 115,  42,
   36,  34,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 112,  97, 116, 116,
  101, 114, 110,  32,  61,  32,  34,  94,  37, 115,  42, 118,  97, 114,  37, 115,
   43,  40,  91,  94,  37, 115,  93,  43,  41,  37, 115,  42,  58,  37, 115,  42,
   40,  91,  94,  37, 115,  93,  43,  41,  37, 115,  42,  61,  37, 115,  42,  40,
   46,  45,  41,  37, 115,  42,  36,  34,  59,  10,  32,  32,  32,  32, 118,  97,
  114,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32, 123, 125,  59,  10,  32,
   32,  32,  32, 102, 111, 114,  40,  32, 108, 105, 110, 101,  32, 105, 110,  32,
  115, 116, 114,  45,  62, 103, 109,  97, 116,  99, 104,  40,  34,  91,  94,  92,
  114,  92, 110,  93,  43,  34,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32, 118,  97, 114, 116,  44,  32, 107, 101, 121,  44,
   32, 118,  97, 108, 117, 101,  32,  61,  32, 108, 105, 110, 101,  45,  62, 109,
   97, 116,  99, 104,  40, 112,  97, 116, 116, 101, 114, 110,  41,  59,  10,  32,
   32,  32,  32,  32,  32, 105, 102,  40,  32, 118,  97, 114, 116,  32,  38,  38,
   32, 107, 101, 121,  32,  38,  38,  32, 118,  97, 108, 117, 101,  32,  41,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46,
  105, 110, 115, 101, 114, 116,  40, 114, 101, 115, 117, 108, 116,  44,  32, 123,
  118,  97, 114, 116,  44,  32, 107, 101, 121,  44,  32, 118,  97, 108, 117, 101,
   44,  32, 108, 105, 110, 101, 125,  41,  59,  10,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 114, 101, 116, 117,
  114, 110,  32, 114, 101, 115, 117, 108, 116,  59,  10, 125,  10, 102, 117, 110,
   99, 116, 105, 111, 110,  32,  97, 115, 115, 105, 103, 110,  40, 115, 116, 114,
   41,  32, 123,  10,  32,  32,  32,  32,  47,  47,  32,  84,  97, 107, 101, 115,
   32, 105, 110,  32,  99, 111, 100, 101,  32, 108, 111, 111, 107, 115,  32, 102,
  111, 114,  32,  97, 115, 115, 105, 103, 110, 109, 101, 110, 116, 115,  32, 119,
  105, 116, 104,  32,  97, 110, 110, 111, 116,  97, 116, 105, 111, 110, 115,  10,
   32,  32,  32,  32, 118,  97, 114,  32, 112,  97, 116, 116, 101, 114, 110,  32,
   61,  32,  34,  37, 115,  42,  40,  91,  94,  37, 115,  93,  43,  41,  37, 115,
   42,  58,  37, 115,  42,  40,  91,  94,  37, 115,  93,  43,  41,  37, 115,  42,
   61,  37, 115,  42,  40,  91,  94,  37, 115,  93,  43,  41,  37, 115,  42,  34,
   59,  10,  32,  32,  32,  32, 118,  97, 114,  32, 114, 101, 115, 117, 108, 116,
   32,  61,  32, 123, 125,  59,  10,  32,  32,  32,  32, 102, 111, 114,  40,  32,
  108, 105, 110, 101,  32, 105, 110,  32, 115, 116, 114,  45,  62, 103, 109,  97,
  116,  99, 104,  40,  34,  91,  94,  92, 114,  92, 110,  93,  43,  34,  41,  32,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 118,  97,
  114, 116,  44,  32, 107, 101, 121,  44,  32, 118,  97, 108, 117, 101,  32,  61,
   32, 108, 105, 110, 101,  45,  62, 109,  97, 116,  99, 104,  40, 112,  97, 116,
  116, 101, 114, 110,  41,  59,  10,  32,  32,  32,  32,  32,  32, 105, 102,  40,
   32, 118,  97, 114, 116,  32,  38,  38,  32, 107, 101, 121,  32,  38,  38,  32,
  118,  97, 108, 117, 101,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  47,  47,  32,  86, 101, 114, 105, 102, 121,  32, 118,  97, 114,  44,
   32, 107, 101, 121,  44,  32, 118,  97, 108, 117, 101,  32,  97, 114, 101,  32,
  110, 111, 116,  32, 101, 108, 105, 103, 105,  98, 108, 101,  32, 102, 111, 114,
   32, 100, 101, 102,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,
   32,  33,  32, 100, 101, 102, 102, 105, 110, 100,  40, 108, 105, 110, 101,  41,
   91,  49,  93,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,
   40, 114, 101, 115, 117, 108, 116,  44,  32, 123, 118,  97, 114, 116,  44,  32,
  107, 101, 121,  44,  32, 118,  97, 108, 117, 101,  44,  32, 108, 105, 110, 101,
  125,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  32, 114, 101, 115, 117, 108, 116,  59,  10, 125,
   10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 102, 105, 110, 100, 102, 117,
  110,  99, 116, 105, 111, 110, 115,  40, 115, 116, 114,  41, 123,  10,  32,  32,
   47,  47,  32,  76, 111, 111, 107, 115,  32, 102, 111, 114,  32,  96, 102, 117,
  110,  99, 116, 105, 111, 110,  32, 120,  40,  60,  63,  62,  41,  96,  32,  97,
  110, 100,  32, 114, 101, 116, 117, 114, 110, 115,  32,  97,  32, 116,  97,  98,
  108, 101,  32, 111, 102,  32,  97, 108, 108,  32, 116, 104, 101,  32, 102, 117,
  110,  99, 116, 105, 111, 110, 115,  32,  97, 110, 100,  32, 115, 111, 117, 114,
   99, 101,  32,  99, 111, 100, 101,  10,  32,  32, 118,  97, 114,  32, 112,  97,
  116, 116, 101, 114, 110,  32,  61,  32,  34,  94,  37, 115,  42, 102, 117, 110,
   99, 116, 105, 111, 110,  37, 115,  43,  40,  91,  94,  37, 115,  93,  43,  41,
   37, 115,  42,  37,  40,  40,  91,  94,  37, 115,  93,  42,  41,  37,  41,  37,
  115,  42,  36,  34,  59,  10,  32,  32, 118,  97, 114,  32, 114, 101, 115, 117,
  108, 116,  32,  61,  32, 123, 125,  59,  10,  32,  32, 102, 111, 114,  40,  32,
  108, 105, 110, 101,  32, 105, 110,  32, 115, 116, 114,  45,  62, 103, 109,  97,
  116,  99, 104,  40,  34,  91,  94,  92, 114,  92, 110,  93,  43,  34,  41,  32,
   41,  32, 123,  10,  32,  32,  32,  32, 118,  97, 114,  32, 107, 101, 121,  44,
   32, 118,  97, 108, 117, 101,  32,  61,  32, 108, 105, 110, 101,  45,  62, 109,
   97, 116,  99, 104,  40, 112,  97, 116, 116, 101, 114, 110,  41,  59,  10,  32,
   32,  32,  32, 105, 102,  40,  32, 107, 101, 121,  32,  38,  38,  32, 118,  97,
  108, 117, 101,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32, 116,  97,
   98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40, 114, 101, 115, 117, 108,
  116,  44,  32, 123, 107, 101, 121,  44,  32, 118,  97, 108, 117, 101,  44,  32,
  108, 105, 110, 101, 125,  41,  59,  10,  32,  32,  32,  32, 125,  10,  32,  32,
  125,  10,  32,  32, 114, 101, 116, 117, 114, 110,  32, 114, 101, 115, 117, 108,
  116,  59,  10, 125,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32,  97, 108,
  108,  97, 115, 115, 105, 103, 110,  40, 115, 116, 114,  41, 123,  10,  32,  32,
   47,  47,  32,  85, 115, 101, 100,  32, 116, 111,  32, 108, 111, 111, 107,  32,
  102, 111, 114,  32, 116, 121, 112, 101, 108, 101, 115, 115,  32,  97, 115, 115,
  105, 103, 110, 109, 101, 110, 116, 115,  10,  32,  32, 118,  97, 114,  32, 112,
   97, 116, 116, 101, 114, 110,  32,  61,  32,  34,  37, 115,  42,  40,  91,  94,
   37, 115,  93,  43,  41,  37, 115,  42,  61,  37, 115,  42,  40,  91,  94,  37,
  115,  93,  43,  41,  37, 115,  42,  34,  59,  10,  32,  32, 118,  97, 114,  32,
  114, 101, 115, 117, 108, 116,  32,  61,  32, 123, 125,  59,  10,  32,  32, 102,
  111, 114,  40,  32, 108, 105, 110, 101,  32, 105, 110,  32, 115, 116, 114,  45,
   62, 103, 109,  97, 116,  99, 104,  40,  34,  91,  94,  92, 114,  92, 110,  93,
   43,  34,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32, 118,  97, 114,  32,
  107, 101, 121,  44,  32, 118,  97, 108, 117, 101,  32,  61,  32, 108, 105, 110,
  101,  45,  62, 109,  97, 116,  99, 104,  40, 112,  97, 116, 116, 101, 114, 110,
   41,  59,  10,  32,  32,  32,  32, 105, 102,  40,  32, 107, 101, 121,  32,  38,
   38,  32, 118,  97, 108, 117, 101,  32,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32, 105, 102,  32,  40,  33,  32, 100, 101, 102, 102, 105, 110, 100,  40,
  108, 105, 110, 101,  41,  91,  49,  93,  32,  38,  38,  32,  33,  32,  97, 115,
  115, 105, 103, 110,  40, 108, 105, 110, 101,  41,  91,  49,  93,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105,
  110, 115, 101, 114, 116,  40, 114, 101, 115, 117, 108, 116,  44,  32, 123, 107,
  101, 121,  44,  32, 118,  97, 108, 117, 101,  44,  32, 108, 105, 110, 101, 125,
   41,  59,  10,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 125,
   10,  32,  32, 125,  10,  32,  32, 114, 101, 116, 117, 114, 110,  32, 114, 101,
  115, 117, 108, 116,  59,  10, 125,  10, 102, 117, 110,  99, 116, 105, 111, 110,
   32, 102, 105, 110, 100,  97, 108, 108,  40, 115, 116, 114,  41, 123,  10,  32,
   32,  47,  47,  32,  85, 115, 101, 100,  32, 116, 111,  32, 108, 111, 111, 107,
   32, 102, 111, 114,  32,  37, 115,  61,  37, 115,  10,  32,  32, 118,  97, 114,
   32, 112,  97, 116, 116, 101, 114, 110,  32,  61,  32,  34,  37, 115,  42,  61,
   37, 115,  42,  34,  59,  10,  32,  32, 118,  97, 114,  32, 114, 101, 115, 117,
  108, 116,  32,  61,  32, 123, 125,  59,  10,  32,  32, 102, 111, 114,  40,  32,
  108, 105, 110, 101,  32, 105, 110,  32, 115, 116, 114,  45,  62, 103, 109,  97,
  116,  99, 104,  40,  34,  91,  94,  92, 114,  92, 110,  93,  43,  34,  41,  32,
   41,  32, 123,  10,  32,  32,  32,  32, 118,  97, 114,  32, 107, 101, 121,  44,
   32, 118,  97, 108, 117, 101,  32,  61,  32, 108, 105, 110, 101,  45,  62, 109,
   97, 116,  99, 104,  40, 112,  97, 116, 116, 101, 114, 110,  41,  59,  10,  32,
   32,  32,  32, 105, 102,  40,  32, 107, 101, 121,  32,  38,  38,  32, 118,  97,
  108, 117, 101,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32, 116,  97,
   98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40, 114, 101, 115, 117, 108,
  116,  44,  32, 123, 107, 101, 121,  44,  32, 118,  97, 108, 117, 101,  44,  32,
  108, 105, 110, 101, 125,  41,  59,  10,  32,  32,  32,  32, 125,  10,  32,  32,
  125,  10,  32,  32, 114, 101, 116, 117, 114, 110,  32, 114, 101, 115, 117, 108,
  116,  59,  10, 125,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 114, 101,
  118, 105, 118, 101,  40, 115, 116, 114,  41, 123,  10,  32,  32, 102, 111, 114,
   32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40,
  100, 101,  97, 100,  41,  41, 123,  10,  32,  32,  32,  32, 118,  97, 114,  32,
  105, 110, 100, 101, 120,  32,  61,  32,  34,  39,  68,  69,  65,  68,  86,  65,
   76,  85,  69,  83,  84,  82,  84,  89,  80,  69,  67,  72,  69,  67,  75,  45,
   34,  46,  46,  40, 105,  41,  46,  46,  34,  39,  34,  10,  10,  32,  32,  32,
   32,  47,  47,  32,  71, 111,  32,  99, 104,  97, 114,  97,  99, 116, 101, 114,
   32,  98, 121,  32,  99, 104,  97, 114,  97,  99, 116, 101, 114,  32,  97, 110,
  100,  32, 108, 111, 111, 107,  32, 102, 111, 114,  32, 105, 110, 100, 101, 120,
   10,  32,  32,  32,  32,  47,  47,  32,  73,  32, 119,  97, 110, 116,  32, 116,
  111,  32, 117, 115, 101,  32,  45,  62, 103, 115, 117,  98,  32,  98, 117, 116,
   32, 116, 104,  97, 116,  32, 100, 111, 101, 115, 110, 116,  32, 119, 111, 114,
  107,  32, 102, 111, 114,  32, 115, 117, 109,  32, 114, 101,  97, 115, 111, 110,
   32, 115, 111,  32,  73,  32,  97, 109,  32, 117, 115, 105, 110, 103,  32,  97,
   32,  10,  32,  32,  32,  32,  47,  47,  32, 109,  97, 110, 117,  97, 108,  32,
  109, 101, 116, 104, 111, 100,  10,  32,  32,  32,  32, 118,  97, 114,  32,  99,
  105,  32,  61,  32,  49,  59,  10,  32,  32,  32,  32, 118,  97, 114,  32,  99,
  115, 111, 102,  97, 114,  32,  61,  32,  34,  34,  59,  10,  32,  32,  32,  32,
  102, 111, 114,  32,  40, 105, 105,  32,  61,  32,  49,  44,  32,  35, 115, 116,
  114,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  99,
  104,  97, 114,  32,  61,  32, 115, 116, 114,  45,  62, 115, 117,  98,  40, 105,
  105,  44,  32, 105, 105,  41,  59,  10,  32,  32,  32,  32,  32,  32, 105, 102,
   32,  40,  99, 104,  97, 114,  32,  61,  61,  32, 105, 110, 100, 101, 120,  45,
   62, 115, 117,  98,  40,  99, 105,  44,  32,  99, 105,  41,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  99, 105,  43,  43,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  99, 115, 111, 102,  97, 114,  32,  61,  32,  99,
  115, 111, 102,  97, 114,  46,  46,  99, 104,  97, 114,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 105, 102,  32,  40,  99, 115, 111, 102,  97, 114,  32,
   61,  61,  32, 105, 110, 100, 101, 120,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 115, 116, 114,  32,  61,  32, 115, 116, 114,  45,
   62, 115, 117,  98,  40,  49,  44,  32, 105, 105,  32,  45,  32,  35, 105, 110,
  100, 101, 120,  41,  46,  46, 118,  46,  46, 115, 116, 114,  45,  62, 115, 117,
   98,  40, 105, 105,  32,  43,  32,  49,  44,  32,  35, 115, 116, 114,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32, 125,  32, 101, 108, 115, 101,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  99, 105,  32,  61,  32,  49,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  99, 115, 111, 102,  97, 114,  32,  61,  32,  34,  34,  59,  10,  32,
   32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  32,  32, 125,
   10,  32,  32, 114, 101, 116, 117, 114, 110,  32, 115, 116, 114,  10, 125,  10,
  102, 117, 110,  99, 116, 105, 111, 110,  32,  99, 108, 101,  97, 110,  40, 115,
  116, 114,  41,  32, 123,  10,  32,  32,  47,  47,  32,  84,  97, 107, 101, 115,
   32, 105, 110,  32,  99, 111, 100, 101,  32,  97, 110, 100,  32, 114, 101, 109,
  111, 118, 101, 115,  32,  99, 111, 109, 109, 101, 110, 116, 115,  44,  32, 115,
  116, 114, 105, 110, 103, 115,  46,  10,  32,  32,  47,  47,  32,  82, 101, 109,
  111, 118, 101,  32, 115, 116, 114, 105, 110, 103, 115,  32,  97, 110, 100,  32,
   97, 100, 100,  32, 105, 116,  32, 116, 111,  32,  34, 100, 101,  97, 100,  34,
   32, 116,  97,  98, 108, 101,  10,  32,  32, 118,  97, 114,  32, 100, 101,  97,
  100,  32,  61,  32, 123, 125,  59,  10,  32,  32, 118,  97, 114,  32, 105,  32,
   61,  32,  48,  59,  10,  32,  32, 111, 103, 115, 116, 114,  32,  61,  32, 115,
  116, 114,  59,  10,  32,  32, 105, 102,  32,  40,  33, 115, 116, 114,  91,  34,
  103, 115, 117,  98,  34,  93,  41,  32, 116, 121, 112, 101, 114, 114, 111, 114,
   40,  34, 115, 116, 114, 105, 110, 103,  46, 103, 115, 117,  98,  32, 105, 115,
   32, 110, 111, 116,  32,  97,  32, 102, 111, 117, 110, 100,  32, 102, 117, 110,
   99, 116, 105, 111, 110,  44,  32,  65, 114, 101,  32, 121, 111, 117,  32, 115,
  117, 114, 101,  32, 121, 111, 117,  32, 112, 114, 111, 118, 105, 100, 101, 100,
   32,  97,  32, 115, 116, 114, 105, 110, 103,  63,  34,  41,  10,  32,  32, 115,
  116, 114,  32,  61,  32, 115, 116, 114,  45,  62, 103, 115, 117,  98,  40,  34,
   39,  91,  94,  39,  93,  45,  39,  34,  44,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  40, 109,  97, 116,  99, 104,  41, 123,  10,  32,  32,  32,  32, 105,
   43,  43,  59,  10,  32,  32,  32,  32, 100, 101,  97, 100,  91, 105,  93,  32,
   61,  32, 109,  97, 116,  99, 104,  59,  10,  32,  32,  32,  32, 114, 101, 116,
  117, 114, 110,  32,  34,  39,  68,  69,  65,  68,  86,  65,  76,  85,  69,  83,
   84,  82,  84,  89,  80,  69,  67,  72,  69,  67,  75,  45,  34,  46,  46,  40,
  105,  41,  46,  46,  34,  39,  34,  59,  10,  32,  32, 125,  41,  45,  62, 103,
  115, 117,  98,  40,  39,  34,  91,  94,  34,  93,  45,  34,  39,  44,  32, 102,
  117, 110,  99, 116, 105, 111, 110,  40, 109,  97, 116,  99, 104,  41, 123,  10,
   32,  32,  32,  32, 105,  43,  43,  59,  10,  32,  32,  32,  32, 100, 101,  97,
  100,  91, 105,  93,  32,  61,  32, 109,  97, 116,  99, 104,  59,  10,  32,  32,
   32,  32, 114, 101, 116, 117, 114, 110,  32,  34,  39,  68,  69,  65,  68,  86,
   65,  76,  85,  69,  83,  84,  82,  84,  89,  80,  69,  67,  72,  69,  67,  75,
   45,  34,  46,  46,  40, 105,  41,  46,  46,  34,  39,  34,  59,  10,  32,  32,
  125,  41,  45,  62, 103, 115, 117,  98,  40,  39,  37,  91,  37,  91,  46,  45,
   37,  93,  37,  93,  39,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,
  109,  97, 116,  99, 104,  41, 123,  10,  32,  32,  32,  32, 105,  43,  43,  59,
   10,  32,  32,  32,  32, 100, 101,  97, 100,  91, 105,  93,  32,  61,  32, 109,
   97, 116,  99, 104,  59,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32,  34,  39,  68,  69,  65,  68,  86,  65,  76,  85,  69,  83,  84,  82,  84,
   89,  80,  69,  67,  72,  69,  67,  75,  45,  34,  46,  46,  40, 105,  41,  46,
   46,  34,  39,  34,  59,  10,  32,  32, 125,  41,  59,  10,  32,  32, 114, 101,
  116, 117, 114, 110,  32, 115, 116, 114,  45,  62, 103, 115, 117,  98,  40,  39,
   47,  47,  46,  45,  92, 110,  39,  44,  32,  39,  92, 110,  39,  41,  45,  62,
  103, 115, 117,  98,  40,  39,  47,  37,  42,  46,  45,  37,  42,  47,  39,  44,
   32,  39,  92, 110,  39,  41,  44,  32, 100, 101,  97, 100,  59,  10, 125,  10,
   10,  47,  47,  32,  67,  72,  69,  67,  75,  69,  82,  10, 116, 121, 112, 101,
  111, 102,  32,  61,  32, 116, 121, 112, 101,  59,  10, 102, 117, 110,  99, 116,
  105, 111, 110,  32,  99, 104, 101,  99, 107,  40, 116, 121, 112, 101,  44,  32,
  118,  97, 108, 117, 101,  44,  32, 118, 110,  97, 109, 101,  44,  32, 107, 110,
  111, 119, 110,  86,  97, 108, 117, 101, 115,  44,  32, 108, 105, 110, 101,  41,
   32, 123,  10,  32,  32, 118,  97, 108, 117, 101,  44,  32, 101, 114, 114,  32,
   61,  32, 108, 111,  97, 100, 101, 110, 118,  40, 107, 110, 111, 119, 110,  86,
   97, 108, 117, 101, 115,  44,  32,  34, 114, 101, 116, 117, 114, 110,  32,  34,
   32,  46,  46,  32, 118,  97, 108, 117, 101,  41,  10,  32,  32, 105, 102,  32,
   40,  33, 118,  97, 108, 117, 101,  41, 123,  10,  32,  32,  32,  32, 116, 121,
  112, 101, 114, 114, 111, 114,  40,  34,  67, 104, 101,  99, 107,  32, 101, 114,
  114, 111, 114,  58,  32,  34,  46,  46, 101, 114, 114,  44,  32, 108, 105, 110,
  101,  41,  10,  32,  32, 125,  10,  32,  32, 120, 112,  99,  97, 108, 108,  40,
  102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,
  118,  97, 108, 117, 101,  32,  61,  32, 118,  97, 108, 117, 101,  40,  41,  59,
   10,  32,  32, 125,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 101,
  114, 114,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  73, 103, 110, 111,
  114, 101,  32,  97, 110, 100,  32, 114, 101, 116, 117, 114, 110,  32, 116, 114,
  117, 101,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 114,
  117, 101,  59,  10,  32,  32, 125,  41,  10,  32,  32, 105, 102,  40,  32, 116,
  121, 112, 101, 115,  91, 116, 121, 112, 101,  93,  32,  41,  32, 123,  10,  32,
   32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101, 115,  91, 116, 121, 112,
  101,  93,  40, 118,  97, 108, 117, 101,  41,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  59,  10,
   32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,  32,  32,  32,
   32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101, 111, 102,  40, 118,  97,
  108, 117, 101,  41,  32,  61,  61,  32,  34, 102, 117, 110,  99, 116, 105, 111,
  110,  34,  41,  32, 114, 101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  59,
   32,  47,  47,  32,  73, 103, 110, 111, 114, 101,  32, 102, 111, 114,  32, 110,
  111, 119,  10,  32,  32,  32,  32,  32,  32, 116, 121, 112, 101, 114, 114, 111,
  114,  40,  99, 111, 114, 101,  46, 101, 114, 114, 111, 114,  46, 115, 116, 114,
  101, 114, 114, 111, 114,  40,  49,  49,  49,  41,  45,  62, 102, 111, 114, 109,
   97, 116,  40, 116, 121, 112, 101,  44,  32,  40, 116, 111, 115, 116, 114, 105,
  110, 103,  40, 116, 121, 112, 101, 111, 102,  40, 118,  97, 108, 117, 101,  41,
   41,  46,  46,  34,  32,  40,  97, 110, 100,  32, 105, 116,  39, 115,  32, 100,
  101, 115,  99, 101, 110, 100, 101, 110, 116, 115,  41,  34,  41,  44,  32, 118,
  110,  97, 109, 101,  41,  44,  32, 108, 105, 110, 101,  41,  59,  10,  32,  32,
   32,  32, 125,  10,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,  32,
   32,  32,  32, 116, 121, 112, 101, 114, 114, 111, 114,  40,  99, 111, 114, 101,
   46, 101, 114, 114, 111, 114,  46, 115, 116, 114, 101, 114, 114, 111, 114,  40,
   49,  49,  50,  41,  45,  62, 102, 111, 114, 109,  97, 116,  40, 116, 121, 112,
  101,  41,  44,  32, 108, 105, 110, 101,  44,  32,  34,  85, 115, 101,  32,  96,
   99, 111,  98,  97, 108, 116, 112, 114, 101,  32,  45, 116, 121, 112, 101, 115,
   96,  32, 116, 111,  32, 115, 101, 101,  32,  97, 108, 108,  32, 116, 121, 112,
  101, 115,  34,  41,  59,  10,  32,  32, 125,  10, 125,  10,  10,  47,  47,  32,
   77,  65,  73,  78,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 116, 121,
  112, 101,  99, 104, 101,  99, 107,  40,  99, 111, 100, 101,  41, 123,  10,  32,
   32,  99, 108, 101,  97, 110, 101, 100,  67, 111, 100, 101,  44,  32, 110, 101,
  119, 100, 101,  97, 100,  32,  61,  32,  99, 108, 101,  97, 110,  40,  99, 111,
  100, 101,  41,  59,  10,  32,  32, 100, 101,  97, 100,  32,  61,  32, 110, 101,
  119, 100, 101,  97, 100,  59,  10,  32,  32, 102, 111, 114,  32,  40, 105,  44,
   32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40,  99, 108, 101,  97,
  110, 101, 100,  67, 111, 100, 101,  45,  62, 115, 112, 108, 105, 116,  40,  34,
   92, 110,  34,  41,  41,  41, 123,  10,  32,  32,  32,  32,  99, 108, 101,  97,
  110, 101, 100,  67, 111, 100, 101,  32,  61,  32,  99, 108, 101,  97, 110, 101,
  100,  67, 111, 100, 101,  45,  62, 115, 112, 108, 105, 116,  40,  34,  92, 110,
   34,  41,  91, 105,  93,  32, 124, 124,  32,  34,  34,  59,  10,  32,  32,  32,
   32, 118,  97, 114,  32, 100, 101, 102, 115,  32,  61,  32, 100, 101, 102, 102,
  105, 110, 100,  40,  99, 108, 101,  97, 110, 101, 100,  67, 111, 100, 101,  41,
   59,  10,  32,  32,  32,  32, 118,  97, 114,  32,  97, 115, 115, 105, 103, 110,
  115,  32,  61,  32,  97, 115, 115, 105, 103, 110,  40,  99, 108, 101,  97, 110,
  101, 100,  67, 111, 100, 101,  41,  59,  10,  32,  32,  32,  32, 118,  97, 114,
   32,  97, 108, 108,  97, 115, 115, 105, 103, 110, 115,  32,  61,  32,  97, 108,
  108,  97, 115, 115, 105, 103, 110,  40,  99, 108, 101,  97, 110, 101, 100,  67,
  111, 100, 101,  41,  59,  10,  32,  32,  32,  32, 118,  97, 114,  32, 102, 117,
  110,  99, 116, 105, 111, 110, 115,  32,  61,  32, 102, 105, 110, 100, 102, 117,
  110,  99, 116, 105, 111, 110, 115,  40,  99, 108, 101,  97, 110, 101, 100,  67,
  111, 100, 101,  41,  59,  10,  32,  32,  32,  32, 118,  97, 114,  32,  97, 108,
  108,  32,  61,  32, 102, 105, 110, 100,  97, 108, 108,  40,  99, 108, 101,  97,
  110, 101, 100,  67, 111, 100, 101,  41,  59,  10,  10,  32,  32,  32,  32, 118,
   97, 114,  32, 107, 110, 111, 119, 110,  84, 121, 112, 101, 115,  32,  61,  32,
  123, 125,  59,  10,  32,  32,  32,  32, 118,  97, 114,  32, 107, 110, 111, 119,
  110,  86,  97, 108, 117, 101, 115,  32,  61,  32, 123, 125,  59,  32,  10,  32,
   32,  32,  32, 102, 111, 114,  40,  32,  95,  44,  32, 100, 101, 102,  32, 105,
  110,  32, 112,  97, 105, 114, 115,  40, 100, 101, 102, 115,  41,  32,  41,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  99, 104, 101,  99, 107,  40, 100, 101,
  102,  91,  50,  93,  44,  32, 100, 101, 102,  91,  51,  93,  44,  32, 100, 101,
  102,  91,  49,  93,  44,  32, 107, 110, 111, 119, 110,  86,  97, 108, 117, 101,
  115,  44,  32, 100, 101, 102,  91,  52,  93,  41,  10,  32,  32,  32,  32,  32,
   32, 118,  97, 108, 117, 101,  44,  32, 101, 114, 114,  32,  61,  32, 108, 111,
   97, 100, 101, 110, 118,  40, 107, 110, 111, 119, 110,  86,  97, 108, 117, 101,
  115,  44,  32,  34, 114, 101, 116, 117, 114, 110,  32,  34,  32,  46,  46,  32,
  100, 101, 102,  91,  51,  93,  41,  10,  32,  32,  32,  32,  32,  32, 105, 102,
   32,  40,  33, 118,  97, 108, 117, 101,  41, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 116, 121, 112, 101, 114, 114, 111, 114,  40,  34,  67, 104, 101,
   99, 107,  32, 101, 114, 114, 111, 114,  58,  32,  34,  46,  46, 101, 114, 114,
   41,  10,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,
  107, 110, 111, 119, 110,  84, 121, 112, 101, 115,  91, 100, 101, 102,  91,  49,
   93,  93,  32,  61,  32, 100, 101, 102,  91,  50,  93,  59,  10,  32,  32,  32,
   32,  32,  32, 120, 112,  99,  97, 108, 108,  40, 102, 117, 110,  99, 116, 105,
  111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 107, 110,
  111, 119, 110,  86,  97, 108, 117, 101, 115,  91, 100, 101, 102,  91,  49,  93,
   93,  32,  61,  32, 118,  97, 108, 117, 101,  40,  41,  59,  10,  32,  32,  32,
   32,  32,  32, 125,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 101,
  114, 114,  41, 123, 125,  41,  10,  32,  32,  32,  32,  32,  32,  10,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32, 102, 111, 114,  40,  32,  95,  44,  32,
   97, 108, 108,  97, 115, 115, 105, 103, 110,  32, 105, 110,  32, 112,  97, 105,
  114, 115,  40,  97, 108, 108,  97, 115, 115, 105, 103, 110, 115,  41,  32,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 107, 110, 111,
  119, 110,  84, 121, 112, 101, 115,  91,  97, 108, 108,  97, 115, 115, 105, 103,
  110,  91,  49,  93,  93,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  99, 104, 101,  99, 107,  40, 107, 110, 111, 119, 110,  84, 121, 112, 101,
  115,  91,  97, 108, 108,  97, 115, 115, 105, 103, 110,  91,  49,  93,  93,  44,
   32,  97, 108, 108,  97, 115, 115, 105, 103, 110,  91,  50,  93,  44,  32,  97,
  108, 108,  97, 115, 115, 105, 103, 110,  91,  49,  93,  44,  32, 107, 110, 111,
  119, 110,  86,  97, 108, 117, 101, 115,  44,  32,  97, 108, 108,  97, 115, 115,
  105, 103, 110,  91,  51,  93,  41,  59,  10,  32,  32,  32,  32,  32,  32, 125,
  101, 108, 115, 101,  32, 105, 102,  40,  33, 107, 110, 111, 119, 110,  86,  97,
  108, 117, 101, 115,  91,  97, 108, 108,  97, 115, 115, 105, 103, 110,  91,  49,
   93,  93,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 107, 110,
  111, 119, 110,  86,  97, 108, 117, 101, 115,  91,  97, 108, 108,  97, 115, 115,
  105, 103, 110,  91,  49,  93,  93,  32,  61,  32,  97, 108, 108,  97, 115, 115,
  105, 103, 110,  91,  50,  93,  59,  10,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 102, 111, 114,  40,  32,  95,
   44,  32,  97, 115, 115, 105, 103, 110,  32, 105, 110,  32, 112,  97, 105, 114,
  115,  40,  97, 115, 115, 105, 103, 110, 115,  41,  32,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  99, 104, 101,  99, 107,  40,  97, 115, 115, 105, 103,
  110,  91,  50,  93,  44,  32,  97, 115, 115, 105, 103, 110,  91,  51,  93,  44,
   32,  97, 115, 115, 105, 103, 110,  91,  49,  93,  44,  32, 107, 110, 111, 119,
  110,  86,  97, 108, 117, 101, 115,  44,  32,  97, 115, 115, 105, 103, 110,  91,
   52,  93,  41,  59,  10,  32,  32,  32,  32,  32,  32, 107, 110, 111, 119, 110,
   86,  97, 108, 117, 101, 115,  91,  97, 115, 115, 105, 103, 110,  91,  49,  93,
   93,  32,  61,  32,  97, 115, 115, 105, 103, 110,  91,  51,  93,  59,  10,  32,
   32,  32,  32,  32,  32, 107, 110, 111, 119, 110,  84, 121, 112, 101, 115,  91,
   97, 115, 115, 105, 103, 110,  91,  49,  93,  93,  32,  61,  32,  97, 115, 115,
  105, 103, 110,  91,  50,  93,  59,  10,  32,  32,  32,  32, 125,  10,  32,  32,
  125,  10,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  59,
   10, 125,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32,  97, 108, 108,  40,
   41, 123,  10,  32,  32,  47,  47,  32,  80, 114, 105, 110, 116, 115,  32,  97,
  108, 108,  32, 116, 121, 112, 101, 115,  10,  32,  32, 112, 114, 105, 110, 116,
   40,  34,  65, 108, 108,  32, 118,  97, 108, 105, 100,  32,  99, 104, 101,  99,
  107,  97,  98, 108, 101,  32, 116, 121, 112, 101, 115,  58,  34,  41,  10,  32,
   32, 102, 111, 114,  32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97,
  105, 114, 115,  40,  97, 108, 108, 116, 121, 112, 101, 115,  41,  41,  32, 123,
   10,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,  34,  32,  32,  34,  46,
   46, 118,  41,  10,  32,  32, 125,  10, 125,  10,  10, 116, 121, 112, 101,  99,
  104, 101,  99, 107, 101, 114,  32,  61,  32, 123,  10,  32,  32,  34,  97, 108,
  108,  34,  58,  32,  97, 108, 108,  44,  10,  32,  32,  34,  99, 104, 101,  99,
  107,  34,  58,  32, 116, 121, 112, 101,  99, 104, 101,  99, 107,  44,  10,  32,
   32,  34,  99, 108, 101,  97, 110,  34,  58,  32,  99, 108, 101,  97, 110,  44,
   10,  32,  32,  34, 114, 101, 118, 105, 118, 101,  34,  58,  32, 114, 101, 118,
  105, 118, 101,  44,  10, 125,  10,  10,  47,  47,  32,  83,  69,  67,  84,  73,
   79,  78,  32,  50,  58,  32,  76,  97, 110, 103, 117,  97, 103, 101,  32, 101,
  120, 116, 101, 110, 115, 105, 111, 110, 115,  10,  10,  47,  42,  32,  69,  88,
   84,  69,  78,  68,  83,  58,  10,  45,  32, 102,  34, 123, 120, 125,  34,  32,
   61,  32, 115, 116, 114, 105, 110, 103,  46, 102, 111, 114, 109,  97, 116,  40,
   34,  37, 115,  34,  44,  32, 120,  41,  10,  45,  32,  36, 116,  97,  98, 108,
  101,  32,  61,  32, 112,  97, 105, 114, 115,  40, 116,  97,  98, 108, 101,  41,
   10,  45,  32,  64, 116,  97,  98, 108, 101,  32,  61,  32, 105, 112,  97, 105,
  114, 115,  40, 116,  97,  98, 108, 101,  41,  10,  45,  32, 120, 126, 121,  32,
   61,  32,  95,  71,  46, 120,  32,  61,  32, 121,  44,  32, 114, 101, 116, 117,
  114, 110,  32, 121,  10,  45,  32, 114, 101, 109, 111, 118, 101, 115,  32,  99,
  111, 109, 109, 101, 110, 116, 115,  10,  45,  32, 118,  97, 114,  32,  91, 120,
   44,  32, 121,  44,  32, 122,  93,  32,  61,  32, 116,  98, 108,  32,  40, 120,
   44,  32, 121,  44,  32, 122,  32,  97, 114, 101,  32, 116, 104, 101,  32, 107,
  101, 121, 115,  32, 111, 102,  32, 116,  98, 108,  41,  10,  45,  32, 118,  97,
  114,  32, 120,  32,  60, 112, 114, 101,  62,  32,  61,  32, 121,  32,  40, 119,
  105, 108, 108,  32,  99,  97, 108,  99, 117, 108,  97, 116, 101,  32, 121,  32,
  111, 110,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  41,
   10,  45,  32,  38, 120,  32,  61,  32, 117, 110, 112,  97,  99, 107,  40, 120,
   41,  10,  42,  47,  10,  10,  47,  42,  32,  84,  79,  68,  79,  58,  10,  32,
   32,  45,  32,  70, 105, 120,  32, 116, 104, 101,  32, 110, 101, 115, 116, 101,
  100,  32, 115, 116, 114, 105, 110, 103,  32,  98, 117, 103,  10,  32,  32,  45,
   32,  83, 116, 114, 105, 110, 103, 115,  32, 116, 104,  97, 116,  32,  97, 114,
  101,  32, 111, 112, 116, 105, 109, 105, 122, 101, 100,  32, 116, 111,  32,  98,
  101,  32,  34,  44,  32,  39,  32, 115, 104, 111, 117, 108, 100,  32, 110, 111,
  116,  32, 108, 111, 115, 101,  32, 112, 111, 119, 101, 114,  10,  42,  47,  10,
   10,  47,  42,  32,  83,  89,  83,  84,  69,  77,  58,  10,  32,  84, 104, 105,
  115,  32, 117, 115, 101, 115,  32, 116, 104, 101,  32, 116, 121, 112, 101,  99,
  104, 101,  99, 107, 101, 114,  39, 115,  32, 100, 101,  97, 100,  32,  38,  32,
   97, 108, 105, 118, 101,  32, 115, 121, 115, 116, 101, 109,  32, 116, 111,  32,
   10,  32, 107, 105, 108, 108,  32,  97, 108, 108,  32, 110, 111, 110,  32, 115,
  121, 110, 116,  97, 120,  32, 115, 116,  97, 116, 101, 109, 101, 110, 116, 115,
   32,  97, 110, 100,  32, 119, 105, 108, 108,  32, 108, 111, 111, 107,  32, 102,
  111, 114,  32,  97,  32,  10,  32, 102,  34, 120,  32, 123, 115, 116, 114, 105,
  110, 103, 125,  32, 123, 115, 116, 114, 105, 110, 103,  50, 125,  34,  32,  97,
  110, 100,  32, 114, 101, 112, 108,  97,  99, 101,  32, 105, 116,  32, 119, 105,
  116, 104,  32, 115, 116, 114, 105, 110, 103,  46, 102, 111, 114, 109,  97, 116,
   40,  34, 120,  32,  37, 115,  34,  44,  32, 115, 116, 114, 105, 110, 103,  44,
   32, 115, 116, 114, 105, 110, 103,  50,  41,  46,  10,  42,  47,  10,  10, 102,
  117, 110,  99, 116, 105, 111, 110,  32, 103, 115, 117,  98,  40, 115, 116, 114,
   44,  32, 112,  97, 116, 116, 101, 114, 110,  44,  32, 114, 101, 112, 108,  97,
   99, 101,  41, 123,  10,  32,  32,  47,  47,  32,  82,  97, 119,  32,  71,  83,
   85,  66,  32, 102, 117, 110,  99, 116, 105, 111, 110,  10,  32,  32, 118,  97,
  114,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32,  34,  34,  10,  32,  32,
  118,  97, 114,  32, 112,  97, 116, 116, 101, 114, 110,  95, 108, 101, 110,  32,
   61,  32,  35, 112,  97, 116, 116, 101, 114, 110,  10,  32,  32, 118,  97, 114,
   32, 105,  32,  61,  32,  49,  10,  32,  32, 119, 104, 105, 108, 101,  32,  40,
  105,  32,  60,  61,  32,  35, 115, 116, 114,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32, 105, 102,  32,  40, 115, 116, 114,  45,  62, 115, 117,  98,  40,
  105,  44,  32, 105,  32,  43,  32, 112,  97, 116, 116, 101, 114, 110,  95, 108,
  101, 110,  32,  45,  32,  49,  41,  32,  61,  61,  32, 112,  97, 116, 116, 101,
  114, 110,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  114, 101, 115, 117, 108, 116,  32,  61,  32, 114, 101, 115, 117, 108, 116,  32,
   46,  46,  32, 114, 101, 112, 108,  97,  99, 101,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  43,  32, 112,  97, 116,
  116, 101, 114, 110,  95, 108, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 125, 101, 108, 115, 101, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32, 114, 101, 115, 117, 108,
  116,  32,  46,  46,  32, 115, 116, 114,  45,  62, 115, 117,  98,  40, 105,  44,
   32, 105,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,  32,
   61,  32, 105,  32,  43,  32,  49,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32, 125,  10,  32,  32, 114, 101, 116, 117, 114, 110,
   32, 114, 101, 115, 117, 108, 116,  10, 125,  10,  10, 102, 117, 110,  99, 116,
  105, 111, 110,  32, 102, 105, 110, 100,  40, 115, 116, 114,  44,  32, 112,  97,
  116, 116, 101, 114, 110,  44,  32, 105, 110, 105, 116,  41, 123,  10,  32,  32,
  105, 110, 105, 116,  32,  61,  32, 105, 110, 105, 116,  32, 124, 124,  32,  49,
   10,  32,  32, 118,  97, 114,  32, 112,  97, 116, 116, 101, 114, 110,  95, 108,
  101, 110,  32,  61,  32,  35, 112,  97, 116, 116, 101, 114, 110,  10,  32,  32,
  118,  97, 114,  32, 105,  32,  61,  32, 105, 110, 105, 116,  10,  32,  32, 119,
  104, 105, 108, 101,  32,  40, 105,  32,  60,  61,  32,  35, 115, 116, 114,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 115, 116, 114,
   45,  62, 115, 117,  98,  40, 105,  44,  32, 105,  32,  43,  32, 112,  97, 116,
  116, 101, 114, 110,  95, 108, 101, 110,  32,  45,  32,  49,  41,  32,  61,  61,
   32, 112,  97, 116, 116, 101, 114, 110,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 105,  44,  32,
  105,  32,  43,  32, 112,  97, 116, 116, 101, 114, 110,  95, 108, 101, 110,  32,
   45,  32,  49,  10,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
   32,  32, 105,  32,  61,  32, 105,  32,  43,  32,  49,  10,  32,  32, 125,  10,
   32,  32, 114, 101, 116, 117, 114, 110,  32, 110, 117, 108, 108,  10, 125,  10,
   10, 101, 120, 116,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,
  115, 116, 114,  41, 123,  10,  32,  32,  99, 108, 101,  97, 110, 101, 100,  67,
  111, 100, 101,  44,  32, 100, 101,  97, 100,  32,  61,  32, 116, 121, 112, 101,
   99, 104, 101,  99, 107, 101, 114,  46,  99, 108, 101,  97, 110,  40, 115, 116,
  114,  41,  10,  32,  32,  10,  32,  32, 108, 105, 110, 101, 115,  32,  61,  32,
   99, 108, 101,  97, 110, 101, 100,  67, 111, 100, 101,  45,  62, 115, 112, 108,
  105, 116,  40,  34,  92, 110,  34,  41,  10,  10,  10,  32,  32, 102, 111, 114,
   32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40,
  108, 105, 110, 101, 115,  41,  41, 123,  10,  32,  32,  32,  32, 118,  99, 108,
  101,  97, 110,  32,  61,  32,  32, 116, 121, 112, 101,  99, 104, 101,  99, 107,
  101, 114,  46, 114, 101, 118, 105, 118, 101,  40, 118,  44,  32, 100, 101,  97,
  100,  41,  10,  32,  32,  32,  32,  47,  47,  32, 108, 111, 111, 107,  32, 102,
  111, 114,  32, 118,  97, 114,  32,  37, 115,  32,  60, 112, 114, 101,  62,  32,
   61,  32,  37, 115,  32,  10,  32,  32,  32,  32, 118,  97, 114,  32, 112,  97,
  116, 116, 101, 114, 110,  32,  61,  32,  34, 118,  97, 114,  37, 115,  43,  40,
   91,  94,  37, 115,  93,  43,  41,  37, 115,  43,  60, 112, 114, 101,  62,  37,
  115,  42,  61,  37, 115,  42,  40,  46,  45,  41,  37, 115,  42,  36,  34,  10,
   32,  32,  32,  32, 102, 111, 114,  32,  40, 109,  97, 116,  99, 104,  44,  32,
  109,  97, 116,  99, 104,  50,  32, 105, 110,  32, 118,  99, 108, 101,  97, 110,
   45,  62, 103, 109,  97, 116,  99, 104,  40, 112,  97, 116, 116, 101, 114, 110,
   41,  41, 123,  10,  32,  32,  32,  32,  32,  32, 110, 101, 119, 118,  97, 108,
   32,  61,  32,  34,  34,  10,  32,  32,  32,  32,  32,  32, 120, 112,  99,  97,
  108, 108,  40, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 110, 101, 119, 118,  97, 108,  32,  61,  32,
  108, 111,  97, 100, 115, 116, 114, 105, 110, 103,  40,  34, 114, 101, 116, 117,
  114, 110,  32,  34,  46,  46, 109,  97, 116,  99, 104,  50,  41,  40,  41,  10,
   32,  32,  32,  32,  32,  32, 125,  44,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  40, 101, 114, 114,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111,
  114,  40,  34,  69, 114, 114, 111, 114,  32, 114, 101, 110, 100, 101, 114, 105,
  110, 103,  32,  60, 112, 114, 101,  62,  32, 118,  97, 108, 117, 101,  58,  32,
   34,  46,  46, 101, 114, 114,  44,  32, 118,  41,  10,  32,  32,  32,  32,  32,
   32, 125,  41,  10,  10,  32,  32,  32,  32,  32,  32,  47,  47,  32,  70, 111,
  114, 109,  97, 116,  32, 110, 101, 119, 118,  97, 108,  10,  32,  32,  32,  32,
   32,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40, 110, 101, 119, 118,  97,
  108,  41,  32,  61,  61,  32,  34, 115, 116, 114, 105, 110, 103,  34,  41,  32,
  110, 101, 119, 118,  97, 108,  32,  61,  32,  39,  34,  39,  46,  46, 110, 101,
  119, 118,  97, 108,  46,  46,  39,  34,  39,  10,  32,  32,  32,  32,  32,  32,
  105, 102,  32,  40, 116, 121, 112, 101,  40, 110, 101, 119, 118,  97, 108,  41,
   32,  61,  61,  32,  34, 116,  97,  98, 108, 101,  34,  41,  32, 110, 101, 119,
  118,  97, 108,  32,  61,  32, 116,  97,  98, 108, 101, 116, 111, 115, 116, 114,
  105, 110, 103,  40, 110, 101, 119, 118,  97, 108,  41,  10,  32,  32,  32,  32,
   32,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40, 110, 101, 119, 118,  97,
  108,  41,  32,  61,  61,  32,  34, 102, 117, 110,  99, 116, 105, 111, 110,  34,
   41,  32, 110, 101, 119, 118,  97, 108,  32,  61,  32, 101, 114, 114, 111, 114,
  112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40,  34,  70, 117,
  110,  99, 116, 105, 111, 110, 115,  32,  97, 114, 101,  32, 110, 111, 116,  32,
  115, 117, 112, 112, 111, 114, 116, 101, 100,  32, 105, 110,  32,  60, 112, 114,
  101,  62,  32, 118,  97, 108, 117, 101, 115,  34,  44,  32, 118,  41,  10,  32,
   32,  32,  32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40, 110, 101,
  119, 118,  97, 108,  41,  32,  61,  61,  32,  34, 117, 115, 101, 114, 100,  97,
  116,  97,  34,  41,  32, 110, 101, 119, 118,  97, 108,  32,  61,  32, 101, 114,
  114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40,
   34,  85, 115, 101, 114, 100,  97, 116,  97,  32, 105, 115,  32, 110, 111, 116,
   32, 115, 117, 112, 112, 111, 114, 116, 101, 100,  32, 105, 110,  32,  60, 112,
  114, 101,  62,  32, 118,  97, 108, 117, 101, 115,  34,  44,  32, 118,  41,  10,
   32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40, 110,
  101, 119, 118,  97, 108,  41,  32,  61,  61,  32,  34, 116, 104, 114, 101,  97,
  100,  34,  41,  32, 110, 101, 119, 118,  97, 108,  32,  61,  32, 101, 114, 114,
  111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40,  34,
   84, 104, 114, 101,  97, 100, 115,  32,  97, 114, 101,  32, 110, 111, 116,  32,
  115, 117, 112, 112, 111, 114, 116, 101, 100,  32, 105, 110,  32,  60, 112, 114,
  101,  62,  32, 118,  97, 108, 117, 101, 115,  34,  44,  32, 118,  41,  10,  32,
   32,  32,  32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40, 110, 101,
  119, 118,  97, 108,  41,  32,  61,  61,  32,  34, 110, 117, 108, 108,  34,  41,
   32, 110, 101, 119, 118,  97, 108,  32,  61,  32,  34, 110, 117, 108, 108,  34,
   10,  10,  10,  10,  32,  32,  32,  32,  32,  32, 118,  32,  61,  32, 118,  45,
   62, 103, 115, 117,  98,  40,  34, 118,  97, 114,  37, 115,  43,  40,  91,  94,
   37, 115,  93,  43,  41,  37, 115,  43,  60, 112, 114, 101,  62,  37, 115,  42,
   61,  37, 115,  42,  40,  46,  45,  41,  37, 115,  42,  36,  34,  44,  32,  34,
  118,  97, 114,  32,  34,  46,  46, 109,  97, 116,  99, 104,  46,  46,  34,  32,
   61,  32,  34,  46,  46, 110, 101, 119, 118,  97, 108,  41,  10,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  47,  47,  32,  82, 101, 112, 108,  97,  99,
  101,  32,  36, 116,  97,  98, 108, 101,  32, 119, 105, 116, 104,  32, 112,  97,
  105, 114, 115,  40, 116,  97,  98, 108, 101,  41,  44,  32,  97, 110, 100,  32,
   36,  36, 116,  97,  98, 108, 101,  32, 119, 105, 116, 104,  32, 105, 112,  97,
  105, 114, 115,  40, 116,  97,  98, 108, 101,  41,  46,  32,  77,  97, 107, 101,
   32, 115, 117, 114, 101,  32, 116, 104, 101,  32,  36,  36,  32, 100, 111, 101,
  115, 110, 116,  32, 114, 101, 110, 100, 101, 114,  32,  97, 115,  32,  36,  10,
   32,  32,  32,  32, 102, 111, 114,  32,  40, 109,  97, 116,  99, 104,  32, 105,
  110,  32, 118,  99, 108, 101,  97, 110,  45,  62, 103, 109,  97, 116,  99, 104,
   40,  34,  64,  91,  97,  45, 122,  65,  45,  90,  48,  45,  57,  95,  93,  43,
   34,  41,  41, 123,  10,  32,  32,  32,  32,  32,  32, 118,  32,  61,  32, 118,
   45,  62, 103, 115, 117,  98,  40, 109,  97, 116,  99, 104,  44,  32,  34, 105,
  112,  97, 105, 114, 115,  40,  34,  46,  46,  40, 109,  97, 116,  99, 104,  45,
   62, 115, 117,  98,  40,  50,  41,  41,  46,  46,  34,  41,  34,  41,  10,  32,
   32,  32,  32, 125,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40, 109,  97,
  116,  99, 104,  32, 105, 110,  32, 118,  99, 108, 101,  97, 110,  45,  62, 103,
  109,  97, 116,  99, 104,  40,  34,  36,  91,  97,  45, 122,  65,  45,  90,  48,
   45,  57,  95,  93,  43,  34,  41,  41, 123,  10,  32,  32,  32,  32,  32,  32,
  118,  32,  61,  32, 118,  45,  62, 103, 115, 117,  98,  40, 109,  97, 116,  99,
  104,  44,  32,  34, 112,  97, 105, 114, 115,  40,  34,  46,  46, 109,  97, 116,
   99, 104,  45,  62, 115, 117,  98,  40,  50,  41,  46,  46,  34,  41,  34,  41,
   10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40,
  109,  97, 116,  99, 104,  32, 105, 110,  32, 118,  99, 108, 101,  97, 110,  45,
   62, 103, 109,  97, 116,  99, 104,  40,  34,  38,  91,  97,  45, 122,  65,  45,
   90,  48,  45,  57,  95,  93,  43,  34,  41,  41, 123,  10,  32,  32,  32,  32,
   32,  32, 118,  32,  61,  32, 118,  45,  62, 103, 115, 117,  98,  40, 109,  97,
  116,  99, 104,  44,  32,  34, 116,  97,  98, 108, 101,  46, 117, 110, 112,  97,
   99, 107,  40,  34,  46,  46, 109,  97, 116,  99, 104,  45,  62, 115, 117,  98,
   40,  50,  41,  46,  46,  34,  41,  34,  41,  10,  32,  32,  32,  32, 125,  10,
   10,  32,  32,  32,  32,  47,  47,  32, 120, 126, 121,  32,  40, 121,  32, 105,
  115,  32,  97, 110, 121, 116, 104, 105, 110, 103,  32, 117, 110, 116, 105, 108,
   32, 119, 104, 105, 116, 101, 115, 112,  97,  99, 101,  32,  40, 110, 111, 116,
   32, 105, 110, 115, 105, 100, 101,  32,  97,  32, 115, 116, 114, 105, 110, 103,
   41,  41,  32, 119, 105, 108, 108,  32,  97, 100, 100,  32, 116, 111,  32, 116,
  104, 101,  32, 115, 116,  97, 114, 116,  32,  95,  71,  46, 120,  61, 121,  59,
   32,  97, 110, 100,  32, 116, 104, 101, 110,  32, 119, 105, 108, 108,  32, 114,
  101, 112, 108,  97,  99, 101,  32, 116, 104, 101,  32, 120, 126, 121,  32, 119,
  105, 116, 104,  32, 120,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40, 109,
   97, 116,  99, 104,  32, 105, 110,  32, 118,  45,  62, 103, 109,  97, 116,  99,
  104,  40,  34,  91,  97,  45, 122,  65,  45,  90,  48,  45,  57,  95,  93,  43,
  126,  91,  94,  37, 115,  93,  43,  34,  41,  41, 123,  10,  32,  32,  32,  32,
   32,  32,  47,  42,  10,  32,  32,  32,  32,  32,  32, 118,  32,  61,  32,  34,
   95,  71,  91,  92,  34,  34,  46,  46, 109,  97, 116,  99, 104,  45,  62, 115,
  117,  98,  40,  49,  44,  32, 109,  97, 116,  99, 104,  45,  62, 102, 105, 110,
  100,  40,  34, 126,  34,  41,  45,  49,  41,  46,  46,  34,  92,  34,  93,  32,
   61,  32,  34,  46,  46, 109,  97, 116,  99, 104,  45,  62, 115, 117,  98,  40,
  109,  97, 116,  99, 104,  45,  62, 102, 105, 110, 100,  40,  34, 126,  34,  41,
   43,  49,  41,  46,  46,  34,  59,  32,  34,  46,  46, 118,  10,  32,  32,  32,
   32,  10,  32,  32,  32,  32,  32,  32,  47,  47,  32, 114, 101, 112, 108,  97,
   99, 101,  32, 109,  97, 116,  99, 104,  32, 119, 105, 116, 104,  32, 116, 104,
  101,  32, 102, 105, 114, 115, 116,  32, 112,  97, 114, 116,  32, 111, 102,  32,
  116, 104, 101,  32, 109,  97, 116,  99, 104,  46,  32,  66, 117, 116,  32, 100,
  111,  32, 110, 111, 116,  32, 117, 115, 101,  32, 103, 115, 117,  98,  10,  32,
   32,  32,  32,  32,  32, 118,  32,  61,  32, 103, 115, 117,  98,  40, 118,  44,
   32, 109,  97, 116,  99, 104,  44,  32, 109,  97, 116,  99, 104,  45,  62, 115,
  117,  98,  40,  49,  44,  32, 109,  97, 116,  99, 104,  45,  62, 102, 105, 110,
  100,  40,  34, 126,  34,  41,  45,  49,  41,  41,  10,  32,  32,  32,  32,  32,
   32,  42,  47,  10,  32,  32,  32,  32,  32,  32,  97, 114, 103,  49,  32,  61,
   32, 109,  97, 116,  99, 104,  45,  62, 115, 117,  98,  40,  49,  44,  32, 109,
   97, 116,  99, 104,  45,  62, 102, 105, 110, 100,  40,  34, 126,  34,  41,  45,
   49,  41,  10,  32,  32,  32,  32,  32,  32,  97, 114, 103,  50,  32,  61,  32,
  109,  97, 116,  99, 104,  45,  62, 115, 117,  98,  40, 109,  97, 116,  99, 104,
   45,  62, 102, 105, 110, 100,  40,  34, 126,  34,  41,  43,  49,  41,  10,  32,
   32,  32,  32,  32,  32, 118,  32,  61,  32, 103, 115, 117,  98,  40, 118,  44,
   32, 109,  97, 116,  99, 104,  44,  32,  34,  95,  46, 103, 108, 111,  98,  97,
  108,  40,  92,  34,  34,  46,  46,  97, 114, 103,  49,  46,  46,  34,  92,  34,
   44,  32,  34,  46,  46,  97, 114, 103,  50,  46,  46,  34,  41,  34,  41,  10,
   32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  47,  47,  32, 116,  97,
   98, 108, 101,  32,  91, 120,  44,  32, 121,  44,  32, 122,  93,  32,  61,  32,
  116,  98, 108,  10,  32,  32,  32,  32,  47,  42,  10,  32,  32,  32,  32, 102,
  111, 114,  32,  40, 109,  97, 116,  99, 104,  32, 105, 110,  32, 118,  45,  62,
  103, 109,  97, 116,  99, 104,  40,  34,  40,  91,  97,  45, 122,  65,  45,  90,
   48,  45,  57,  95,  93,  43,  41,  37, 115,  42,  37,  91,  40,  46,  45,  41,
   37,  93,  37, 115,  42,  61,  34,  41,  41, 123,  10,  32,  32,  32,  32,  32,
   32, 112, 114, 105, 110, 116,  40, 118,  41,  10,  32,  32,  32,  32,  32,  32,
   47,  47,  32, 114, 101, 112, 108,  97,  99, 101,  32, 116, 104, 101,  32, 109,
   97, 116,  99, 104,  32, 119, 105, 116, 104,  32, 116, 104, 101,  32, 102, 105,
  114, 115, 116,  32, 112,  97, 114, 116,  32, 111, 102,  32, 116, 104, 101,  32,
  109,  97, 116,  99, 104,  10,  32,  32,  32,  32,  32,  32, 118,  32,  61,  32,
  103, 115, 117,  98,  40, 118,  44,  32, 109,  97, 116,  99, 104,  44,  32, 109,
   97, 116,  99, 104,  45,  62, 115, 117,  98,  40,  49,  44,  32, 102, 105, 110,
  100,  40, 109,  97, 116,  99, 104,  44,  32,  34,  91,  34,  41,  45,  49,  41,
   41,  10,  32,  32,  32,  32,  32,  32,  47,  47,  32, 114, 101, 112, 108,  97,
   99, 101,  32, 116, 104, 101,  32, 109,  97, 116,  99, 104,  32, 119, 105, 116,
  104,  32, 116, 104, 101,  32, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101,
  114, 116,  40, 116,  98, 108,  44,  32, 120,  44,  32, 121,  44,  32, 122,  41,
   10,  32,  32,  32,  32,  32,  32, 118,  32,  61,  32, 103, 115, 117,  98,  40,
  118,  44,  32, 109,  97, 116,  99, 104,  44,  32,  34, 116,  97,  98, 108, 101,
   46, 105, 110, 115, 101, 114, 116,  40,  34,  46,  46, 109,  97, 116,  99, 104,
   45,  62, 115, 117,  98,  40, 102, 105, 110, 100,  40, 109,  97, 116,  99, 104,
   44,  32,  34,  61,  34,  41,  43,  49,  41,  46,  46,  34,  44,  32,  34,  46,
   46, 109,  97, 116,  99, 104,  45,  62, 115, 117,  98,  40, 102, 105, 110, 100,
   40, 109,  97, 116,  99, 104,  44,  32,  34,  91,  34,  41,  43,  49,  44,  32,
  102, 105, 110, 100,  40, 109,  97, 116,  99, 104,  44,  32,  34,  93,  34,  41,
   45,  49,  41,  46,  46,  34,  41,  34,  41,  10,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  42,  47,  10,  10,  32,  32,  32,  32, 102, 111, 114,  32,
   40, 109,  97, 116,  99, 104,  32, 105, 110,  32, 118,  45,  62, 103, 109,  97,
  116,  99, 104,  40,  34, 102,  39,  40,  46,  45,  41,  39,  34,  41,  41, 123,
   10,  32,  32,  32,  32,  32,  32,  47,  47,  32, 114, 101, 112, 108,  97,  99,
  101,  32, 116, 104, 101,  32, 102,  39, 123, 125,  39,  32, 119, 105, 116, 104,
   32, 115, 116, 114, 105, 110, 103,  46, 102, 111, 114, 109,  97, 116,  40,  34,
  123, 125,  34,  44,  32,  46,  46,  46,  41,  10,  32,  32,  32,  32,  32,  32,
  118,  32,  61,  32, 116, 121, 112, 101,  99, 104, 101,  99, 107, 101, 114,  46,
  114, 101, 118, 105, 118, 101,  40, 118,  45,  62, 103, 115, 117,  98,  40,  34,
  102,  39,  40,  46,  45,  41,  39,  34,  44,  32,  34, 115, 116, 114, 105, 110,
  103,  46, 102, 111, 114, 109,  97, 116,  40,  39,  34,  46,  46, 109,  97, 116,
   99, 104,  46,  46,  34,  39,  34,  41,  44,  32, 100, 101,  97, 100,  41,  10,
   32,  32,  32,  32,  32,  32,  47,  47,  32, 102, 105, 110, 100,  32,  97, 108,
  108,  32, 123, 125,  32, 105, 110,  32, 116, 104, 101,  32, 115, 116, 114, 105,
  110, 103,  10,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 116,
   32, 105, 110,  32, 118,  45,  62, 103, 109,  97, 116,  99, 104,  40,  34, 123,
   40,  46,  45,  41, 125,  34,  41,  41, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  47,  47,  32,  70, 111, 114,  32, 101,  97,  99, 104,  32, 123, 125,
   32,  97, 100, 100,  32,  97,  32,  44,  32,  97, 110, 100,  32, 116, 104, 101,
   32, 118,  97, 108, 117, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   32,  61,  32, 118,  46,  46,  34,  44,  32,  34,  46,  46, 105, 116,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  97, 108, 115, 111,  32, 114,
  101, 112, 108,  97,  99, 101,  32, 116, 104, 101,  32, 123, 125,  32, 119, 105,
  116, 104,  32,  37, 115,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  32,
   61,  32, 118,  45,  62, 103, 115, 117,  98,  40,  34, 123,  40,  46,  45,  41,
  125,  34,  44,  32,  34,  37,  37, 115,  34,  41,  10,  32,  32,  32,  32,  32,
   32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  47,  47,  32,  97, 100, 100,
   32, 116, 104, 101,  32,  99, 108, 111, 115, 105, 110, 103,  32,  98, 114,  97,
   99, 107, 101, 116,  10,  32,  32,  32,  32,  32,  32, 118,  32,  61,  32, 118,
   46,  46,  34,  41,  34,  10,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,
   32, 102, 111, 114,  32,  40, 109,  97, 116,  99, 104,  32, 105, 110,  32, 118,
   45,  62, 103, 109,  97, 116,  99, 104,  40,  34, 102,  91,  91,  40,  46,  42,
   41,  93,  93,  34,  41,  41, 123,  10,  32,  32,  32,  32,  32,  32, 112, 114,
  105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49, 109,  80, 114,
  101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32, 101, 114, 114, 111, 114,
   58,  92,  50,  55,  91,  48, 109,  34,  41,  10,  32,  32,  32,  32,  32,  32,
  112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49, 109,
   69, 114, 114, 111, 114,  32, 119, 105, 116, 104,  32, 116, 104, 101,  32,  39,
  102,  91,  91,  39,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111,
  114,  32,  99, 111, 109, 109,  97, 110, 100,  46,  92,  50,  55,  91,  48, 109,
   92, 110,  92, 110,  34,  41,  10,  32,  32,  32,  32,  32,  32, 105, 102,  32,
   40, 101, 114, 114, 111, 114, 105, 110,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,  34,  92,  50,  55,
   91,  49,  59,  51,  49, 109,  77, 117, 108, 116, 105, 108, 105, 110, 101,  32,
  102, 111, 114, 109,  97, 116, 116, 101, 100,  32, 115, 116, 114, 105, 110, 103,
  115,  32,  97, 114, 101,  32, 110, 111, 116,  32, 115, 117, 112, 112, 111, 114,
  116, 101, 100,  46,  92,  50,  55,  91,  48, 109,  92, 110,  92, 110,  34,  41,
   10,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32, 112,
  114, 105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49, 109,  83,
  116, 111, 112, 112, 105, 110, 103,  32, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  46,  92,  50,  55,  91,  48, 109,  34,  41,  10,  32,  32,
   32,  32,  32,  32, 111, 115,  46, 101, 120, 105, 116,  40,  41,  10,  32,  32,
   32,  32, 125,  10,  10,  32,  32,  32,  32, 108, 105, 110, 101, 115,  91, 105,
   93,  32,  61,  32, 116, 121, 112, 101,  99, 104, 101,  99, 107, 101, 114,  46,
  114, 101, 118, 105, 118, 101,  40, 118,  41,  10,  32,  32, 125,  10,  10,  10,
   32,  32, 114, 101, 116, 117, 114, 110,  32, 116,  97,  98, 108, 101,  46,  99,
  111, 110,  99,  97, 116,  40, 108, 105, 110, 101, 115,  44,  34,  92, 110,  34,
   41,  10, 125,  10,  10,  47,  47,  32,  83,  69,  67,  84,  73,  79,  78,  32,
   51,  58,  32,  73, 110, 116, 101, 114, 102,  97,  99, 101,  32,  38,  32,  80,
  114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32, 100, 105, 114, 101,
   99, 116, 105, 118, 101, 115,  10,  10,  47,  42,  32,  68, 101, 112, 101, 110,
  100, 101, 110,  99, 105, 101, 115,  10,  32,  32,  32,  47,  47,  32, 102, 105,
  108, 101, 120,  32,  40,  73, 110, 115, 116,  97, 108, 108, 101, 100,  32, 119,
  105, 116, 104,  32,  96, 109,  97, 107, 101,  32, 115, 101, 116, 117, 112,  96,
   41,  10,  32,  32,  32,  47,  47,  32,  99, 111, 114, 101,  10,  32,  32,  32,
   47,  47,  32, 102, 102, 105,  10,  32,  32,  32,  47,  47,  32,  98,  97, 115,
  101,  32, 108, 105,  98, 114,  97, 114, 105, 101, 115,  10,  42,  47,  10,  10,
   47,  42,  32,  78, 111, 116, 101, 115,  10,  32,  32,  32,  32,  45,  32,  84,
  104, 101,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32,
  105, 115,  32, 110, 111, 116,  32,  97, 112,  97, 114, 116,  32, 111, 102,  32,
  116, 104, 101,  32,  99, 111, 109, 112, 105, 108, 101, 114,  10,  32,  32,  32,
   32,  45,  32,  85, 115, 105, 110, 103,  32,  67,  32,  77,  97,  99, 114, 111,
  115,  32, 114, 101, 113, 117, 105, 114, 101,  32,  71,  67,  67,  32, 116, 111,
   32,  98, 101,  32, 105, 110, 115, 116,  97, 108, 108, 101, 100,  32,  40,  65,
  115,  32, 111, 102,  32, 116, 104, 101,  32,  96,  99, 111, 114, 101,  96,  32,
  108, 105,  98, 114,  97, 114, 121,  32, 100, 101, 112, 101, 110, 100, 101, 110,
   99, 121,  41,  10,  42,  47,  10,  10,  47,  42,  32,  84,  79,  68,  79,  58,
   10,  32,  32,  32,  32,  45,  32,  65,  99, 116, 117,  97, 108, 108, 121,  32,
  115, 117,  98, 115, 116, 105, 116, 117, 116, 101,  32, 109,  97,  99, 114, 111,
  115,  32,  38,  32, 100, 101, 102, 105, 110, 105, 116, 105, 111, 110, 115,  10,
   42,  47,  10,  10,  47,  42,  32,  83, 117, 112, 112, 111, 114, 116, 115,  10,
   32,  32,  32,  47,  47,  32,  69, 110,  97,  98, 108, 101, 100,  58,  10,  32,
   32,  32,  32,  47,  47,  32,  35, 111, 112, 101, 110,  32,  40, 110,  97, 109,
  101,  41,  58,  32,  67, 104, 101,  99, 107, 115,  32, 105, 102,  32,  97,  32,
   77,  97,  99, 114, 111,  32, 105, 115,  32, 100, 101, 102, 105, 110, 101, 100,
   32,  97, 110, 100,  32, 111, 112, 101, 110, 115,  32, 105, 116,  32, 115, 111,
   32, 116, 104,  97, 116,  32, 116, 104, 101,  32, 112, 114, 111, 103, 114,  97,
  109,  32,  99,  97, 110,  32, 117, 115, 101,  32, 105, 116,  10,  32,  32,  32,
   32,  47,  47,  32,  35, 100, 101, 102, 105, 110, 101,  32,  40, 110,  97, 109,
  101,  41,  32,  40, 118,  97, 108, 117, 101,  32,  60, 111, 112, 116, 105, 111,
  110,  97, 108,  62,  41,  58,  32,  83, 101, 116, 115,  32,  97,  32, 109,  97,
   99, 114, 111,  10,  32,  32,  32,  32,  47,  47,  32,  35, 100, 101, 102, 105,
  110, 101,  32,  40, 108,  97, 109,  98, 100,  97, 110,  97, 109, 101,  41,  40,
   97, 114, 103, 115,  41,  32,  40, 102, 117, 110,  99, 116, 105, 111, 110,  41,
   58,  32,  83, 101, 116, 115,  32,  97,  32, 109,  97,  99, 114, 111,  32, 116,
  111,  32,  97,  32, 108,  97, 109,  98, 100,  97,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  10,  32,  32,  32,  32,  47,  47,  32,  35, 117, 110, 100, 101,
  102,  32,  40, 110,  97, 109, 101,  41,  58,  32,  82, 101, 109, 111, 118, 101,
  115,  32,  97,  32, 109,  97,  99, 114, 111,  10,  32,  32,  32,  32,  47,  47,
   32,  35, 105, 102, 100, 101, 102,  32,  40, 110,  97, 109, 101,  41,  58,  32,
   73, 102,  32, 109,  97,  99, 114, 111,  32, 105, 115,  32, 100, 101, 102, 105,
  110, 101, 100,  44,  32,  67, 111, 110, 100, 105, 116, 105, 111, 110,  32, 109,
  117, 115, 116,  32,  98, 101,  32, 119, 114,  97, 112, 112, 101, 100,  32, 105,
  110,  32,  40,  41,  10,  32,  32,  32,  32,  47,  47,  32,  35, 105, 102, 110,
  100, 101, 102,  32,  40, 110,  97, 109, 101,  41,  58,  32,  73, 102,  32, 109,
   97,  99, 114, 111,  32, 105, 115,  32, 110, 111, 116,  32, 100, 101, 102, 105,
  110, 101, 100,  44,  32,  67, 111, 110, 100, 105, 116, 105, 111, 110,  32, 109,
  117, 115, 116,  32,  98, 101,  32, 119, 114,  97, 112, 112, 101, 100,  32, 105,
  110,  32,  40,  41,  10,  32,  32,  32,  32,  47,  47,  32,  35, 101, 108, 105,
  102,  32,  40, 110,  97, 109, 101,  41,  58,  32,  69, 108, 115, 101,  32, 105,
  102,  32, 109,  97,  99, 114, 111,  32, 105, 115,  32, 100, 101, 102, 105, 110,
  101, 100,  44,  32,  67, 111, 110, 100, 105, 116, 105, 111, 110,  32, 109, 117,
  115, 116,  32,  98, 101,  32, 119, 114,  97, 112, 112, 101, 100,  32, 105, 110,
   32,  40,  41,  10,  32,  32,  32,  32,  47,  47,  32,  35, 101, 108, 115, 101,
   58,  32,  69, 108, 115, 101,  44,  32, 110, 111,  32,  99, 111, 110, 100, 105,
  116, 105, 111, 110,  10,  32,  32,  32,  32,  47,  47,  32,  35, 101, 110, 100,
  105, 102,  58,  32,  69, 110, 100,  32, 105, 102,  10,  32,  32,  32,  32,  47,
   47,  32,  35, 101, 114, 114, 111, 114,  32,  40, 109, 101, 115, 115,  97, 103,
  101,  41,  58,  32,  82,  97, 105, 115, 101, 115,  32,  97, 110,  32, 101, 114,
  114, 111, 114,  10,  32,  32,  32,  32,  47,  47,  32,  35, 119,  97, 114, 110,
  105, 110, 103,  32,  40, 109, 101, 115, 115,  97, 103, 101,  41,  58,  32,  82,
   97, 105, 115, 101, 115,  32,  97,  32, 119,  97, 114, 110, 105, 110, 103,  10,
   10,  32,  32,  32,  47,  47,  32,  68, 105, 115,  97,  98, 108, 101, 100,  58,
   10,  32,  32,  32,  32,  47,  47,  32,  35, 105, 110,  99, 108, 117, 100, 101,
   32,  34, 102, 105, 108, 101,  46,  99, 111,  98,  97, 108, 116,  34,  58,  32,
   73, 110,  99, 108, 117, 100, 101, 115,  32,  97,  32, 102, 105, 108, 101,  32,
   40,  67, 121,  99, 108, 105,  99,  32, 100, 101, 112, 101, 110, 100, 101, 110,
   99, 105, 101, 115,  32, 119, 105, 108, 108,  32, 108, 101,  97, 118, 101,  32,
  116, 104, 101,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,
   32, 105, 110,  32,  97, 110,  32, 105, 110, 102, 105, 110, 105, 116, 101,  32,
  108, 111, 111, 112,  41,  32,  40,  78,  97, 109, 101,  32, 109, 117, 115, 116,
   32,  98, 101,  32, 105, 110,  32,  34,  34,  41,  10,  32,  32,  32,  32,  47,
   47,  32,  35, 108, 105, 110, 101,  32,  40, 108, 105, 110, 101,  41,  32,  34,
  102, 105, 108, 101,  46,  99, 111,  98,  97, 108, 116,  32,  60, 111, 112, 116,
  105, 111, 110,  97, 108,  62,  34,  58,  32,  83, 101, 116, 115,  32, 116, 104,
  101,  32, 108, 105, 110, 101,  32, 110, 117, 109,  98, 101, 114,  32,  97, 110,
  100,  32, 102, 105, 108, 101,  32, 110,  97, 109, 101,  32, 102, 111, 114,  32,
  116, 104, 101,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,
   32,  40,  67, 121,  99, 108, 105,  99,  32, 100, 101, 112, 101, 110, 100, 101,
  110,  99, 105, 101, 115,  32, 119, 105, 108, 108,  32, 108, 101,  97, 118, 101,
   32, 116, 104, 101,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111,
  114,  32, 105, 110,  32,  97, 110,  32, 105, 110, 102, 105, 110, 105, 116, 101,
   32, 108, 111, 111, 112,  41,  32,  40,  78,  97, 109, 101,  32, 109, 117, 115,
  116,  32,  98, 101,  32, 105, 110,  32,  34,  34,  41,  10,  10,  10,  32,  32,
   32,  32,  47,  47,  32,  69, 118, 101, 114, 121, 116, 104, 105, 110, 103,  32,
  101, 108, 115, 101,  32, 116, 104,  97, 116,  32, 115, 116,  97, 114, 116, 115,
   32, 119, 105, 116, 104,  32,  97,  32,  35,  32, 119, 105, 108, 108,  32,  98,
  101,  32, 101, 120, 101,  99, 117, 116, 101, 100,  32,  97, 115,  32,  97,  32,
   99, 111,  98,  97, 108, 116,  32, 115, 111, 117, 114,  99, 101,  32, 108, 105,
  110, 101,  10,  32,  32,  32,  32,  47,  47,  32,  67,  32,  77,  97,  99, 114,
  111, 115,  32,  97, 114, 101,  32, 115, 117, 112, 112, 111, 114, 116, 101, 100,
   32, 105, 102,  32,  71,  67,  67,  32, 105, 115,  32, 105, 110, 115, 116,  97,
  108, 108, 101, 100,  44,  32, 105, 102,  32, 110, 111, 116,  44,  32, 116, 104,
  101, 121,  32, 119, 105, 108, 108,  32,  98, 101,  32, 105, 103, 110, 111, 114,
  101, 100,  46,  10,  32,  32,  32,  32,  47,  47,  32,  99, 111,  98,  97, 108,
  116,  32,  97, 110, 100,  32,  99, 111,  98,  97, 108, 116, 118, 101, 114, 115,
  105, 111, 110,  32,  97, 114, 101,  32, 105, 110,  99, 108, 117, 100, 101, 100,
   32, 109,  97,  99, 114, 111, 115,  10,  42,  47,  10,  10, 102, 117, 110,  99,
  116, 105, 111, 110,  32, 112, 114, 111,  99, 101, 115, 115,  40, 115, 116, 114,
   44,  32, 105, 116, 101, 109, 116, 121, 112, 101,  44,  32, 111, 117, 116,  44,
   32, 111, 117, 116, 102, 105, 108, 101,  44,  32,  46,  46,  46,  41, 123,  10,
   32,  32,  32,  32,  47,  47,  32,  48,  58,  32,  73, 110, 105, 116,  10,  32,
   32,  32,  32,  10,  32,  32,  32,  32,  47,  47,  47,  32,  67, 104, 101,  99,
  107,  32, 109, 111, 100, 101,  58,  10,  32,  32,  32,  32, 105, 102,  32,  40,
  111, 117, 116, 102, 105, 108, 101,  32,  61,  61,  32,  34,  45, 116, 121, 112,
  101, 115,  34,  32, 124, 124,  32,  40, 115, 116, 114,  32,  61,  61,  32,  34,
   45, 116, 121, 112, 101, 115,  34,  32,  38,  38,  32,  33, 111, 117, 116, 102,
  105, 108, 101,  41,  32,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  116, 121, 112, 101,  99, 104, 101,  99, 107, 101, 114,  46,  97, 108, 108,  40,
   41,  32,  47,  47,  32,  80, 114, 105, 110, 116,  32,  97, 108, 108,  32, 118,
   97, 108, 105, 100,  32, 116, 121, 112, 101, 115,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 114, 101, 116, 117, 114, 110,  59,  10,  32,  32,  32,  32, 125,
  105, 102,  32,  40, 123,  46,  46,  46, 125,  32,  61,  61,  32, 123, 125,  41,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114,  40,
   34,  78, 111,  32,  97, 114, 103, 117, 109, 101, 110, 116, 115,  32, 111, 114,
   32, 105, 110, 118,  97, 108, 105, 100,  32, 102, 108,  97, 103, 115,  32, 112,
  114, 111, 118, 105, 100, 101, 100,  46,  34,  41,  10,  32,  32,  32,  32, 125,
   10,  10,  32,  32,  32,  32,  47,  47,  47,  32,  73, 110, 105, 116,  32, 109,
   97,  99, 114, 111, 115,  10,  32,  32,  32,  32, 109,  97,  99, 114, 111, 115,
   40,  41,  10,  10,  32,  32,  32,  32,  47,  47,  32,  49,  58,  32,  83, 112,
  108, 105, 116,  32, 108, 105, 110, 101, 115,  10,  32,  32,  32,  32, 118,  97,
  114,  32, 110, 115, 116, 114,  10,  32,  32,  32,  32, 118,  97, 114,  32, 111,
  103, 115, 116, 114,  32,  61,  32, 111, 117, 116,  32,  63,  32, 115, 116, 114,
   32,  58,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32, 105, 102,  32,  40,
  105, 116, 101, 109, 116, 121, 112, 101,  32,  61,  61,  32,  34, 102, 105, 108,
  101,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32, 102, 105, 108, 101,  32,  61,  32, 105, 111,  46, 111, 112, 101, 110,
   40, 115, 116, 114,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,
   32,  40,  33, 102, 105, 108, 101,  41, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114,  40,  99, 111, 114, 101,
   46, 101, 114, 114, 111, 114,  46, 115, 116, 114, 101, 114, 114, 111, 114,  40,
   50,  41,  46,  46,  34,  32,  34,  46,  46, 115, 116, 114,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  110, 115, 116, 114,  32,  61,  32, 102, 105, 108, 101,  45,  62, 114, 101,  97,
  100,  40,  34,  42,  97, 108, 108,  34,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 102, 105, 108, 101,  45,  62,  99, 108, 111, 115, 101,  40,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33, 110, 115, 116,
  114,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  101, 114, 114, 111, 114,  40,  99, 111, 114, 101,  46, 101, 114, 114, 111, 114,
   46, 115, 116, 114, 101, 114, 114, 111, 114,  40,  50,  41,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  47,  47,  32,  48,  58,  32,  82, 117, 110,  32, 116, 121, 112, 101,
   99, 104, 101,  99, 107, 101, 114,  32,  97, 110, 100,  32, 108,  97, 110, 103,
  117,  97, 103, 101,  32, 101, 120, 116, 101, 110, 115, 105, 111, 110, 115,  10,
   32,  32,  32,  32,  10,  32,  32,  32,  32, 105, 102,  32,  40,  33, 110, 115,
  116, 114,  41,  32, 110, 115, 116, 114,  32,  61,  32, 115, 116, 114,  10,  32,
   32,  32,  32, 116, 121, 112, 101,  99, 104, 101,  99, 107, 101, 114,  46,  99,
  104, 101,  99, 107,  40, 110, 115, 116, 114,  41,  10,  32,  32,  32,  32, 110,
  115, 116, 114,  32,  61,  32, 101, 120, 116,  40, 110, 115, 116, 114,  41,  10,
   10,  32,  32,  32,  32,  47,  47,  32,  48,  46,  53,  58,  32,  83, 112, 108,
  105, 116,  32, 108, 105, 110, 101, 115,  10,  32,  32,  32,  32, 118,  97, 114,
   32, 108, 105, 110, 101, 115,  32,  61,  32,  91,  93,  10,  32,  32,  32,  32,
  102, 111, 114,  32,  40, 108, 105, 110, 101,  32, 105, 110,  32, 110, 115, 116,
  114,  45,  62, 103, 109,  97, 116,  99, 104,  40,  34,  91,  94,  92, 114,  92,
  110,  93,  43,  34,  41,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 108, 105, 110, 101, 115,  91,  35, 108, 105, 110, 101, 115,  32,  43,  32,
   49,  93,  32,  61,  32, 108, 105, 110, 101,  10,  32,  32,  32,  32, 125,  10,
   10,  32,  32,  32,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32, 103, 101,
  116, 110,  97, 109, 101,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  32,  40, 111, 103, 115, 116, 114,  41, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  99, 119, 100,  47,
  111, 103, 115, 116, 114,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 114, 101, 116, 117, 114, 110,  32, 102, 105, 108, 101, 120,  46, 106,
  111, 105, 110,  40, 102, 105, 108, 101, 115, 121, 115, 116, 101, 109,  46,  99,
  117, 114, 114, 101, 110, 116, 100, 105, 114,  40,  41,  44,  32, 111, 103, 115,
  116, 114,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125, 101, 108, 115,
  101, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32, 100, 101,  98, 117, 103,  46, 103, 101, 116, 105,
  110, 102, 111,  40,  50,  44,  32,  34,  83,  34,  41,  46, 115, 111, 117, 114,
   99, 101,  45,  62, 115, 117,  98,  40,  50,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,
   47,  47,  32,  50,  58,  32,  76, 111, 111, 107,  32, 102, 111, 114,  32, 112,
  114, 101, 112, 114, 111,  99, 101, 115, 115,  32, 108, 105, 110, 101, 115,  10,
   32,  32,  32,  32, 118,  97, 114,  32, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115,  32,  61,  32,  91,  93,  10,  32,  32,  32,  32, 102, 111, 114,  32,
   40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 108,
  105, 110, 101, 115,  41,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 118,  97, 114,  32, 102, 105, 114, 115, 116,  32,  61,  32, 118,  45,  62,
  115, 117,  98,  40,  49,  44,  32,  49,  41,  32,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 118,  97, 114,  32,  99, 104,  97, 114,  32,  61,  32,  49,  10,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101,  32,  40,
  102, 105, 114, 115, 116,  32,  61,  61,  32,  34,  32,  34,  32, 124, 124,  32,
  102, 105, 114, 115, 116,  32,  61,  61,  32,  34,  92, 116,  34,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 104,  97,
  114,  43,  43,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 102, 105, 114, 115, 116,  32,  61,  32, 118,  45,  62, 115, 117,  98,  40,
   99, 104,  97, 114,  44,  32,  99, 104,  97, 114,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  32,  40, 102, 105, 114, 115, 116,  32,  61,  61,  32,  34,  35,  34,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   32,  61,  32, 118,  45,  62, 115, 117,  98,  40,  99, 104,  97, 114,  44,  32,
   35, 118,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105,
  110, 115, 101, 114, 116,  40, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,
   44,  32,  91, 105,  44,  32, 118,  93,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  10,  32,
   32,  32,  32,  47,  47,  32,  51,  58,  32,  69, 120, 101,  99, 117, 116, 101,
   32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,  32, 108, 105, 110, 101,
  115,  10,  32,  32,  32,  32, 118,  97, 114,  32, 101, 110, 118,  32,  61,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  34,  99, 111,  98,  97, 108,
  116,  34,  58,  32, 116, 114, 117, 101,  44,  32,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  34,  99, 111,  98,  97, 108, 116, 118, 101, 114, 115, 105, 111,
  110,  34,  58,  32,  34,  50,  51,  34,  44,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  34, 101, 100, 105, 116, 105, 111, 110,  34,  58,  32,  34, 115, 116,
   97, 110, 100,  97, 114, 100,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  34,  99, 112, 108, 117, 115, 112, 108, 117, 115,  34,  58,  32, 102,  97,
  108, 115, 101,  44,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  47,
   47,  32, 105, 110, 101, 110, 118,  32, 119, 105, 108, 108,  32,  98, 101,  32,
  108, 105, 107, 101,  58,  32,  45,  88,  61,  34, 116,  34,  32,  45,  77,  61,
   50,  32,  45,  90,  61, 116, 114, 117, 101,  32, 119, 105, 108, 108,  32,  98,
  101,  99, 111, 109, 101,  32, 123,  91,  34,  88,  34,  93,  61,  34, 116,  34,
   44,  32,  91,  34,  77,  34,  93,  61,  50,  44,  32,  91,  34,  90,  34,  93,
   61, 116, 114, 117, 101, 125,  10,  32,  32,  32,  32, 101, 110, 118, 105, 116,
  101, 109, 115,  32,  61,  32, 116,  97,  98, 108, 101,  46, 112,  97,  99, 107,
   40,  46,  46,  46,  41,  10,  32,  32,  32,  32, 105, 110, 101, 110, 118,  32,
   61,  32, 123, 125,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105,  44,
   32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 101, 110, 118, 105,
  116, 101, 109, 115,  41,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  32,  40, 116, 121, 112, 101,  40, 118,  41,  32,  61,  61,  32,  34,
  110, 117, 109,  98, 101, 114,  34,  41, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32, 115, 112, 108, 105, 116,  32,  61,  32, 118,  45,  62, 103, 115,
  117,  98,  40,  34,  45,  34,  44,  32,  34,  34,  41,  45,  62, 115, 112, 108,
  105, 116,  40,  34,  61,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 110, 101, 110, 118,  91, 115, 112, 108, 105, 116,  91,  49,  93,  93,  32,
   61,  32, 108, 111,  97, 100, 115, 116, 114, 105, 110, 103,  40,  34, 114, 101,
  116, 117, 114, 110,  32,  34,  46,  46, 115, 112, 108, 105, 116,  91,  50,  93,
   41,  40,  41,  10,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  47,
   47,  32,  52,  58,  32,  65, 100, 100,  32, 105, 110, 101, 110, 118,  32, 116,
  111,  32, 101, 110, 118,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105,
   44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 105, 110, 101,
  110, 118,  41,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,
   32,  40, 116, 121, 112, 101,  40, 118,  41,  32,  61,  61,  32,  34, 115, 116,
  114, 105, 110, 103,  34,  41,  32, 118,  32,  61,  32,  39,  34,  39,  46,  46,
  118,  46,  46,  39,  34,  39,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101,
  110, 118,  91, 105,  93,  32,  61,  32, 118,  10,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32, 118,  97, 114,  32, 110, 101, 119, 108, 105, 110, 101, 115,
   32,  61,  32, 108, 105, 110, 101, 115,  10,  32,  32,  32,  32, 118,  97, 114,
   32,  97,  99, 116, 105, 118, 101, 105, 102, 115,  32,  61,  32,  91,  93,  10,
   32,  32,  32,  32, 118,  97, 114,  32, 114, 117, 110,  32,  61,  32, 116, 114,
  117, 101,  10,  32,  32,  32,  32, 118,  97, 114,  32, 105, 110,  99, 111, 109,
  109, 101, 110, 116,  32,  61,  32, 102,  97, 108, 115, 101,  10,  10,  32,  32,
   32,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32, 101, 110, 118, 108, 111,
   97, 100,  40, 115, 116, 114,  50,  41, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32, 116,  98, 108, 100,  32,  61,  32,  34, 123,  34,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 107,  44,
   32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 101, 110, 118,  41,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  32,  40, 116, 121, 112, 101,  40, 107,  41,  32,  61,  61,  32,  34,
  110, 117, 109,  98, 101, 114,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116,  98, 108, 100,  32,
   61,  32, 116,  98, 108, 100,  32,  46,  46,  32, 118,  32,  46,  46,  32,  34,
   44,  34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
  101, 108, 115, 101,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40, 107,  41,
   32,  61,  61,  32,  34, 115, 116, 114, 105, 110, 103,  34,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  116,  98, 108, 100,  32,  61,  32, 116,  98, 108, 100,  32,  46,  46,  32,  39,
   34,  39,  32,  46,  46,  32, 107,  32,  46,  46,  32,  39,  34,  58,  32,  39,
   32,  46,  46,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 118,  41,  32,
   46,  46,  32,  34,  44,  34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 116,  98, 108, 100,  32,  61,  32, 116,  98,
  108, 100,  32,  46,  46,  32,  34, 125,  34,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 114, 101, 116, 117, 114, 110,  32, 108, 111,  97, 100, 115, 116, 114,
  105, 110, 103,  40,  91,  61,  91,  47,  47,  32,  67, 111,  98,  97, 108, 116,
   32, 101, 120, 101,  99, 117, 116, 105, 111, 110,  32, 101, 110, 118, 105, 114,
  111, 110, 109, 101, 110, 116,  58,  32,  73, 103, 110, 111, 114, 101,  46,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 118,  32,
   61,  32,  93,  61,  93,  46,  46, 116,  98, 108, 100,  46,  46,  91,  61,  91,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111,
  114,  32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,
   40, 101, 110, 118,  41,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  95,  69,  78,  86,  91, 105,  93,  32,
   61,  32, 118,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111,
  114, 101,  32,  61,  32, 105, 109, 112, 111, 114, 116,  40,  34,  99, 111, 114,
  101,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  102, 117, 110,  99, 116, 105, 111, 110,  32, 100, 101, 102, 105, 110, 101, 100,
   40, 118,  97, 108,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  99, 104, 101,  99, 107,  32,
  105, 102,  32, 105, 116,  32, 105, 115,  32, 105, 110,  32, 101, 110, 118,  44,
   32, 105, 102,  32, 105, 116,  32, 114, 101, 116, 117, 114, 110,  32, 116, 104,
  101,  32, 118,  97, 108, 117, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 101, 110, 118,  91,
  118,  97, 108,  93,  32,  33,  61,  32, 110, 117, 108, 108,  32,  38,  38,  32,
  101, 110, 118,  91, 118,  97, 108,  93,  32,  33,  61,  32, 102,  97, 108, 115,
  101,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,
  101, 110, 118,  91, 118,  97, 108,  93,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  93,  61,  93,  46,  46, 115, 116, 114,
   50,  41,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 102, 111, 114,
   32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40,
  108, 105, 110, 101, 115,  41,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  47,  47,  32,  67, 104, 101,  99, 107,  32, 105, 102,  32, 105,  32,
  105, 115,  32, 118,  91,  49,  93,  32, 102, 111, 114,  32, 111, 110, 101,  32,
  111, 102,  32, 116, 104, 101,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115,
  115,  32, 108, 105, 110, 101, 115,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  47,  32,  71, 111,  32, 116, 104, 114, 111, 117, 103, 104,  32, 101,
  118, 101, 114, 121,  32,  99, 104,  97, 114,  97,  99, 116, 101, 114,  44,  32,
  105, 102,  32,  97,  32,  47,  42,  32, 105, 115,  32, 102, 111, 117, 110, 100,
   32, 109,  97, 107, 101,  32, 105, 110,  99, 111, 109, 109, 101, 110, 116,  32,
  116, 114, 117, 101,  44,  32, 105, 102,  32,  97,  32,  42,  47,  32, 105, 115,
   32, 102, 111, 117, 110, 100,  32, 109,  97, 107, 101,  32, 105, 110,  99, 111,
  109, 109, 101, 110, 116,  32, 102,  97, 108, 115, 101,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  47,  32,  73, 102,  32, 105, 110,  99, 111, 109,
  109, 101, 110, 116,  32, 105, 115,  32, 116, 114, 117, 101,  44,  32, 114, 101,
  109, 111, 118, 101,  32, 116, 104, 101,  32, 108, 105, 110, 101,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,  32,  61,  32,
   49,  44,  32,  35, 118,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 118,  97, 114,  32,  99, 104,  97, 114,  32,  61,  32,
  118,  45,  62, 115, 117,  98,  40, 105, 105,  44,  32, 105, 105,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  99,
  104,  97, 114,  32,  61,  61,  32,  34,  47,  34,  32,  38,  38,  32, 118,  45,
   62, 115, 117,  98,  40, 105, 105,  32,  43,  32,  49,  44,  32, 105, 105,  32,
   43,  32,  49,  41,  32,  61,  61,  32,  34,  42,  34,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  110,  99, 111, 109, 109, 101, 110, 116,  32,  61,  32, 116, 114, 117, 101,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  99, 104,
   97, 114,  32,  61,  61,  32,  34,  42,  34,  32,  38,  38,  32, 118,  45,  62,
  115, 117,  98,  40, 105, 105,  32,  43,  32,  49,  44,  32, 105, 105,  32,  43,
   32,  49,  41,  32,  61,  61,  32,  34,  47,  34,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 110,
   99, 111, 109, 109, 101, 110, 116,  32,  61,  32, 102,  97, 108, 115, 101,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  32,  40, 105, 110,  99, 111, 109, 109, 101, 110, 116,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 110,
  116, 105, 110, 117, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 102, 111, 117,
  110, 100,  32,  61,  32, 102,  97, 108, 115, 101,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 102, 111, 114,  32,  40, 105,  50,  44,  32, 118,  50,  32, 105,
  110,  32, 112,  97, 105, 114, 115,  40, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115,  41,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 102,  32,  40, 118,  50,  91,  49,  93,  32,  61,  61,  32,
  105,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 118,  32,  61,  32, 118,  50,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 117, 110,
  100,  32,  61,  32, 116, 114, 117, 101,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  32,  40,  33, 102, 111, 117, 110, 100,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33, 114,
  117, 110,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 105,
   93,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  99, 111, 110, 116, 105, 110, 117, 101,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32,  71, 101, 116,  32, 116, 104, 101,  32, 102, 105, 114, 115, 116,
   32, 119, 111, 114, 100,  32, 111, 102,  32, 116, 104, 101,  32, 108, 105, 110,
  101,  10,  32,  32,  32,  32,  32,  32,  32,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  40, 101, 114, 114, 111, 114, 105, 110,  41, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110, 116,
   40,  34,  92,  50,  55,  91,  49,  59,  51,  49, 109,  80, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 111, 114,  32, 101, 114, 114, 111, 114,  58,  92,  50,
   55,  91,  48, 109,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,
   51,  49, 109,  69, 114, 114, 111, 114,  32, 119, 105, 116, 104,  32, 116, 104,
  101,  32,  39,  34,  46,  46, 118,  91,  50,  93,  46,  46,  34,  39,  32, 112,
  114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32,  99, 111, 109, 109,
   97, 110, 100,  46,  92,  50,  55,  91,  48, 109,  92, 110,  92, 110,  34,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,
   40, 101, 114, 114, 111, 114, 105, 110,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110,
  116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49, 109,  34,  46,  46, 101,
  114, 114, 111, 114, 105, 110,  46,  46,  34,  92,  50,  55,  91,  48, 109,  92,
  110,  92, 110,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49, 109,
   83, 116, 111, 112, 112, 105, 110, 103,  32, 112, 114, 101, 112, 114, 111,  99,
  101, 115, 115, 111, 114,  46,  92,  50,  55,  91,  48, 109,  34,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 111, 115,  46, 101, 120,
  105, 116,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  73, 102,  32, 116, 104,
  101,  32, 115, 101,  99, 111, 110, 100,  32,  99, 104,  97, 114,  97,  99, 116,
  101, 114,  32, 105, 115,  32,  97,  32,  33,  44,  32, 105, 103, 110, 111, 114,
  101,  32, 116, 104, 101,  32, 108, 105, 110, 101,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 102,  32,  40, 118,  91,  50,  93,  45,  62, 115, 117,  98,
   40,  50,  44,  32,  50,  41,  32,  61,  61,  32,  34,  33,  34,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119,
  108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 110, 117,
  108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32,  47,  47,  32,  83, 107, 105, 112,  32, 116, 104,
  105, 115,  32, 108, 105, 110, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32, 115, 119, 105, 116,  99,
  104,  40, 118,  91,  50,  93,  45,  62, 109,  97, 116,  99, 104,  40,  34,  37,
   83,  43,  34,  41,  44,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  34,  35, 111, 112, 101, 110,  34,  58,  32, 102, 117, 110,
   99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  69, 120,  97, 109,
  112, 108, 101,  58,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32,  35, 111, 112, 101, 110,  32,  88,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32, 116, 104, 105, 115,  32, 105, 115,  32,  97, 115, 115, 117, 109,
  105, 110, 103,  32,  88,  32, 105, 115,  32, 105, 110,  32, 116, 104, 101,  32,
  101, 110, 118,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32, 118,  97, 114,  32,  88,  32,  61,  32,  60,
  119, 104,  97, 116, 101, 118, 101, 114,  32,  88,  32, 105, 115,  32, 105, 110,
   32, 116, 104, 101,  32, 101, 110, 118,  62,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 110,  97,
  109, 101,  32,  61,  32, 118,  91,  50,  93,  45,  62, 103, 115, 117,  98,  40,
   34,  35, 111, 112, 101, 110,  32,  34,  44,  32,  34,  34,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32, 118,  97, 108, 117, 101,  32,  61,  32, 101, 110, 118,  91, 110,  97,
  109, 101,  93,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  32,  40, 118,  97, 108, 117, 101,  32,  61,  61,
   32, 110, 117, 108, 108,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114,
  111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40,  34,
   77,  97,  99, 114, 111,  32,  39,  34,  46,  46, 110,  97, 109, 101,  46,  46,
   34,  39,  32, 105, 115,  32, 110, 111, 116,  32, 100, 101, 102, 105, 110, 101,
  100,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,
   91,  49,  93,  93,  32,  61,  32,  34, 118,  97, 114,  32,  34,  46,  46, 116,
  111, 115, 116, 114, 105, 110, 103,  40, 110,  97, 109, 101,  41,  46,  46,  34,
   32,  61,  32,  34,  46,  46,  40,  40, 116, 121, 112, 101,  40, 118,  97, 108,
  117, 101,  41,  32,  61,  61,  32,  34, 115, 116, 114, 105, 110, 103,  34,  32,
   38,  38,  32,  40, 115, 116, 114,  45,  62, 115, 117,  98,  40,  49,  44,  49,
   41,  32,  61,  61,  32,  39,  34,  39,  32,  38,  38,  32, 115, 116, 114,  45,
   62, 115, 117,  98,  40,  45,  49,  41,  32,  61,  61,  32,  39,  34,  39,  41,
   32, 124, 124,  32,  40, 115, 116, 114,  45,  62, 115, 117,  98,  40,  49,  44,
   49,  41,  32,  61,  61,  32,  34,  39,  34,  32,  38,  38,  32, 115, 116, 114,
   45,  62, 115, 117,  98,  40,  45,  49,  41,  32,  61,  61,  32,  34,  39,  34,
   41,  41,  32,  63,  32,  39,  34,  39,  46,  46, 118,  97, 108, 117, 101,  46,
   46,  39,  34,  39,  32,  58,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40,
  118,  97, 108, 117, 101,  41,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  65, 118, 111, 105,
  100,  32, 109, 101, 109, 111, 114, 121,  32, 108, 101,  97, 107, 115,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110,
   97, 109, 101,  44,  32, 118,  97, 108, 117, 101,  32,  61,  32, 110, 117, 108,
  108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  44,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  35, 100,
  101, 102, 105, 110, 101,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,
   40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32, 115, 112, 108, 105, 116,  32, 118,  91,  50,
   93,  32,  98, 121,  32, 115, 112,  97,  99, 101, 115,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,
  115, 112, 108, 105, 116,  32,  61,  32, 118,  91,  50,  93,  45,  62, 115, 112,
  108, 105, 116,  40,  34,  32,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  49,  58,  32,  71,
  101, 116,  32, 116, 104, 101,  32, 110,  97, 109, 101,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,
  110,  97, 109, 101,  32,  61,  32, 115, 112, 108, 105, 116,  91,  50,  93,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  32,  40, 115, 116, 114, 105, 110, 103,  46, 115, 117,  98,  40, 110,
   97, 109, 101,  44,  32,  45,  49,  41,  32,  61,  61,  32,  34,  41,  34,  41,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  47,  47,  32,  69, 120,  97, 109, 112, 108, 101,
   58,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  47,  47,  32,  35, 100, 101, 102, 105, 110, 101,
   32,  82,  65,  68,  84,  79,  68,  69,  71,  40, 114,  97, 100,  41,  32,  40,
  114,  97, 100,  32,  42,  32,  49,  56,  48,  32,  47,  32,  80,  73,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32, 115, 104, 111, 117, 108, 100,  32,  98, 101,
   99, 111, 109, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 118,  97, 114,  32,
   82,  65,  68,  84,  79,  68,  69,  71,  32,  61,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40, 114,  97, 100,  41, 123,  32, 114, 101, 116, 117, 114, 110,
   32,  40, 114,  97, 100,  32,  42,  32,  49,  56,  48,  32,  47,  32,  80,  73,
   41, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  49,  58,  32,  71, 101,
  116,  32, 116, 104, 101,  32, 110,  97, 109, 101,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32, 118,  97, 108, 117, 101, 115,  32,  61,  32, 115, 116, 114, 105,
  110, 103,  46, 115, 112, 108, 105, 116,  40, 118,  91,  50,  93,  44,  32,  34,
   32,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 100, 101, 102, 110,
   97, 109, 101,  32,  61,  32, 118,  97, 108, 117, 101, 115,  91,  50,  93,  45,
   62, 115, 112, 108, 105, 116,  40,  34,  40,  34,  41,  91,  49,  93,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 118,  97, 114,  32,  97, 114, 103, 115,  32,  61,  32, 118,  97,
  108, 117, 101, 115,  91,  50,  93,  45,  62, 115, 112, 108, 105, 116,  40,  34,
   40,  34,  41,  91,  50,  93,  45,  62, 103, 115, 117,  98,  40,  34,  37,  41,
   34,  44,  32,  34,  34,  41,  45,  62, 115, 112, 108, 105, 116,  40,  34,  44,
   34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 102, 117, 110,  99,  32,
   61,  32, 118,  97, 108, 117, 101, 115,  91,  51,  93,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  102, 111, 114,  32,  40, 105, 105,  32,  61,  32,  52,  44,  32,  35, 118,  97,
  108, 117, 101, 115,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  102, 117, 110,  99,  32,  61,  32, 102, 117, 110,  99,  46,  46,  34,  32,  34,
   46,  46, 118,  97, 108, 117, 101, 115,  91, 105, 105,  93,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,  44,  32,
  118, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40,  97, 114, 103, 115,
   41,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  97, 114, 103, 115,
   91, 105, 105,  93,  32,  61,  32, 118, 118,  45,  62, 103, 115, 117,  98,  40,
   34,  32,  34,  44,  32,  34,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 118,  97, 114,  32, 102, 117, 110,  99, 100, 101, 102,  32,
   61,  32,  34, 102, 117, 110,  99, 116, 105, 111, 110,  40,  34,  46,  46, 116,
   97,  98, 108, 101,  46,  99, 111, 110,  99,  97, 116,  40,  97, 114, 103, 115,
   44,  32,  34,  44,  34,  41,  46,  46,  34,  41, 123,  32, 114, 101, 116, 117,
  114, 110,  32,  34,  46,  46, 102, 117, 110,  99,  46,  46,  34,  59,  32, 125,
   34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 118,  97, 108, 100, 101, 102,
   32,  61,  32,  34, 118,  97, 114,  32,  34,  46,  46, 100, 101, 102, 110,  97,
  109, 101,  46,  46,  34,  32,  61,  32,  34,  46,  46, 102, 117, 110,  99, 100,
  101, 102,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  50,  58,  32,  83, 101,
  116,  32, 118,  97, 108, 117, 101, 115,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119,
  108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 118,  97,
  108, 100, 101, 102,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 118,  91, 110,  97, 109,
  101,  93,  32,  61,  32, 102, 117, 110,  99, 100, 101, 102,  10,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  47,  47,  32,  51,  58,  32,  67, 108, 101,  97, 114,  32, 109, 101,
  109, 111, 114, 121,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 108, 117, 101, 115,  44,
   32, 100, 101, 102, 110,  97, 109, 101,  44,  32, 102, 117, 110,  99, 100, 101,
  102,  44,  32, 118,  97, 108, 100, 101, 102,  44,  32,  97, 114, 103, 115,  44,
   32, 102, 117, 110,  99,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125, 101, 108,
  115, 101, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  50,  58,  32,  71, 101,
  116,  32, 116, 104, 101,  32, 118,  97, 108, 117, 101,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 118,  97, 108, 117, 101,  32,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32, 102, 117, 110,  44,  32, 101, 114, 114,  32,  61,  32, 101, 110,
  118, 108, 111,  97, 100,  40,  34, 114, 101, 116, 117, 114, 110,  32,  34,  46,
   46, 115, 112, 108, 105, 116,  91,  51,  93,  32, 124, 124,  32,  34, 102,  97,
  108, 115, 101,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33, 102,
  117, 110,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114,
  111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40, 101,
  114, 114,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125, 101, 108, 115, 101, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 108, 117, 101,  32,  61,  32, 102,
  117, 110,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,
   47,  32,  51,  58,  32,  83, 101, 116,  32, 116, 104, 101,  32, 118,  97, 108,
  117, 101,  32, 105, 110,  32, 116, 104, 101,  32, 101, 110, 118,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 101, 110, 118,  91, 110,  97, 109, 101,  93,  32,  61,  32, 118,  97,
  108, 117, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  52,  58,  32,  82, 101,
  109, 111, 118, 101,  32, 116, 104, 101,  32, 108, 105, 110, 101,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,
   32,  61,  32,  34, 118,  97, 114,  32,  34,  46,  46, 110,  97, 109, 101,  46,
   46,  34,  32,  61,  32,  34,  46,  46,  40, 116, 121, 112, 101,  40, 118,  97,
  108, 117, 101,  41,  32,  61,  61,  32,  34, 115, 116, 114, 105, 110, 103,  34,
   32,  63,  32,  39,  34,  39,  46,  46, 118,  97, 108, 117, 101,  46,  46,  39,
   34,  39,  32,  58,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 118,  97,
  108, 117, 101,  41,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  35,
   35, 108, 105, 110, 101,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,
   40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32,  69, 120,  97, 109, 112, 108, 101,  58,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32,  35, 108, 105, 110, 101,  32,  49,  32,  34, 102, 105, 108, 101,
   46,  99, 111,  98,  97, 108, 116,  34,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  87, 105, 108, 108,
   32,  97, 100, 100,  32, 101, 118, 101, 114, 121, 116, 104, 105, 110, 103,  32,
   97, 102, 116, 101, 114,  32, 116, 104,  97, 116,  32, 108, 105, 110, 101,  32,
  105, 110,  32, 116, 104,  97, 116,  32, 102, 105, 108, 101,  32, 116, 111,  32,
  116, 104, 101,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 105,  93,  32,
  116,  97,  98, 108, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  47,  47,  32,  34, 102, 105, 108, 101,  46,  99,
  111,  98,  97, 108, 116,  34,  32, 105, 102,  32, 105, 116,  32, 105, 115,  32,
  110, 111, 116,  32, 112, 114, 111, 118, 105, 100, 101, 100,  32, 105, 116,  32,
  105, 115,  32, 116, 104, 101,  32,  99, 117, 114, 114, 101, 110, 116,  32, 102,
  105, 108, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32,  49,  32, 105, 115,  32, 116, 104, 101,  32,
  108, 105, 110, 101,  32, 110, 117, 109,  98, 101, 114,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 119,  97, 114, 110,
   40,  34,  85, 115, 105, 110, 103,  32,  35, 108, 105, 110, 101,  32, 105, 115,
   32, 110, 111, 116,  32, 114, 101,  99, 111, 109, 109, 101, 110, 100, 101, 100,
   44,  32,  85, 115, 101,  32, 105, 109, 112, 111, 114, 116,  40,  41,  32, 105,
  110, 115, 116, 101,  97, 100,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 115, 112, 108,
  105, 116,  32,  61,  32, 118,  91,  50,  93,  45,  62, 115, 112, 108, 105, 116,
   40,  34,  32,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 108, 105, 110, 101,  32,  61,
   32, 115, 112, 108, 105, 116,  91,  50,  93,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 102, 105,
  108, 101, 110,  97, 109, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33, 115, 112, 108, 105,
  116,  91,  51,  93,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 105, 108, 101,
  110,  97, 109, 101,  32,  61,  32, 103, 101, 116, 110,  97, 109, 101,  40,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125, 101, 108, 115, 101, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 105, 108, 101,
  110,  97, 109, 101,  32,  61,  32, 115, 116, 114, 105, 110, 103,  46, 115, 117,
   98,  40, 115, 112, 108, 105, 116,  91,  51,  93,  44,  32,  50,  44,  32,  45,
   50,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40, 102, 105, 108, 101, 110,
   97, 109, 101,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 118,  97, 114,  32, 102,  32,  61,  32, 105, 111,  46,
  111, 112, 101, 110,  40, 102, 105, 108, 101, 110,  97, 109, 101,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  32,  40,  33, 102,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,
   32, 115,  99, 114, 105, 112, 116,  95, 112,  97, 116, 104,  32,  61,  32, 103,
  101, 116, 110,  97, 109, 101,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,
   32, 115,  99, 114, 105, 112, 116,  95, 100, 105, 114,  32,  61,  32, 115,  99,
  114, 105, 112, 116,  95, 112,  97, 116, 104,  45,  62, 109,  97, 116,  99, 104,
   40,  34,  40,  46,  42,  47,  41,  34,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,
   32,  40, 115,  99, 114, 105, 112, 116,  95, 100, 105, 114,  32,  61,  61,  32,
  110, 117, 108, 108,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  115,  99, 114, 105, 112, 116,  95, 100, 105, 114,  32,  61,  32,  34,  46,  47,
   34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102,  32,  61,  32,
  105, 111,  46, 111, 112, 101, 110,  40, 115,  99, 114, 105, 112, 116,  95, 100,
  105, 114,  46,  46, 102, 105, 108, 101, 110,  97, 109, 101,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  32,  40,  33, 102,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99,
  101, 115, 115, 111, 114,  40,  34,  70, 105, 108, 101,  32,  39,  34,  46,  46,
  115,  99, 114, 105, 112, 116,  95, 100, 105, 114,  46,  46, 102, 105, 108, 101,
  110,  97, 109, 101,  46,  46,  34,  39,  32, 110, 111, 116,  32, 102, 111, 117,
  110, 100,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32,  99, 111, 110, 116, 101, 110, 116,  32,  61,  32, 102,  45,  62, 114,
  101,  97, 100,  40,  34,  42,  97, 108, 108,  34,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102,  45,  62,  99,
  108, 111, 115, 101,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  83, 101, 116,  32, 105,  32,
  108, 105, 110, 101,  32, 110, 117, 109,  98, 101, 114,  32, 116, 111,  32, 114,
   40,  99, 111, 110, 116, 101, 110, 116,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 110, 116, 101, 110,
  116,  32,  61,  32, 112, 114, 111,  99, 101, 115, 115,  40,  99, 111, 110, 116,
  101, 110, 116,  44,  32, 110, 117, 108, 108,  44,  32, 110, 117, 108, 108,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  47,  47,  32,  83, 112, 108, 105, 116,  32,  99, 111, 110, 116, 101, 110,
  116,  32, 116, 111,  32, 101, 118, 101, 114, 121, 116, 104, 105, 110, 103,  32,
   97, 102, 116, 101, 114,  32, 116, 111, 110, 117, 109,  98, 101, 114,  40, 108,
  105, 110, 101,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 115, 112, 108, 105, 116,  32,  61,  32,  99, 111, 110,
  116, 101, 110, 116,  45,  62, 115, 112, 108, 105, 116,  40,  34,  92, 110,  34,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32, 110, 101, 119,  99, 111, 110, 116, 101, 110, 116,
   32,  61,  32,  34,  34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,  32,  61,  32,
  116, 111, 110, 117, 109,  98, 101, 114,  40, 108, 105, 110, 101,  41,  44,  32,
   35, 115, 112, 108, 105, 116,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101,
  119,  99, 111, 110, 116, 101, 110, 116,  32,  61,  32, 110, 101, 119,  99, 111,
  110, 116, 101, 110, 116,  46,  46, 115, 112, 108, 105, 116,  91, 105, 105,  93,
   46,  46,  34,  92, 110,  34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101,
  115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 110, 101, 119,  99, 111, 110,
  116, 101, 110, 116,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  47,  47,  32,  65, 118, 111, 105, 100,  32, 109,
  101, 109, 111, 114, 121,  32, 108, 101,  97, 107, 115,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102,  32,  61,  32,
  110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  99, 111, 110, 116, 101, 110, 116,  32,  61,  32, 110,
  117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 110, 101, 119,  99, 111, 110, 116, 101, 110, 116,  32,  61,
   32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 115, 112, 108, 105, 116,  32,  61,  32, 110, 117,
  108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 102, 105, 108, 101,  44,  32, 108, 105, 110, 101,  32,  61,  32,
  110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   34,  35,  35, 105, 110,  99, 108, 117, 100, 101,  34,  58,  32, 102, 117, 110,
   99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 119,  97, 114, 110,  40,  34,  85,
  115, 105, 110, 103,  32,  35, 105, 110,  99, 108, 117, 100, 101,  32, 105, 115,
   32, 110, 111, 116,  32, 114, 101,  99, 111, 109, 109, 101, 110, 100, 101, 100,
   44,  32,  85, 115, 101,  32, 105, 109, 112, 111, 114, 116,  40,  41,  32, 105,
  110, 115, 116, 101,  97, 100,  34,  41,  10,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 102, 105,
  108, 101,  32,  61,  32, 118,  91,  50,  93,  45,  62, 103, 115, 117,  98,  40,
   34,  35, 105, 110,  99, 108, 117, 100, 101,  32,  92,  34,  34,  44,  32,  34,
   34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 118,  97, 114,  32, 111, 103, 102, 105, 108, 101,  32,  61,  32,
  102, 105, 108, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32,  70, 105, 108, 101,  32, 115, 104, 111,
  117, 108, 100,  32,  98, 101,  32,  97,  32, 115, 116, 114, 105, 110, 103,  32,
  116, 104,  97, 116,  32, 101, 110, 100, 115,  32, 119, 105, 116, 104,  32,  34,
   32,  97, 110, 100,  32, 109,  97, 121,  32, 104,  97, 118, 101,  32, 115, 116,
  117, 102, 102,  32,  97, 102, 116, 101, 114,  32, 116, 104, 101,  32,  34,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32,  82, 101, 109, 111, 118, 101,  32, 116, 104, 101,  32, 108,  97,
  115, 116,  32,  34,  32,  97, 110, 100,  32, 111, 110, 108, 121,  32, 107, 101,
  101, 112,  32, 101, 118, 101, 114, 121, 116, 104, 105, 110, 103,  32,  98, 101,
  102, 111, 114, 101,  32, 105, 116,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,  32,
   61,  32,  49,  44,  32,  35, 102, 105, 108, 101,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32, 118, 118,  32,  61,  32, 102, 105, 108, 101,  45,
   62, 115, 117,  98,  40, 105, 105,  44,  32, 105, 105,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  32,  40, 118, 118,  32,  61,  61,  32,  34,  92,  34,  34,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 105, 108, 101,  32,
   61,  32, 102, 105, 108, 101,  45,  62, 115, 117,  98,  40,  49,  44,  32, 105,
  105,  32,  45,  32,  49,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  98,
  114, 101,  97, 107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32, 102,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40,  95,  44,  32, 118, 118,
   32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 112,  97,  99, 107,  97, 103,
  101,  46, 115, 101,  97, 114,  99, 104, 101, 114, 115,  41,  41, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 102,  32,  40,  35, 116,  97,  98, 108, 101,  46, 112,  97,
   99, 107,  40, 118, 118,  40, 102, 105, 108, 101,  41,  41,  32,  61,  61,  32,
   50,  32,  38,  38,  32,  32, 116,  97,  98, 108, 101,  46, 112,  97,  99, 107,
   40, 118, 118,  40, 102, 105, 108, 101,  41,  41,  91,  49,  93,  32,  33,  61,
   32, 110, 117, 108, 108,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 102,  32,  61,  32, 116,  97,  98, 108, 101,  46, 112,  97,  99, 107,  40,
  118, 118,  40, 102, 105, 108, 101,  41,  41,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  32,  40,  33, 102,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 115,  99, 114, 105, 112, 116,  95, 112,  97, 116, 104,  32,
   61,  32, 103, 101, 116, 110,  97, 109, 101,  40,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 115,  99, 114, 105, 112, 116,  95, 100, 105, 114,  32,  61,
   32, 115,  99, 114, 105, 112, 116,  95, 112,  97, 116, 104,  45,  62, 109,  97,
  116,  99, 104,  40,  34,  40,  46,  42,  47,  41,  34,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  32,  40, 115,  99, 114, 105, 112, 116,  95, 100, 105, 114,  32,
   61,  61,  32, 110, 117, 108, 108,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 115,  99, 114, 105, 112, 116,  95, 100, 105, 114,  32,  61,  32,
   34,  46,  47,  34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  102,  32,  61,  32,  40, 105, 111,  46, 111, 112, 101, 110,  40, 115,  99, 114,
  105, 112, 116,  95, 100, 105, 114,  46,  46, 102, 105, 108, 101,  41,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  32,  40,  33, 102,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 111, 114,  40,  34,  70, 105, 108, 101,  32,  39,  34,
   46,  46, 102, 105, 108, 101,  46,  46,  34,  39,  32, 110, 111, 116,  32, 102,
  111, 117, 110, 100,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  32,  40, 116, 121, 112, 101,  40, 102,  41,  61,  61,  34, 115, 116, 114,
  105, 110, 103,  34,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 105, 108, 101,  32,
   61,  32, 105, 111,  46, 111, 112, 101, 110,  40, 102,  91,  50,  93,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125, 101, 108, 115, 101, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 105, 108, 101,  32,
   61,  32, 102,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  99, 111, 110, 116, 101, 110,
  116,  32,  61,  32, 102, 105, 108, 101,  45,  62, 114, 101,  97, 100,  40,  34,
   42,  97, 108, 108,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 102, 105, 108, 101,  45,  62,  99, 108, 111,
  115, 101,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  47,  47,  32,  83, 101, 116,  32, 105,  32, 108,
  105, 110, 101,  32, 110, 117, 109,  98, 101, 114,  32, 116, 111,  32, 114,  40,
   99, 111, 110, 116, 101, 110, 116,  41,  10,  32,  32,  32,  32,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101,
  119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,  44,  32, 110, 101,
  119, 105, 110,  99, 108, 117, 100, 101, 115,  32,  61,  32, 112, 114, 111,  99,
  101, 115, 115,  40,  99, 111, 110, 116, 101, 110, 116,  44,  32, 110, 117, 108,
  108,  44,  32, 110, 117, 108, 108,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  65, 118, 111, 105,
  100,  32, 109, 101, 109, 111, 114, 121,  32, 108, 101,  97, 107, 115,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102,
  105, 108, 101,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 110, 116, 101,
  110, 116,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102,  32,  61,  32, 110, 117,
  108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  35,
  105, 102,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  47,  47,  32,  69, 120,  97, 109, 112, 108, 101,  58,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   35, 105, 102,  32,  40, 116, 114, 117, 101,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  49,
   58,  32,  71, 101, 116,  32, 116, 104, 101,  32,  99, 111, 110, 100, 105, 116,
  105, 111, 110,  44,  32,  69, 118, 101, 114, 121, 116, 104, 105, 110, 103,  32,
  105, 110,  32,  98, 101, 116, 119, 101, 101, 110,  32, 116, 104, 101,  32,  40,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  32,
   61,  32, 118,  91,  50,  93,  45,  62, 103, 115, 117,  98,  40,  34,  35, 105,
  102,  32,  34,  44,  32,  34,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  47,  32,  71, 101, 116,
   32, 101, 118, 101, 114, 121, 116, 104, 105, 110, 103,  32, 105, 110,  32,  98,
  101, 116, 119, 101, 101, 110,  32, 116, 104, 101,  32,  40,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111,
  114,  32,  40, 105, 105,  32,  61,  32,  49,  44,  32,  35,  99, 111, 110, 100,
  105, 116, 105, 111, 110,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,
   32, 118, 118,  32,  61,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,
   62, 115, 117,  98,  40, 105, 105,  44,  32, 105, 105,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  32,  40, 118, 118,  32,  61,  61,  32,  34,  40,  34,  41,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 110, 100, 105, 116,
  105, 111, 110,  32,  61,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,
   62, 115, 117,  98,  40, 105, 105,  32,  43,  32,  49,  44,  32,  35,  99, 111,
  110, 100, 105, 116, 105, 111, 110,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  102, 111, 114,  32,  40, 105, 105,  32,  61,  32,  35,  99, 111, 110, 100, 105,
  116, 105, 111, 110,  44,  32,  49,  44,  32,  45,  49,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 118,  97, 114,  32, 118, 118,  32,  61,  32,  99, 111, 110, 100,
  105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40, 105, 105,  44,  32, 105,
  105,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 118, 118,  32,  61,  61,
   32,  34,  41,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   99, 111, 110, 100, 105, 116, 105, 111, 110,  32,  61,  32,  99, 111, 110, 100,
  105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40,  49,  44,  32, 105, 105,
   32,  45,  32,  49,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114,
  101,  97, 107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   50,  58,  32,  69, 118,  97, 108, 117,  97, 116, 101,  32, 116, 104, 101,  32,
   99, 111, 110, 100, 105, 116, 105, 111, 110,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 115, 117,
   99,  99, 101, 115, 115,  44,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32,
  120, 112,  99,  97, 108, 108,  40, 102, 117, 110,  99, 116, 105, 111, 110,  40,
   41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  40, 101,
  110, 118, 108, 111,  97, 100,  40,  34, 114, 101, 116, 117, 114, 110,  32,  34,
   46,  46,  99, 111, 110, 100, 105, 116, 105, 111, 110,  41,  32, 124, 124,  32,
  101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111,
  114,  40,  34,  70,  97, 105, 108, 101, 100,  32, 116, 111,  32,  99, 104, 101,
   99, 107,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  92, 110,  34,  46,
   46, 116,  97,  98, 108, 101,  46, 112,  97,  99, 107,  40, 101, 110, 118, 108,
  111,  97, 100,  40,  34, 114, 101, 116, 117, 114, 110,  32,  34,  46,  46,  99,
  111, 110, 100, 105, 116, 105, 111, 110,  41,  41,  91,  50,  93,  41,  41,  40,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 101, 114,
  114,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  40, 101, 114, 114,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  32,  40,  33, 115, 117,  99,  99, 101, 115, 115,  41,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 111, 114,  40, 114, 101, 115, 117, 108, 116,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  47,  47,  32,  51,  58,  32,  82, 101, 109, 111, 118, 101,  32, 116,
  104, 101,  32, 108, 105, 110, 101,  32,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101,
  115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 110, 117, 108, 108,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116,
   97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40,  97,  99, 116, 105,
  118, 101, 105, 102, 115,  44,  32, 114, 101, 115, 117, 108, 116,  41,  10,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32,  52,  58,  32,  82, 101, 109, 111, 118, 101,  32,  97, 108, 108,
   32,  99, 111, 100, 101,  32, 105, 102,  32, 114, 101, 115, 117, 108, 116,  32,
  105, 115,  32, 102,  97, 108, 115, 101,  32, 117, 110, 116, 105, 108,  32,  35,
  101, 110, 100, 105, 102,  32, 111, 114,  32,  35, 101, 108, 115, 101,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  117, 110,  32,  61,  32, 114, 101, 115, 117, 108, 116,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  34,  35, 105, 102, 100, 101, 102,  34,  58,
   32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   69, 120,  97, 109, 112, 108, 101,  58,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  35, 105, 102, 100,
  101, 102,  32,  40,  95,  95,  65,  80,  80,  76,  69,  95,  95,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32,  49,  58,  32,  71, 101, 116,  32, 116, 104, 101,  32,  99, 111,
  110, 100, 105, 116, 105, 111, 110,  44,  32,  69, 118, 101, 114, 121, 116, 104,
  105, 110, 103,  32, 105, 110,  32,  98, 101, 116, 119, 101, 101, 110,  32, 116,
  104, 101,  32,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  99, 111, 110, 100, 105, 116,
  105, 111, 110,  32,  61,  32, 118,  91,  50,  93,  45,  62, 103, 115, 117,  98,
   40,  34,  35, 105, 102,  32,  34,  44,  32,  34,  34,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  47,
   32,  71, 101, 116,  32, 101, 118, 101, 114, 121, 116, 104, 105, 110, 103,  32,
  105, 110,  32,  98, 101, 116, 119, 101, 101, 110,  32, 116, 104, 101,  32,  40,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 102, 111, 114,  32,  40, 105, 105,  32,  61,  32,  49,  44,  32,  35,
   99, 111, 110, 100, 105, 116, 105, 111, 110,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 118,  97, 114,  32, 118, 118,  32,  61,  32,  99, 111, 110, 100, 105, 116,
  105, 111, 110,  45,  62, 115, 117,  98,  40, 105, 105,  44,  32, 105, 105,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 105, 102,  32,  40, 118, 118,  32,  61,  61,  32,  34,
   40,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111,
  110, 100, 105, 116, 105, 111, 110,  32,  61,  32,  99, 111, 110, 100, 105, 116,
  105, 111, 110,  45,  62, 115, 117,  98,  40, 105, 105,  32,  43,  32,  49,  44,
   32,  35,  99, 111, 110, 100, 105, 116, 105, 111, 110,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,  32,  61,  32,  35,  99,
  111, 110, 100, 105, 116, 105, 111, 110,  44,  32,  49,  44,  32,  45,  49,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 118, 118,  32,  61,  32,
   99, 111, 110, 100, 105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40, 105,
   44,  32, 105,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 118, 118,  32,
   61,  61,  32,  34,  41,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  32,  61,  32,  99, 111,
  110, 100, 105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40,  49,  44,  32,
  105, 105,  32,  45,  32,  49,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   98, 114, 101,  97, 107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,
   47,  32,  50,  58,  32,  69, 118,  97, 108, 117,  97, 116, 101,  32, 116, 104,
  101,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,
  115, 117,  99,  99, 101, 115, 115,  44,  32, 114, 101, 115, 117, 108, 116,  32,
   61,  32, 120, 112,  99,  97, 108, 108,  40, 102, 117, 110,  99, 116, 105, 111,
  110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,
   40, 101, 110, 118, 108, 111,  97, 100,  40,  34, 114, 101, 116, 117, 114, 110,
   32, 100, 101, 102, 105, 110, 101, 100,  40,  92,  34,  34,  46,  46,  40,  99,
  111, 110, 100, 105, 116, 105, 111, 110,  32, 124, 124,  32,  34, 110, 117, 108,
  108,  34,  41,  46,  46,  34,  92,  34,  41,  34,  41,  32, 124, 124,  32, 101,
  114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,
   40,  34,  70,  97, 105, 108, 101, 100,  32, 116, 111,  32,  99, 104, 101,  99,
  107,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  92, 110,  34,  46,  46,
   40, 116,  97,  98, 108, 101,  46, 112,  97,  99, 107,  40, 101, 110, 118, 108,
  111,  97, 100,  40,  34, 114, 101, 116, 117, 114, 110,  32,  34,  46,  46,  40,
   99, 111, 110, 100, 105, 116, 105, 111, 110,  32, 124, 124,  32,  34, 110, 117,
  108, 108,  34,  41,  41,  41,  32, 124, 124,  32,  34,  70,  97, 105, 108, 101,
  100,  32, 116, 111,  32, 101, 114, 114, 111, 114,  34,  41,  91,  50,  93,  41,
   41,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,
  101, 114, 114,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112,
  114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40, 101, 114, 114,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  32,  40,  33, 115, 117,  99,  99, 101, 115, 115,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  40, 114, 101, 115, 117, 108, 116,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32,  51,  58,  32,  82, 101, 109, 111, 118, 101,
   32, 116, 104, 101,  32, 108, 105, 110, 101,  32,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105,
  110, 101, 115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 110, 117, 108, 108,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40,  97,  99,
  116, 105, 118, 101, 105, 102, 115,  44,  32, 114, 101, 115, 117, 108, 116,  41,
   10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  47,  47,  32,  52,  58,  32,  82, 101, 109, 111, 118, 101,  32,  97,
  108, 108,  32,  99, 111, 100, 101,  32, 105, 102,  32, 114, 101, 115, 117, 108,
  116,  32, 105, 115,  32, 102,  97, 108, 115, 101,  32, 117, 110, 116, 105, 108,
   32,  35, 101, 110, 100, 105, 102,  32, 111, 114,  32,  35, 101, 108, 115, 101,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 114, 117, 110,  32,  61,  32, 114, 101, 115, 117, 108, 116,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  44,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  35, 105, 102, 110, 100, 101,
  102,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32,  69, 120,  97, 109, 112, 108, 101,  58,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  35,
  105, 102, 100, 101, 102,  32,  40,  95,  95,  65,  80,  80,  76,  69,  95,  95,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  47,  47,  32,  49,  58,  32,  71, 101, 116,  32, 116, 104, 101,
   32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  44,  32,  69, 118, 101, 114,
  121, 116, 104, 105, 110, 103,  32, 105, 110,  32,  98, 101, 116, 119, 101, 101,
  110,  32, 116, 104, 101,  32,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  99, 111, 110,
  100, 105, 116, 105, 111, 110,  32,  61,  32, 118,  91,  50,  93,  45,  62, 103,
  115, 117,  98,  40,  34,  35, 105, 102,  32,  34,  44,  32,  34,  34,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  47,  32,  71, 101, 116,  32, 101, 118, 101, 114, 121, 116, 104, 105,
  110, 103,  32, 105, 110,  32,  98, 101, 116, 119, 101, 101, 110,  32, 116, 104,
  101,  32,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,  32,  61,  32,  49,
   44,  32,  35,  99, 111, 110, 100, 105, 116, 105, 111, 110,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 118,  97, 114,  32, 118, 118,  32,  61,  32,  99, 111, 110,
  100, 105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40, 105, 105,  44,  32,
  105, 105,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 118, 118,  32,  61,
   61,  32,  34,  40,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  32,  61,  32,  99, 111, 110,
  100, 105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40, 105, 105,  32,  43,
   32,  49,  44,  32,  35,  99, 111, 110, 100, 105, 116, 105, 111, 110,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,  32,  61,
   32,  35,  99, 111, 110, 100, 105, 116, 105, 111, 110,  44,  32,  49,  44,  32,
   45,  49,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 118, 118,
   32,  61,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,  62, 115, 117,
   98,  40, 105, 105,  44,  32, 105, 105,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,
   32,  40, 118, 118,  32,  61,  61,  32,  34,  41,  34,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,
   32,  61,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,  62, 115, 117,
   98,  40,  49,  44,  32, 105, 105,  32,  45,  32,  49,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32,  50,  58,  32,  69, 118,  97, 108, 117,  97,
  116, 101,  32, 116, 104, 101,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 118,  97, 114,  32, 115, 117,  99,  99, 101, 115, 115,  44,  32, 114, 101,
  115, 117, 108, 116,  32,  61,  32, 120, 112,  99,  97, 108, 108,  40, 102, 117,
  110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101,
  116, 117, 114, 110,  32,  40, 101, 110, 118, 108, 111,  97, 100,  40,  34, 114,
  101, 116, 117, 114, 110,  32,  33, 100, 101, 102, 105, 110, 101, 100,  40,  92,
   34,  34,  46,  46,  99, 111, 110, 100, 105, 116, 105, 111, 110,  46,  46,  34,
   92,  34,  41,  34,  41,  32, 124, 124,  32, 101, 114, 114, 111, 114, 112, 114,
  101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40,  34,  70,  97, 105, 108,
  101, 100,  32, 116, 111,  32,  99, 104, 101,  99, 107,  32,  99, 111, 110, 100,
  105, 116, 105, 111, 110,  92, 110,  34,  46,  46, 116,  97,  98, 108, 101,  46,
  112,  97,  99, 107,  40, 101, 110, 118, 108, 111,  97, 100,  40,  34, 114, 101,
  116, 117, 114, 110,  32,  34,  46,  46,  99, 111, 110, 100, 105, 116, 105, 111,
  110,  41,  41,  91,  50,  93,  41,  41,  40,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  44,  32, 102, 117,
  110,  99, 116, 105, 111, 110,  40, 101, 114, 114,  41, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,
  111, 114,  40, 101, 114, 114,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33,
  115, 117,  99,  99, 101, 115, 115,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101,
  114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,
   40, 114, 101, 115, 117, 108, 116,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  51,  58,
   32,  82, 101, 109, 111, 118, 101,  32, 116, 104, 101,  32, 108, 105, 110, 101,
   32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,
   32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105, 110,
  115, 101, 114, 116,  40,  97,  99, 116, 105, 118, 101, 105, 102, 115,  44,  32,
  114, 101, 115, 117, 108, 116,  41,  10,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  52,  58,  32,  82,
  101, 109, 111, 118, 101,  32,  97, 108, 108,  32,  99, 111, 100, 101,  32, 105,
  102,  32, 114, 101, 115, 117, 108, 116,  32, 105, 115,  32, 102,  97, 108, 115,
  101,  32, 117, 110, 116, 105, 108,  32,  35, 101, 110, 100, 105, 102,  32, 111,
  114,  32,  35, 101, 108, 115, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 114, 117, 110,  32,  61,  32, 114, 101,
  115, 117, 108, 116,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   34,  35, 101, 108, 105, 102,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32,  69, 120,  97, 109, 112, 108, 101,  58,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  47,  47,  32,  35, 101, 108, 105, 102,  32,  40, 116, 114, 117, 101,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  32,  40, 114, 117, 110,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,  32,  61,
   32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32,  47,  47,  32,  83, 107, 105, 112,  32, 116, 104, 105, 115,  32, 108, 105,
  110, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32,  49,  58,  32,  71, 101, 116,  32, 116,
  104, 101,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  44,  32,  69, 118,
  101, 114, 121, 116, 104, 105, 110, 103,  32, 105, 110,  32,  98, 101, 116, 119,
  101, 101, 110,  32, 116, 104, 101,  32,  40,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  99,
  111, 110, 100, 105, 116, 105, 111, 110,  32,  61,  32, 118,  91,  50,  93,  45,
   62, 103, 115, 117,  98,  40,  34,  35, 101, 108, 105, 102,  32,  34,  44,  32,
   34,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  47,  32,  71, 101, 116,  32, 101, 118, 101, 114,
  121, 116, 104, 105, 110, 103,  32, 105, 110,  32,  98, 101, 116, 119, 101, 101,
  110,  32, 116, 104, 101,  32,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,
   32,  61,  32,  49,  44,  32,  35,  99, 111, 110, 100, 105, 116, 105, 111, 110,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 118, 118,  32,  61,
   32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40,
  105, 105,  44,  32, 105, 105,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,
  118, 118,  32,  61,  61,  32,  34,  40,  34,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  32,  61,
   32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40,
  105, 105,  32,  43,  32,  49,  44,  32,  35,  99, 111, 110, 100, 105, 116, 105,
  111, 110,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97,
  107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40,
  105, 105,  32,  61,  32,  35,  99, 111, 110, 100, 105, 116, 105, 111, 110,  44,
   32,  49,  44,  32,  45,  49,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32, 118, 118,  32,  61,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,
   45,  62, 115, 117,  98,  40, 105, 105,  44,  32, 105, 105,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  32,  40, 118, 118,  32,  61,  61,  32,  34,  41,  34,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 110, 100, 105,
  116, 105, 111, 110,  32,  61,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,
   45,  62, 115, 117,  98,  40,  49,  44,  32, 105, 105,  32,  45,  32,  49,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  50,  58,  32,  69, 118,
   97, 108, 117,  97, 116, 101,  32, 116, 104, 101,  32,  99, 111, 110, 100, 105,
  116, 105, 111, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 118,  97, 114,  32, 115, 117,  99,  99, 101, 115, 115,
   44,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32, 120, 112,  99,  97, 108,
  108,  40, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 114, 101, 116, 117, 114, 110,  32,  40, 101, 110, 118, 108, 111,  97,
  100,  40,  34, 114, 101, 116, 117, 114, 110,  32,  34,  46,  46,  99, 111, 110,
  100, 105, 116, 105, 111, 110,  41,  32, 124, 124,  32, 101, 114, 114, 111, 114,
  112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40,  34,  70,  97,
  105, 108, 101, 100,  32, 116, 111,  32,  99, 104, 101,  99, 107,  32,  99, 111,
  110, 100, 105, 116, 105, 111, 110,  92, 110,  34,  46,  46, 116,  97,  98, 108,
  101,  46, 112,  97,  99, 107,  40, 101, 110, 118, 108, 111,  97, 100,  40,  34,
  114, 101, 116, 117, 114, 110,  32,  34,  46,  46,  99, 111, 110, 100, 105, 116,
  105, 111, 110,  41,  41,  91,  50,  93,  41,  41,  40,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  44,  32,
  102, 117, 110,  99, 116, 105, 111, 110,  40, 101, 114, 114,  41, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  40, 101, 114, 114,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,
   40,  33, 115, 117,  99,  99, 101, 115, 115,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,
  111, 114,  40, 114, 101, 115, 117, 108, 116,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   51,  58,  32,  82, 101, 109, 111, 118, 101,  32, 116, 104, 101,  32, 108, 105,
  110, 101,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,  49,
   93,  93,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46,
  105, 110, 115, 101, 114, 116,  40,  97,  99, 116, 105, 118, 101, 105, 102, 115,
   44,  32, 114, 101, 115, 117, 108, 116,  41,  10,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  52,  58,
   32,  82, 101, 109, 111, 118, 101,  32,  97, 108, 108,  32,  99, 111, 100, 101,
   32, 105, 102,  32, 114, 101, 115, 117, 108, 116,  32, 105, 115,  32, 102,  97,
  108, 115, 101,  32, 117, 110, 116, 105, 108,  32,  35, 101, 110, 100, 105, 102,
   32, 111, 114,  32,  35, 101, 108, 115, 101,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 117, 110,  32,  61,  32,
  114, 101, 115, 117, 108, 116,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  34,  35, 101, 108, 115, 101,  34,  58,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 114, 117, 110,  32,  61,  32,  33, 114, 117,
  110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,
   32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  34,  35, 101, 110, 100, 105, 102,  34,  58,  32, 102, 117, 110,
   99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  97,  99, 116, 105, 118, 101, 105,
  102, 115,  91,  35,  97,  99, 116, 105, 118, 101, 105, 102, 115,  93,  32,  61,
   32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,
   91,  49,  93,  93,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 117, 110,  32,
   61,  32, 116, 114, 117, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  34,  35, 117, 110, 100, 101, 102,  34,  58,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 115, 112, 108, 105, 116,
   32, 118,  91,  50,  93,  32,  98, 121,  32, 115, 112,  97,  99, 101, 115,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 115, 112, 108, 105, 116,  32,  61,  32, 118,  91,  50,  93,
   45,  62, 115, 112, 108, 105, 116,  40,  34,  32,  34,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   49,  58,  32,  71, 101, 116,  32, 116, 104, 101,  32, 110,  97, 109, 101,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 110,  97, 109, 101,  32,  61,  32, 115, 112, 108, 105, 116,
   91,  50,  93,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32,  50,  58,  32,  82, 101, 109, 111, 118, 101,
   32, 116, 104, 101,  32, 118,  97, 108, 117, 101,  32, 105, 110,  32, 116, 104,
  101,  32, 101, 110, 118,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 101, 110, 118,  91, 110,  97, 109, 101,  93,  32,
   61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  51,  58,  32,  82, 101, 109,
  111, 118, 101,  32, 116, 104, 101,  32, 108, 105, 110, 101,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119,
  108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 110, 117,
  108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  35,
  101, 114, 114, 111, 114,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,
   40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 118,  97, 114,  32, 101, 114, 114, 111, 114,  32,  61,  32,
  118,  91,  50,  93,  45,  62, 103, 115, 117,  98,  40,  34,  35, 101, 114, 114,
  111, 114,  32,  34,  44,  32,  34,  34,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,
   34,  92,  50,  55,  91,  49,  59,  51,  49, 109,  82,  97, 105, 115, 101, 100,
   32, 101, 114, 114, 111, 114,  58,  92,  50,  55,  91,  48, 109,  34,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49, 109,
   34,  46,  46, 101, 114, 114, 111, 114,  46,  46,  34,  92,  50,  55,  91,  48,
  109,  92, 110,  92, 110,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114,  40,  34,  69,
  110, 100, 105, 110, 103,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,
  111, 114,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   34,  35, 119,  97, 114, 110, 105, 110, 103,  34,  58,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 119,  97, 114, 110,
  105, 110, 103,  32,  61,  32, 118,  91,  50,  93,  45,  62, 103, 115, 117,  98,
   40,  34,  35, 119,  97, 114, 110, 105, 110, 103,  32,  34,  44,  32,  34,  34,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 119,  97, 114, 110,  40, 119,  97, 114, 110, 105, 110, 103,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,  32,  61,
   32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  34,  35,  99, 111, 110, 102, 105, 103,  34,  58,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  40,  34,  67, 111, 110, 102, 105,
  103,  32, 105, 115,  32, 110, 111, 116,  32, 115, 117, 112, 112, 111, 114, 116,
  101, 100,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   34,  35, 101, 120, 116,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,
   40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32,  73, 110, 115, 116,  97, 108, 108, 115,  32,
   97, 110,  32, 101, 120, 116, 101, 110, 115, 105, 111, 110,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114,
  111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40,  34,
   69, 120, 116, 101, 110, 115, 105, 111, 110, 115,  32,  97, 114, 101,  32, 110,
  111, 116,  32, 115, 117, 112, 112, 111, 114, 116, 101, 100,  34,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  44,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34, 100, 101, 102,  97, 117,
  108, 116,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 118,  97,
  108, 117, 101,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33, 114, 117, 110,  41, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,
   49,  93,  93,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32,  47,  47,  32,  83, 107, 105, 112,  32, 116, 104,
  105, 115,  32, 108, 105, 110, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  69, 120,
  101,  99, 117, 116, 101,  32, 101, 118, 101, 114, 121, 116, 104, 105, 110, 103,
   32, 112,  97, 115, 116,  32, 116, 104, 101,  32,  35,  32,  97, 115,  32,  97,
   32,  99, 111,  98,  97, 108, 116,  32, 108, 105, 110, 101,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,
   32,  99, 111, 100, 101,  32,  61,  32, 118,  91,  50,  93,  45,  62, 115, 117,
   98,  40,  50,  44,  32,  35, 118,  91,  50,  93,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,
   32, 115, 117,  99,  99, 101, 115, 115,  44,  32, 114, 101, 115, 117, 108, 116,
   32,  61,  32, 120, 112,  99,  97, 108, 108,  40, 102, 117, 110,  99, 116, 105,
  111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32,  40, 101, 110, 118, 108, 111,  97, 100,  40,  99, 111, 100, 101,  41,  32,
  124, 124,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  40,  34,  70,  97, 105, 108, 101, 100,  32, 116, 111,  32,
  108, 111,  97, 100,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111,
  114,  32,  99, 111, 109, 109,  97, 110, 100,  34,  41,  41,  40,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 101, 114, 114,  41, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,
   99, 101, 115, 115, 111, 114,  40, 101, 114, 114,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  32,  40,  33, 115, 117,  99,  99, 101, 115, 115,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  40, 114, 101, 115, 117, 108, 116,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125, 101, 108,
  115, 101,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101,
  115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 114, 101, 115, 117, 108, 116,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32,  82, 101, 109, 111, 118, 101,  32, 108, 105,
  110, 101,  32, 102, 114, 111, 109,  32, 110, 101, 119, 108, 105, 110, 101, 115,
   32,  10,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  47,  47,  32,
   52,  58,  32,  74, 111, 105, 110,  32, 110, 101, 119, 108, 105, 110, 101, 115,
   32,  97, 110, 100,  32, 114, 101, 116, 117, 114, 110,  10,  32,  32,  32,  32,
  105, 102,  32,  40,  35,  97,  99, 116, 105, 118, 101, 105, 102, 115,  32,  62,
   32,  48,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114,
  114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40,
   34,  77, 105, 115, 115, 105, 110, 103,  32,  35, 101, 110, 100, 105, 102,  40,
  115,  41,  34,  41,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 108,
  105, 110, 101, 115,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,
  112, 114, 101, 112, 114, 111,  99, 101, 115, 115,  32,  61,  32, 110, 117, 108,
  108,  10,  32,  32,  32,  32, 115, 116, 114,  32,  61,  32, 110, 117, 108, 108,
   10,  32,  32,  32,  32, 118,  97, 114,  32, 106, 111, 105, 110, 101, 100,  32,
   61,  32,  34,  47,  42,  32,  80, 114, 101, 112, 114, 111,  99, 101, 115, 115,
  101, 100,  32, 119, 105, 116, 104,  32, 116, 104, 101,  32,  98, 117, 105, 108,
  116,  32, 105, 110,  32,  67, 111,  98,  97, 108, 116,  32, 112, 114, 101, 112,
  114, 111,  99, 101, 115, 115, 111, 114,  32,  42,  47,  92, 110,  92, 110,  92,
  110,  34,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105,  44,  32, 118,
   32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 110, 101, 119, 108, 105, 110,
  101, 115,  41,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  32,  40, 118,  32,  61,  61,  32, 110, 117, 108, 108,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 110, 116,
  105, 110, 117, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 106, 111, 105, 110, 101, 100,  32,  61,
   32, 106, 111, 105, 110, 101, 100,  46,  46, 118,  46,  46,  34,  92, 110,  34,
   10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 110, 101, 119, 108, 105,
  110, 101, 115,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32, 105,
  102,  32,  40, 111, 117, 116,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  47,  47,  32,  87, 114, 105, 116, 101,  32, 116, 111,  32, 111, 117, 116,
   32,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 102, 105,
  108, 101,  32,  61,  32, 105, 111,  46, 111, 112, 101, 110,  40, 111, 117, 116,
  102, 105, 108, 101,  44,  32,  34, 119,  34,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 102, 105, 108, 101,  45,  62, 119, 114, 105, 116, 101,  40, 106,
  111, 105, 110, 101, 100,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 102,
  105, 108, 101,  45,  62,  99, 108, 111, 115, 101,  40,  41,  10,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  99, 111, 108, 108, 101,  99, 116, 103,  97,
  114,  98,  97, 103, 101,  40,  41,  32,  47,  47,  32,  67, 111, 108, 108, 101,
   99, 116,  32, 103,  97, 114,  98,  97, 103, 101,  10,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32, 106, 111, 105, 110, 101, 100,  10, 125,  10,  10,
   47,  47, 112, 114, 111,  99, 101, 115, 115,  40,  34, 116, 101, 115, 116,  46,
   99, 111,  98,  97, 108, 116,  34,  44,  32,  34, 102, 105, 108, 101,  34,  44,
   32, 116, 114, 117, 101,  44,  32,  34, 116, 101, 115, 116,  50,  46,  99, 111,
   98,  97, 108, 116,  34,  41,  10, 114, 101, 116, 117, 114, 110,  32, 112, 114,
  111,  99, 101, 115, 115,   0
};

#define EXTERNAL LUALIB_API // added by developer to use in linit.c

#define AOT_LUAOPEN_NAME luaopen_preprocess // changed by developer to follow the module naming pattern

#include "aot_footer.c"
