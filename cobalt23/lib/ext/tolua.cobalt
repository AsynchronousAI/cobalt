/*
how to handle recursion ...
a={}
b={}
a.b=b
b.a=a

tolua(a) would give ...
{b={a=error('recursive reference')}}

but how about, if something is found that is marked in touched tables ...
1) wrap everything in a function block
2) give root a local
3) add assignments of self-references after-the-fact

(function()
	local _tmp={b={}}
	_tmp.b.a= _tmp
	return _tmp
end)()
--*/

var table = require ('ext.table');

var function builtinPairs(t) {
	return next,t,null;
}

var _0byte = ('0')->byte();
var _9byte = ('9')->byte();
var function escapeString(s) {
	// [[
	// this will only escape escape codes
	// will respect unicode
	// but it skips \r \t and encodes them as \13 \9
	var o = ('%q')->format(s);
	o = o->gsub('\\\n','\\n');
	return o;
	//]]
	/* this gets those that builtin misses
	-- but does it in lua so it'll be slow
	-- and requires implementations of iscntrl and isdigit
	--
	-- it's slow and has bugs.
	--
	-- TODO 
	-- for size-minimal strings:
	-- if min(# single-quotes, # double-quotes) within the string > 2 then use [[ ]] (so long as that isn't used either)
	-- otherwise use as quotes whatever the min is
	-- or ... use " to wrap if less than 1 " is embedded
	-- then use ' to wrap if less than 1 ' is embedded
	-- then use [[ ]] to wrap if no [[ ]] is embedded
	-- ... etc for [=...=[ all string escape options
	local o = '"'
	for i=1,#s do
		local c = s:sub(i,i)
		if c == '"' then
			o = o .. '\\"'
		elseif c == '\\' then
			o = o .. '\\\\'
		elseif c == '\n' then
			o = o .. '\\n'
		elseif c == '\r' then
			o = o .. '\\r'
		elseif c == '\t' then
			o = o .. '\\t'
		elseif c == '\a' then
			o = o .. '\\a'
		elseif c == '\b' then
			o = o .. '\\b'
		elseif c == '\f' then
			o = o .. '\\f'
		elseif c == '\v' then
			o = o .. '\\v'
		else
			local b = c:byte()
			assert(b < 256)
			if b < 0x20 or b == 0x7f then	-- if iscntrl(c)
-- make sure the next character isn't a digit because that will mess up the encoded escape code
				local b2 = c:byte(i+1)
				if not (b2 and b2 >= _0byte and b2 <= _9byte) then	-- if not isdigit(c2) then
					o = o .. ('\\%d'):format(b)
				else
					o = o .. ('\\%03d'):format(b)
				end
			else
				-- TODO for extended ascii, why am I seeing different things here vs encoding one character at a time?
				o = o .. c
			end
		end
	end
	o = o .. '"'
	o:gsub('\\(%d%d%d)', function(d)
		if tonumber(d) > 255 then 
			print('#s', #s)
			print'o'
			print(o)
			print's'
			print(s)
			error("got an oob escape code: "..d) 
		end
	end)
	local f = require 'ext.fromlua'(o)
	if f ~= s then
		print('#s', #s)
		print('#f', #f)
		print'o'
		print(o)
		print's'
		print(s)
		print'f'
		print(f)
		print("failed to reencode as the same string")
		for i=1,math.min(#s,#f) do
			if f:sub(i,i) ~= s:sub(i,i) then
				print('char '..i..' differs')
				break
			end
		end
		error("here")

	end
	return o
	--*/
}

// as of 5.4.  I could modify this based on the Lua version (like removing 'goto') but misfiring just means wrapping in quotes, so meh.
var reserved = {
	["and"] = true,
	["break"] = true,
	["do"] = true,
	["else"] = true,
	["elseif"] = true,
	["end"] = true,
	["false"] = true,
	["for"] = true,
	["function"] = true,
	["goto"] = true,
	["if"] = true,
	["in"] = true,
	["local"] = true,
	["nil"] = true,
	["not"] = true,
	["or"] = true,
	["repeat"] = true,
	["return"] = true,
	["then"] = true,
	["true"] = true,
	["until"] = true,
	["while"] = true,
};

// returns 'true' if k is a valid variable name, but not a reserved keyword
var function isVarName(k) {
	return type(k) == 'string' && k->match('^[_a-zA-Z][_a-zA-Z0-9]*$') && ! reserved[k];
}

var toLuaRecurse;

var function toLuaKey(state, k, path) {
	if( isVarName(k) ) {
		return k, true;
	} else {
		var result = toLuaRecurse(state, k, null, path, true);
		if( result ) {
			return '['..result..']', false;
		} else {
			return false, false;
		}
	}
}


// another copy of maxn, with custom pairs
var function maxn(t, state) {
	var max = 0;
	for( k,v in state.pairs(t) ) {
		if( type(k) == 'number' ) {
			max = math.max(max, k);
		}
	}
	return max;
}


var defaultSerializeForType = {
	number = function(state,x) {
		if( x == math.huge ) { return 'math.huge'; }
		if( x == -math.huge ) { return '-math.huge'; }
		if( x != x ) { return '0/0'; }
		return tostring(x);
	},
	boolean = function(state,x) { return tostring(x); },
	['nil'] = function(state,x) { return tostring(x); },
	string = function(state,x) { return escapeString(x); },
	['function'] = function(state, x) {
		var result, s = pcall(string.dump, x);

		if( result ) {
			s = 'load('..escapeString(s)..')';
		} else {
			// if string.dump failed then check the builtins
			// check the global object and one table deep
			// todo maybe, check against a predefined set of functions?
			if( s == "unable to dump given function" ) {
				var found;
				for( k,v in state.pairs(_G) ) {
					if( v == x ) {
						found = true;
						s = k;
						break;
					} else if( type(v) == 'table' ) {
						// only one level deep ...
						for( k2,v2 in state.pairs(v) ) {
							if( v2 == x ) {
								s = k..'.'..k2;
								found = true;
								break;
							}
						}
						if( found ) { break; }
					}
				}
				if( ! found ) {
					s = "error('"..s.."')";
				}
			} else {
				return "error('got a function I could neither dump nor lookup in the global namespace nor one level deep')";
			}
		}

		return s;
	},
	table = function(state, x, tab, path, keyRef) {
		var result;

		var newtab = tab .. state.indentChar;
		// TODO override for specific metatables?  as I'm doing for types?

		if( state.touchedTables[x] ) {
			if( state.skipRecursiveReferences ) {
				result = 'error("recursive reference")';
			} else {
				result = false;	// false is used internally and means recursive reference
				state.wrapWithFunction = true;

				// we're serializing *something*
				// is it a value?  if so, use the 'path' to dereference the key
				// is it a key?  if so the what's the value ..
				// do we have to add an entry for both?
				// maybe the caller should be responsible for populating this table ...
				if( keyRef ) {
					state.recursiveReferences->insert('root'..path..'['..state.touchedTables[x]..'] = error("can\'t handle recursive references in keys")');
				} else {
					state.recursiveReferences->insert('root'..path..' = '..state.touchedTables[x]);
				}
			}
		} else {
			state.touchedTables[x] = 'root'..path;

			// prelim see if we can write it as an indexed table
			var numx = maxn(x, state);
			var intNilKeys, intNonNilKeys = 0, 0;
			for( i=1,numx ) {
				if( x[i] == null ) {
					++intNilKeys    ;
				} else {
					++intNonNilKeys    ;
				}
			}

			var hasSubTable;

			var s = table();

			// add integer keys without keys explicitly. nil-padded so long as there are 2x values than nils
			var addedIntKeys = {};
			if( intNonNilKeys >= intNilKeys * 2 ) {	// some metric
				for( k=1,numx ) {
					if( type(x[k]) == 'table' ) { hasSubTable = true; }
					var nextResult = toLuaRecurse(state, x[k], newtab, path && path..'['..k..']');
					if( nextResult ) {
						s->insert(nextResult);
					// else x[k] is a recursive reference
					}
					addedIntKeys[k] = true;
				}
			}

			// sort key/value pairs added here by key
			var mixed = table();
			for( k,v in state.pairs(x) ) {
				if( ! addedIntKeys[k] ) {
					if( type(v) == 'table' ) { hasSubTable = true; }
					var keyStr, usesDot = toLuaKey(state, k, path);
					if( keyStr ) {
						var newpath;
						if( path ) {
							newpath = path;
							if( usesDot ) { newpath = newpath .. '.'; }
							newpath = newpath .. keyStr;
						}
						var nextResult = toLuaRecurse(state, v, newtab, newpath);
						if( nextResult ) {
							mixed->insert({keyStr, nextResult});
						// else x[k] is a recursive reference
						}
					}
				}
			}
			mixed->sort(function(a,b) { return a[1] < b[1]; });	// sort by keys
			mixed = mixed->map(function(kv) { return table.concat(kv, '='); });
			s->append(mixed);

			var thisNewLineChar, thisNewLineSepChar, thisTab, thisNewTab;
			if( ! hasSubTable ) {
				thisNewLineChar = '';
				thisNewLineSepChar = ' ';
				thisTab = '';
				thisNewTab = '';
			} else {
				thisNewLineChar = state.newlineChar;
				thisNewLineSepChar = state.newlineChar;
				thisTab = tab;
				thisNewTab = newtab;
			}

			var rs = '{'..thisNewLineChar;
			if( #s > 0 ) {
				rs = rs .. thisNewTab .. s->concat(','..thisNewLineSepChar..thisNewTab) .. thisNewLineChar;
			}
			rs = rs .. thisTab .. '}';

			result = rs;
		}
		return result;
	},
};

var function defaultSerializeMetatableFunc(state, m, x, tab, path, keyRef) {
	// only serialize the metatables of tables
	// otherwise, assume the current metatable is the default one (which is usually nil)
	if( type(x) != 'table' ) { return 'nil'; }
	return toLuaRecurse(state, m, tab..state.indentChar, path, keyRef);
}

toLuaRecurse = function(state, x, tab, path, keyRef) {
	if( ! tab ) { tab = ''; }

	var xtype = type(x);
	var serializeFunction;
	if( state.serializeForType ) {
		serializeFunction = state.serializeForType[xtype];
	}
	if( ! serializeFunction ) {
		serializeFunction = defaultSerializeForType[xtype];
	}

	var result;
	if( serializeFunction ) {
		result = serializeFunction(state, x, tab, path, keyRef);
	} else {
		result = '['..type(x)..':'..tostring(x)..']';
	}
	assert(result != null);

	if( state.serializeMetatables ) {
		var m = getmetatable(x);
		if( m != null ) {
			var serializeMetatableFunc = state.serializeMetatableFunc || defaultSerializeMetatableFunc;
			var mstr = serializeMetatableFunc(state, m, x, tab, path, keyRef);
			// make sure you get something
			assert(mstr != null);
			// but if that something is nil, i.e. setmetatable(something newly created with a nil metatable, nil), then don't bother modifing the code
			if( mstr != 'nil' && mstr != false ) {
				// if this is false then the result was deferred and we need to add this line to wherever else...
				assert(result != false);
				result = 'setmetatable('..result..', '..mstr..')';
			}
		}
	}

	return result;
};

/*
args:
	indent = default to 'true', set to 'false' to make results concise
	pairs = default to a form of pairs() which iterates over all fields using next().  Set this to your own custom pairs function, or 'pairs' if you would like serialization to respect the __pairs metatable (which it does not by default).
	serializeForType = a table with keys of lua types and values of callbacks for serializing those types
	serializeMetatables = set to 'true' to include serialization of metatables
	serializeMetatableFunc = function to override the default serialization of metatables
	skipRecursiveReferences = default to 'false', set this to 'true' to not include serialization of recursive references
--*/
var function tolua(x, args) {
	var state = {
		indentChar = '',
		newlineChar = '',
		wrapWithFunction = false,
		recursiveReferences = table(),
		touchedTables = {},
	};
	var indent = true;
	if( args ) {
		if( args.indent == false ) { indent = false; }
		state.serializeForType = args.serializeForType;
		state.serializeMetatables = args.serializeMetatables;
		state.serializeMetatableFunc = args.serializeMetatableFunc;
		state.skipRecursiveReferences = args.skipRecursiveReferences;
	}
	if( indent ) {
		state.indentChar = '\t';
		state.newlineChar = '\n';
	}
	state.pairs = builtinPairs;

	var str = toLuaRecurse(state, x, null, '');

	if( state.wrapWithFunction ) {
		str = '(function()' .. state.newlineChar
			.. state.indentChar .. 'local root = '..str .. ' ' .. state.newlineChar
			// TODO defer self-references to here
			.. state.recursiveReferences->concat(' '..state.newlineChar..state.indentChar) .. ' ' .. state.newlineChar
			.. state.indentChar .. 'return root ' .. state.newlineChar
			.. 'end)()';
	}

	return str;
}

return setmetatable({}, {
	__call = function(this, x, args) {
		return tolua(x, args);
	},
	__index = {
		// escaping a Lua string for load() to use
		escapeString = escapeString,
		// returns 'true' if the key passed is a valid Lua variable string, 'false' otherwise
		isVarName = isVarName,
		// table of default serialization functions indexed by each time
		defaultSerializeForType = defaultSerializeForType,
		// default metatable serialization function
		defaultSerializeMetatableFunc = defaultSerializeMetatableFunc,
	}
});
