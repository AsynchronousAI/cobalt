var COLOR_NAMES = require ('helpers.color_names');
var COLOR_NAMES_BY_KEY = require ('helpers.color_names_by_key');

var StringHelper = require ('helpers.string');

var Color = {};

function Color.string_to_rgb(input) {
  var _, key = StringHelper.to_identifier(input);

  if( COLOR_NAMES_BY_KEY[key] != null ) {
    return COLOR_NAMES_BY_KEY[key].rgb;
  }

  return Color.hex_to_rgb(input);
}

function Color.hex_to_rgb(hex) {
  hex = hex->gsub('#', '');

  return {
    tonumber('0x' .. hex->sub(1, 2)),
    tonumber('0x' .. hex->sub(3, 4)),
    tonumber('0x' .. hex->sub(5, 6))
  };
}

function Color.rgb_to_hex(rgb) {
  var hex = '';

  for( _, value in pairs(rgb) ) {
    var partial_hex = '';

    while((value > 0)) {
      var index = math.fmod(value, 16) + 1;
      value = math.floor(value / 16);
      partial_hex = string.sub('0123456789ABCDEF', index, index) .. partial_hex;
    }

    if((string.len(partial_hex) == 0)) {
      partial_hex = '00';

    } else if((string.len(partial_hex) == 1)) {
      partial_hex = '0' .. partial_hex;
    }

    hex = hex .. partial_hex;
  }

  return '#' .. hex;
}

function Color.rgbs_to_hex(rgbs) {
  var hexs = {};

  for( _, rgb in pairs(rgbs) ) {
    table.insert(hexs, Color.rgb_to_hex(rgb));
  }

  return hexs;
}

function Color.nearest_colors(rgb_color) {
  var result = Color.nearest(rgb_color);

  var colors = {};

  for( _, color in pairs(result.colors) ) {
    table.insert(colors, {
      identifier = color.identifier,
      name = color.name,
      rgb = color.rgb,
      hex = Color.rgb_to_hex(color.rgb)
    });
  }

  return { colors = colors, distance = result.distance };
}

function Color.names(rgb_color) {
  var result = Color.nearest_colors(rgb_color);

  var names = {};

  for( _, color in pairs(result.colors) ) {
    table.insert(names, color.name);
  }

  return names;
}

function Color.name(rgb_color) {
  var result = Color.nearest_color(rgb_color);

  return result.color.name;
}

function Color.nearest_color(rgb_color) {
  var result = Color.nearest(rgb_color);

  // TODO: Find a better way to tie the colors.
  var nearest_color = result.colors[1];

  return {
    color = {
      identifier = nearest_color.identifier,
      name = nearest_color.name,
      rgb = nearest_color.rgb,
      hex = Color.rgb_to_hex(nearest_color.rgb)

    },
    distance = result.distance
  };
}

function Color.nearest(rgb_color, colors_list) {

  if( colors_list == null ) {
    colors_list = COLOR_NAMES;
  }

  if( type(rgb_color) == 'string' ) {
    rgb_color = Color.string_to_rgb(rgb_color);
  }

  var nearest_distance = null;
  var nearest_colors = {};

  for( _, cadidate_color in pairs(colors_list) ) {
    if( type(cadidate_color) != 'number' ) {
      var distance = (
        ((rgb_color[1] - cadidate_color.rgb[1]) ** 2) +
        ((rgb_color[2] - cadidate_color.rgb[2]) ** 2) +
        ((rgb_color[3] - cadidate_color.rgb[3]) ** 2)
      );

      if( nearest_distance == null || distance < nearest_distance ) {
        nearest_colors = { cadidate_color };
        nearest_distance = distance;
      } else if( distance == nearest_distance ) {
        table.insert(nearest_colors, cadidate_color);
      }
    }
  }

  return {
    original = rgb_color,
    colors = nearest_colors,
    distance = nearest_distance
  };
}

function Color.naive_gradient(from_rgb, to_rgb, length) {
  var colors = {};

  var step = 1 / (length - 1);

  if( length > 0 ) {
    table.insert(colors, from_rgb);
  }

  for( mix = step, 1.0, step ) {
    if( mix >= 1.0 ) {
      break;
    }

    var color = {
      math.floor((from_rgb[1] * (1 - mix)) + (to_rgb[1] * mix)),
      math.floor((from_rgb[2] * (1 - mix)) + (to_rgb[2] * mix)),
      math.floor((from_rgb[3] * (1 - mix)) + (to_rgb[3] * mix))
    };
    table.insert(colors, color);
  }

  if( length > 1 ) {
    table.insert(colors, to_rgb);
  }

  return colors;
}

return Color;
