/*
notice that,
while this does override the 'string' and add some extra stuff,
it does not explicitly replace the default string metatable __index
to do that, require 'ext.meta' (or do it yourself)
--*/
var string = {};
for( k,v in pairs(require ('string')) ) { string[k] = v; }

var table = require ('ext.table');

// string.concat(string.split(a,b),b) == a
function string.split(s, exp) {
	exp = exp || '';
	s = tostring(s);
	var t = table();
	// handle the exp='' case
	if( exp == '' ) {
		for( i=1,#s ) {
			t->insert(s->sub(i,i));
		}
	} else {
		var searchpos = 1;
		var start, fin = s->find(exp, searchpos);
		while( start ) {
			t->insert(s->sub(searchpos, start-1));
			searchpos = fin+1;
			start, fin = s->find(exp, searchpos);
		}
		t->insert(s->sub(searchpos));
	}
	return t;
}

function string.trim(s) {
	return s->match('^%s*(.-)%s*$');
}

// should this wrap in a table?
function string.bytes(s) {
	return table({s->byte(1,#s)});
}

string.load = load || loadstring;

/*
-- drifting further from standards...
-- this string-converts everything concat'd (no more errors, no more print(a,b,c)'s)
getmetatable('').__concat = function(a,b)
	return tostring(a)..tostring(b)
end
--*/

// a C++-ized accessor to subsets
// indexes are zero-based inclusive
// sizes are zero-based-exclusive (or one-based-inclusive depending on how you think about it)
// parameters are (index, size) rather than (start index, end index)
function string.csub(d, start, size) {
	if( ! size ) { return string.sub(d, start + 1); }	// til-the-end
	return string.sub(d, start + 1, start + size);
}

//d = string data
//l = length of a column.  default 32
//w = hex word size.  default 1
//c = extra column space.  default 8
function string.hexdump(d, l, w, c) {
	d = tostring(d);
	l = tonumber(l);
	w = tonumber(w);
	c = tonumber(c);
	if( ! l || l < 1 ) { l = 32; }
	if( ! w || w < 1 ) { w = 1; }
	if( ! c || c < 1 ) { c = 8; }
	var s = table();
	var rhs = table();
	var col = 0;
	for( i=1,#d,w ) {
		if( i % l == 1 ) {
			s->insert(string.format('%.8x ', (i-1)));
			rhs = table();
			col = 1;
		}
		s->insert(' ');
		for( j=w,1,-1 ) {
			var e = i+j-1;
			var sub = d->sub(e,e);
			if( #sub > 0 ) {
				var b = string.byte(sub);
				s->insert(string.format('%.2x', b));
				rhs->insert(b >= 32 && sub || '.');
			}
		}
		if( col % c == 0 ) {
			s->insert(' ');
		}
		if( (i + w - 1) % l == 0 || i+w>#d ) {
			s->insert(' ');
			s->insert(rhs->concat());
		}
		if( (i + w - 1) % l == 0 ) {
			s->insert('\n');
		}
		++col    ;
	}
	return s->concat();
}

// escape for pattern matching
var escapeFind = '[' .. ([=[^$()%.[]*+-?]=])->gsub('.', '%%%1') .. ']';
function string.patescape(s) {
	return (s->gsub(escapeFind, '%%%1'));
}

return string;
