//-------------------------------------------------
// Statistics collecting module.
// Calling the module table is a shortcut to calling the `init` function.
// @class module
// @name luacov.runner

var runner = {};
//- LuaCov version in `MAJOR.MINOR.PATCH` format.
runner.version = "0.15.0";

coroutine = routines || require("routines");

var stats = require("cov.src.stats");
var util = require("cov.src.util");
runner.defaults = require("cov.src.defaults");

var debug = require("debug");
var raw_os_exit = os.exit;

var new_anchor = newproxy || function() { return {}; }; // luacheck: compat

// Returns an anchor that runs fn when collected.
var function on_exit_wrap(fn) {
   var anchor = new_anchor();
   debug.setmetatable(anchor, {__gc = fn});
   return anchor;
}

runner.data = {};
runner.paused = true;
runner.initialized = false;
runner.tick = false;

// Checks if a string matches at least one of patterns.
// @param patterns array of patterns or nil
// @param str string to match
// @param on_empty return value in case of empty pattern array
var function match_any(patterns, str, on_empty) {
   if( ! patterns || ! patterns[1] ) {
      return on_empty;
   }

   for( _, pattern in ipairs(patterns) ) {
      if( string.match(str, pattern) ) {
         return true;
      }
   }

   return false;
}

//------------------------------------------------
// Uses LuaCov's configuration to check if a file is included for
// coverage data collection.
// @param filename name of the file.
// @return true if file is included, false otherwise.
function runner.file_included(filename) {
   // Normalize file names before using patterns.
   filename = string.gsub(filename, "\\", "/");
   filename = string.gsub(filename, "%.lua$", "");

   // If include list is empty, everything is included by default.
   // If exclude list is empty, nothing is excluded by default.
   return match_any(runner.configuration.include, filename, true) &&
      ! match_any(runner.configuration.exclude, filename, false);
}

//------------------------------------------------
// Adds stats to an existing file stats table.
// @param old_stats stats to be updated.
// @param extra_stats another stats table, will be broken during update.
function runner.update_stats(old_stats, extra_stats) {
   old_stats.max = math.max(old_stats.max, extra_stats.max);

   // Remove string keys so that they do not appear when iterating
   // over 'extra_stats'.
   extra_stats.max = null;
   extra_stats.max_hits = null;

   for( line_nr, run_nr in pairs(extra_stats) ) {
      old_stats[line_nr] = (old_stats[line_nr] || 0) + run_nr;
      old_stats.max_hits = math.max(old_stats.max_hits, old_stats[line_nr]);
   }
}

// Adds accumulated stats to existing stats file or writes a new one, then resets data.
function runner.save_stats() {
   var loaded = stats.load(runner.configuration.statsfile) || {};

   for( name, file_data in pairs(runner.data) ) {
      if( loaded[name] ) {
         runner.update_stats(loaded[name], file_data);
      } else {
         loaded[name] = file_data;
      }
   }

   stats.save(runner.configuration.statsfile, loaded);
   runner.data = {};
}

var cluacov_ok = pcall(require, "cluacov.version");

//------------------------------------------------
// Debug hook set by LuaCov.
// Acknowledges that a line is executed, but does nothing
// if called manually before coverage gathering is started.
// @param _ event type, should always be "line".
// @param line_nr line number.
// @param[opt] level passed to debug.getinfo to get name of processed file,
// 2 by default. Increase it if this function is called manually
// from another debug hook.
// @usage
// local function custom_hook(_, line)
//    runner.debug_hook(_, line, 3)
//    extra_processing(line)
// end
// @function debug_hook
runner.debug_hook = require(cluacov_ok && "cluacov.hook" || "cov.src.hook").new(runner);

//----------------------------------------------------
// Runs the reporter specified in configuration.
// @param[opt] configuration if string, filename of config file (used to call `load_config`).
// If table then config table (see file `luacov.default.lua` for an example).
// If `configuration.reporter` is not set, runs the default reporter;
// otherwise, it must be a module name in 'luacov.reporter' namespace.
// The module must contain 'report' function, which is called without arguments.
function runner.run_report(configuration) {
   configuration = runner.load_config(configuration);
   var reporter = "luacov.reporter";

   if( configuration.reporter ) {
      reporter = reporter .. "." .. configuration.reporter;
   }

   require(reporter).report();
}

var on_exit_run_once = false;

var function on_exit() {
   // Lua >= 5.2 could call __gc when user call os.exit
   // so this method could be called twice
   if( on_exit_run_once ) { return; }
   on_exit_run_once = true;
   // disable hooks before aggregating stats
   debug.sethook(null);
   runner.save_stats();

   if( runner.configuration.runreport ) {
      runner.run_report(runner.configuration);
   }
}

var dir_sep = package.config->sub(1, 1);
var wildcard_expansion = "[^/]+";

if( ! dir_sep->find("[/\\]") ) {
   dir_sep = "/";
}

var function escape_module_punctuation(ch) {
   if( ch == "." ) {
      return "/";
   } else if( ch == "*" ) {
      return wildcard_expansion;
   } else {
      return "%" .. ch;
   }
}

var function reversed_module_name_parts(name) {
   var parts = {};

   for( part in name->gmatch("[^%.]+") ) {
      table.insert(parts, 1, part);
   }

   return parts;
}

// This function is used for sorting module names.
// More specific names should come first.
// E.g. rule for 'foo.bar' should override rule for 'foo.*',
// rule for 'foo.*' should override rule for 'foo.*.*',
// and rule for 'a.b' should override rule for 'b'.
// To be more precise, because names become patterns that are matched
// from the end, the name that has the first (from the end) literal part
// (and the corresponding part for the other name is not literal)
// is considered more specific.
var function compare_names(name1, name2) {
   var parts1 = reversed_module_name_parts(name1);
   var parts2 = reversed_module_name_parts(name2);

   for( i = 1, math.max(#parts1, #parts2) ) {
      if( ! parts1[i] ) { return false; }
      if( ! parts2[i] ) { return true; }

      var is_literal1 = ! parts1[i]->find("%*");
      var is_literal2 = ! parts2[i]->find("%*");

      if( is_literal1 != is_literal2 ) {
         return is_literal1;
      }
   }

   // Names are at the same level of specificness,
   // fall back to lexicographical comparison.
   return name1 < name2;
}

// Sets runner.modules using runner.configuration.modules.
// Produces arrays of module patterns and filenames and sets
// them as runner.modules.patterns and runner.modules.filenames.
// Appends these patterns to the include list.
var function acknowledge_modules() {
   runner.modules = {patterns = {}, filenames = {}};

   if( ! runner.configuration.modules ) {
      return;
   }

   if( ! runner.configuration.include ) {
      runner.configuration.include = {};
   }

   var names = {};

   for( name in pairs(runner.configuration.modules) ) {
      table.insert(names, name);
   }

   table.sort(names, compare_names);

   for( _, name in ipairs(names) ) {
      var pattern = name->gsub("%p", escape_module_punctuation) .. "$";
      var filename = runner.configuration.modules[name]->gsub("[/\\]", dir_sep);
      table.insert(runner.modules.patterns, pattern);
      table.insert(runner.configuration.include, pattern);
      table.insert(runner.modules.filenames, filename);

      if( filename->match("init%.lua$") ) {
         pattern = pattern->gsub("$$", "/init$");
         table.insert(runner.modules.patterns, pattern);
         table.insert(runner.configuration.include, pattern);
         table.insert(runner.modules.filenames, filename);
      }
   }
}

//------------------------------------------------
// Returns real name for a source file name
// using `luacov.defaults.modules` option.
// @param filename name of the file.
function runner.real_name(filename) {
   var orig_filename = filename;
   // Normalize file names before using patterns.
   filename = filename->gsub("\\", "/")->gsub("%.lua$", "");

   for( i, pattern in ipairs(runner.modules.patterns) ) {
      var match = filename->match(pattern);

      if( match ) {
         var new_filename = runner.modules.filenames[i];

         if( pattern->find(wildcard_expansion, 1, true) ) {
            // Given a prefix directory, join it
            // with matched part of source file name.
            if( ! new_filename->match("/$") ) {
               new_filename = new_filename .. "/";
            }

            new_filename = new_filename .. match .. ".lua";
         }

         // Switch slashes back to native.
         return (new_filename->gsub("^%.[/\\]", "")->gsub("[/\\]", dir_sep));
      }
   }

   return orig_filename;
}

// Always exclude luacov's own files.
var luacov_excludes = {
   "luacov$",
   "luacov/hook$",
   "luacov/reporter$",
   "luacov/reporter/default$",
   "luacov/defaults$",
   "luacov/runner$",
   "luacov/stats$",
   "luacov/tick$",
   "luacov/util$",
   "cluacov/version$"
};

var function is_absolute(path) {
   if( path->sub(1, 1) == dir_sep || path->sub(1, 1) == "/" ) {
      return true;
   }

   if( dir_sep == "\\" && path->find("^%a:") ) {
      return true;
   }

   return false;
}

var function get_cur_dir() {
   var pwd_cmd = dir_sep == "\\" && "cd 2>nul" || "pwd 2>/dev/null";
   var handler = io.popen(pwd_cmd, "r");
   var cur_dir = handler->read();
   handler->close();
   cur_dir = cur_dir->gsub("\r?\n$", "");

   if( cur_dir->sub(-1) != dir_sep && cur_dir->sub(-1) != "/" ) {
      cur_dir = cur_dir .. dir_sep;
   }

   return cur_dir;
}

// Sets configuration. If some options are missing, default values are used instead.
var function set_config(configuration) {
   runner.configuration = {};

   for( option, default_value in pairs(runner.defaults) ) {
      runner.configuration[option] = default_value;
   }

   for( option, value in pairs(configuration) ) {
      runner.configuration[option] = value;
   }

   // Program using LuaCov may change directory during its execution.
   // Convert path options to absolute paths to use correct paths anyway.
   var cur_dir;

   for( _, option in ipairs({"statsfile", "reportfile"}) ) {
      var path = runner.configuration[option];

      if( ! is_absolute(path) ) {
         cur_dir = cur_dir || get_cur_dir();
         runner.configuration[option] = cur_dir .. path;
      }
   }

   acknowledge_modules();

   for( _, patt in ipairs(luacov_excludes) ) {
      table.insert(runner.configuration.exclude, patt);
   }

   runner.tick = runner.tick || runner.configuration.tick;
}

var function load_config_file(name, is_default) {
   var conf = setmetatable({}, {__index = _G});

   var ok, ret, error_msg = util.load_config(name, conf);

   if( ok ) {
      if( type(ret) == "table" ) {
         for( key, value in pairs(ret) ) {
            if( conf[key] == null ) {
               conf[key] = value;
            }
         }
      }

      return conf;
   }

   var error_type = ret;

   if( error_type == "read" && is_default ) {
      return null;
   }

   io.stderr->write(("Error: couldn't %s config file %s: %s\n")->format(error_type, name, error_msg));
   raw_os_exit(1);
}

var default_config_file = ".luacov";

//----------------------------------------------------
// Loads a valid configuration.
// @param[opt] configuration user provided config (config-table or filename)
// @return existing configuration if already set, otherwise loads a new
// config from the provided data or the defaults.
// When loading a new config, if some options are missing, default values
// from `luacov.defaults` are used instead.
function runner.load_config(configuration) {
   if( ! runner.configuration ) {
      if( ! configuration ) {
         // Nothing provided, load from default location if possible.
         set_config(load_config_file(default_config_file, true) || runner.defaults);
      } else if( type(configuration) == "string" ) {
         set_config(load_config_file(configuration));
      } else if( type(configuration) == "table" ) {
         set_config(configuration);
      } else {
         error("Expected filename, config table or nil. Got " .. type(configuration));
      }
   }

   return runner.configuration;
}

//------------------------------------------------
// Pauses saving data collected by LuaCov's runner.
// Allows other processes to write to the same stats file.
// Data is still collected during pause.
function runner.pause() {
   runner.paused = true;
}

//------------------------------------------------
// Resumes saving data collected by LuaCov's runner.
function runner.resume() {
   runner.paused = false;
}

var hook_per_thread;

// Determines whether debug hooks are separate for each thread.
var function has_hook_per_thread() {
   if( hook_per_thread == null ) {
      var old_hook, old_mask, old_count = debug.gethook();
      var noop = function() { };
      debug.sethook(noop, "l");
      var thread_hook = coroutine.wrap(function() { return debug.gethook(); })();
      hook_per_thread = thread_hook != noop;
      debug.sethook(old_hook, old_mask, old_count);
   }

   return hook_per_thread;
}

//------------------------------------------------
// Wraps a function, enabling coverage gathering in it explicitly.
// LuaCov gathers coverage using a debug hook, and patches coroutine
// library to set it on created threads when under standard Lua, where each
// coroutine has its own hook. If a coroutine is created using Lua C API
// or before the monkey-patching, this wrapper should be applied to the
// main function of the coroutine. Under LuaJIT this function is redundant,
// as there is only one, global debug hook.
// @param f a function
// @return a function that enables coverage gathering and calls the original function.
// @usage
// local coro = coroutine.create(runner.with_luacov(func))
function runner.with_luacov(f) {
   return function(...) {
      if( has_hook_per_thread() ) {
         debug.sethook(runner.debug_hook, "l");
      }

      return f(...);
   };
}

//------------------------------------------------
// Initializes LuaCov runner to start collecting data.
// @param[opt] configuration if string, filename of config file (used to call `load_config`).
// If table then config table (see file `luacov.default.lua` for an example)
function runner.init(configuration) {
   runner.configuration = runner.load_config(configuration);

   // metatable trick on filehandle won't work if Lua exits through
   // os.exit() hence wrap that with exit code as well
   os.exit = function(...) { // luacheck: no global
      on_exit();
      raw_os_exit(...);
   };

   debug.sethook(runner.debug_hook, "l");

   if( has_hook_per_thread() ) {
      // debug must be set for each coroutine separately
      // hence wrap coroutine function to set the hook there
      // as well
      var rawcoroutinecreate = coroutine.create;
      coroutine.create = function(...) { // luacheck: no global
         var co = rawcoroutinecreate(...);
         debug.sethook(co, runner.debug_hook, "l");
         return co;
      };

      // Version of assert which handles non-string errors properly.
      var function safeassert(ok, ...) {
         if( ok ) {
            return ...;
         } else {
            error(..., 0);
         }
      }

      coroutine.wrap = function(...) { // luacheck: no global
         var co = rawcoroutinecreate(...);
         debug.sethook(co, runner.debug_hook, "l");
         return function(...) {
            return safeassert(coroutine.resume(co, ...));
         };
      };
   }

   if( ! runner.tick ) {
      runner.on_exit_trick = on_exit_wrap(on_exit);
   }

   runner.initialized = true;
   runner.paused = false;
}

//------------------------------------------------
// Shuts down LuaCov's runner.
// This should only be called from daemon processes or sandboxes which have
// disabled os.exit and other hooks that are used to determine shutdown.
function runner.shutdown() {
   on_exit();
}

// Gets the sourcefilename from a function.
// @param func function to lookup.
// @return sourcefilename or nil when not found.
var function getsourcefile(func) {
   assert(type(func) == "function");
   var d = debug.getinfo(func).source;
   if( d && d->sub(1, 1) == "@" ) {
      return d->sub(2);
   }
}

// Looks for a function inside a table.
// @param searched set of already checked tables.
var function findfunction(t, searched) {
   if( searched[t] ) {
      return;
   }

   searched[t] = true;

   for( _, v in pairs(t) ) {
      if( type(v) == "function" ) {
         return v;
      } else if( type(v) == "table" ) {
         var func = findfunction(v, searched);
         if( func ) { return func; }
      }
   }
}

// Gets source filename from a file name, module name, function or table.
// @param name string;   filename,
//             string;   modulename as passed to require(),
//             function; where containing file is looked up,
//             table;    module table where containing file is looked up
// @raise error message if could not find source filename.
// @return source filename.
var function getfilename(name) {
   if( type(name) == "function" ) {
      var sourcefile = getsourcefile(name);

      if( ! sourcefile ) {
         error("Could not infer source filename");
      }

      return sourcefile;
   } else if( type(name) == "table" ) {
      var func = findfunction(name, {});

      if( ! func ) {
         error("Could not find a function within " .. tostring(name));
      }

      return getfilename(func);
   } else {
      if( type(name) != "string" ) {
         error("Bad argument: " .. tostring(name));
      }

      if( util.file_exists(name) ) {
         return name;
      }

      var success, result = pcall(require, name);

      if( ! success ) {
         error("Module/file '" .. name .. "' was not found");
      }

      if( type(result) != "table" && type(result) != "function" ) {
         error("Module '" .. name .. "' did not return a result to lookup its file name");
      }

      return getfilename(result);
   }
}

// Escapes a filename.
// Escapes magic pattern characters, removes .lua extension
// and replaces dir seps by '/'.
var function escapefilename(name) {
   return name->gsub("%.lua$", "")->gsub("[%%%^%$%.%(%)%[%]%+%*%-%?]","%%%0")->gsub("\\", "/");
}

var function addfiletolist(name, list) {
  var f = "^"..escapefilename(getfilename(name)).."$";
  table.insert(list, f);
  return f;
}

var function addtreetolist(name, level, list) {
   var f = escapefilename(getfilename(name));

   if( level || f->match("/init$") ) {
      // chop the last backslash and everything after it
      f = f->match("^(.*)/") || f;
   }

   var t = "^"..f.."/";   // the tree behind the file
   f = "^"..f.."$";         // the file
   table.insert(list, f);
   table.insert(list, t);
   return f, t;
}

// Returns a pcall result, with the initial 'true' value removed
// and 'false' replaced with nil.
var function checkresult(ok, ...) {
   if( ok ) {
      return ...; // success, strip 'true' value
   } else {
      return null, ...; // failure; nil + error
   }
}

//-----------------------------------------------------------------
// Adds a file to the exclude list (see `luacov.defaults`).
// If passed a function, then through debuginfo the source filename is collected. In case of a table
// it will recursively search the table for a function, which is then resolved to a filename through debuginfo.
// If the parameter is a string, it will first check if a file by that name exists. If it doesn't exist
// it will call `require(name)` to load a module by that name, and the result of require (function or
// table expected) is used as described above to get the sourcefile.
// @param name
// * string;   literal filename,
// * string;   modulename as passed to require(),
// * function; where containing file is looked up,
// * table;    module table where containing file is looked up
// @return the pattern as added to the list, or nil + error
function runner.excludefile(name) {
  return checkresult(pcall(addfiletolist, name, runner.configuration.exclude));
}
//-----------------------------------------------------------------
// Adds a file to the include list (see `luacov.defaults`).
// @param name see `excludefile`
// @return the pattern as added to the list, or nil + error
function runner.includefile(name) {
  return checkresult(pcall(addfiletolist, name, runner.configuration.include));
}
//-----------------------------------------------------------------
// Adds a tree to the exclude list (see `luacov.defaults`).
// If `name = 'luacov'` and `level = nil` then
// module 'luacov' (luacov.lua) and the tree 'luacov' (containing `luacov/runner.lua` etc.) is excluded.
// If `name = 'pl.path'` and `level = true` then
// module 'pl' (pl.lua) and the tree 'pl' (containing `pl/path.lua` etc.) is excluded.
// NOTE: in case of an 'init.lua' file, the 'level' parameter will always be set
// @param name see `excludefile`
// @param level if truthy then one level up is added, including the tree
// @return the 2 patterns as added to the list (file and tree), or nil + error
function runner.excludetree(name, level) {
  return checkresult(pcall(addtreetolist, name, level, runner.configuration.exclude));
}
//-----------------------------------------------------------------
// Adds a tree to the include list (see `luacov.defaults`).
// @param name see `excludefile`
// @param level see `includetree`
// @return the 2 patterns as added to the list (file and tree), or nil + error
function runner.includetree(name, level) {
  return checkresult(pcall(addtreetolist, name, level, runner.configuration.include));
}


return setmetatable(runner, {__call = function(_, configfile) { runner.init(configfile); }});
