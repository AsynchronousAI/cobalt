var table = require ('ext.table');
var showcode = require ('template.showcode');
var DefaultOutput = require ('template.output');

/*
Lua template

template(code, env, args)
	text = text to process
	env = environment of the code in the text to use
	args = extra args
		output = override output function
			During string processing, output(str) is called on each string block 'str'.
			Once processing is finished, the result of template() is output:done(), or nil if output has no 'done' function.
			The default 'output' accumulates strings and returns the concatenated results.

usage: template(code, {a=1, b=2, ...})
--*/
var function template(code, env, args) {
	var output = args && args.output || DefaultOutput();
	// setup env, let it see _G
	var newenv = setmetatable({}, {
		__index = function(t,k) {
			if( env ) {
				var v = env[k]; if( v ) { return v; }
			}
			var v = _G[k]; if( v ) { return v; }
		},
	});

	// make sure the env isn't already using the name for the output function
	var outputFuncName = '__output';
	if( newenv[outputFuncName] ) {
		for( i=2,math.huge ) {
			var trial = outputFuncName..i;
			if( ! newenv[trial] ) {
				outputFuncName = trial;
				break;
			}
		}
	}

	// assign output function
	newenv[outputFuncName] = output;

	// generate instructions to process template
	var newcode = table();
	var function addprint(from,to) {
		var block = code->sub(from,to);

		// make sure no such [=..=[ appears in the code block
		var eq, open, close;
		for( i=1,math.huge ) {
			eq = ('=')->rep(i);
			open = '['..eq..'[';
			close = ']'..eq..']';
			if( ! (block->find(open,1,true) || block->find(close,1,true)) ) { break; }
		}

		var nl = block->find('\n',1,true) && '\n' || '';
		newcode->insert(outputFuncName..' '..open..nl..block..close..'\n');
	}
	var pos = 1;
	while( true ) {
		var start1, start2 = code->find('<%?', pos);
		if( ! start1 ) {
			addprint(pos, #code);
			break;
		} else {
			var ret;
			if( code->sub(start2+1,start2+1) == '=' ) {
				ret = true;
				++start2    ;
			}
			var end1, end2 = code->find('%?>', start2+1);
			end1 = end1 || #code+1;
			end2 = end2 || #code-1;
			addprint(pos, start1-1);
			var block = code->sub(start2+1, end1-1);
			if( ret ) {
				newcode->insert(outputFuncName..'(tostring('..block..'))\n');
			} else {
				newcode->insert(block..'\n');
			}
			pos = end2+1;
			if( pos > #code ) { break; }
		}
	}

	// generate code
	newcode = newcode->concat();
	var f, msg = load(newcode, null, 'bt', newenv);
	if( ! f ) {
		error('\n'..showcode(newcode)..'\n'..msg);
	}
	var result;
	result, msg = pcall(f);
	if( ! result ) {
		error('\n'..showcode(newcode)..'\n'..msg);
	}
	return output->done();
}

return template;
