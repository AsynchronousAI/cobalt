// Cobalt preprocessor
// process(strcode) -> processed code
// This is a very basic preprocessor, it only supports #define, #include, #if, #else, #endif, #undef, #error, #warning, #pragma
// It supports built in macros in #define but not lambdas in #define
// #elif is not supported, use #else #if instead
// #ifdef and #ifndef are not supported, use #if (defined()) and #if (!defined()) instead
// #line is not supported
/*
#include "file.cobalt" // Looks for file.cobalt in package.searchers
// Replaces that line with the contents of file.cobalt

#define PI 3.14 // Sets PI to 3.14

#if defined("__APPLE__")
// Maybe put some cross platform Mac code here
#endif
#if defined(_WIN32)
// Maybe put some cross platform Windows code here
#endif

for (i = 1, PI*100){
    print(i/100)
}
*/
switch = import("switch") // Switch library for cobalt

function process(str){
    // 1: Split lines
    var lines = []
    for (line in str->gmatch("[^\r\n]+")) {
        lines[#lines + 1] = line
    }
    
    // 2: Look for preprocess lines
    var preprocess = []
    for (i, v in pairs(lines)) {
        var first = v->sub(1, 1) 
        var char = 1

        while (first == " " || first == "\t") {
            char++;
            first = v->sub(char, char)
        }

        if (first == "#") {
            v = v->sub(char, #v)
        
            table.insert(preprocess, [i, v])
        }
    }
    
    // 3: Execute preprocess lines
    var env = {
        "cobalt": true, 
        "cobaltversion": "23",
    }
    var newlines = lines
    var activeifs = []
    var run = true
    function table_to_string(tbl){
        var str = "{"
        for (k, v in pairs(tbl)) {
            if (type(k) == "number") {
                str = str .. v .. ","
            }else if (type(k) == "string") {
                str = str .. '"' .. k .. '": ' .. tostring(v) .. ","
            }
        }
        str = str .. "}"
        return str
    }
    function envload(str){
        return loadstring([[
            // Cobalt execution environment
            // Ignore.
            env = ]]..table_to_string(env)..[[;
            for (i, v in pairs(env)){
                _ENV[i] = v
            }
            core = import("core")
            function defined(val){
                // check if it is in env, if it return the value
                if (env[val] != null) {
                    return env[val]
                }else{
                    return core.macros(val)
                }
            }]]..str)
    }
    for (i, v in pairs(lines)) {
        // Check if i is v[1] for one of the preprocess lines
        var found = false
        for (i2, v2 in pairs(preprocess)) {
            if (v2[1] == i) {
                v = v2
                found = true
                break;
            }
        }
        if (!found) {
            if (!run) {
                newlines[i] = ""
            }
            continue;
        }

        // Get the first word of the line
        function errorpreprocessor(error){
            print("\27[1;31mPreprocessor error:\27[0m")
            print("\27[1;31mError with the '"..v[2].."' preprocessor command.\27[0m\n\n")
            if (error) {
                print("\27[1;31m"..error.."\27[0m\n\n")
            }
            print("\27[1;31mStopping preprocessor.\27[0m")
            os.exit()
        }
        switch(v[2]->match("%S+"), {
            "#define": function(){
                // split v[2] by spaces
                var split = v[2]->split(" ")
                // 1: Get the name
                var name = split[2]
                // 2: Get the value
                var value 
                var fun, err = envload("return "..split[3] || "false")
                if (!fun){
                    errorpreprocessor(err)
                }else{
                    value = fun()
                }
                // 3: Set the value in the env
                env[name] = value
                // 4: Remove the line
                newlines[v[1]] = "var "..name.." = "..value
                return
            },
            "#include": function(){
                var file = v[2]->gsub("#include \"", "")
                // File should be a string that ends with " and may have stuff after the "
                // Remove the last " and only keep everything before it
                for (i = 1, #file) {
                    var v = file->sub(i, i)
                    if (v == "\"") {
                        file = file->sub(1, i - 1)
                        break;
                    }
                }

                var f;
                for (i, v in pairs(package.searchers)){
                    if (#table.pack(v(file)) == 2 &&  table.pack(v(file))[1] != null) {
                        f = table.pack(v(file));
                        break;
                    }
                }
                if (!f) {
                    errorpreprocessor("File '"..file.."' not found")
                }
                file = io.open(f[2])
                var content = file->read("*all")
                file->close()
                
                // Set i line number to r(content)
    
                newlines[v[1]] = process(content)

                // Avoid memory leaks
                file = null
                content = null
                f = null
            },
            "#if": function(){
                // Example:
                // #if (true)
                
                // 1: Get the condition, Everything in between the ()
                var condition = v[2]->gsub("#if ", "")
                /// Get everything in between the ()
                for (i = 1, #condition) {
                    var v = condition->sub(i, i)
                    if (v == "(") {
                        condition = condition->sub(i + 1, #condition)
                        break;
                    }
                }
                for (i = #condition, 1, -1) {
                    var v = condition->sub(i, i)
                    if (v == ")") {
                        condition = condition->sub(1, i - 1)
                        break;
                    }
                }
                // 2: Evaluate the condition
                var success, result = xpcall(function(){
                    return (envload("return "..condition) || errorpreprocessor("Failed to check condition"))()
                }, function(err){
                    errorpreprocessor(err)
                })
                if (!success) {
                    errorpreprocessor(result)
                }
                // 3: Remove the line 
                newlines[v[1]] = ""
                table.insert(activeifs, result)

                // 4: Remove all code if result is false until #endif or #else
                run = result
            },
            "#else": function(){
                run = !run
                newlines[v[1]] = ""
            },
            "#endif": function(){
                activeifs[#activeifs] = null
                newlines[v[1]] = ""
                run = true
            },
            "#undef": function(){
                // split v[2] by spaces
                var split = v[2]->split(" ")
                // 1: Get the name
                var name = split[2]
                // 2: Remove the value in the env
                env[name] = null
                // 3: Remove the line
                newlines[v[1]] = ""
            },
            "#error": function(){
                var error = v[2]->gsub("#error ", "")
                print("\27[1;31mRaised error:\27[0m")
                print("\27[1;31m"..error.."\27[0m\n\n")
                os.exit()
            },
            "#warning": function(){
                var warning = v[2]->gsub("#warning ", "")
                warn(warning)
                newlines[v[1]] = ""
            },
            "#pragma": function(){
                var pragma = v[2]->gsub("#pragma ", "")
                warn("Pragma: "..pragma)
                newlines[v[1]] = ""
            },
            "default": function(value){
                if (!run){
                    newlines[v[1]] = ""
                    return // Skip this line
                }
                // Execute everything past the # as a cobalt line
                var code = v[2]->sub(2, #v[2])
                
                var success, result = xpcall(function(){
                    return (envload(code) || errorpreprocessor("Failed to load preprocessor command"))()
                }, function(err){
                    errorpreprocessor(err)
                })
                if (!success) {
                    errorpreprocessor(result)
                }else {
                    newlines[v[1]] = result
                }
            }
        })
        // Remove line from newlines
    }

    // 4: Join newlines and return
    if (#activeifs > 0) {
        errorpreprocessor("Missing #endif(s)")
    }
    lines = null
    preprocess = null
    str = null
    var joined = ""
    for (i, v in pairs(newlines)) {
        joined = joined..v.."\n"
    }
    newlines = null
    return joined
}
return process