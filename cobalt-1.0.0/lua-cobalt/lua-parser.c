/* This file is automatically generated by Lemon from input grammar
** source file "lua-parser.ly". */
/*
** 2000-05-29
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** Driver template for the LEMON parser generator.
**
** The "lemon" program processes an LALR(1) input grammar file, then uses
** this template to construct a parser.  The "lemon" program inserts text
** at each "%%" line.  Also, any "P-a-r-s-e" identifer prefix (without the
** interstitial "-" characters) contained in this template is changed into
** the value of the %name directive from the grammar.  Otherwise, the content
** of this template is copied straight through into the generate parser
** source file.
**
** The following is the concatenation of all %include directives from the
** input grammar file:
*/
/************ Begin %include sections from the grammar ************************/
#line 13 "lua-parser.ly"


  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
  #include <limits.h>
  #include <stdarg.h>
  #include <assert.h>
  #include "lua-parser.h"

  enum SepcialTokens {
    TK_SPACE = TK_LEMON_LAST_TOKEN,
    TK_COMMENT,
    TK_LONGCOMMENT,
    TK_THEEND
  };

  enum TokenFlags {
    noSemicolonNeeded = 0x01,
  };

  typedef struct LuaParserToken {
    int token_id;
    int space_before_size;
    int space_before_pos;
    int token_value_size;
    const char *token_value;
    int flags;
  } LuaParserToken;

 // void dummyFree(void *p) {assert(p);};

  typedef struct LuaParserState {
    const char *src;
    void **stack;
    int stack_size, stack_top;
    int noToCompound;
  } LuaParserState;

  void initializeLuaParserState(LuaParserState *pState) {
    pState->src = NULL;
    pState->stack = NULL;
    pState->stack_size = 0;
    pState->stack_top = 0;
    pState->noToCompound = 0;
  }

  void resetLuaParserState(LuaParserState *pState) {
    for(int i=0; i < pState->stack_top; ++i) {
      LuaParserToken *tk = pState->stack[i];
      if(tk->token_value_size < 0) {
        free((void*)tk->token_value);
      }
      free(tk);
    }
    free(pState->stack);
    initializeLuaParserState(pState);
  }

  void pushLuaParserToken(LuaParserState *pState, LuaParserToken *tk) {
    int new_top = pState->stack_top + 1;
    if(new_top >= pState->stack_size) {
      size_t new_size = ((pState->stack_size) ? pState->stack_size * 2 : 32);
      void *new_stack = realloc(pState->stack, new_size * sizeof(void*));
      if(!new_stack) {
        printf("Failed to allocate memory of size = %d\n", (int) new_size);
        exit(1);
      }
      pState->stack = new_stack;
      pState->stack_size = new_size;
    }
    //printf("%d: %d : %.*s\n", pState->stack_top, tk->token_id, tk->token_value_size, pState->src + tk->token_value_pos);fflush(stdout);
    //printf("push = %d : %d\n", pState->stack_top, pState->stack_size);
    pState->stack[pState->stack_top++] = tk;
  }

  int getLuaParserStateChildren(LuaParserState *pState, LuaParserToken *tk) {
    int children = 0;
    for(int i=pState->stack_top-1; i >= 0; --i) {
      if(pState->stack[i] == tk) break;
      ++children;
    }
    return children;
  }

  LuaParserToken *getLastLuaParserState(LuaParserState *pState) {
    /*
    * There is a problem with this when the last stement is not followed by a '\n'
    * right now we are avoiding it by adding a '\n' at the end when reading the file
    */
    int idx = pState->stack_top-2;
    LuaParserToken *ltk = pState->stack[idx];
    for(; idx >= 0; --idx) {
      //if the token is a comment/space skip it
      if(ltk->token_id < TK_LEMON_LAST_TOKEN) break;
      ltk = pState->stack[idx];
    }
    return ltk;
  }

  LuaParserToken *getNextLuaParserState(LuaParserState *pState, LuaParserToken *tk) {
    int idx = pState->stack_top-2;
    int top = idx;
    LuaParserToken *ltk = pState->stack[idx];
    while(idx >= 0 && pState->stack[idx] != tk) --idx;
    while(++idx <= top) {
      ltk = pState->stack[idx];
      //if the token is a comment/space skip it
      if(ltk->token_id < TK_LEMON_LAST_TOKEN) break;
    }
    return ltk;
  }

  int getLuaParserStateForwardCount(LuaParserState *pState, LuaParserToken *tk) {
    int idx = pState->stack_top-2;
    int top = idx;
    while(idx >= 0 && pState->stack[idx] != tk) --idx;
    return top - idx;
  }

  char *newStrFmt(LuaParserToken *tk, const char* fmt, ...) __attribute__ ((__format__ (__printf__, 2, 3)));
  char *newStrFmt(LuaParserToken *tk, const char* fmt, ...) {
    char tmp[8];
    va_list args;
    va_start(args, fmt);
    int sz = vsnprintf(tmp, sizeof(tmp), fmt, args);
    if(sz < 0) {
      printf("bad format string |%s|\n", fmt);
      exit(1);
    }
    va_end(args);

    char *str = malloc(sz+1);
    va_start(args, fmt);
    sz = vsnprintf(str, sz+1, fmt, args);
    va_end(args);
    if(tk->token_value_size < 0) free((void*)tk->token_value);
    tk->token_value = str;
    tk->token_value_size = -sz;
    return str;
  }

  void doOutput(LuaParserState *pState) {
    for(int i=0; i < pState->stack_top; ++i) {
      LuaParserToken *tk = pState->stack[i];
      if(tk->token_id < 0) {
        fprintf(stdout, "%c", tk->token_id*-1);
        continue;
      }
      if(tk->space_before_size) {
        fprintf(stdout, "%.*s", tk->space_before_size, pState->src + tk->space_before_pos);
      }
      //if(tk->children) fprintf(stderr, "|%d|", tk->children);
      fprintf(stdout, "%.*s", abs(tk->token_value_size), tk->token_value);
    }
  }

  void setTokenValue(LuaParserToken *tk, const char *str) {
    if(tk->token_value_size < 0) free((void*)tk->token_value);
    tk->token_value_size = strlen(str);
    tk->token_value = str;
  }
  void moveTokenValue(LuaParserToken *tk, LuaParserToken *tk_src) {
    if(tk->token_value_size < 0) free((void*)tk->token_value);
    tk->token_value_size = tk_src->token_value_size;
    tk->token_value = tk_src->token_value;
    tk_src->token_value = NULL;
    tk_src->token_value_size = 0;
  }
  void local2var(LuaParserToken *tk) {setTokenValue(tk, "var");}

  int _canMakePlusPlusMinusMinus(LuaParserState *pState, LuaParserToken *tkSrc, LuaParserToken *tkAssign, LuaParserToken *tk1,
						LuaParserToken *tkOp, const char *mORp) {
    LuaParserToken *tkAftertOp = getNextLuaParserState(pState, tkOp);
    if(tkAftertOp->token_value_size == 1 && tkAftertOp->token_value[0] == '1') {
	newStrFmt(tkSrc, "%s%.*s", mORp, tkSrc->token_value_size, tkSrc->token_value);
	setTokenValue(tkAftertOp, "");
	setTokenValue(tk1, "");
	setTokenValue(tkOp, "");
	setTokenValue(tkAssign, "");
	return 1;
    }
    return 0;
  }

  void checkSetAssignTokenOpToken(LuaParserState *pState, LuaParserToken *tkSrc, LuaParserToken *tkAssign, LuaParserToken *tk1) {

   /* compound assignment can produce a wrong result when there is more than one expression on the right side */
   /* so it's a bad idea to do it blindly */

    if(tkAssign->token_id != TK_ASSIGN) return;
    if(pState->noToCompound) return;
    if(getNextLuaParserState(pState, tkSrc) != tkAssign) return; //if it's a list assignment do nothing
    if(tkSrc->token_value_size == tk1->token_value_size) {
      if(strncmp(tkSrc->token_value, tk1->token_value, tkSrc->token_value_size) == 0) {
        LuaParserToken *tkOp = getNextLuaParserState(pState, tk1);
	int forwardCount = getLuaParserStateForwardCount(pState, tk1);

	if(forwardCount > 2) return; //only safe to do it with two ahead tokens/expressions
	//printf("== %.*s : %d\n", tkSrc->token_value_size, tkSrc->token_value, forwardCount);

        const char *newOp = NULL;
        switch(tkOp->token_id) {
          case TK_PLUS:
            if(_canMakePlusPlusMinusMinus(pState, tkSrc, tkAssign, tk1, tkOp, "++")) return;
            newOp = "+=";
          break;
          case TK_MINUS:
            if(_canMakePlusPlusMinusMinus(pState, tkSrc, tkAssign, tk1, tkOp, "--")) return;
            newOp = "-=";
          break;
/* this ones are safe only if there is one more expresion */
          case TK_MOD:
            newOp = "%=";
          break;
          case TK_MUL:
            newOp = "*=";
          break;
          case TK_DIV:
            newOp = "/=";
          break;
        }
        if(newOp) {
          setTokenValue(tkAssign, newOp);
          setTokenValue(tk1, "");
          setTokenValue(tkOp, "");
        }
      }
    }
  }

  void dumpToken(LuaParserToken *tk) {
    printf("%d : %.*s\n", tk->token_id, tk->token_value_size, tk->token_value);
  }

  void setTokenFlag(LuaParserToken *tk, enum TokenFlags fv, int OnOff) {
    if(OnOff) tk->flags |= fv;
    else tk->flags &= ~fv;
  }

  void fixLongStringQuote(LuaParserToken *tk) {
    if(tk->token_value[1] == '[') {
      /* we need at least one '=' on the quote to differentiate from arrays */
      int tk_vsz = abs(tk->token_value_size);
      int sz = tk_vsz + 2;
      char *str = malloc(sz+1);
      snprintf(str, sz+1, "[=[%.*s]=]", tk_vsz-4, tk->token_value+2);
      if(tk->token_value_size < 0) free((void*)tk->token_value);
      tk->token_value = str;
      tk->token_value_size = sz * -1;
    }
  }

#line 283 "lua-parser.c"
/**************** End of %include directives **********************************/
/* These constants specify the various numeric values for terminal symbols.
***************** Begin token definitions *************************************/
#ifndef TK_OPEN
#define TK_OPEN                            1
#define TK_LPAREN                          2
#define TK_SEMICOLON                       3
#define TK_UNTIL                           4
#define TK_DO                              5
#define TK_END                             6
#define TK_WHILE                           7
#define TK_REPEAT                          8
#define TK_IF                              9
#define TK_FUNCTION                       10
#define TK_ASSIGN                         11
#define TK_GOTO                           12
#define TK_LABEL                          13
#define TK_FOR                            14
#define TK_IN                             15
#define TK_ELSE                           16
#define TK_ELSEIF                         17
#define TK_THEN                           18
#define TK_BREAK                          19
#define TK_RETURN                         20
#define TK_LOCAL                          21
#define TK_COLON                          22
#define TK_DOT                            23
#define TK_COMMA                          24
#define TK_OR                             25
#define TK_AND                            26
#define TK_EQ                             27
#define TK_NEQ                            28
#define TK_LT                             29
#define TK_LTEQ                           30
#define TK_BT                             31
#define TK_BTEQ                           32
#define TK_CONCAT                         33
#define TK_PLUS                           34
#define TK_MINUS                          35
#define TK_MUL                            36
#define TK_DIV                            37
#define TK_MOD                            38
#define TK_NOT                            39
#define TK_LEN                            40
#define TK_POW                            41
#define TK_NIL                            42
#define TK_TRUE                           43
#define TK_FALSE                          44
#define TK_NUMBER                         45
#define TK_ELLIPSIS                       46
#define TK_IDIV                           47
#define TK_SHL                            48
#define TK_SHR                            49
#define TK_BITAND                         50
#define TK_BITOR                          51
#define TK_BITNOT                         52
#define TK_LBRACKET                       53
#define TK_RBRACKET                       54
#define TK_RPAREN                         55
#define TK_LBRACE                         56
#define TK_RBRACE                         57
#define TK_NAME                           58
#define TK_STRING                         59
#define TK_LONGSTRING                     60
#endif
/**************** End token definitions ***************************************/

/* The next sections is a series of control #defines.
** various aspects of the generated parser.
**    YYCODETYPE         is the data type used to store the integer codes
**                       that represent terminal and non-terminal symbols.
**                       "unsigned char" is used if there are fewer than
**                       256 symbols.  Larger types otherwise.
**    YYNOCODE           is a number of type YYCODETYPE that is not used for
**                       any terminal or nonterminal symbol.
**    YYFALLBACK         If defined, this indicates that one or more tokens
**                       (also known as: "terminal symbols") have fall-back
**                       values which should be used if the original symbol
**                       would not parse.  This permits keywords to sometimes
**                       be used as identifiers, for example.
**    YYACTIONTYPE       is the data type used for "action codes" - numbers
**                       that indicate what to do in response to the next
**                       token.
**    LuaParserTOKENTYPE     is the data type used for minor type for terminal
**                       symbols.  Background: A "minor type" is a semantic
**                       value associated with a terminal or non-terminal
**                       symbols.  For example, for an "ID" terminal symbol,
**                       the minor type might be the name of the identifier.
**                       Each non-terminal can have a different minor type.
**                       Terminal symbols all have the same minor type, though.
**                       This macros defines the minor type for terminal
**                       symbols.
**    YYMINORTYPE        is the data type used for all minor types.
**                       This is typically a union of many types, one of
**                       which is LuaParserTOKENTYPE.  The entry in the union
**                       for terminal symbols is called "yy0".
**    YYSTACKDEPTH       is the maximum depth of the parser's stack.  If
**                       zero the stack is dynamically sized using realloc()
**    LuaParserARG_SDECL     A static variable declaration for the %extra_argument
**    LuaParserARG_PDECL     A parameter declaration for the %extra_argument
**    LuaParserARG_PARAM     Code to pass %extra_argument as a subroutine parameter
**    LuaParserARG_STORE     Code to store %extra_argument into yypParser
**    LuaParserARG_FETCH     Code to extract %extra_argument from yypParser
**    LuaParserCTX_*         As LuaParserARG_ except for %extra_context
**    YYERRORSYMBOL      is the code number of the error symbol.  If not
**                       defined, then do no error processing.
**    YYNSTATE           the combined number of states.
**    YYNRULE            the number of rules in the grammar
**    YYNTOKEN           Number of terminal symbols
**    YY_MAX_SHIFT       Maximum value for shift actions
**    YY_MIN_SHIFTREDUCE Minimum value for shift-reduce actions
**    YY_MAX_SHIFTREDUCE Maximum value for shift-reduce actions
**    YY_ERROR_ACTION    The yy_action[] code for syntax error
**    YY_ACCEPT_ACTION   The yy_action[] code for accept
**    YY_NO_ACTION       The yy_action[] code for no-op
**    YY_MIN_REDUCE      Minimum value for reduce actions
**    YY_MAX_REDUCE      Maximum value for reduce actions
*/
#ifndef INTERFACE
# define INTERFACE 1
#endif
/************* Begin control #defines *****************************************/
#define YYCODETYPE unsigned char
#define YYNOCODE 95
#define YYACTIONTYPE unsigned short int
#define LuaParserTOKENTYPE  LuaParserToken* 
typedef union {
  int yyinit;
  LuaParserTOKENTYPE yy0;
} YYMINORTYPE;
#ifndef YYSTACKDEPTH
#define YYSTACKDEPTH 1000
#endif
#define LuaParserARG_SDECL  LuaParserState *pState ;
#define LuaParserARG_PDECL , LuaParserState *pState 
#define LuaParserARG_PARAM ,pState 
#define LuaParserARG_FETCH  LuaParserState *pState =yypParser->pState ;
#define LuaParserARG_STORE yypParser->pState =pState ;
#define LuaParserCTX_SDECL
#define LuaParserCTX_PDECL
#define LuaParserCTX_PARAM
#define LuaParserCTX_FETCH
#define LuaParserCTX_STORE
#define YYFALLBACK 1
#define YYNSTATE             143
#define YYNRULE              111
#define YYNRULE_WITH_ACTION  34
#define YYNTOKEN             61
#define YY_MAX_SHIFT         142
#define YY_MIN_SHIFTREDUCE   202
#define YY_MAX_SHIFTREDUCE   312
#define YY_ERROR_ACTION      313
#define YY_ACCEPT_ACTION     314
#define YY_NO_ACTION         315
#define YY_MIN_REDUCE        316
#define YY_MAX_REDUCE        426
/************* End control #defines *******************************************/
#define YY_NLOOKAHEAD ((int)(sizeof(yy_lookahead)/sizeof(yy_lookahead[0])))

/* Define the yytestcase() macro to be a no-op if is not already defined
** otherwise.
**
** Applications can choose to define yytestcase() in the %include section
** to a macro that can assist in verifying code coverage.  For production
** code the yytestcase() macro should be turned off.  But it is useful
** for testing.
*/
#ifndef yytestcase
# define yytestcase(X)
#endif


/* Next are the tables used to determine what action to take based on the
** current state and lookahead token.  These tables are used to implement
** functions that take a state number and lookahead value and return an
** action integer.
**
** Suppose the action integer is N.  Then the action is determined as
** follows
**
**   0 <= N <= YY_MAX_SHIFT             Shift N.  That is, push the lookahead
**                                      token onto the stack and goto state N.
**
**   N between YY_MIN_SHIFTREDUCE       Shift to an arbitrary state then
**     and YY_MAX_SHIFTREDUCE           reduce by rule N-YY_MIN_SHIFTREDUCE.
**
**   N == YY_ERROR_ACTION               A syntax error has occurred.
**
**   N == YY_ACCEPT_ACTION              The parser accepts its input.
**
**   N == YY_NO_ACTION                  No such action.  Denotes unused
**                                      slots in the yy_action[] table.
**
**   N between YY_MIN_REDUCE            Reduce by rule N-YY_MIN_REDUCE
**     and YY_MAX_REDUCE
**
** The action table is constructed as a single large table named yy_action[].
** Given state S and lookahead X, the action is computed as either:
**
**    (A)   N = yy_action[ yy_shift_ofst[S] + X ]
**    (B)   N = yy_default[S]
**
** The (A) formula is preferred.  The B formula is used instead if
** yy_lookahead[yy_shift_ofst[S]+X] is not equal to X.
**
** The formulas above are for computing the action when the lookahead is
** a terminal symbol.  If the lookahead is a non-terminal (as occurs after
** a reduce action) then the yy_reduce_ofst[] array is used in place of
** the yy_shift_ofst[] array.
**
** The following are the tables generated in this section:
**
**  yy_action[]        A single table containing all actions.
**  yy_lookahead[]     A table containing the lookahead for each entry in
**                     yy_action.  Used to detect hash collisions.
**  yy_shift_ofst[]    For each state, the offset into yy_action for
**                     shifting terminals.
**  yy_reduce_ofst[]   For each state, the offset into yy_action for
**                     shifting non-terminals after a reduce.
**  yy_default[]       Default action for each state.
**
*********** Begin parsing tables **********************************************/
#define YY_ACTTAB_COUNT (1196)
static const YYACTIONTYPE yy_action[] = {
 /*     0 */    80,   57,  314,  142,  128,   77,  120,   51,    3,   49,
 /*    10 */    49,  120,  370,  121,  121,   19,   80,   80,   49,   80,
 /*    20 */    49,  116,   55,  116,   12,   45,   42,   35,   34,   40,
 /*    30 */    38,   37,   36,   33,   32,   31,   30,   29,   28,  344,
 /*    40 */   344,   27,  343,  343,  409,  342,  360,   26,   25,   24,
 /*    50 */    23,   22,   21,   13,   45,   42,   35,   34,   40,   38,
 /*    60 */    37,   36,   33,   32,   31,   30,   29,   28,  234,  129,
 /*    70 */    27,   77,  234,    4,  321,   59,   26,   25,   24,   23,
 /*    80 */    22,   21,   45,   42,   35,   34,   40,   38,   37,   36,
 /*    90 */    33,   32,   31,   30,   29,   28,   71,   70,   27,   23,
 /*   100 */    22,   21,   60,   10,   26,   25,   24,   23,   22,   21,
 /*   110 */    45,   42,   35,   34,   40,   38,   37,   36,   33,   32,
 /*   120 */    31,   30,   29,   28,  368,  401,   27,    2,   15,  333,
 /*   130 */   312,  235,   26,   25,   24,   23,   22,   21,  401,  290,
 /*   140 */    45,   42,   35,   34,   40,   38,   37,   36,   33,   32,
 /*   150 */    31,   30,   29,   28,   67,  135,   27,  135,  126,  297,
 /*   160 */   117,   50,   26,   25,   24,   23,   22,   21,  134,  132,
 /*   170 */    45,   42,   35,   34,   40,   38,   37,   36,   33,   32,
 /*   180 */    31,   30,   29,   28,   63,  329,   27,   77,  405,  237,
 /*   190 */    48,  118,   26,   25,   24,   23,   22,   21,  306,   48,
 /*   200 */   294,  118,  234,  357,   45,   42,   35,   34,   40,   38,
 /*   210 */    37,   36,   33,   32,   31,   30,   29,   28,  355,  305,
 /*   220 */    27,  327,   11,   77,  353,   15,   26,   25,   24,   23,
 /*   230 */    22,   21,   45,   42,   35,   34,   40,   38,   37,   36,
 /*   240 */    33,   32,   31,   30,   29,   28,    8,  130,   27,   77,
 /*   250 */   208,   14,  303,   61,   26,   25,   24,   23,   22,   21,
 /*   260 */    42,   35,   34,   40,   38,   37,   36,   33,   32,   31,
 /*   270 */    30,   29,   28,  206,  136,   27,   77,  140,  141,   77,
 /*   280 */    77,   26,   25,   24,   23,   22,   21,   35,   34,   40,
 /*   290 */    38,   37,   36,   33,   32,   31,   30,   29,   28,   16,
 /*   300 */    18,   27,   66,  232,  233,   21,  205,   26,   25,   24,
 /*   310 */    23,   22,   21,  313,  313,   40,   38,   37,   36,   33,
 /*   320 */    32,   31,   30,   29,   28,  204,  350,   27,  299,  332,
 /*   330 */   358,  345,    7,   26,   25,   24,   23,   22,   21,   19,
 /*   340 */   234,   68,  315,  315,  315,   62,   62,   62,   58,  313,
 /*   350 */   313,  313,  313,   33,   32,   31,   30,   29,   28,  315,
 /*   360 */   315,   27,  301,    5,  315,  315,  315,   26,   25,   24,
 /*   370 */    23,   22,   21,   39,  234,  315,   68,   43,   41,   19,
 /*   380 */   220,  261,  262,  263,  265,  315,  402,  315,   58,  315,
 /*   390 */    20,   17,   88,    9,    2,  302,  234,  312,  235,  402,
 /*   400 */   122,   49,   49,  315,  315,  315,   47,  315,   88,   88,
 /*   410 */    49,   88,   49,   39,  315,  315,  315,   43,   41,   19,
 /*   420 */   220,  261,  262,  263,  265,  315,  315,  315,   58,  315,
 /*   430 */    20,   17,  315,   27,    2,  304,  234,  312,  235,   26,
 /*   440 */    25,   24,   23,   22,   21,  315,  315,  315,  315,  315,
 /*   450 */   315,  315,  315,   39,  315,  315,  315,   43,   41,   19,
 /*   460 */   220,  261,  262,  263,  265,  315,  315,  315,   58,  315,
 /*   470 */    20,   88,  315,  296,    2,  315,  234,  312,  235,  123,
 /*   480 */    49,   49,  315,  315,  315,  315,  315,   88,   88,   49,
 /*   490 */    88,   49,  315,   39,  315,  315,  315,   43,   41,  315,
 /*   500 */   220,  261,  262,  263,  265,  315,  315,  315,  315,  315,
 /*   510 */    20,  315,  315,  315,    2,  315,  234,  312,  235,   19,
 /*   520 */   315,  315,  315,   64,  315,   46,   53,    1,   52,  315,
 /*   530 */    69,  210,   56,  315,  315,  315,  315,  249,    6,   54,
 /*   540 */   315,  315,  315,  315,   33,   32,   31,   30,   29,   28,
 /*   550 */   315,  315,   27,  315,  315,  315,  315,  315,   26,   25,
 /*   560 */    24,   23,   22,   21,  315,  315,  315,  315,  315,   91,
 /*   570 */   315,  315,  315,  315,  315,  315,  234,  315,   49,  133,
 /*   580 */   315,  315,  315,  315,  315,   91,   91,   49,   91,   49,
 /*   590 */   315,  315,  315,   65,  315,   65,   30,   29,   28,  315,
 /*   600 */   315,   27,  315,  315,  315,  315,   91,   26,   25,   24,
 /*   610 */    23,   22,   21,  315,  315,   49,  133,  315,  315,  315,
 /*   620 */   315,   88,   91,   91,   49,   91,   49,  315,  315,  124,
 /*   630 */    49,   49,  422,  315,  315,  315,  315,   88,   88,   49,
 /*   640 */    88,   49,  315,  315,  315,   88,  315,  315,  315,  315,
 /*   650 */   315,  315,  315,  125,   49,   49,  315,   79,  315,  315,
 /*   660 */   315,   88,   88,   49,   88,   49,   49,   49,  325,  315,
 /*   670 */    88,  315,  315,   79,   79,   49,   79,   49,  127,   49,
 /*   680 */    49,  315,  315,  315,   80,  315,   88,   88,   49,   88,
 /*   690 */    49,  315,  315,   49,   49,  315,  315,  315,  328,  315,
 /*   700 */    80,   80,   49,   80,   49,   76,  315,  315,   75,   74,
 /*   710 */   131,  315,  315,  315,  119,  315,  103,  115,  315,  315,
 /*   720 */   315,  315,   85,  315,  315,   48,  315,  115,  315,  315,
 /*   730 */   315,   49,   49,  315,   78,  315,  315,  315,   85,   85,
 /*   740 */    49,   85,   49,   49,   49,  315,   86,  315,  315,  315,
 /*   750 */    78,   78,   49,   78,   49,   49,   49,  315,   87,  315,
 /*   760 */   315,  315,   86,   86,   49,   86,   49,   49,   49,  315,
 /*   770 */    89,  315,  315,  315,   87,   87,   49,   87,   49,   49,
 /*   780 */    49,  315,  315,   82,  315,  315,   89,   89,   49,   89,
 /*   790 */    49,  315,   49,   49,  315,  315,   90,  315,  315,   82,
 /*   800 */    82,   49,   82,   49,  315,   49,   49,  315,   83,  315,
 /*   810 */   315,  315,   90,   90,   49,   90,   49,   49,   49,  315,
 /*   820 */   104,  315,  315,  315,   83,   83,   49,   83,   49,   49,
 /*   830 */    49,  315,  137,  315,  315,  315,  104,  104,   49,  104,
 /*   840 */    49,   49,   49,  315,  138,  315,  315,  315,  137,  137,
 /*   850 */    49,  137,   49,   49,   49,  315,  139,  315,  315,  315,
 /*   860 */   138,  138,   49,  138,   49,   49,   49,  315,  112,  315,
 /*   870 */   315,  315,  139,  139,   49,  139,   49,   49,   49,  315,
 /*   880 */   315,  113,  315,  315,  112,  112,   49,  112,   49,  315,
 /*   890 */    49,   49,  315,  114,  315,  315,  315,  113,  113,   49,
 /*   900 */   113,   49,   49,   49,  315,  105,  315,  315,  315,  114,
 /*   910 */   114,   49,  114,   49,   49,   49,  315,  106,  315,  315,
 /*   920 */   315,  105,  105,   49,  105,   49,   49,   49,  315,  107,
 /*   930 */   315,  315,  315,  106,  106,   49,  106,   49,   49,   49,
 /*   940 */   315,  108,  315,  315,  315,  107,  107,   49,  107,   49,
 /*   950 */    49,   49,  315,  101,  315,  315,  315,  108,  108,   49,
 /*   960 */   108,   49,   49,   49,  315,  315,  102,  315,  315,  101,
 /*   970 */   101,   49,  101,   49,  315,   49,   49,  315,  100,  315,
 /*   980 */   315,  315,  102,  102,   49,  102,   49,   49,   49,  315,
 /*   990 */    94,  315,  315,  315,  100,  100,   49,  100,   49,   49,
 /*  1000 */    49,  315,   95,  315,  315,  315,   94,   94,   49,   94,
 /*  1010 */    49,   49,   49,  315,   97,  315,  315,  315,   95,   95,
 /*  1020 */    49,   95,   49,   49,   49,  315,   98,  315,  315,  315,
 /*  1030 */    97,   97,   49,   97,   49,   49,   49,  315,   99,  315,
 /*  1040 */   315,  315,   98,   98,   49,   98,   49,   49,   49,  315,
 /*  1050 */   315,  109,  315,  315,   99,   99,   49,   99,   49,  315,
 /*  1060 */    49,   49,  315,   96,  315,  315,  315,  109,  109,   49,
 /*  1070 */   109,   49,   49,   49,  315,  110,  315,  315,  315,   96,
 /*  1080 */    96,   49,   96,   49,   49,   49,  315,   93,  315,  315,
 /*  1090 */   315,  110,  110,   49,  110,   49,   49,   49,  315,  111,
 /*  1100 */   315,  315,  315,   93,   93,   49,   93,   49,   49,   49,
 /*  1110 */   315,   81,  315,  315,    4,  111,  111,   49,  111,   49,
 /*  1120 */    49,   49,  315,   92,  315,  315,  315,   81,   81,   49,
 /*  1130 */    81,   49,   49,   49,   72,   73,   84,  407,  315,   92,
 /*  1140 */    92,   49,   92,   49,  315,   49,   49,  315,  315,  315,
 /*  1150 */   315,  315,   84,   84,   49,   84,   49,  407,  407,  315,
 /*  1160 */   315,  315,  315,  315,  315,   44,  315,  315,    2,  315,
 /*  1170 */   315,  312,  235,  315,  315,  315,  315,  315,  315,  315,
 /*  1180 */   315,  315,  315,  315,  315,  315,  315,  315,  407,  315,
 /*  1190 */   315,  407,  315,  315,  407,  407,
};
static const YYCODETYPE yy_lookahead[] = {
 /*     0 */    68,   73,   61,   62,   72,   64,   78,    2,   93,   77,
 /*    10 */    78,   83,   78,   81,   82,    1,   84,   85,   86,   87,
 /*    20 */    88,   78,   78,   80,   24,   25,   26,   27,   28,   29,
 /*    30 */    30,   31,   32,   33,   34,   35,   36,   37,   38,   84,
 /*    40 */    84,   41,   87,   87,   89,   89,   78,   47,   48,   49,
 /*    50 */    50,   51,   52,   24,   25,   26,   27,   28,   29,   30,
 /*    60 */    31,   32,   33,   34,   35,   36,   37,   38,   58,   62,
 /*    70 */    41,   64,   58,    2,   67,   18,   47,   48,   49,   50,
 /*    80 */    51,   52,   25,   26,   27,   28,   29,   30,   31,   32,
 /*    90 */    33,   34,   35,   36,   37,   38,   22,   23,   41,   50,
 /*   100 */    51,   52,   16,   17,   47,   48,   49,   50,   51,   52,
 /*   110 */    25,   26,   27,   28,   29,   30,   31,   32,   33,   34,
 /*   120 */    35,   36,   37,   38,   78,   11,   41,   56,   24,   78,
 /*   130 */    59,   60,   47,   48,   49,   50,   51,   52,   24,   54,
 /*   140 */    25,   26,   27,   28,   29,   30,   31,   32,   33,   34,
 /*   150 */    35,   36,   37,   38,   10,   78,   41,   80,   78,   55,
 /*   160 */    80,   78,   47,   48,   49,   50,   51,   52,   91,   54,
 /*   170 */    25,   26,   27,   28,   29,   30,   31,   32,   33,   34,
 /*   180 */    35,   36,   37,   38,    5,   62,   41,   64,   78,    3,
 /*   190 */    77,   78,   47,   48,   49,   50,   51,   52,    3,   86,
 /*   200 */    55,   88,   58,   63,   25,   26,   27,   28,   29,   30,
 /*   210 */    31,   32,   33,   34,   35,   36,   37,   38,   63,   24,
 /*   220 */    41,   62,   65,   64,   63,   24,   47,   48,   49,   50,
 /*   230 */    51,   52,   25,   26,   27,   28,   29,   30,   31,   32,
 /*   240 */    33,   34,   35,   36,   37,   38,   11,   62,   41,   64,
 /*   250 */     6,    4,   57,    5,   47,   48,   49,   50,   51,   52,
 /*   260 */    26,   27,   28,   29,   30,   31,   32,   33,   34,   35,
 /*   270 */    36,   37,   38,    6,   62,   41,   64,   62,   62,   64,
 /*   280 */    64,   47,   48,   49,   50,   51,   52,   27,   28,   29,
 /*   290 */    30,   31,   32,   33,   34,   35,   36,   37,   38,   11,
 /*   300 */    11,   41,   24,    6,   55,   52,    6,   47,   48,   49,
 /*   310 */    50,   51,   52,   27,   28,   29,   30,   31,   32,   33,
 /*   320 */    34,   35,   36,   37,   38,    6,    0,   41,   46,   74,
 /*   330 */    74,   74,   15,   47,   48,   49,   50,   51,   52,    1,
 /*   340 */    58,   24,   95,   95,   95,   90,   90,   90,   10,   29,
 /*   350 */    30,   31,   32,   33,   34,   35,   36,   37,   38,   95,
 /*   360 */    95,   41,   46,   11,   95,   95,   95,   47,   48,   49,
 /*   370 */    50,   51,   52,   35,   58,   95,   24,   39,   40,    1,
 /*   380 */    42,   43,   44,   45,   46,   95,   11,   95,   10,   95,
 /*   390 */    52,   53,   68,   11,   56,   57,   58,   59,   60,   24,
 /*   400 */    76,   77,   78,   95,   95,   95,   24,   95,   84,   85,
 /*   410 */    86,   87,   88,   35,   95,   95,   95,   39,   40,    1,
 /*   420 */    42,   43,   44,   45,   46,   95,   95,   95,   10,   95,
 /*   430 */    52,   53,   95,   41,   56,   57,   58,   59,   60,   47,
 /*   440 */    48,   49,   50,   51,   52,   95,   95,   95,   95,   95,
 /*   450 */    95,   95,   95,   35,   95,   95,   95,   39,   40,    1,
 /*   460 */    42,   43,   44,   45,   46,   95,   95,   95,   10,   95,
 /*   470 */    52,   68,   95,   55,   56,   95,   58,   59,   60,   76,
 /*   480 */    77,   78,   95,   95,   95,   95,   95,   84,   85,   86,
 /*   490 */    87,   88,   95,   35,   95,   95,   95,   39,   40,   95,
 /*   500 */    42,   43,   44,   45,   46,   95,   95,   95,   95,   95,
 /*   510 */    52,   95,   95,   95,   56,   95,   58,   59,   60,    1,
 /*   520 */    95,   95,   95,    5,   95,    7,    8,    9,   10,   95,
 /*   530 */    12,   13,   14,   95,   95,   95,   95,   19,   20,   21,
 /*   540 */    95,   95,   95,   95,   33,   34,   35,   36,   37,   38,
 /*   550 */    95,   95,   41,   95,   95,   95,   95,   95,   47,   48,
 /*   560 */    49,   50,   51,   52,   95,   95,   95,   95,   95,   68,
 /*   570 */    95,   95,   95,   95,   95,   95,   58,   95,   77,   78,
 /*   580 */    95,   95,   95,   95,   95,   84,   85,   86,   87,   88,
 /*   590 */    95,   95,   95,   92,   95,   94,   36,   37,   38,   95,
 /*   600 */    95,   41,   95,   95,   95,   95,   68,   47,   48,   49,
 /*   610 */    50,   51,   52,   95,   95,   77,   78,   95,   95,   95,
 /*   620 */    95,   68,   84,   85,   86,   87,   88,   95,   95,   76,
 /*   630 */    77,   78,   94,   95,   95,   95,   95,   84,   85,   86,
 /*   640 */    87,   88,   95,   95,   95,   68,   95,   95,   95,   95,
 /*   650 */    95,   95,   95,   76,   77,   78,   95,   68,   95,   95,
 /*   660 */    95,   84,   85,   86,   87,   88,   77,   78,   79,   95,
 /*   670 */    68,   95,   95,   84,   85,   86,   87,   88,   76,   77,
 /*   680 */    78,   95,   95,   95,   68,   95,   84,   85,   86,   87,
 /*   690 */    88,   95,   95,   77,   78,   95,   95,   95,   82,   95,
 /*   700 */    84,   85,   86,   87,   88,   66,   95,   95,   69,   70,
 /*   710 */    71,   95,   95,   95,   75,   95,   77,   78,   95,   95,
 /*   720 */    95,   95,   68,   95,   95,   86,   95,   88,   95,   95,
 /*   730 */    95,   77,   78,   95,   68,   95,   95,   95,   84,   85,
 /*   740 */    86,   87,   88,   77,   78,   95,   68,   95,   95,   95,
 /*   750 */    84,   85,   86,   87,   88,   77,   78,   95,   68,   95,
 /*   760 */    95,   95,   84,   85,   86,   87,   88,   77,   78,   95,
 /*   770 */    68,   95,   95,   95,   84,   85,   86,   87,   88,   77,
 /*   780 */    78,   95,   95,   68,   95,   95,   84,   85,   86,   87,
 /*   790 */    88,   95,   77,   78,   95,   95,   68,   95,   95,   84,
 /*   800 */    85,   86,   87,   88,   95,   77,   78,   95,   68,   95,
 /*   810 */    95,   95,   84,   85,   86,   87,   88,   77,   78,   95,
 /*   820 */    68,   95,   95,   95,   84,   85,   86,   87,   88,   77,
 /*   830 */    78,   95,   68,   95,   95,   95,   84,   85,   86,   87,
 /*   840 */    88,   77,   78,   95,   68,   95,   95,   95,   84,   85,
 /*   850 */    86,   87,   88,   77,   78,   95,   68,   95,   95,   95,
 /*   860 */    84,   85,   86,   87,   88,   77,   78,   95,   68,   95,
 /*   870 */    95,   95,   84,   85,   86,   87,   88,   77,   78,   95,
 /*   880 */    95,   68,   95,   95,   84,   85,   86,   87,   88,   95,
 /*   890 */    77,   78,   95,   68,   95,   95,   95,   84,   85,   86,
 /*   900 */    87,   88,   77,   78,   95,   68,   95,   95,   95,   84,
 /*   910 */    85,   86,   87,   88,   77,   78,   95,   68,   95,   95,
 /*   920 */    95,   84,   85,   86,   87,   88,   77,   78,   95,   68,
 /*   930 */    95,   95,   95,   84,   85,   86,   87,   88,   77,   78,
 /*   940 */    95,   68,   95,   95,   95,   84,   85,   86,   87,   88,
 /*   950 */    77,   78,   95,   68,   95,   95,   95,   84,   85,   86,
 /*   960 */    87,   88,   77,   78,   95,   95,   68,   95,   95,   84,
 /*   970 */    85,   86,   87,   88,   95,   77,   78,   95,   68,   95,
 /*   980 */    95,   95,   84,   85,   86,   87,   88,   77,   78,   95,
 /*   990 */    68,   95,   95,   95,   84,   85,   86,   87,   88,   77,
 /*  1000 */    78,   95,   68,   95,   95,   95,   84,   85,   86,   87,
 /*  1010 */    88,   77,   78,   95,   68,   95,   95,   95,   84,   85,
 /*  1020 */    86,   87,   88,   77,   78,   95,   68,   95,   95,   95,
 /*  1030 */    84,   85,   86,   87,   88,   77,   78,   95,   68,   95,
 /*  1040 */    95,   95,   84,   85,   86,   87,   88,   77,   78,   95,
 /*  1050 */    95,   68,   95,   95,   84,   85,   86,   87,   88,   95,
 /*  1060 */    77,   78,   95,   68,   95,   95,   95,   84,   85,   86,
 /*  1070 */    87,   88,   77,   78,   95,   68,   95,   95,   95,   84,
 /*  1080 */    85,   86,   87,   88,   77,   78,   95,   68,   95,   95,
 /*  1090 */    95,   84,   85,   86,   87,   88,   77,   78,   95,   68,
 /*  1100 */    95,   95,   95,   84,   85,   86,   87,   88,   77,   78,
 /*  1110 */    95,   68,   95,   95,    2,   84,   85,   86,   87,   88,
 /*  1120 */    77,   78,   95,   68,   95,   95,   95,   84,   85,   86,
 /*  1130 */    87,   88,   77,   78,   22,   23,   68,    2,   95,   84,
 /*  1140 */    85,   86,   87,   88,   95,   77,   78,   95,   95,   95,
 /*  1150 */    95,   95,   84,   85,   86,   87,   88,   22,   23,   95,
 /*  1160 */    95,   95,   95,   95,   95,   53,   95,   95,   56,   95,
 /*  1170 */    95,   59,   60,   95,   95,   95,   95,   95,   95,   95,
 /*  1180 */    95,   95,   95,   95,   95,   95,   95,   95,   53,   95,
 /*  1190 */    95,   56,   95,   95,   59,   60,   95,   95,   95,   61,
 /*  1200 */    61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
 /*  1210 */    61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
 /*  1220 */    61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
 /*  1230 */    61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
 /*  1240 */    61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
 /*  1250 */    61,   61,   61,   61,   61,   61,   61,
};
#define YY_SHIFT_COUNT    (142)
#define YY_SHIFT_MIN      (0)
#define YY_SHIFT_MAX      (1135)
static const unsigned short int yy_shift_ofst[] = {
 /*     0 */  1196,  458,  338,  378,  418,  458,  458,  458,  458,  458,
 /*    10 */   458,  518,  458,  458,  458,  458,  458,  458,  458,  458,
 /*    20 */   458,  458,  458,  458,  458,  458,  458,  458,  458,  458,
 /*    30 */   458,  458,  458,  458,  458,  458,  458,  458,  458,  458,
 /*    40 */   458,  458,  458,  458,  458,  458,  458,   14, 1112, 1112,
 /*    50 */    71,  282,   10, 1196,  144,    5,   10,    5,    5, 1196,
 /*    60 */  1196, 1196, 1196, 1196, 1196,  195,  316,   10,   10,   10,
 /*    70 */    10,   10,   10,   10,  186,  186,  186, 1196,    0,   29,
 /*    80 */    57,   85,  115,  145,  179,  207,  207,  207,  207,  207,
 /*    90 */   207,  207,  234,  260,  286,  286,  320,  320,  320,  320,
 /*   100 */   511,  560,  560, 1135,  392,  392,  392,  392,  392,  392,
 /*   110 */   392,  392,   49,   49,   49,  114,  352,  317,  375,  382,
 /*   120 */    74,   86,  104,  201,  201,  201,  235,  201,  244,  247,
 /*   130 */   267,  248,  288,  289,  249,  278,  297,  253,  253,  253,
 /*   140 */   300,  319,  326,
};
#define YY_REDUCE_COUNT (77)
#define YY_REDUCE_MIN   (-85)
#define YY_REDUCE_MAX   (1068)
static const short yy_reduce_ofst[] = {
 /*     0 */   -59,  -68,  501,  538,  324,  403,  553,  577,  589,  602,
 /*    10 */   616,  639,  654,  666,  678,  690,  702,  715,  728,  740,
 /*    20 */   752,  764,  776,  788,  800,  813,  825,  837,  849,  861,
 /*    30 */   873,  885,  898,  910,  922,  934,  946,  958,  970,  983,
 /*    40 */   995, 1007, 1019, 1031, 1043, 1055, 1068,  113,  -45,  -45,
 /*    50 */   -44,   77,  -72,    7,  -57,  255,   80,  256,  257,  123,
 /*    60 */   159,  185,  212,  215,  216,  -85,  -66,  -56,  -66,  -32,
 /*    70 */    46,   51,   83,  110,  140,  155,  161,  157,
};
static const YYACTIONTYPE yy_default[] = {
 /*     0 */   354,  313,  313,  313,  313,  313,  364,  313,  313,  313,
 /*    10 */   313,  352,  313,  313,  313,  313,  313,  313,  313,  313,
 /*    20 */   313,  313,  313,  313,  313,  313,  313,  313,  313,  313,
 /*    30 */   313,  313,  313,  313,  313,  313,  313,  313,  313,  313,
 /*    40 */   313,  313,  313,  313,  313,  313,  313,  313,  313,  381,
 /*    50 */   313,  412,  313,  354,  313,  313,  313,  313,  313,  354,
 /*    60 */   354,  354,  354,  354,  354,  313,  313,  313,  313,  313,
 /*    70 */   313,  313,  313,  313,  316,  316,  316,  356,  373,  313,
 /*    80 */   313,  313,  313,  313,  313,  374,  317,  372,  371,  425,
 /*    90 */   424,  423,  336,  337,  338,  389,  385,  388,  387,  386,
 /*   100 */   390,  392,  391,  359,  396,  339,  395,  394,  393,  384,
 /*   110 */   383,  335,  398,  397,  340,  406,  330,  313,  406,  313,
 /*   120 */   366,  361,  313,  331,  365,  326,  369,  323,  313,  313,
 /*   130 */   313,  313,  313,  403,  313,  414,  313,  341,  400,  399,
 /*   140 */   313,  313,  313,
};
/********** End of lemon-generated parsing tables *****************************/

/* The next table maps tokens (terminal symbols) into fallback tokens.
** If a construct like the following:
**
**      %fallback ID X Y Z.
**
** appears in the grammar, then ID becomes a fallback token for X, Y,
** and Z.  Whenever one of the tokens X, Y, or Z is input to the parser
** but it does not parse, the type of the token is changed to ID and
** the parse is retried before an error is thrown.
**
** This feature can be used, for example, to cause some keywords in a language
** to revert to identifiers if they keyword does not apply in the context where
** it appears.
*/
#ifdef YYFALLBACK
static const YYCODETYPE yyFallback[] = {
    0,  /*          $ => nothing */
    0,  /*       OPEN => nothing */
    1,  /*     LPAREN => OPEN */
    0,  /*  SEMICOLON => nothing */
    0,  /*      UNTIL => nothing */
    0,  /*         DO => nothing */
    0,  /*        END => nothing */
    0,  /*      WHILE => nothing */
    0,  /*     REPEAT => nothing */
    0,  /*         IF => nothing */
    0,  /*   FUNCTION => nothing */
    0,  /*     ASSIGN => nothing */
    0,  /*       GOTO => nothing */
    0,  /*      LABEL => nothing */
    0,  /*        FOR => nothing */
    0,  /*         IN => nothing */
    0,  /*       ELSE => nothing */
    0,  /*     ELSEIF => nothing */
    0,  /*       THEN => nothing */
    0,  /*      BREAK => nothing */
    0,  /*     RETURN => nothing */
    0,  /*      LOCAL => nothing */
    0,  /*      COLON => nothing */
    0,  /*        DOT => nothing */
    0,  /*      COMMA => nothing */
    0,  /*         OR => nothing */
    0,  /*        AND => nothing */
    0,  /*         EQ => nothing */
    0,  /*        NEQ => nothing */
    0,  /*         LT => nothing */
    0,  /*       LTEQ => nothing */
    0,  /*         BT => nothing */
    0,  /*       BTEQ => nothing */
    0,  /*     CONCAT => nothing */
    0,  /*       PLUS => nothing */
    0,  /*      MINUS => nothing */
    0,  /*        MUL => nothing */
    0,  /*        DIV => nothing */
    0,  /*        MOD => nothing */
    0,  /*        NOT => nothing */
    0,  /*        LEN => nothing */
    0,  /*        POW => nothing */
    0,  /*        NIL => nothing */
    0,  /*       TRUE => nothing */
    0,  /*      FALSE => nothing */
    0,  /*     NUMBER => nothing */
    0,  /*   ELLIPSIS => nothing */
    0,  /*       IDIV => nothing */
    0,  /*        SHL => nothing */
    0,  /*        SHR => nothing */
    0,  /*     BITAND => nothing */
    0,  /*      BITOR => nothing */
    0,  /*     BITNOT => nothing */
    0,  /*   LBRACKET => nothing */
    0,  /*   RBRACKET => nothing */
    0,  /*     RPAREN => nothing */
    0,  /*     LBRACE => nothing */
    0,  /*     RBRACE => nothing */
    0,  /*       NAME => nothing */
    0,  /*     STRING => nothing */
    0,  /* LONGSTRING => nothing */
};
#endif /* YYFALLBACK */

/* The following structure represents a single element of the
** parser's stack.  Information stored includes:
**
**   +  The state number for the parser at this level of the stack.
**
**   +  The value of the token stored at this level of the stack.
**      (In other words, the "major" token.)
**
**   +  The semantic value stored at this level of the stack.  This is
**      the information used by the action routines in the grammar.
**      It is sometimes called the "minor" token.
**
** After the "shift" half of a SHIFTREDUCE action, the stateno field
** actually contains the reduce action for the second half of the
** SHIFTREDUCE.
*/
struct yyStackEntry {
  YYACTIONTYPE stateno;  /* The state-number, or reduce action in SHIFTREDUCE */
  YYCODETYPE major;      /* The major token value.  This is the code
                         ** number for the token at this stack level */
  YYMINORTYPE minor;     /* The user-supplied minor token value.  This
                         ** is the value of the token  */
};
typedef struct yyStackEntry yyStackEntry;

/* The state of the parser is completely contained in an instance of
** the following structure */
struct yyParser {
  yyStackEntry *yytos;          /* Pointer to top element of the stack */
#ifdef YYTRACKMAXSTACKDEPTH
  int yyhwm;                    /* High-water mark of the stack */
#endif
#ifndef YYNOERRORRECOVERY
  int yyerrcnt;                 /* Shifts left before out of the error */
#endif
  LuaParserARG_SDECL                /* A place to hold %extra_argument */
  LuaParserCTX_SDECL                /* A place to hold %extra_context */
#if YYSTACKDEPTH<=0
  int yystksz;                  /* Current side of the stack */
  yyStackEntry *yystack;        /* The parser's stack */
  yyStackEntry yystk0;          /* First stack entry */
#else
  yyStackEntry yystack[YYSTACKDEPTH];  /* The parser's stack */
  yyStackEntry *yystackEnd;            /* Last entry in the stack */
#endif
};
typedef struct yyParser yyParser;

#ifndef NDEBUG
#include <stdio.h>
#include <assert.h>
static FILE *yyTraceFILE = 0;
static char *yyTracePrompt = 0;
#endif /* NDEBUG */

#ifndef NDEBUG
/*
** Turn parser tracing on by giving a stream to which to write the trace
** and a prompt to preface each trace message.  Tracing is turned off
** by making either argument NULL
**
** Inputs:
** <ul>
** <li> A FILE* to which trace output should be written.
**      If NULL, then tracing is turned off.
** <li> A prefix string written at the beginning of every
**      line of trace output.  If NULL, then tracing is
**      turned off.
** </ul>
**
** Outputs:
** None.
*/
void LuaParserTrace(FILE *TraceFILE, char *zTracePrompt){
  yyTraceFILE = TraceFILE;
  yyTracePrompt = zTracePrompt;
  if( yyTraceFILE==0 ) yyTracePrompt = 0;
  else if( yyTracePrompt==0 ) yyTraceFILE = 0;
}
#endif /* NDEBUG */

#if defined(YYCOVERAGE) || !defined(NDEBUG)
/* For tracing shifts, the names of all terminals and nonterminals
** are required.  The following table supplies these names */
static const char *const yyTokenName[] = {
  /*    0 */ "$",
  /*    1 */ "OPEN",
  /*    2 */ "LPAREN",
  /*    3 */ "SEMICOLON",
  /*    4 */ "UNTIL",
  /*    5 */ "DO",
  /*    6 */ "END",
  /*    7 */ "WHILE",
  /*    8 */ "REPEAT",
  /*    9 */ "IF",
  /*   10 */ "FUNCTION",
  /*   11 */ "ASSIGN",
  /*   12 */ "GOTO",
  /*   13 */ "LABEL",
  /*   14 */ "FOR",
  /*   15 */ "IN",
  /*   16 */ "ELSE",
  /*   17 */ "ELSEIF",
  /*   18 */ "THEN",
  /*   19 */ "BREAK",
  /*   20 */ "RETURN",
  /*   21 */ "LOCAL",
  /*   22 */ "COLON",
  /*   23 */ "DOT",
  /*   24 */ "COMMA",
  /*   25 */ "OR",
  /*   26 */ "AND",
  /*   27 */ "EQ",
  /*   28 */ "NEQ",
  /*   29 */ "LT",
  /*   30 */ "LTEQ",
  /*   31 */ "BT",
  /*   32 */ "BTEQ",
  /*   33 */ "CONCAT",
  /*   34 */ "PLUS",
  /*   35 */ "MINUS",
  /*   36 */ "MUL",
  /*   37 */ "DIV",
  /*   38 */ "MOD",
  /*   39 */ "NOT",
  /*   40 */ "LEN",
  /*   41 */ "POW",
  /*   42 */ "NIL",
  /*   43 */ "TRUE",
  /*   44 */ "FALSE",
  /*   45 */ "NUMBER",
  /*   46 */ "ELLIPSIS",
  /*   47 */ "IDIV",
  /*   48 */ "SHL",
  /*   49 */ "SHR",
  /*   50 */ "BITAND",
  /*   51 */ "BITOR",
  /*   52 */ "BITNOT",
  /*   53 */ "LBRACKET",
  /*   54 */ "RBRACKET",
  /*   55 */ "RPAREN",
  /*   56 */ "LBRACE",
  /*   57 */ "RBRACE",
  /*   58 */ "NAME",
  /*   59 */ "STRING",
  /*   60 */ "LONGSTRING",
  /*   61 */ "chunk",
  /*   62 */ "block",
  /*   63 */ "semi",
  /*   64 */ "scope",
  /*   65 */ "statlist",
  /*   66 */ "laststat",
  /*   67 */ "ublock",
  /*   68 */ "exp",
  /*   69 */ "binding",
  /*   70 */ "stat",
  /*   71 */ "repetition",
  /*   72 */ "conds",
  /*   73 */ "funcname",
  /*   74 */ "funcbody",
  /*   75 */ "setlist",
  /*   76 */ "explist1",
  /*   77 */ "functioncall",
  /*   78 */ "ident",
  /*   79 */ "explist23",
  /*   80 */ "namelist",
  /*   81 */ "condlist",
  /*   82 */ "cond",
  /*   83 */ "dottedname",
  /*   84 */ "string",
  /*   85 */ "function",
  /*   86 */ "prefixexp",
  /*   87 */ "tableconstructor",
  /*   88 */ "var",
  /*   89 */ "args",
  /*   90 */ "params",
  /*   91 */ "parlist",
  /*   92 */ "fieldlist",
  /*   93 */ "fieldsep",
  /*   94 */ "field",
};
#endif /* defined(YYCOVERAGE) || !defined(NDEBUG) */

#ifndef NDEBUG
/* For tracing reduce actions, the names of all rules are required.
*/
static const char *const yyRuleName[] = {
 /*   0 */ "semi ::=",
 /*   1 */ "ublock ::= block UNTIL exp",
 /*   2 */ "stat ::= DO block END",
 /*   3 */ "stat ::= WHILE exp DO block END",
 /*   4 */ "stat ::= repetition DO block END",
 /*   5 */ "stat ::= REPEAT ublock",
 /*   6 */ "stat ::= IF conds END",
 /*   7 */ "stat ::= setlist ASSIGN explist1",
 /*   8 */ "stat ::= LABEL",
 /*   9 */ "repetition ::= FOR ident ASSIGN explist23",
 /*  10 */ "repetition ::= FOR namelist IN explist1",
 /*  11 */ "conds ::= condlist ELSE block",
 /*  12 */ "condlist ::= condlist ELSEIF cond",
 /*  13 */ "cond ::= exp THEN block",
 /*  14 */ "binding ::= LOCAL namelist",
 /*  15 */ "binding ::= LOCAL namelist ASSIGN explist1",
 /*  16 */ "binding ::= LOCAL FUNCTION ident funcbody",
 /*  17 */ "funcname ::= dottedname COLON ident",
 /*  18 */ "exp ::= NIL",
 /*  19 */ "exp ::= NOT exp",
 /*  20 */ "exp ::= exp OR exp",
 /*  21 */ "exp ::= exp AND exp",
 /*  22 */ "exp ::= exp NEQ exp",
 /*  23 */ "exp ::= exp POW exp",
 /*  24 */ "exp ::= exp IDIV exp",
 /*  25 */ "exp ::= exp BITNOT exp",
 /*  26 */ "functioncall ::= prefixexp COLON ident args",
 /*  27 */ "args ::= tableconstructor",
 /*  28 */ "args ::= string",
 /*  29 */ "function ::= FUNCTION funcbody",
 /*  30 */ "funcbody ::= params block END",
 /*  31 */ "params ::= LPAREN parlist RPAREN",
 /*  32 */ "ident ::= NAME",
 /*  33 */ "string ::= LONGSTRING",
 /*  34 */ "chunk ::= block",
 /*  35 */ "semi ::= SEMICOLON",
 /*  36 */ "block ::= scope statlist",
 /*  37 */ "block ::= scope statlist laststat semi",
 /*  38 */ "scope ::=",
 /*  39 */ "scope ::= scope statlist binding semi",
 /*  40 */ "statlist ::=",
 /*  41 */ "statlist ::= statlist stat semi",
 /*  42 */ "stat ::= FUNCTION funcname funcbody",
 /*  43 */ "stat ::= functioncall",
 /*  44 */ "stat ::= GOTO ident",
 /*  45 */ "conds ::= condlist",
 /*  46 */ "condlist ::= cond",
 /*  47 */ "laststat ::= BREAK",
 /*  48 */ "laststat ::= RETURN",
 /*  49 */ "laststat ::= RETURN explist1",
 /*  50 */ "funcname ::= dottedname",
 /*  51 */ "dottedname ::= ident",
 /*  52 */ "dottedname ::= dottedname DOT ident",
 /*  53 */ "namelist ::= ident",
 /*  54 */ "namelist ::= namelist COMMA ident",
 /*  55 */ "explist1 ::= exp",
 /*  56 */ "explist1 ::= explist1 COMMA exp",
 /*  57 */ "explist23 ::= exp COMMA exp",
 /*  58 */ "explist23 ::= exp COMMA exp COMMA exp",
 /*  59 */ "exp ::= TRUE",
 /*  60 */ "exp ::= FALSE",
 /*  61 */ "exp ::= NUMBER",
 /*  62 */ "exp ::= string",
 /*  63 */ "exp ::= ELLIPSIS",
 /*  64 */ "exp ::= function",
 /*  65 */ "exp ::= prefixexp",
 /*  66 */ "exp ::= tableconstructor",
 /*  67 */ "exp ::= LEN exp",
 /*  68 */ "exp ::= MINUS exp",
 /*  69 */ "exp ::= exp LT exp",
 /*  70 */ "exp ::= exp LTEQ exp",
 /*  71 */ "exp ::= exp BT exp",
 /*  72 */ "exp ::= exp BTEQ exp",
 /*  73 */ "exp ::= exp EQ exp",
 /*  74 */ "exp ::= exp CONCAT exp",
 /*  75 */ "exp ::= exp PLUS exp",
 /*  76 */ "exp ::= exp MINUS exp",
 /*  77 */ "exp ::= exp MUL exp",
 /*  78 */ "exp ::= exp DIV exp",
 /*  79 */ "exp ::= exp MOD exp",
 /*  80 */ "exp ::= BITNOT exp",
 /*  81 */ "exp ::= exp SHL exp",
 /*  82 */ "exp ::= exp SHR exp",
 /*  83 */ "exp ::= exp BITAND exp",
 /*  84 */ "exp ::= exp BITOR exp",
 /*  85 */ "setlist ::= var",
 /*  86 */ "setlist ::= setlist COMMA var",
 /*  87 */ "var ::= ident",
 /*  88 */ "var ::= prefixexp LBRACKET exp RBRACKET",
 /*  89 */ "var ::= prefixexp DOT ident",
 /*  90 */ "prefixexp ::= var",
 /*  91 */ "prefixexp ::= functioncall",
 /*  92 */ "prefixexp ::= OPEN exp RPAREN",
 /*  93 */ "functioncall ::= prefixexp args",
 /*  94 */ "args ::= LPAREN RPAREN",
 /*  95 */ "args ::= LPAREN explist1 RPAREN",
 /*  96 */ "parlist ::=",
 /*  97 */ "parlist ::= ELLIPSIS",
 /*  98 */ "parlist ::= namelist",
 /*  99 */ "parlist ::= namelist COMMA ELLIPSIS",
 /* 100 */ "tableconstructor ::= LBRACE RBRACE",
 /* 101 */ "tableconstructor ::= LBRACE fieldlist RBRACE",
 /* 102 */ "tableconstructor ::= LBRACE fieldlist fieldsep RBRACE",
 /* 103 */ "fieldsep ::= COMMA",
 /* 104 */ "fieldsep ::= SEMICOLON",
 /* 105 */ "fieldlist ::= field",
 /* 106 */ "fieldlist ::= fieldlist fieldsep field",
 /* 107 */ "field ::= exp",
 /* 108 */ "field ::= ident ASSIGN exp",
 /* 109 */ "field ::= LBRACKET exp RBRACKET ASSIGN exp",
 /* 110 */ "string ::= STRING",
};
#endif /* NDEBUG */


#if YYSTACKDEPTH<=0
/*
** Try to increase the size of the parser stack.  Return the number
** of errors.  Return 0 on success.
*/
static int yyGrowStack(yyParser *p){
  int newSize;
  int idx;
  yyStackEntry *pNew;

  newSize = p->yystksz*2 + 100;
  idx = p->yytos ? (int)(p->yytos - p->yystack) : 0;
  if( p->yystack==&p->yystk0 ){
    pNew = malloc(newSize*sizeof(pNew[0]));
    if( pNew ) pNew[0] = p->yystk0;
  }else{
    pNew = realloc(p->yystack, newSize*sizeof(pNew[0]));
  }
  if( pNew ){
    p->yystack = pNew;
    p->yytos = &p->yystack[idx];
#ifndef NDEBUG
    if( yyTraceFILE ){
      fprintf(yyTraceFILE,"%sStack grows from %d to %d entries.\n",
              yyTracePrompt, p->yystksz, newSize);
    }
#endif
    p->yystksz = newSize;
  }
  return pNew==0;
}
#endif

/* Datatype of the argument to the memory allocated passed as the
** second argument to LuaParserAlloc() below.  This can be changed by
** putting an appropriate #define in the %include section of the input
** grammar.
*/
#ifndef YYMALLOCARGTYPE
# define YYMALLOCARGTYPE size_t
#endif

/* Initialize a new parser that has already been allocated.
*/
void LuaParserInit(void *yypRawParser LuaParserCTX_PDECL){
  yyParser *yypParser = (yyParser*)yypRawParser;
  LuaParserCTX_STORE
#ifdef YYTRACKMAXSTACKDEPTH
  yypParser->yyhwm = 0;
#endif
#if YYSTACKDEPTH<=0
  yypParser->yytos = NULL;
  yypParser->yystack = NULL;
  yypParser->yystksz = 0;
  if( yyGrowStack(yypParser) ){
    yypParser->yystack = &yypParser->yystk0;
    yypParser->yystksz = 1;
  }
#endif
#ifndef YYNOERRORRECOVERY
  yypParser->yyerrcnt = -1;
#endif
  yypParser->yytos = yypParser->yystack;
  yypParser->yystack[0].stateno = 0;
  yypParser->yystack[0].major = 0;
#if YYSTACKDEPTH>0
  yypParser->yystackEnd = &yypParser->yystack[YYSTACKDEPTH-1];
#endif
}

#ifndef LuaParser_ENGINEALWAYSONSTACK
/*
** This function allocates a new parser.
** The only argument is a pointer to a function which works like
** malloc.
**
** Inputs:
** A pointer to the function used to allocate memory.
**
** Outputs:
** A pointer to a parser.  This pointer is used in subsequent calls
** to LuaParser and LuaParserFree.
*/
void *LuaParserAlloc(void *(*mallocProc)(YYMALLOCARGTYPE) LuaParserCTX_PDECL){
  yyParser *yypParser;
  yypParser = (yyParser*)(*mallocProc)( (YYMALLOCARGTYPE)sizeof(yyParser) );
  if( yypParser ){
    LuaParserCTX_STORE
    LuaParserInit(yypParser LuaParserCTX_PARAM);
  }
  return (void*)yypParser;
}
#endif /* LuaParser_ENGINEALWAYSONSTACK */


/* The following function deletes the "minor type" or semantic value
** associated with a symbol.  The symbol can be either a terminal
** or nonterminal. "yymajor" is the symbol code, and "yypminor" is
** a pointer to the value to be deleted.  The code used to do the
** deletions is derived from the %destructor and/or %token_destructor
** directives of the input grammar.
*/
static void yy_destructor(
  yyParser *yypParser,    /* The parser */
  YYCODETYPE yymajor,     /* Type code for object to destroy */
  YYMINORTYPE *yypminor   /* The object to be destroyed */
){
  LuaParserARG_FETCH
  LuaParserCTX_FETCH
  switch( yymajor ){
    /* Here is inserted the actions which take place when a
    ** terminal or non-terminal is destroyed.  This can happen
    ** when the symbol is popped from the stack during a
    ** reduce or during error processing or when a parser is
    ** being destroyed before it is finished parsing.
    **
    ** Note: during a reduce, the only symbols destroyed are those
    ** which appear on the RHS of the rule, but which are *not* used
    ** inside the C code.
    */
/********* Begin destructor definitions ***************************************/
/********* End destructor definitions *****************************************/
    default:  break;   /* If no destructor action specified: do nothing */
  }
}

/*
** Pop the parser's stack once.
**
** If there is a destructor routine associated with the token which
** is popped from the stack, then call it.
*/
static void yy_pop_parser_stack(yyParser *pParser){
  yyStackEntry *yytos;
  assert( pParser->yytos!=0 );
  assert( pParser->yytos > pParser->yystack );
  yytos = pParser->yytos--;
#ifndef NDEBUG
  if( yyTraceFILE ){
    fprintf(yyTraceFILE,"%sPopping %s\n",
      yyTracePrompt,
      yyTokenName[yytos->major]);
  }
#endif
  yy_destructor(pParser, yytos->major, &yytos->minor);
}

/*
** Clear all secondary memory allocations from the parser
*/
void LuaParserFinalize(void *p){
  yyParser *pParser = (yyParser*)p;
  while( pParser->yytos>pParser->yystack ) yy_pop_parser_stack(pParser);
#if YYSTACKDEPTH<=0
  if( pParser->yystack!=&pParser->yystk0 ) free(pParser->yystack);
#endif
}

#ifndef LuaParser_ENGINEALWAYSONSTACK
/*
** Deallocate and destroy a parser.  Destructors are called for
** all stack elements before shutting the parser down.
**
** If the YYPARSEFREENEVERNULL macro exists (for example because it
** is defined in a %include section of the input grammar) then it is
** assumed that the input pointer is never NULL.
*/
void LuaParserFree(
  void *p,                    /* The parser to be deleted */
  void (*freeProc)(void*)     /* Function used to reclaim memory */
){
#ifndef YYPARSEFREENEVERNULL
  if( p==0 ) return;
#endif
  LuaParserFinalize(p);
  (*freeProc)(p);
}
#endif /* LuaParser_ENGINEALWAYSONSTACK */

/*
** Return the peak depth of the stack for a parser.
*/
#ifdef YYTRACKMAXSTACKDEPTH
int LuaParserStackPeak(void *p){
  yyParser *pParser = (yyParser*)p;
  return pParser->yyhwm;
}
#endif

/* This array of booleans keeps track of the parser statement
** coverage.  The element yycoverage[X][Y] is set when the parser
** is in state X and has a lookahead token Y.  In a well-tested
** systems, every element of this matrix should end up being set.
*/
#if defined(YYCOVERAGE)
static unsigned char yycoverage[YYNSTATE][YYNTOKEN];
#endif

/*
** Write into out a description of every state/lookahead combination that
**
**   (1)  has not been used by the parser, and
**   (2)  is not a syntax error.
**
** Return the number of missed state/lookahead combinations.
*/
#if defined(YYCOVERAGE)
int LuaParserCoverage(FILE *out){
  int stateno, iLookAhead, i;
  int nMissed = 0;
  for(stateno=0; stateno<YYNSTATE; stateno++){
    i = yy_shift_ofst[stateno];
    for(iLookAhead=0; iLookAhead<YYNTOKEN; iLookAhead++){
      if( yy_lookahead[i+iLookAhead]!=iLookAhead ) continue;
      if( yycoverage[stateno][iLookAhead]==0 ) nMissed++;
      if( out ){
        fprintf(out,"State %d lookahead %s %s\n", stateno,
                yyTokenName[iLookAhead],
                yycoverage[stateno][iLookAhead] ? "ok" : "missed");
      }
    }
  }
  return nMissed;
}
#endif

/*
** Find the appropriate action for a parser given the terminal
** look-ahead token iLookAhead.
*/
static YYACTIONTYPE yy_find_shift_action(
  YYCODETYPE iLookAhead,    /* The look-ahead token */
  YYACTIONTYPE stateno      /* Current state number */
){
  int i;

  if( stateno>YY_MAX_SHIFT ) return stateno;
  assert( stateno <= YY_SHIFT_COUNT );
#if defined(YYCOVERAGE)
  yycoverage[stateno][iLookAhead] = 1;
#endif
  do{
    i = yy_shift_ofst[stateno];
    assert( i>=0 );
    assert( i<=YY_ACTTAB_COUNT );
    assert( i+YYNTOKEN<=(int)YY_NLOOKAHEAD );
    assert( iLookAhead!=YYNOCODE );
    assert( iLookAhead < YYNTOKEN );
    i += iLookAhead;
    assert( i<(int)YY_NLOOKAHEAD );
    if( yy_lookahead[i]!=iLookAhead ){
#ifdef YYFALLBACK
      YYCODETYPE iFallback;            /* Fallback token */
      assert( iLookAhead<sizeof(yyFallback)/sizeof(yyFallback[0]) );
      iFallback = yyFallback[iLookAhead];
      if( iFallback!=0 ){
#ifndef NDEBUG
        if( yyTraceFILE ){
          fprintf(yyTraceFILE, "%sFALLBACK %s => %s\n",
             yyTracePrompt, yyTokenName[iLookAhead], yyTokenName[iFallback]);
        }
#endif
        assert( yyFallback[iFallback]==0 ); /* Fallback loop must terminate */
        iLookAhead = iFallback;
        continue;
      }
#endif
#ifdef YYWILDCARD
      {
        int j = i - iLookAhead + YYWILDCARD;
        assert( j<(int)(sizeof(yy_lookahead)/sizeof(yy_lookahead[0])) );
        if( yy_lookahead[j]==YYWILDCARD && iLookAhead>0 ){
#ifndef NDEBUG
          if( yyTraceFILE ){
            fprintf(yyTraceFILE, "%sWILDCARD %s => %s\n",
               yyTracePrompt, yyTokenName[iLookAhead],
               yyTokenName[YYWILDCARD]);
          }
#endif /* NDEBUG */
          return yy_action[j];
        }
      }
#endif /* YYWILDCARD */
      return yy_default[stateno];
    }else{
      assert( i>=0 && i<(int)(sizeof(yy_action)/sizeof(yy_action[0])) );
      return yy_action[i];
    }
  }while(1);
}

/*
** Find the appropriate action for a parser given the non-terminal
** look-ahead token iLookAhead.
*/
static YYACTIONTYPE yy_find_reduce_action(
  YYACTIONTYPE stateno,     /* Current state number */
  YYCODETYPE iLookAhead     /* The look-ahead token */
){
  int i;
#ifdef YYERRORSYMBOL
  if( stateno>YY_REDUCE_COUNT ){
    return yy_default[stateno];
  }
#else
  assert( stateno<=YY_REDUCE_COUNT );
#endif
  i = yy_reduce_ofst[stateno];
  assert( iLookAhead!=YYNOCODE );
  i += iLookAhead;
#ifdef YYERRORSYMBOL
  if( i<0 || i>=YY_ACTTAB_COUNT || yy_lookahead[i]!=iLookAhead ){
    return yy_default[stateno];
  }
#else
  assert( i>=0 && i<YY_ACTTAB_COUNT );
  assert( yy_lookahead[i]==iLookAhead );
#endif
  return yy_action[i];
}

/*
** The following routine is called if the stack overflows.
*/
static void yyStackOverflow(yyParser *yypParser){
   LuaParserARG_FETCH
   LuaParserCTX_FETCH
#ifndef NDEBUG
   if( yyTraceFILE ){
     fprintf(yyTraceFILE,"%sStack Overflow!\n",yyTracePrompt);
   }
#endif
   while( yypParser->yytos>yypParser->yystack ) yy_pop_parser_stack(yypParser);
   /* Here code is inserted which will execute if the parser
   ** stack every overflows */
/******** Begin %stack_overflow code ******************************************/
/******** End %stack_overflow code ********************************************/
   LuaParserARG_STORE /* Suppress warning about unused %extra_argument var */
   LuaParserCTX_STORE
}

/*
** Print tracing information for a SHIFT action
*/
#ifndef NDEBUG
static void yyTraceShift(yyParser *yypParser, int yyNewState, const char *zTag){
  if( yyTraceFILE ){
    if( yyNewState<YYNSTATE ){
      fprintf(yyTraceFILE,"%s%s '%s', go to state %d\n",
         yyTracePrompt, zTag, yyTokenName[yypParser->yytos->major],
         yyNewState);
    }else{
      fprintf(yyTraceFILE,"%s%s '%s', pending reduce %d\n",
         yyTracePrompt, zTag, yyTokenName[yypParser->yytos->major],
         yyNewState - YY_MIN_REDUCE);
    }
  }
}
#else
# define yyTraceShift(X,Y,Z)
#endif

/*
** Perform a shift action.
*/
static void yy_shift(
  yyParser *yypParser,          /* The parser to be shifted */
  YYACTIONTYPE yyNewState,      /* The new state to shift in */
  YYCODETYPE yyMajor,           /* The major token to shift in */
  LuaParserTOKENTYPE yyMinor        /* The minor token to shift in */
){
  yyStackEntry *yytos;
  yypParser->yytos++;
#ifdef YYTRACKMAXSTACKDEPTH
  if( (int)(yypParser->yytos - yypParser->yystack)>yypParser->yyhwm ){
    yypParser->yyhwm++;
    assert( yypParser->yyhwm == (int)(yypParser->yytos - yypParser->yystack) );
  }
#endif
#if YYSTACKDEPTH>0
  if( yypParser->yytos>yypParser->yystackEnd ){
    yypParser->yytos--;
    yyStackOverflow(yypParser);
    return;
  }
#else
  if( yypParser->yytos>=&yypParser->yystack[yypParser->yystksz] ){
    if( yyGrowStack(yypParser) ){
      yypParser->yytos--;
      yyStackOverflow(yypParser);
      return;
    }
  }
#endif
  if( yyNewState > YY_MAX_SHIFT ){
    yyNewState += YY_MIN_REDUCE - YY_MIN_SHIFTREDUCE;
  }
  yytos = yypParser->yytos;
  yytos->stateno = yyNewState;
  yytos->major = yyMajor;
  yytos->minor.yy0 = yyMinor;
  yyTraceShift(yypParser, yyNewState, "Shift");
}

/* For rule J, yyRuleInfoLhs[J] contains the symbol on the left-hand side
** of that rule */
static const YYCODETYPE yyRuleInfoLhs[] = {
    63,  /* (0) semi ::= */
    67,  /* (1) ublock ::= block UNTIL exp */
    70,  /* (2) stat ::= DO block END */
    70,  /* (3) stat ::= WHILE exp DO block END */
    70,  /* (4) stat ::= repetition DO block END */
    70,  /* (5) stat ::= REPEAT ublock */
    70,  /* (6) stat ::= IF conds END */
    70,  /* (7) stat ::= setlist ASSIGN explist1 */
    70,  /* (8) stat ::= LABEL */
    71,  /* (9) repetition ::= FOR ident ASSIGN explist23 */
    71,  /* (10) repetition ::= FOR namelist IN explist1 */
    72,  /* (11) conds ::= condlist ELSE block */
    81,  /* (12) condlist ::= condlist ELSEIF cond */
    82,  /* (13) cond ::= exp THEN block */
    69,  /* (14) binding ::= LOCAL namelist */
    69,  /* (15) binding ::= LOCAL namelist ASSIGN explist1 */
    69,  /* (16) binding ::= LOCAL FUNCTION ident funcbody */
    73,  /* (17) funcname ::= dottedname COLON ident */
    68,  /* (18) exp ::= NIL */
    68,  /* (19) exp ::= NOT exp */
    68,  /* (20) exp ::= exp OR exp */
    68,  /* (21) exp ::= exp AND exp */
    68,  /* (22) exp ::= exp NEQ exp */
    68,  /* (23) exp ::= exp POW exp */
    68,  /* (24) exp ::= exp IDIV exp */
    68,  /* (25) exp ::= exp BITNOT exp */
    77,  /* (26) functioncall ::= prefixexp COLON ident args */
    89,  /* (27) args ::= tableconstructor */
    89,  /* (28) args ::= string */
    85,  /* (29) function ::= FUNCTION funcbody */
    74,  /* (30) funcbody ::= params block END */
    90,  /* (31) params ::= LPAREN parlist RPAREN */
    78,  /* (32) ident ::= NAME */
    84,  /* (33) string ::= LONGSTRING */
    61,  /* (34) chunk ::= block */
    63,  /* (35) semi ::= SEMICOLON */
    62,  /* (36) block ::= scope statlist */
    62,  /* (37) block ::= scope statlist laststat semi */
    64,  /* (38) scope ::= */
    64,  /* (39) scope ::= scope statlist binding semi */
    65,  /* (40) statlist ::= */
    65,  /* (41) statlist ::= statlist stat semi */
    70,  /* (42) stat ::= FUNCTION funcname funcbody */
    70,  /* (43) stat ::= functioncall */
    70,  /* (44) stat ::= GOTO ident */
    72,  /* (45) conds ::= condlist */
    81,  /* (46) condlist ::= cond */
    66,  /* (47) laststat ::= BREAK */
    66,  /* (48) laststat ::= RETURN */
    66,  /* (49) laststat ::= RETURN explist1 */
    73,  /* (50) funcname ::= dottedname */
    83,  /* (51) dottedname ::= ident */
    83,  /* (52) dottedname ::= dottedname DOT ident */
    80,  /* (53) namelist ::= ident */
    80,  /* (54) namelist ::= namelist COMMA ident */
    76,  /* (55) explist1 ::= exp */
    76,  /* (56) explist1 ::= explist1 COMMA exp */
    79,  /* (57) explist23 ::= exp COMMA exp */
    79,  /* (58) explist23 ::= exp COMMA exp COMMA exp */
    68,  /* (59) exp ::= TRUE */
    68,  /* (60) exp ::= FALSE */
    68,  /* (61) exp ::= NUMBER */
    68,  /* (62) exp ::= string */
    68,  /* (63) exp ::= ELLIPSIS */
    68,  /* (64) exp ::= function */
    68,  /* (65) exp ::= prefixexp */
    68,  /* (66) exp ::= tableconstructor */
    68,  /* (67) exp ::= LEN exp */
    68,  /* (68) exp ::= MINUS exp */
    68,  /* (69) exp ::= exp LT exp */
    68,  /* (70) exp ::= exp LTEQ exp */
    68,  /* (71) exp ::= exp BT exp */
    68,  /* (72) exp ::= exp BTEQ exp */
    68,  /* (73) exp ::= exp EQ exp */
    68,  /* (74) exp ::= exp CONCAT exp */
    68,  /* (75) exp ::= exp PLUS exp */
    68,  /* (76) exp ::= exp MINUS exp */
    68,  /* (77) exp ::= exp MUL exp */
    68,  /* (78) exp ::= exp DIV exp */
    68,  /* (79) exp ::= exp MOD exp */
    68,  /* (80) exp ::= BITNOT exp */
    68,  /* (81) exp ::= exp SHL exp */
    68,  /* (82) exp ::= exp SHR exp */
    68,  /* (83) exp ::= exp BITAND exp */
    68,  /* (84) exp ::= exp BITOR exp */
    75,  /* (85) setlist ::= var */
    75,  /* (86) setlist ::= setlist COMMA var */
    88,  /* (87) var ::= ident */
    88,  /* (88) var ::= prefixexp LBRACKET exp RBRACKET */
    88,  /* (89) var ::= prefixexp DOT ident */
    86,  /* (90) prefixexp ::= var */
    86,  /* (91) prefixexp ::= functioncall */
    86,  /* (92) prefixexp ::= OPEN exp RPAREN */
    77,  /* (93) functioncall ::= prefixexp args */
    89,  /* (94) args ::= LPAREN RPAREN */
    89,  /* (95) args ::= LPAREN explist1 RPAREN */
    91,  /* (96) parlist ::= */
    91,  /* (97) parlist ::= ELLIPSIS */
    91,  /* (98) parlist ::= namelist */
    91,  /* (99) parlist ::= namelist COMMA ELLIPSIS */
    87,  /* (100) tableconstructor ::= LBRACE RBRACE */
    87,  /* (101) tableconstructor ::= LBRACE fieldlist RBRACE */
    87,  /* (102) tableconstructor ::= LBRACE fieldlist fieldsep RBRACE */
    93,  /* (103) fieldsep ::= COMMA */
    93,  /* (104) fieldsep ::= SEMICOLON */
    92,  /* (105) fieldlist ::= field */
    92,  /* (106) fieldlist ::= fieldlist fieldsep field */
    94,  /* (107) field ::= exp */
    94,  /* (108) field ::= ident ASSIGN exp */
    94,  /* (109) field ::= LBRACKET exp RBRACKET ASSIGN exp */
    84,  /* (110) string ::= STRING */
};

/* For rule J, yyRuleInfoNRhs[J] contains the negative of the number
** of symbols on the right-hand side of that rule. */
static const signed char yyRuleInfoNRhs[] = {
    0,  /* (0) semi ::= */
   -3,  /* (1) ublock ::= block UNTIL exp */
   -3,  /* (2) stat ::= DO block END */
   -5,  /* (3) stat ::= WHILE exp DO block END */
   -4,  /* (4) stat ::= repetition DO block END */
   -2,  /* (5) stat ::= REPEAT ublock */
   -3,  /* (6) stat ::= IF conds END */
   -3,  /* (7) stat ::= setlist ASSIGN explist1 */
   -1,  /* (8) stat ::= LABEL */
   -4,  /* (9) repetition ::= FOR ident ASSIGN explist23 */
   -4,  /* (10) repetition ::= FOR namelist IN explist1 */
   -3,  /* (11) conds ::= condlist ELSE block */
   -3,  /* (12) condlist ::= condlist ELSEIF cond */
   -3,  /* (13) cond ::= exp THEN block */
   -2,  /* (14) binding ::= LOCAL namelist */
   -4,  /* (15) binding ::= LOCAL namelist ASSIGN explist1 */
   -4,  /* (16) binding ::= LOCAL FUNCTION ident funcbody */
   -3,  /* (17) funcname ::= dottedname COLON ident */
   -1,  /* (18) exp ::= NIL */
   -2,  /* (19) exp ::= NOT exp */
   -3,  /* (20) exp ::= exp OR exp */
   -3,  /* (21) exp ::= exp AND exp */
   -3,  /* (22) exp ::= exp NEQ exp */
   -3,  /* (23) exp ::= exp POW exp */
   -3,  /* (24) exp ::= exp IDIV exp */
   -3,  /* (25) exp ::= exp BITNOT exp */
   -4,  /* (26) functioncall ::= prefixexp COLON ident args */
   -1,  /* (27) args ::= tableconstructor */
   -1,  /* (28) args ::= string */
   -2,  /* (29) function ::= FUNCTION funcbody */
   -3,  /* (30) funcbody ::= params block END */
   -3,  /* (31) params ::= LPAREN parlist RPAREN */
   -1,  /* (32) ident ::= NAME */
   -1,  /* (33) string ::= LONGSTRING */
   -1,  /* (34) chunk ::= block */
   -1,  /* (35) semi ::= SEMICOLON */
   -2,  /* (36) block ::= scope statlist */
   -4,  /* (37) block ::= scope statlist laststat semi */
    0,  /* (38) scope ::= */
   -4,  /* (39) scope ::= scope statlist binding semi */
    0,  /* (40) statlist ::= */
   -3,  /* (41) statlist ::= statlist stat semi */
   -3,  /* (42) stat ::= FUNCTION funcname funcbody */
   -1,  /* (43) stat ::= functioncall */
   -2,  /* (44) stat ::= GOTO ident */
   -1,  /* (45) conds ::= condlist */
   -1,  /* (46) condlist ::= cond */
   -1,  /* (47) laststat ::= BREAK */
   -1,  /* (48) laststat ::= RETURN */
   -2,  /* (49) laststat ::= RETURN explist1 */
   -1,  /* (50) funcname ::= dottedname */
   -1,  /* (51) dottedname ::= ident */
   -3,  /* (52) dottedname ::= dottedname DOT ident */
   -1,  /* (53) namelist ::= ident */
   -3,  /* (54) namelist ::= namelist COMMA ident */
   -1,  /* (55) explist1 ::= exp */
   -3,  /* (56) explist1 ::= explist1 COMMA exp */
   -3,  /* (57) explist23 ::= exp COMMA exp */
   -5,  /* (58) explist23 ::= exp COMMA exp COMMA exp */
   -1,  /* (59) exp ::= TRUE */
   -1,  /* (60) exp ::= FALSE */
   -1,  /* (61) exp ::= NUMBER */
   -1,  /* (62) exp ::= string */
   -1,  /* (63) exp ::= ELLIPSIS */
   -1,  /* (64) exp ::= function */
   -1,  /* (65) exp ::= prefixexp */
   -1,  /* (66) exp ::= tableconstructor */
   -2,  /* (67) exp ::= LEN exp */
   -2,  /* (68) exp ::= MINUS exp */
   -3,  /* (69) exp ::= exp LT exp */
   -3,  /* (70) exp ::= exp LTEQ exp */
   -3,  /* (71) exp ::= exp BT exp */
   -3,  /* (72) exp ::= exp BTEQ exp */
   -3,  /* (73) exp ::= exp EQ exp */
   -3,  /* (74) exp ::= exp CONCAT exp */
   -3,  /* (75) exp ::= exp PLUS exp */
   -3,  /* (76) exp ::= exp MINUS exp */
   -3,  /* (77) exp ::= exp MUL exp */
   -3,  /* (78) exp ::= exp DIV exp */
   -3,  /* (79) exp ::= exp MOD exp */
   -2,  /* (80) exp ::= BITNOT exp */
   -3,  /* (81) exp ::= exp SHL exp */
   -3,  /* (82) exp ::= exp SHR exp */
   -3,  /* (83) exp ::= exp BITAND exp */
   -3,  /* (84) exp ::= exp BITOR exp */
   -1,  /* (85) setlist ::= var */
   -3,  /* (86) setlist ::= setlist COMMA var */
   -1,  /* (87) var ::= ident */
   -4,  /* (88) var ::= prefixexp LBRACKET exp RBRACKET */
   -3,  /* (89) var ::= prefixexp DOT ident */
   -1,  /* (90) prefixexp ::= var */
   -1,  /* (91) prefixexp ::= functioncall */
   -3,  /* (92) prefixexp ::= OPEN exp RPAREN */
   -2,  /* (93) functioncall ::= prefixexp args */
   -2,  /* (94) args ::= LPAREN RPAREN */
   -3,  /* (95) args ::= LPAREN explist1 RPAREN */
    0,  /* (96) parlist ::= */
   -1,  /* (97) parlist ::= ELLIPSIS */
   -1,  /* (98) parlist ::= namelist */
   -3,  /* (99) parlist ::= namelist COMMA ELLIPSIS */
   -2,  /* (100) tableconstructor ::= LBRACE RBRACE */
   -3,  /* (101) tableconstructor ::= LBRACE fieldlist RBRACE */
   -4,  /* (102) tableconstructor ::= LBRACE fieldlist fieldsep RBRACE */
   -1,  /* (103) fieldsep ::= COMMA */
   -1,  /* (104) fieldsep ::= SEMICOLON */
   -1,  /* (105) fieldlist ::= field */
   -3,  /* (106) fieldlist ::= fieldlist fieldsep field */
   -1,  /* (107) field ::= exp */
   -3,  /* (108) field ::= ident ASSIGN exp */
   -5,  /* (109) field ::= LBRACKET exp RBRACKET ASSIGN exp */
   -1,  /* (110) string ::= STRING */
};

static void yy_accept(yyParser*);  /* Forward Declaration */

/*
** Perform a reduce action and the shift that must immediately
** follow the reduce.
**
** The yyLookahead and yyLookaheadToken parameters provide reduce actions
** access to the lookahead token (if any).  The yyLookahead will be YYNOCODE
** if the lookahead token has already been consumed.  As this procedure is
** only called from one place, optimizing compilers will in-line it, which
** means that the extra parameters have no performance impact.
*/
static YYACTIONTYPE yy_reduce(
  yyParser *yypParser,         /* The parser */
  unsigned int yyruleno,       /* Number of the rule by which to reduce */
  int yyLookahead,             /* Lookahead token, or YYNOCODE if none */
  LuaParserTOKENTYPE yyLookaheadToken  /* Value of the lookahead token */
  LuaParserCTX_PDECL                   /* %extra_context */
){
  int yygoto;                     /* The next state */
  YYACTIONTYPE yyact;             /* The next action */
  yyStackEntry *yymsp;            /* The top of the parser's stack */
  int yysize;                     /* Amount to pop the stack */
  LuaParserARG_FETCH
  (void)yyLookahead;
  (void)yyLookaheadToken;
  yymsp = yypParser->yytos;

  switch( yyruleno ){
  /* Beginning here are the reduction cases.  A typical example
  ** follows:
  **   case 0:
  **  #line <lineno> <grammarfile>
  **     { ... }           // User supplied code
  **  #line <lineno> <thisfile>
  **     break;
  */
/********** Begin reduce actions **********************************************/
      case 0: /* semi ::= */
#line 288 "lua-parser.ly"
{ LuaParserToken *tk = getLastLuaParserState(pState);
                              if(!(tk->flags & noSemicolonNeeded))
                                newStrFmt(tk, "%.*s;", tk->token_value_size, tk->token_value); }
#line 1869 "lua-parser.c"
        break;
      case 1: /* ublock ::= block UNTIL exp */
#line 295 "lua-parser.ly"
{ setTokenValue(yymsp[-1].minor.yy0, "} while(!(");
                                                        LuaParserToken *tk = getLastLuaParserState(pState);
                                                        newStrFmt(tk, "%.*s) )", tk->token_value_size, tk->token_value); }
#line 1876 "lua-parser.c"
        break;
      case 2: /* stat ::= DO block END */
#line 308 "lua-parser.ly"
{ setTokenValue(yymsp[-2].minor.yy0, "{"); setTokenValue(yymsp[0].minor.yy0, "}"); setTokenFlag(yymsp[0].minor.yy0, noSemicolonNeeded, 1);}
#line 1881 "lua-parser.c"
        break;
      case 3: /* stat ::= WHILE exp DO block END */
#line 309 "lua-parser.ly"
{ setTokenValue(yymsp[-4].minor.yy0, "while("); setTokenValue(yymsp[-2].minor.yy0, ") {"); setTokenValue(yymsp[0].minor.yy0, "}"); setTokenFlag(yymsp[0].minor.yy0, noSemicolonNeeded, 1);}
#line 1886 "lua-parser.c"
        break;
      case 4: /* stat ::= repetition DO block END */
#line 310 "lua-parser.ly"
{ setTokenValue(yymsp[-2].minor.yy0, ") {"); setTokenValue(yymsp[0].minor.yy0, "}"); setTokenFlag(yymsp[0].minor.yy0, noSemicolonNeeded, 1);}
#line 1891 "lua-parser.c"
        break;
      case 5: /* stat ::= REPEAT ublock */
#line 311 "lua-parser.ly"
{ setTokenValue(yymsp[-1].minor.yy0, "do {"); }
#line 1896 "lua-parser.c"
        break;
      case 6: /* stat ::= IF conds END */
#line 312 "lua-parser.ly"
{ setTokenValue(yymsp[-2].minor.yy0, "if("); setTokenValue(yymsp[0].minor.yy0, "}"); setTokenFlag(yymsp[0].minor.yy0, noSemicolonNeeded, 1);}
#line 1901 "lua-parser.c"
        break;
      case 7: /* stat ::= setlist ASSIGN explist1 */
#line 314 "lua-parser.ly"
{checkSetAssignTokenOpToken(pState, yymsp[-2].minor.yy0, yymsp[-1].minor.yy0, yymsp[0].minor.yy0);}
#line 1906 "lua-parser.c"
        break;
      case 8: /* stat ::= LABEL */
#line 319 "lua-parser.ly"
{ newStrFmt(yymsp[0].minor.yy0, "%.*s", yymsp[0].minor.yy0->token_value_size-3, yymsp[0].minor.yy0->token_value+2);  setTokenFlag(yymsp[0].minor.yy0, noSemicolonNeeded, 1);}
#line 1911 "lua-parser.c"
        break;
      case 9: /* repetition ::= FOR ident ASSIGN explist23 */
      case 10: /* repetition ::= FOR namelist IN explist1 */ yytestcase(yyruleno==10);
#line 322 "lua-parser.ly"
{setTokenValue(yymsp[-3].minor.yy0, "for(");}
#line 1917 "lua-parser.c"
        break;
      case 11: /* conds ::= condlist ELSE block */
#line 326 "lua-parser.ly"
{ setTokenValue(yymsp[-1].minor.yy0, "} else {");}
#line 1922 "lua-parser.c"
        break;
      case 12: /* condlist ::= condlist ELSEIF cond */
#line 329 "lua-parser.ly"
{ setTokenValue(yymsp[-1].minor.yy0, "} else if(");}
#line 1927 "lua-parser.c"
        break;
      case 13: /* cond ::= exp THEN block */
#line 331 "lua-parser.ly"
{ setTokenValue(yymsp[-1].minor.yy0, ") {");}
#line 1932 "lua-parser.c"
        break;
      case 14: /* binding ::= LOCAL namelist */
#line 337 "lua-parser.ly"
{ local2var(yymsp[-1].minor.yy0);}
#line 1937 "lua-parser.c"
        break;
      case 15: /* binding ::= LOCAL namelist ASSIGN explist1 */
#line 338 "lua-parser.ly"
{ local2var(yymsp[-3].minor.yy0); /*setTokenValue(yymsp[-1].minor.yy0, ":=:");*/}
#line 1942 "lua-parser.c"
        break;
      case 16: /* binding ::= LOCAL FUNCTION ident funcbody */
#line 339 "lua-parser.ly"
{ local2var(yymsp[-3].minor.yy0);}
#line 1947 "lua-parser.c"
        break;
      case 17: /* funcname ::= dottedname COLON ident */
#line 343 "lua-parser.ly"
{ setTokenValue(yymsp[-1].minor.yy0, "::");}
#line 1952 "lua-parser.c"
        break;
      case 18: /* exp ::= NIL */
#line 367 "lua-parser.ly"
{ setTokenValue(yymsp[0].minor.yy0, "null");}
#line 1957 "lua-parser.c"
        break;
      case 19: /* exp ::= NOT exp */
#line 377 "lua-parser.ly"
{ setTokenValue(yymsp[-1].minor.yy0, "!");}
#line 1962 "lua-parser.c"
        break;
      case 20: /* exp ::= exp OR exp */
#line 381 "lua-parser.ly"
{ setTokenValue(yymsp[-1].minor.yy0, "||");}
#line 1967 "lua-parser.c"
        break;
      case 21: /* exp ::= exp AND exp */
#line 382 "lua-parser.ly"
{ setTokenValue(yymsp[-1].minor.yy0, "&&");}
#line 1972 "lua-parser.c"
        break;
      case 22: /* exp ::= exp NEQ exp */
#line 388 "lua-parser.ly"
{ setTokenValue(yymsp[-1].minor.yy0, "!=");}
#line 1977 "lua-parser.c"
        break;
      case 23: /* exp ::= exp POW exp */
#line 395 "lua-parser.ly"
{ setTokenValue(yymsp[-1].minor.yy0, "**");}
#line 1982 "lua-parser.c"
        break;
      case 24: /* exp ::= exp IDIV exp */
#line 402 "lua-parser.ly"
{ setTokenValue(yymsp[-1].minor.yy0, "idiv");}
#line 1987 "lua-parser.c"
        break;
      case 25: /* exp ::= exp BITNOT exp */
#line 407 "lua-parser.ly"
{ setTokenValue(yymsp[-1].minor.yy0, "^");}
#line 1992 "lua-parser.c"
        break;
      case 26: /* functioncall ::= prefixexp COLON ident args */
#line 422 "lua-parser.ly"
{ setTokenValue(yymsp[-2].minor.yy0, "->");}
#line 1997 "lua-parser.c"
        break;
      case 27: /* args ::= tableconstructor */
#line 426 "lua-parser.ly"
{ newStrFmt(yymsp[0].minor.yy0, "(%.*s", yymsp[0].minor.yy0->token_value_size, yymsp[0].minor.yy0->token_value);
                                                        setTokenValue(getLastLuaParserState(pState), "})"); }
#line 2003 "lua-parser.c"
        break;
      case 28: /* args ::= string */
#line 428 "lua-parser.ly"
{ newStrFmt(yymsp[0].minor.yy0, "(%.*s)", yymsp[0].minor.yy0->token_value_size, yymsp[0].minor.yy0->token_value);}
#line 2008 "lua-parser.c"
        break;
      case 29: /* function ::= FUNCTION funcbody */
#line 430 "lua-parser.ly"
{LuaParserToken *tk = getLastLuaParserState(pState);
                                                          /* here we invert the setting done on funcbody */ setTokenFlag(tk, noSemicolonNeeded, 0);}
#line 2014 "lua-parser.c"
        break;
      case 30: /* funcbody ::= params block END */
#line 433 "lua-parser.ly"
{ setTokenValue(yymsp[0].minor.yy0, "}");  setTokenFlag(yymsp[0].minor.yy0, noSemicolonNeeded, 1);}
#line 2019 "lua-parser.c"
        break;
      case 31: /* params ::= LPAREN parlist RPAREN */
#line 435 "lua-parser.ly"
{ setTokenValue(yymsp[0].minor.yy0, ") {");}
#line 2024 "lua-parser.c"
        break;
      case 32: /* ident ::= NAME */
#line 456 "lua-parser.ly"
{
                                      #define SELF_NAME "self"
                                      if(yymsp[0].minor.yy0->token_value_size == (sizeof(SELF_NAME)-1)
                                            && strncmp(yymsp[0].minor.yy0->token_value, SELF_NAME, yymsp[0].minor.yy0->token_value_size) == 0) setTokenValue(yymsp[0].minor.yy0, "this");
                                      #undef SELF_NAME
                                      #define VAR_NAME "var"
                                      else if(yymsp[0].minor.yy0->token_value_size == (sizeof(VAR_NAME)-1)
                                            && strncmp(yymsp[0].minor.yy0->token_value, VAR_NAME, yymsp[0].minor.yy0->token_value_size) == 0) setTokenValue(yymsp[0].minor.yy0, "_v_var");
                                      #undef VAR_NAME
                                    }
#line 2038 "lua-parser.c"
        break;
      case 33: /* string ::= LONGSTRING */
#line 468 "lua-parser.ly"
{fixLongStringQuote(yymsp[0].minor.yy0);}
#line 2043 "lua-parser.c"
        break;
      default:
      /* (34) chunk ::= block */ yytestcase(yyruleno==34);
      /* (35) semi ::= SEMICOLON */ yytestcase(yyruleno==35);
      /* (36) block ::= scope statlist */ yytestcase(yyruleno==36);
      /* (37) block ::= scope statlist laststat semi */ yytestcase(yyruleno==37);
      /* (38) scope ::= */ yytestcase(yyruleno==38);
      /* (39) scope ::= scope statlist binding semi */ yytestcase(yyruleno==39);
      /* (40) statlist ::= */ yytestcase(yyruleno==40);
      /* (41) statlist ::= statlist stat semi */ yytestcase(yyruleno==41);
      /* (42) stat ::= FUNCTION funcname funcbody */ yytestcase(yyruleno==42);
      /* (43) stat ::= functioncall */ yytestcase(yyruleno==43);
      /* (44) stat ::= GOTO ident */ yytestcase(yyruleno==44);
      /* (45) conds ::= condlist */ yytestcase(yyruleno==45);
      /* (46) condlist ::= cond (OPTIMIZED OUT) */ assert(yyruleno!=46);
      /* (47) laststat ::= BREAK */ yytestcase(yyruleno==47);
      /* (48) laststat ::= RETURN */ yytestcase(yyruleno==48);
      /* (49) laststat ::= RETURN explist1 */ yytestcase(yyruleno==49);
      /* (50) funcname ::= dottedname */ yytestcase(yyruleno==50);
      /* (51) dottedname ::= ident (OPTIMIZED OUT) */ assert(yyruleno!=51);
      /* (52) dottedname ::= dottedname DOT ident */ yytestcase(yyruleno==52);
      /* (53) namelist ::= ident */ yytestcase(yyruleno==53);
      /* (54) namelist ::= namelist COMMA ident */ yytestcase(yyruleno==54);
      /* (55) explist1 ::= exp */ yytestcase(yyruleno==55);
      /* (56) explist1 ::= explist1 COMMA exp */ yytestcase(yyruleno==56);
      /* (57) explist23 ::= exp COMMA exp */ yytestcase(yyruleno==57);
      /* (58) explist23 ::= exp COMMA exp COMMA exp */ yytestcase(yyruleno==58);
      /* (59) exp ::= TRUE */ yytestcase(yyruleno==59);
      /* (60) exp ::= FALSE */ yytestcase(yyruleno==60);
      /* (61) exp ::= NUMBER */ yytestcase(yyruleno==61);
      /* (62) exp ::= string (OPTIMIZED OUT) */ assert(yyruleno!=62);
      /* (63) exp ::= ELLIPSIS */ yytestcase(yyruleno==63);
      /* (64) exp ::= function (OPTIMIZED OUT) */ assert(yyruleno!=64);
      /* (65) exp ::= prefixexp */ yytestcase(yyruleno==65);
      /* (66) exp ::= tableconstructor (OPTIMIZED OUT) */ assert(yyruleno!=66);
      /* (67) exp ::= LEN exp */ yytestcase(yyruleno==67);
      /* (68) exp ::= MINUS exp */ yytestcase(yyruleno==68);
      /* (69) exp ::= exp LT exp */ yytestcase(yyruleno==69);
      /* (70) exp ::= exp LTEQ exp */ yytestcase(yyruleno==70);
      /* (71) exp ::= exp BT exp */ yytestcase(yyruleno==71);
      /* (72) exp ::= exp BTEQ exp */ yytestcase(yyruleno==72);
      /* (73) exp ::= exp EQ exp */ yytestcase(yyruleno==73);
      /* (74) exp ::= exp CONCAT exp */ yytestcase(yyruleno==74);
      /* (75) exp ::= exp PLUS exp */ yytestcase(yyruleno==75);
      /* (76) exp ::= exp MINUS exp */ yytestcase(yyruleno==76);
      /* (77) exp ::= exp MUL exp */ yytestcase(yyruleno==77);
      /* (78) exp ::= exp DIV exp */ yytestcase(yyruleno==78);
      /* (79) exp ::= exp MOD exp */ yytestcase(yyruleno==79);
      /* (80) exp ::= BITNOT exp */ yytestcase(yyruleno==80);
      /* (81) exp ::= exp SHL exp */ yytestcase(yyruleno==81);
      /* (82) exp ::= exp SHR exp */ yytestcase(yyruleno==82);
      /* (83) exp ::= exp BITAND exp */ yytestcase(yyruleno==83);
      /* (84) exp ::= exp BITOR exp */ yytestcase(yyruleno==84);
      /* (85) setlist ::= var */ yytestcase(yyruleno==85);
      /* (86) setlist ::= setlist COMMA var */ yytestcase(yyruleno==86);
      /* (87) var ::= ident */ yytestcase(yyruleno==87);
      /* (88) var ::= prefixexp LBRACKET exp RBRACKET */ yytestcase(yyruleno==88);
      /* (89) var ::= prefixexp DOT ident */ yytestcase(yyruleno==89);
      /* (90) prefixexp ::= var */ yytestcase(yyruleno==90);
      /* (91) prefixexp ::= functioncall */ yytestcase(yyruleno==91);
      /* (92) prefixexp ::= OPEN exp RPAREN */ yytestcase(yyruleno==92);
      /* (93) functioncall ::= prefixexp args */ yytestcase(yyruleno==93);
      /* (94) args ::= LPAREN RPAREN */ yytestcase(yyruleno==94);
      /* (95) args ::= LPAREN explist1 RPAREN */ yytestcase(yyruleno==95);
      /* (96) parlist ::= */ yytestcase(yyruleno==96);
      /* (97) parlist ::= ELLIPSIS */ yytestcase(yyruleno==97);
      /* (98) parlist ::= namelist */ yytestcase(yyruleno==98);
      /* (99) parlist ::= namelist COMMA ELLIPSIS */ yytestcase(yyruleno==99);
      /* (100) tableconstructor ::= LBRACE RBRACE */ yytestcase(yyruleno==100);
      /* (101) tableconstructor ::= LBRACE fieldlist RBRACE */ yytestcase(yyruleno==101);
      /* (102) tableconstructor ::= LBRACE fieldlist fieldsep RBRACE */ yytestcase(yyruleno==102);
      /* (103) fieldsep ::= COMMA */ yytestcase(yyruleno==103);
      /* (104) fieldsep ::= SEMICOLON */ yytestcase(yyruleno==104);
      /* (105) fieldlist ::= field (OPTIMIZED OUT) */ assert(yyruleno!=105);
      /* (106) fieldlist ::= fieldlist fieldsep field */ yytestcase(yyruleno==106);
      /* (107) field ::= exp */ yytestcase(yyruleno==107);
      /* (108) field ::= ident ASSIGN exp */ yytestcase(yyruleno==108);
      /* (109) field ::= LBRACKET exp RBRACKET ASSIGN exp */ yytestcase(yyruleno==109);
      /* (110) string ::= STRING */ yytestcase(yyruleno==110);
        break;
/********** End reduce actions ************************************************/
  };
  assert( yyruleno<sizeof(yyRuleInfoLhs)/sizeof(yyRuleInfoLhs[0]) );
  yygoto = yyRuleInfoLhs[yyruleno];
  yysize = yyRuleInfoNRhs[yyruleno];
  yyact = yy_find_reduce_action(yymsp[yysize].stateno,(YYCODETYPE)yygoto);

  /* There are no SHIFTREDUCE actions on nonterminals because the table
  ** generator has simplified them to pure REDUCE actions. */
  assert( !(yyact>YY_MAX_SHIFT && yyact<=YY_MAX_SHIFTREDUCE) );

  /* It is not possible for a REDUCE to be followed by an error */
  assert( yyact!=YY_ERROR_ACTION );

  yymsp += yysize+1;
  yypParser->yytos = yymsp;
  yymsp->stateno = (YYACTIONTYPE)yyact;
  yymsp->major = (YYCODETYPE)yygoto;
  yyTraceShift(yypParser, yyact, "... then shift");
  return yyact;
}

/*
** The following code executes when the parse fails
*/
#ifndef YYNOERRORRECOVERY
static void yy_parse_failed(
  yyParser *yypParser           /* The parser */
){
  LuaParserARG_FETCH
  LuaParserCTX_FETCH
#ifndef NDEBUG
  if( yyTraceFILE ){
    fprintf(yyTraceFILE,"%sFail!\n",yyTracePrompt);
  }
#endif
  while( yypParser->yytos>yypParser->yystack ) yy_pop_parser_stack(yypParser);
  /* Here code is inserted which will be executed whenever the
  ** parser fails */
/************ Begin %parse_failure code ***************************************/
/************ End %parse_failure code *****************************************/
  LuaParserARG_STORE /* Suppress warning about unused %extra_argument variable */
  LuaParserCTX_STORE
}
#endif /* YYNOERRORRECOVERY */

/*
** The following code executes when a syntax error first occurs.
*/
static void yy_syntax_error(
  yyParser *yypParser,           /* The parser */
  int yymajor,                   /* The major type of the error token */
  LuaParserTOKENTYPE yyminor         /* The minor type of the error token */
){
  LuaParserARG_FETCH
  LuaParserCTX_FETCH
#define TOKEN yyminor
/************ Begin %syntax_error code ****************************************/
/************ End %syntax_error code ******************************************/
  LuaParserARG_STORE /* Suppress warning about unused %extra_argument variable */
  LuaParserCTX_STORE
}

/*
** The following is executed when the parser accepts
*/
static void yy_accept(
  yyParser *yypParser           /* The parser */
){
  LuaParserARG_FETCH
  LuaParserCTX_FETCH
#ifndef NDEBUG
  if( yyTraceFILE ){
    fprintf(yyTraceFILE,"%sAccept!\n",yyTracePrompt);
  }
#endif
#ifndef YYNOERRORRECOVERY
  yypParser->yyerrcnt = -1;
#endif
  assert( yypParser->yytos==yypParser->yystack );
  /* Here code is inserted which will be executed whenever the
  ** parser accepts */
/*********** Begin %parse_accept code *****************************************/
/*********** End %parse_accept code *******************************************/
  LuaParserARG_STORE /* Suppress warning about unused %extra_argument variable */
  LuaParserCTX_STORE
}

/* The main parser program.
** The first argument is a pointer to a structure obtained from
** "LuaParserAlloc" which describes the current state of the parser.
** The second argument is the major token number.  The third is
** the minor token.  The fourth optional argument is whatever the
** user wants (and specified in the grammar) and is available for
** use by the action routines.
**
** Inputs:
** <ul>
** <li> A pointer to the parser (an opaque structure.)
** <li> The major token number.
** <li> The minor token number.
** <li> An option argument of a grammar-specified type.
** </ul>
**
** Outputs:
** None.
*/
void LuaParser(
  void *yyp,                   /* The parser */
  int yymajor,                 /* The major token code number */
  LuaParserTOKENTYPE yyminor       /* The value for the token */
  LuaParserARG_PDECL               /* Optional %extra_argument parameter */
){
  YYMINORTYPE yyminorunion;
  YYACTIONTYPE yyact;   /* The parser action. */
#if !defined(YYERRORSYMBOL) && !defined(YYNOERRORRECOVERY)
  int yyendofinput;     /* True if we are at the end of input */
#endif
#ifdef YYERRORSYMBOL
  int yyerrorhit = 0;   /* True if yymajor has invoked an error */
#endif
  yyParser *yypParser = (yyParser*)yyp;  /* The parser */
  LuaParserCTX_FETCH
  LuaParserARG_STORE

  assert( yypParser->yytos!=0 );
#if !defined(YYERRORSYMBOL) && !defined(YYNOERRORRECOVERY)
  yyendofinput = (yymajor==0);
#endif

  yyact = yypParser->yytos->stateno;
#ifndef NDEBUG
  if( yyTraceFILE ){
    if( yyact < YY_MIN_REDUCE ){
      fprintf(yyTraceFILE,"%sInput '%s' in state %d\n",
              yyTracePrompt,yyTokenName[yymajor],yyact);
    }else{
      fprintf(yyTraceFILE,"%sInput '%s' with pending reduce %d\n",
              yyTracePrompt,yyTokenName[yymajor],yyact-YY_MIN_REDUCE);
    }
  }
#endif

  while(1){ /* Exit by "break" */
    assert( yypParser->yytos>=yypParser->yystack );
    assert( yyact==yypParser->yytos->stateno );
    yyact = yy_find_shift_action((YYCODETYPE)yymajor,yyact);
    if( yyact >= YY_MIN_REDUCE ){
      unsigned int yyruleno = yyact - YY_MIN_REDUCE; /* Reduce by this rule */
      assert( yyruleno<(int)(sizeof(yyRuleName)/sizeof(yyRuleName[0])) );
#ifndef NDEBUG
      if( yyTraceFILE ){
        int yysize = yyRuleInfoNRhs[yyruleno];
        if( yysize ){
          fprintf(yyTraceFILE, "%sReduce %d [%s]%s, pop back to state %d.\n",
            yyTracePrompt,
            yyruleno, yyRuleName[yyruleno],
            yyruleno<YYNRULE_WITH_ACTION ? "" : " without external action",
            yypParser->yytos[yysize].stateno);
        }else{
          fprintf(yyTraceFILE, "%sReduce %d [%s]%s.\n",
            yyTracePrompt, yyruleno, yyRuleName[yyruleno],
            yyruleno<YYNRULE_WITH_ACTION ? "" : " without external action");
        }
      }
#endif /* NDEBUG */

      /* Check that the stack is large enough to grow by a single entry
      ** if the RHS of the rule is empty.  This ensures that there is room
      ** enough on the stack to push the LHS value */
      if( yyRuleInfoNRhs[yyruleno]==0 ){
#ifdef YYTRACKMAXSTACKDEPTH
        if( (int)(yypParser->yytos - yypParser->yystack)>yypParser->yyhwm ){
          yypParser->yyhwm++;
          assert( yypParser->yyhwm ==
                  (int)(yypParser->yytos - yypParser->yystack));
        }
#endif
#if YYSTACKDEPTH>0
        if( yypParser->yytos>=yypParser->yystackEnd ){
          yyStackOverflow(yypParser);
          break;
        }
#else
        if( yypParser->yytos>=&yypParser->yystack[yypParser->yystksz-1] ){
          if( yyGrowStack(yypParser) ){
            yyStackOverflow(yypParser);
            break;
          }
        }
#endif
      }
      yyact = yy_reduce(yypParser,yyruleno,yymajor,yyminor LuaParserCTX_PARAM);
    }else if( yyact <= YY_MAX_SHIFTREDUCE ){
      yy_shift(yypParser,yyact,(YYCODETYPE)yymajor,yyminor);
#ifndef YYNOERRORRECOVERY
      yypParser->yyerrcnt--;
#endif
      break;
    }else if( yyact==YY_ACCEPT_ACTION ){
      yypParser->yytos--;
      yy_accept(yypParser);
      return;
    }else{
      assert( yyact == YY_ERROR_ACTION );
      yyminorunion.yy0 = yyminor;
#ifdef YYERRORSYMBOL
      int yymx;
#endif
#ifndef NDEBUG
      if( yyTraceFILE ){
        fprintf(yyTraceFILE,"%sSyntax Error!\n",yyTracePrompt);
      }
#endif
#ifdef YYERRORSYMBOL
      /* A syntax error has occurred.
      ** The response to an error depends upon whether or not the
      ** grammar defines an error token "ERROR".
      **
      ** This is what we do if the grammar does define ERROR:
      **
      **  * Call the %syntax_error function.
      **
      **  * Begin popping the stack until we enter a state where
      **    it is legal to shift the error symbol, then shift
      **    the error symbol.
      **
      **  * Set the error count to three.
      **
      **  * Begin accepting and shifting new tokens.  No new error
      **    processing will occur until three tokens have been
      **    shifted successfully.
      **
      */
      if( yypParser->yyerrcnt<0 ){
        yy_syntax_error(yypParser,yymajor,yyminor);
      }
      yymx = yypParser->yytos->major;
      if( yymx==YYERRORSYMBOL || yyerrorhit ){
#ifndef NDEBUG
        if( yyTraceFILE ){
          fprintf(yyTraceFILE,"%sDiscard input token %s\n",
             yyTracePrompt,yyTokenName[yymajor]);
        }
#endif
        yy_destructor(yypParser, (YYCODETYPE)yymajor, &yyminorunion);
        yymajor = YYNOCODE;
      }else{
        while( yypParser->yytos >= yypParser->yystack
            && (yyact = yy_find_reduce_action(
                        yypParser->yytos->stateno,
                        YYERRORSYMBOL)) > YY_MAX_SHIFTREDUCE
        ){
          yy_pop_parser_stack(yypParser);
        }
        if( yypParser->yytos < yypParser->yystack || yymajor==0 ){
          yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);
          yy_parse_failed(yypParser);
#ifndef YYNOERRORRECOVERY
          yypParser->yyerrcnt = -1;
#endif
          yymajor = YYNOCODE;
        }else if( yymx!=YYERRORSYMBOL ){
          yy_shift(yypParser,yyact,YYERRORSYMBOL,yyminor);
        }
      }
      yypParser->yyerrcnt = 3;
      yyerrorhit = 1;
      if( yymajor==YYNOCODE ) break;
      yyact = yypParser->yytos->stateno;
#elif defined(YYNOERRORRECOVERY)
      /* If the YYNOERRORRECOVERY macro is defined, then do not attempt to
      ** do any kind of error recovery.  Instead, simply invoke the syntax
      ** error routine and continue going as if nothing had happened.
      **
      ** Applications can set this macro (for example inside %include) if
      ** they intend to abandon the parse upon the first syntax error seen.
      */
      yy_syntax_error(yypParser,yymajor, yyminor);
      yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);
      break;
#else  /* YYERRORSYMBOL is not defined */
      /* This is what we do if the grammar does not define ERROR:
      **
      **  * Report an error message, and throw away the input token.
      **
      **  * If the input token is $, then fail the parse.
      **
      ** As before, subsequent error messages are suppressed until
      ** three input tokens have been successfully shifted.
      */
      if( yypParser->yyerrcnt<=0 ){
        yy_syntax_error(yypParser,yymajor, yyminor);
      }
      yypParser->yyerrcnt = 3;
      yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);
      if( yyendofinput ){
        yy_parse_failed(yypParser);
#ifndef YYNOERRORRECOVERY
        yypParser->yyerrcnt = -1;
#endif
      }
      break;
#endif
    }
  }
#ifndef NDEBUG
  if( yyTraceFILE ){
    yyStackEntry *i;
    char cDiv = '[';
    fprintf(yyTraceFILE,"%sReturn. Stack=",yyTracePrompt);
    for(i=&yypParser->yystack[1]; i<=yypParser->yytos; i++){
      fprintf(yyTraceFILE,"%c%s", cDiv, yyTokenName[i->major]);
      cDiv = ' ';
    }
    fprintf(yyTraceFILE,"]\n");
  }
#endif
  return;
}

/*
** Return the fallback token corresponding to canonical token iToken, or
** 0 if iToken has no fallback.
*/
int LuaParserFallback(int iToken){
#ifdef YYFALLBACK
  assert( iToken<(int)(sizeof(yyFallback)/sizeof(yyFallback[0])) );
  return yyFallback[iToken];
#else
  (void)iToken;
  return 0;
#endif
}
/* Generated by re2c 1.3 on Sun Jan  3 19:13:58 2021 */
#line 1 "lua-parser.re2c"
typedef struct LuaScanner {
  char *top, *last_top, *cur, *ptr, *pos, *limit;
  int line;
#ifndef NDEBUG
  char parsePrompt[32];
#endif
} LuaScanner;

#define   YYCTYPE     unsigned char
#define   YYCURSOR    s->cur
#define   YYMARKER    s->ptr
#define   YYLIMIT    s->limit

static void processNewLine(LuaScanner* s)
{
  //printf("%d:%.25s\n", s->line, s->top);
  s->pos = s->cur;
  s->line++;
#ifndef NDEBUG
  snprintf(s->parsePrompt, sizeof(s->parsePrompt), "parser %d >>", s->line);
#endif
}

static int scan(LuaScanner* s, char *buff_end) {

  int nest_count = 0, quote_size = 0, long_start_line;
  char *long_top;

regular:
  if (s->cur >= buff_end) {
    return TK_THEEND;
  }
  s->top = s->cur;

#line 65 "lua-parser.re2c"



#line 42 "lua-parser.re2c.c"
{
	YYCTYPE yych;
	unsigned int yyaccept = 0;
	yych = *YYCURSOR;
	switch (yych) {
	case 0x00:	goto yy2;
	case '\t':
	case '\v':
	case '\f':
	case '\r':
	case ' ':	goto yy6;
	case '\n':	goto yy8;
	case '"':	goto yy10;
	case '#':	goto yy11;
	case '%':	goto yy13;
	case '&':	goto yy15;
	case '\'':	goto yy17;
	case '(':	goto yy18;
	case ')':	goto yy20;
	case '*':	goto yy22;
	case '+':	goto yy24;
	case ',':	goto yy26;
	case '-':	goto yy28;
	case '.':	goto yy30;
	case '/':	goto yy32;
	case '0':	goto yy34;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy36;
	case ':':	goto yy38;
	case ';':	goto yy40;
	case '<':	goto yy42;
	case '=':	goto yy44;
	case '>':	goto yy46;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'c':
	case 'h':
	case 'j':
	case 'k':
	case 'm':
	case 'p':
	case 'q':
	case 's':
	case 'v':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	case '[':	goto yy51;
	case ']':	goto yy53;
	case '^':	goto yy55;
	case 'a':	goto yy57;
	case 'b':	goto yy58;
	case 'd':	goto yy59;
	case 'e':	goto yy60;
	case 'f':	goto yy61;
	case 'g':	goto yy62;
	case 'i':	goto yy63;
	case 'l':	goto yy64;
	case 'n':	goto yy65;
	case 'o':	goto yy66;
	case 'r':	goto yy67;
	case 't':	goto yy68;
	case 'u':	goto yy69;
	case 'w':	goto yy70;
	case '{':	goto yy71;
	case '|':	goto yy73;
	case '}':	goto yy75;
	case '~':	goto yy77;
	default:	goto yy4;
	}
yy2:
	++YYCURSOR;
#line 167 "lua-parser.re2c"
	{ goto regular; }
#line 149 "lua-parser.re2c.c"
yy4:
	++YYCURSOR;
yy5:
#line 161 "lua-parser.re2c"
	{ fprintf(stderr, "unexpected character: '%c' at line %d:%d\n",
                        *s->cur, s->line, (int)(s->cur - s->pos));
                        exit(1);
                    }
#line 158 "lua-parser.re2c.c"
yy6:
	++YYCURSOR;
#line 71 "lua-parser.re2c"
	{ goto regular; }
#line 163 "lua-parser.re2c.c"
yy8:
	++YYCURSOR;
#line 70 "lua-parser.re2c"
	{ processNewLine(s); goto regular; }
#line 168 "lua-parser.re2c.c"
yy10:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 0x00) goto yy5;
	goto yy80;
yy11:
	yych = *++YYCURSOR;
	switch (yych) {
	case '!':	goto yy85;
	default:	goto yy12;
	}
yy12:
#line 109 "lua-parser.re2c"
	{ return TK_LEN; }
#line 183 "lua-parser.re2c.c"
yy13:
	++YYCURSOR;
#line 107 "lua-parser.re2c"
	{ return TK_MOD; }
#line 188 "lua-parser.re2c.c"
yy15:
	++YYCURSOR;
#line 128 "lua-parser.re2c"
	{ return TK_BITAND; }
#line 193 "lua-parser.re2c.c"
yy17:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 0x00) goto yy5;
	goto yy89;
yy18:
	++YYCURSOR;
#line 137 "lua-parser.re2c"
	{ return TK_LPAREN; }
#line 203 "lua-parser.re2c.c"
yy20:
	++YYCURSOR;
#line 138 "lua-parser.re2c"
	{ return TK_RPAREN; }
#line 208 "lua-parser.re2c.c"
yy22:
	++YYCURSOR;
#line 106 "lua-parser.re2c"
	{ return TK_MUL; }
#line 213 "lua-parser.re2c.c"
yy24:
	++YYCURSOR;
#line 103 "lua-parser.re2c"
	{ return TK_PLUS; }
#line 218 "lua-parser.re2c.c"
yy26:
	++YYCURSOR;
#line 114 "lua-parser.re2c"
	{ return TK_COMMA; }
#line 223 "lua-parser.re2c.c"
yy28:
	yych = *++YYCURSOR;
	switch (yych) {
	case '-':	goto yy93;
	default:	goto yy29;
	}
yy29:
#line 104 "lua-parser.re2c"
	{ return TK_MINUS; }
#line 233 "lua-parser.re2c.c"
yy30:
	yych = *++YYCURSOR;
	switch (yych) {
	case '.':	goto yy95;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy97;
	default:	goto yy31;
	}
yy31:
#line 136 "lua-parser.re2c"
	{ return TK_DOT; }
#line 253 "lua-parser.re2c.c"
yy32:
	yych = *++YYCURSOR;
	switch (yych) {
	case '/':	goto yy99;
	default:	goto yy33;
	}
yy33:
#line 105 "lua-parser.re2c"
	{ return TK_DIV; }
#line 263 "lua-parser.re2c.c"
yy34:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'X':
	case 'x':	goto yy105;
	default:	goto yy37;
	}
yy35:
#line 149 "lua-parser.re2c"
	{ return TK_NUMBER; }
#line 275 "lua-parser.re2c.c"
yy36:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
yy37:
	switch (yych) {
	case '.':	goto yy101;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy36;
	case 'E':
	case 'e':	goto yy102;
	case 'L':	goto yy103;
	case 'U':	goto yy104;
	case 'l':	goto yy106;
	case 'u':	goto yy107;
	default:	goto yy35;
	}
yy38:
	yyaccept = 2;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case ':':	goto yy108;
	default:	goto yy39;
	}
yy39:
#line 135 "lua-parser.re2c"
	{ return TK_COLON; }
#line 310 "lua-parser.re2c.c"
yy40:
	++YYCURSOR;
#line 134 "lua-parser.re2c"
	{ return TK_SEMICOLON; }
#line 315 "lua-parser.re2c.c"
yy42:
	yych = *++YYCURSOR;
	switch (yych) {
	case '<':	goto yy109;
	case '=':	goto yy111;
	default:	goto yy43;
	}
yy43:
#line 112 "lua-parser.re2c"
	{ return TK_LT; }
#line 326 "lua-parser.re2c.c"
yy44:
	yych = *++YYCURSOR;
	switch (yych) {
	case '=':	goto yy113;
	default:	goto yy45;
	}
yy45:
#line 102 "lua-parser.re2c"
	{ return TK_ASSIGN; }
#line 336 "lua-parser.re2c.c"
yy46:
	yych = *++YYCURSOR;
	switch (yych) {
	case '=':	goto yy115;
	case '>':	goto yy117;
	default:	goto yy47;
	}
yy47:
#line 113 "lua-parser.re2c"
	{ return TK_BT; }
#line 347 "lua-parser.re2c.c"
yy48:
	yych = *++YYCURSOR;
yy49:
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy50;
	}
yy50:
#line 146 "lua-parser.re2c"
	{ return TK_NAME; }
#line 420 "lua-parser.re2c.c"
yy51:
	yyaccept = 3;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case '=':	goto yy119;
	case '[':	goto yy121;
	default:	goto yy52;
	}
yy52:
#line 141 "lua-parser.re2c"
	{ return TK_LBRACKET; }
#line 432 "lua-parser.re2c.c"
yy53:
	++YYCURSOR;
#line 142 "lua-parser.re2c"
	{ return TK_RBRACKET; }
#line 437 "lua-parser.re2c.c"
yy55:
	++YYCURSOR;
#line 108 "lua-parser.re2c"
	{ return TK_POW; }
#line 442 "lua-parser.re2c.c"
yy57:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'n':	goto yy123;
	default:	goto yy49;
	}
yy58:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'r':	goto yy124;
	default:	goto yy49;
	}
yy59:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'o':	goto yy125;
	default:	goto yy49;
	}
yy60:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'l':	goto yy127;
	case 'n':	goto yy128;
	default:	goto yy49;
	}
yy61:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'a':	goto yy129;
	case 'o':	goto yy130;
	case 'u':	goto yy131;
	default:	goto yy49;
	}
yy62:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'o':	goto yy132;
	default:	goto yy49;
	}
yy63:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'f':	goto yy133;
	case 'n':	goto yy135;
	default:	goto yy49;
	}
yy64:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'o':	goto yy137;
	default:	goto yy49;
	}
yy65:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'i':	goto yy138;
	case 'o':	goto yy139;
	default:	goto yy49;
	}
yy66:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'r':	goto yy140;
	default:	goto yy49;
	}
yy67:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'e':	goto yy142;
	default:	goto yy49;
	}
yy68:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'h':	goto yy143;
	case 'r':	goto yy144;
	default:	goto yy49;
	}
yy69:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'n':	goto yy145;
	default:	goto yy49;
	}
yy70:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'h':	goto yy146;
	default:	goto yy49;
	}
yy71:
	++YYCURSOR;
#line 139 "lua-parser.re2c"
	{ return TK_LBRACE; }
#line 537 "lua-parser.re2c.c"
yy73:
	++YYCURSOR;
#line 127 "lua-parser.re2c"
	{ return TK_BITOR; }
#line 542 "lua-parser.re2c.c"
yy75:
	++YYCURSOR;
#line 140 "lua-parser.re2c"
	{ return TK_RBRACE; }
#line 547 "lua-parser.re2c.c"
yy77:
	yych = *++YYCURSOR;
	switch (yych) {
	case '=':	goto yy147;
	default:	goto yy78;
	}
yy78:
#line 126 "lua-parser.re2c"
	{ return TK_BITNOT; }
#line 557 "lua-parser.re2c.c"
yy79:
	yych = *++YYCURSOR;
yy80:
	switch (yych) {
	case 0x00:	goto yy81;
	case '"':	goto yy82;
	case '\\':	goto yy84;
	default:	goto yy79;
	}
yy81:
	YYCURSOR = YYMARKER;
	switch (yyaccept) {
	case 0: 	goto yy5;
	case 1: 	goto yy35;
	case 2: 	goto yy39;
	case 3: 	goto yy52;
	case 4: 	goto yy94;
	default:	goto yy162;
	}
yy82:
	++YYCURSOR;
#line 154 "lua-parser.re2c"
	{ return TK_STRING; }
#line 581 "lua-parser.re2c.c"
yy84:
	yych = *++YYCURSOR;
	if (yych <= 0x00) goto yy81;
	goto yy79;
yy85:
	yych = *++YYCURSOR;
	switch (yych) {
	case 0x00:
	case '\n':	goto yy87;
	default:	goto yy85;
	}
yy87:
#line 157 "lua-parser.re2c"
	{ goto regular; }
#line 596 "lua-parser.re2c.c"
yy88:
	yych = *++YYCURSOR;
yy89:
	switch (yych) {
	case 0x00:	goto yy81;
	case '\'':	goto yy90;
	case '\\':	goto yy92;
	default:	goto yy88;
	}
yy90:
	++YYCURSOR;
#line 153 "lua-parser.re2c"
	{ return TK_STRING; }
#line 610 "lua-parser.re2c.c"
yy92:
	yych = *++YYCURSOR;
	if (yych <= 0x00) goto yy81;
	goto yy88;
yy93:
	yyaccept = 4;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case '[':	goto yy149;
	default:	goto yy94;
	}
yy94:
#line 75 "lua-parser.re2c"
	{ goto Comment; }
#line 625 "lua-parser.re2c.c"
yy95:
	yych = *++YYCURSOR;
	switch (yych) {
	case '.':	goto yy151;
	default:	goto yy96;
	}
yy96:
#line 111 "lua-parser.re2c"
	{ return TK_CONCAT; }
#line 635 "lua-parser.re2c.c"
yy97:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy97;
	case 'E':
	case 'e':	goto yy102;
	default:	goto yy35;
	}
yy99:
	++YYCURSOR;
#line 122 "lua-parser.re2c"
	{ return TK_IDIV; }
#line 658 "lua-parser.re2c.c"
yy101:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'i':	goto yy35;
	default:	goto yy154;
	}
yy102:
	yych = *++YYCURSOR;
	switch (yych) {
	case '+':
	case '-':	goto yy155;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy156;
	default:	goto yy81;
	}
yy103:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'L':	goto yy158;
	default:	goto yy81;
	}
yy104:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'L':	goto yy103;
	default:	goto yy81;
	}
yy105:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':	goto yy160;
	default:	goto yy81;
	}
yy106:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'l':	goto yy158;
	default:	goto yy81;
	}
yy107:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'l':	goto yy106;
	default:	goto yy81;
	}
yy108:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case ':':	goto yy81;
	default:	goto yy164;
	}
yy109:
	++YYCURSOR;
#line 129 "lua-parser.re2c"
	{ return TK_SHL; }
#line 754 "lua-parser.re2c.c"
yy111:
	++YYCURSOR;
#line 117 "lua-parser.re2c"
	{ return TK_LTEQ; }
#line 759 "lua-parser.re2c.c"
yy113:
	++YYCURSOR;
#line 115 "lua-parser.re2c"
	{ return TK_EQ; }
#line 764 "lua-parser.re2c.c"
yy115:
	++YYCURSOR;
#line 116 "lua-parser.re2c"
	{ return TK_BTEQ; }
#line 769 "lua-parser.re2c.c"
yy117:
	++YYCURSOR;
#line 130 "lua-parser.re2c"
	{ return TK_SHR; }
#line 774 "lua-parser.re2c.c"
yy119:
	yych = *++YYCURSOR;
	switch (yych) {
	case '=':	goto yy119;
	case '[':	goto yy121;
	default:	goto yy81;
	}
yy121:
	++YYCURSOR;
#line 143 "lua-parser.re2c"
	{ long_start_line = s->line; nest_count=0; quote_size = (int)(s->cur - s->top); goto LongString; }
#line 786 "lua-parser.re2c.c"
yy123:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'd':	goto yy165;
	default:	goto yy49;
	}
yy124:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'e':	goto yy167;
	default:	goto yy49;
	}
yy125:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy126;
	}
yy126:
#line 80 "lua-parser.re2c"
	{ return TK_DO; }
#line 870 "lua-parser.re2c.c"
yy127:
	yych = *++YYCURSOR;
	switch (yych) {
	case 's':	goto yy168;
	default:	goto yy49;
	}
yy128:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'd':	goto yy169;
	default:	goto yy49;
	}
yy129:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'l':	goto yy171;
	default:	goto yy49;
	}
yy130:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'r':	goto yy172;
	default:	goto yy49;
	}
yy131:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'n':	goto yy174;
	default:	goto yy49;
	}
yy132:
	yych = *++YYCURSOR;
	switch (yych) {
	case 't':	goto yy175;
	default:	goto yy49;
	}
yy133:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy134;
	}
yy134:
#line 88 "lua-parser.re2c"
	{ return TK_IF; }
#line 978 "lua-parser.re2c.c"
yy135:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy136;
	}
yy136:
#line 89 "lua-parser.re2c"
	{ return TK_IN; }
#line 1050 "lua-parser.re2c.c"
yy137:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'c':	goto yy176;
	default:	goto yy49;
	}
yy138:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'l':	goto yy177;
	default:	goto yy49;
	}
yy139:
	yych = *++YYCURSOR;
	switch (yych) {
	case 't':	goto yy179;
	default:	goto yy49;
	}
yy140:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy141;
	}
yy141:
#line 93 "lua-parser.re2c"
	{ return TK_OR; }
#line 1140 "lua-parser.re2c.c"
yy142:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'p':	goto yy181;
	case 't':	goto yy182;
	default:	goto yy49;
	}
yy143:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'e':	goto yy183;
	default:	goto yy49;
	}
yy144:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'u':	goto yy184;
	default:	goto yy49;
	}
yy145:
	yych = *++YYCURSOR;
	switch (yych) {
	case 't':	goto yy185;
	default:	goto yy49;
	}
yy146:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'i':	goto yy186;
	default:	goto yy49;
	}
yy147:
	++YYCURSOR;
#line 118 "lua-parser.re2c"
	{ return TK_NEQ; }
#line 1176 "lua-parser.re2c.c"
yy149:
	yych = *++YYCURSOR;
	switch (yych) {
	case '=':	goto yy149;
	case '[':	goto yy187;
	default:	goto yy81;
	}
yy151:
	++YYCURSOR;
#line 110 "lua-parser.re2c"
	{ return TK_ELLIPSIS; }
#line 1188 "lua-parser.re2c.c"
yy153:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
yy154:
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy153;
	case 'E':
	case 'e':	goto yy102;
	case 'i':	goto yy189;
	default:	goto yy35;
	}
yy155:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy156;
	default:	goto yy81;
	}
yy156:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy156;
	default:	goto yy35;
	}
yy158:
	++YYCURSOR;
#line 150 "lua-parser.re2c"
	{ return TK_NUMBER; }
#line 1243 "lua-parser.re2c.c"
yy160:
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':	goto yy160;
	case 'L':	goto yy191;
	case 'P':
	case 'p':	goto yy192;
	case 'U':	goto yy193;
	case 'l':	goto yy194;
	case 'u':	goto yy195;
	default:	goto yy162;
	}
yy162:
#line 151 "lua-parser.re2c"
	{ return TK_NUMBER; }
#line 1281 "lua-parser.re2c.c"
yy163:
	yych = *++YYCURSOR;
yy164:
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy163;
	case ':':	goto yy196;
	default:	goto yy81;
	}
yy165:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy166;
	}
yy166:
#line 78 "lua-parser.re2c"
	{ return TK_AND; }
#line 1423 "lua-parser.re2c.c"
yy167:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'a':	goto yy197;
	default:	goto yy49;
	}
yy168:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'e':	goto yy198;
	default:	goto yy49;
	}
yy169:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy170;
	}
yy170:
#line 83 "lua-parser.re2c"
	{ return TK_END; }
#line 1507 "lua-parser.re2c.c"
yy171:
	yych = *++YYCURSOR;
	switch (yych) {
	case 's':	goto yy200;
	default:	goto yy49;
	}
yy172:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy173;
	}
yy173:
#line 85 "lua-parser.re2c"
	{ return TK_FOR; }
#line 1585 "lua-parser.re2c.c"
yy174:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'c':	goto yy201;
	default:	goto yy49;
	}
yy175:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'o':	goto yy202;
	default:	goto yy49;
	}
yy176:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'a':	goto yy204;
	default:	goto yy49;
	}
yy177:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy178;
	}
yy178:
#line 91 "lua-parser.re2c"
	{ return TK_NIL; }
#line 1675 "lua-parser.re2c.c"
yy179:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy180;
	}
yy180:
#line 92 "lua-parser.re2c"
	{ return TK_NOT; }
#line 1747 "lua-parser.re2c.c"
yy181:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'e':	goto yy205;
	default:	goto yy49;
	}
yy182:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'u':	goto yy206;
	default:	goto yy49;
	}
yy183:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'n':	goto yy207;
	default:	goto yy49;
	}
yy184:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'e':	goto yy209;
	default:	goto yy49;
	}
yy185:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'i':	goto yy211;
	default:	goto yy49;
	}
yy186:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'l':	goto yy212;
	default:	goto yy49;
	}
yy187:
	++YYCURSOR;
#line 74 "lua-parser.re2c"
	{ long_start_line = s->line; nest_count=0; quote_size = ((int)(s->cur - s->top)) - 2;  goto LongComment; }
#line 1788 "lua-parser.re2c.c"
yy189:
	++YYCURSOR;
#line 152 "lua-parser.re2c"
	{ return TK_NUMBER; }
#line 1793 "lua-parser.re2c.c"
yy191:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'L':	goto yy213;
	default:	goto yy81;
	}
yy192:
	yych = *++YYCURSOR;
	switch (yych) {
	case '+':
	case '-':	goto yy214;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy215;
	default:	goto yy81;
	}
yy193:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'L':	goto yy191;
	default:	goto yy81;
	}
yy194:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'l':	goto yy213;
	default:	goto yy81;
	}
yy195:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'l':	goto yy194;
	default:	goto yy81;
	}
yy196:
	yych = *++YYCURSOR;
	switch (yych) {
	case ':':	goto yy217;
	default:	goto yy81;
	}
yy197:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'k':	goto yy219;
	default:	goto yy49;
	}
yy198:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	case 'i':	goto yy221;
	default:	goto yy199;
	}
yy199:
#line 81 "lua-parser.re2c"
	{ return TK_ELSE; }
#line 1918 "lua-parser.re2c.c"
yy200:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'e':	goto yy222;
	default:	goto yy49;
	}
yy201:
	yych = *++YYCURSOR;
	switch (yych) {
	case 't':	goto yy224;
	default:	goto yy49;
	}
yy202:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy203;
	}
yy203:
#line 121 "lua-parser.re2c"
	{ return TK_GOTO; }
#line 2002 "lua-parser.re2c.c"
yy204:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'l':	goto yy225;
	default:	goto yy49;
	}
yy205:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'a':	goto yy227;
	default:	goto yy49;
	}
yy206:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'r':	goto yy228;
	default:	goto yy49;
	}
yy207:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy208;
	}
yy208:
#line 96 "lua-parser.re2c"
	{ return TK_THEN; }
#line 2092 "lua-parser.re2c.c"
yy209:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy210;
	}
yy210:
#line 97 "lua-parser.re2c"
	{ return TK_TRUE; }
#line 2164 "lua-parser.re2c.c"
yy211:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'l':	goto yy229;
	default:	goto yy49;
	}
yy212:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'e':	goto yy231;
	default:	goto yy49;
	}
yy213:
	++YYCURSOR;
	goto yy162;
yy214:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy215;
	default:	goto yy81;
	}
yy215:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy215;
	default:	goto yy162;
	}
yy217:
	++YYCURSOR;
#line 123 "lua-parser.re2c"
	{ return TK_LABEL; }
#line 2214 "lua-parser.re2c.c"
yy219:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy220;
	}
yy220:
#line 79 "lua-parser.re2c"
	{ return TK_BREAK; }
#line 2286 "lua-parser.re2c.c"
yy221:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'f':	goto yy233;
	default:	goto yy49;
	}
yy222:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy223;
	}
yy223:
#line 84 "lua-parser.re2c"
	{ return TK_FALSE; }
#line 2364 "lua-parser.re2c.c"
yy224:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'i':	goto yy235;
	default:	goto yy49;
	}
yy225:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy226;
	}
yy226:
#line 90 "lua-parser.re2c"
	{ return TK_LOCAL; }
#line 2442 "lua-parser.re2c.c"
yy227:
	yych = *++YYCURSOR;
	switch (yych) {
	case 't':	goto yy236;
	default:	goto yy49;
	}
yy228:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'n':	goto yy238;
	default:	goto yy49;
	}
yy229:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy230;
	}
yy230:
#line 98 "lua-parser.re2c"
	{ return TK_UNTIL; }
#line 2526 "lua-parser.re2c.c"
yy231:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy232;
	}
yy232:
#line 99 "lua-parser.re2c"
	{ return TK_WHILE; }
#line 2598 "lua-parser.re2c.c"
yy233:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy234;
	}
yy234:
#line 82 "lua-parser.re2c"
	{ return TK_ELSEIF; }
#line 2670 "lua-parser.re2c.c"
yy235:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'o':	goto yy240;
	default:	goto yy49;
	}
yy236:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy237;
	}
yy237:
#line 94 "lua-parser.re2c"
	{ return TK_REPEAT; }
#line 2748 "lua-parser.re2c.c"
yy238:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy239;
	}
yy239:
#line 95 "lua-parser.re2c"
	{ return TK_RETURN; }
#line 2820 "lua-parser.re2c.c"
yy240:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'n':	goto yy241;
	default:	goto yy49;
	}
yy241:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy48;
	default:	goto yy242;
	}
yy242:
#line 86 "lua-parser.re2c"
	{ return TK_FUNCTION; }
#line 2898 "lua-parser.re2c.c"
}
#line 169 "lua-parser.re2c"


LongString:
  long_top = s->cur;


#line 2907 "lua-parser.re2c.c"
{
	YYCTYPE yych;
	yych = *YYCURSOR;
	switch (yych) {
	case 0x00:	goto yy245;
	case '\n':	goto yy249;
	case '[':	goto yy251;
	case ']':	goto yy252;
	default:	goto yy247;
	}
yy245:
	++YYCURSOR;
#line 183 "lua-parser.re2c"
	{ fprintf(stderr, "unfinished long string at line %d\n", long_start_line); exit(1);}
#line 2922 "lua-parser.re2c.c"
yy247:
	++YYCURSOR;
yy248:
#line 182 "lua-parser.re2c"
	{ goto LongString; }
#line 2928 "lua-parser.re2c.c"
yy249:
	++YYCURSOR;
#line 180 "lua-parser.re2c"
	{ processNewLine(s); goto LongString; }
#line 2933 "lua-parser.re2c.c"
yy251:
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case '=':	goto yy253;
	case '[':	goto yy256;
	default:	goto yy248;
	}
yy252:
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case '=':	goto yy258;
	case ']':	goto yy260;
	default:	goto yy248;
	}
yy253:
	yych = *++YYCURSOR;
	switch (yych) {
	case '=':	goto yy253;
	case '[':	goto yy256;
	default:	goto yy255;
	}
yy255:
	YYCURSOR = YYMARKER;
	goto yy248;
yy256:
	++YYCURSOR;
#line 176 "lua-parser.re2c"
	{ int qsz = (int)(s->cur - long_top); if(qsz == quote_size) nest_count++; goto LongString; }
#line 2962 "lua-parser.re2c.c"
yy258:
	yych = *++YYCURSOR;
	switch (yych) {
	case '=':	goto yy258;
	case ']':	goto yy260;
	default:	goto yy255;
	}
yy260:
	++YYCURSOR;
	YYCURSOR -= 1;
#line 177 "lua-parser.re2c"
	{ int qsz = (int)(s->cur+1 - long_top); if( (nest_count == 0) && (qsz == quote_size)) { if(*s->cur == '\n') processNewLine(s); ++s->cur; return TK_LONGSTRING; };
                          if(qsz == quote_size) nest_count--; goto LongString; }
#line 2976 "lua-parser.re2c.c"
}
#line 185 "lua-parser.re2c"


Comment:


#line 2984 "lua-parser.re2c.c"
{
	YYCTYPE yych;
	yych = *YYCURSOR;
	switch (yych) {
	case 0x00:	goto yy265;
	case '\n':	goto yy264;
	default:	goto yy267;
	}
yy264:
#line 191 "lua-parser.re2c"
	{ return TK_COMMENT; }
#line 2996 "lua-parser.re2c.c"
yy265:
	++YYCURSOR;
#line 192 "lua-parser.re2c"
	{ goto regular; }
#line 3001 "lua-parser.re2c.c"
yy267:
	yych = *++YYCURSOR;
	switch (yych) {
	case 0x00:
	case '\n':	goto yy264;
	default:	goto yy267;
	}
}
#line 194 "lua-parser.re2c"


LongComment:
  long_top = s->cur;


#line 3017 "lua-parser.re2c.c"
{
	YYCTYPE yych;
	yych = *YYCURSOR;
	switch (yych) {
	case 0x00:	goto yy271;
	case '\n':	goto yy275;
	case '[':	goto yy277;
	case ']':	goto yy278;
	default:	goto yy273;
	}
yy271:
	++YYCURSOR;
#line 207 "lua-parser.re2c"
	{ fprintf(stderr, "unfinished long comment at line %d\n", long_start_line); exit(1);}
#line 3032 "lua-parser.re2c.c"
yy273:
	++YYCURSOR;
yy274:
#line 206 "lua-parser.re2c"
	{ goto LongComment; }
#line 3038 "lua-parser.re2c.c"
yy275:
	++YYCURSOR;
#line 205 "lua-parser.re2c"
	{ processNewLine(s); goto LongComment; }
#line 3043 "lua-parser.re2c.c"
yy277:
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case '=':	goto yy279;
	case '[':	goto yy282;
	default:	goto yy274;
	}
yy278:
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case '=':	goto yy284;
	case ']':	goto yy286;
	default:	goto yy274;
	}
yy279:
	yych = *++YYCURSOR;
	switch (yych) {
	case '=':	goto yy279;
	case '[':	goto yy282;
	default:	goto yy281;
	}
yy281:
	YYCURSOR = YYMARKER;
	goto yy274;
yy282:
	++YYCURSOR;
#line 201 "lua-parser.re2c"
	{ int qsz = (int)(s->cur - long_top); if(qsz == quote_size) nest_count++; goto LongComment; }
#line 3072 "lua-parser.re2c.c"
yy284:
	yych = *++YYCURSOR;
	switch (yych) {
	case '=':	goto yy284;
	case ']':	goto yy286;
	default:	goto yy281;
	}
yy286:
	++YYCURSOR;
	YYCURSOR -= 1;
#line 202 "lua-parser.re2c"
	{ int qsz = (int)(s->cur+1 - long_top); if( (nest_count == 0) && (qsz == quote_size)) { if(*s->cur == '\n') processNewLine(s); ++s->cur; return TK_LONGCOMMENT; };
                          if(qsz == quote_size) nest_count--; goto LongComment; }
#line 3086 "lua-parser.re2c.c"
}
#line 209 "lua-parser.re2c"


  fprintf(stderr, "impossible"); exit(1);/* die */
}

static LuaParserToken *pushToken(LuaParserState *pState, LuaScanner *scanner, int token_id) {
  LuaParserToken* token_value = malloc(sizeof(*token_value));
  token_value->flags = 0;
  token_value->token_id = token_id;
  if(scanner->last_top != scanner->top) {
    token_value->space_before_size = (int)(scanner->top - scanner->last_top);
    token_value->space_before_pos = (int)(scanner->last_top - pState->src);
  }
  else {
    token_value->space_before_size = 0;
    token_value->space_before_pos = 0;
  }
  scanner->last_top = scanner->cur;
  token_value->token_value_size = (int)(scanner->cur - scanner->top);
  token_value->token_value =  scanner->top;
  pushLuaParserToken(pState, token_value);
  return token_value;
}

int main(int argc, char *argv[]) {

  FILE *fp, *traceFile;
  long size;
  char *buff, *buff_end;
  size_t bytes;
  int token;
  LuaScanner scanner;
  LuaParserState parser_state;
  void *parser;
  //ParserCount pCount;

  int fn_argc = 1;
  int noToCompound = 0;
  int withTrace = 0;
  if(argc > 2) {
    for(; fn_argc < (argc-1); ++fn_argc) {
      if (strcmp(argv[fn_argc] , "-nc") == 0) noToCompound = 1;
#ifndef NDEBUG
      else if (strcmp(argv[fn_argc] , "-t") == 0) withTrace = 1;
#endif
      else {
        printf("usage : %s [options] lua_fname\n\toptions:\n\t\t-nc\tdo not convert to compound assginments\n"
#ifndef NDEBUG
                 "\t\t-t\tgenerate parser trace\n"
#endif
	    , argv[0]);
        exit(1);
    }
   }
  }

  /* Open input file */
  const char *fname = "test.lua";
  if(argc > 1) fname = argv[fn_argc];
  fp = fopen(fname, "r");
  if(fp == NULL) {
    fprintf(stderr, "Can't open test file\n");
    exit(-1);
  }

  if(withTrace) {
	/* Open trace file */
	traceFile = fopen("trace.out", "w");
	if(traceFile == NULL) {
	    fprintf(stderr, "Can't open trace file\n");
	    exit(-1);
	}
  }

  /* Get file size */
  fseek(fp, 0, SEEK_END);
  size = ftell(fp);
  rewind(fp);

  /*We only manage sources smaller than INT_MAX size */
  if(size > INT_MAX) {
    printf("Error file size bigger than %d\n", INT_MAX);
    exit(1);
  }

  /*
  * Allocate buffer and read, +2 just in case file do not end in '\n'
  */
  buff = (char*) malloc((size+2) * sizeof(char));
  bytes = fread(buff, 1, size, fp);
  if (bytes != size) {
    fprintf(stderr, "Error reading input file\n");
    exit(-1);
  }
  buff[size] = '\0';

  if(size > 1 && buff[size-1] != '\n') {
    /* to make things easy to parse we need a '\n' at the end */
    buff[size] = '\n';
    buff[size+1] = '\0';
    ++size;
  }

  /* Initialize scanner */
  scanner.line = 1;
  scanner.top = scanner.last_top = buff;
  scanner.cur = buff;
  scanner.pos = buff;
  scanner.ptr = buff;
  scanner.limit = buff+size;
#ifndef NDEBUG
   snprintf(scanner.parsePrompt, sizeof(scanner.parsePrompt), "parser %d >>", scanner.line);
#endif

  /* Initialize parser state */
  initializeLuaParserState(&parser_state);
  parser_state.src = buff;
  parser_state.noToCompound = noToCompound;

  /* Initialize the parser state structure */
  //pCount.numFunctionDefinitions = 0;
  //pCount.numVariableDeclarations = 0;

  /* Pointer to the end of the buffer */
  buff_end = (char*) (((char*)buff) + size);

  /* Create parser and set up tracing */
  parser = LuaParserAlloc(malloc);
#ifndef NDEBUG
  if(withTrace) LuaParserTrace(traceFile, scanner.parsePrompt);
#endif

  //printf("%d:%d:%d:%d\n", TK_SPACE, TK_COMMENT, TK_LONGCOMMENT, TK_THEEND);
  while((token = scan(&scanner, buff_end))) {
    if(token != TK_THEEND) {
      LuaParserToken *token_value = pushToken(&parser_state, &scanner, token);
      //printf("\n==++== %d : %d : %.8s\n", scanner.line, token, scanner.top);

      if(token < TK_LEMON_LAST_TOKEN) {
        LuaParser(parser, token, token_value, &parser_state);
      }
      else //SpecialTokens
      {
        //size_t gap_length = scanner.cur - scanner.top;
        switch(token) {
          case TK_SPACE:
            //printf("=S=%.*s=S=\n", (int)gap_length, scanner.top);
          break;
          case TK_COMMENT:
            //printf("=C=%.*s=C=\n", (int)gap_length, scanner.top);
            newStrFmt(token_value, "//%.*s", token_value->token_value_size-2, token_value->token_value+2);
          break;
          case TK_LONGCOMMENT: {
            //printf("=LC=%.*s=LC=\n", (int)gap_length, scanner.top);
            int quote_end = 4; // "--[["
            while(token_value->token_value[quote_end-1] != '[') ++quote_end; //try to find the end
            newStrFmt(token_value, "/*%.*s*/", token_value->token_value_size - quote_end - (quote_end-2), // -2 for "--"
                                                                  token_value->token_value + quote_end);
          }
          break;
        }
      }
    }
    else {
      if(scanner.last_top < buff_end) pushToken(&parser_state, &scanner, TK_SPACE);
      // Execute Parse for the last time
      LuaParser(parser, 0, NULL, &parser_state);
      break;
    }
  }
  /* Print results of parsing */
  //printf("Number of function definitions: %d.\n", pCount.numFunctionDefinitions);
  //printf("Number of variable declarations: %d.\n", pCount.numVariableDeclarations);

  /* output the reconstruction */
  doOutput(&parser_state);

  /* Deallocate parser */
  LuaParserFree(parser, free);

  resetLuaParserState(&parser_state);

  /* Close files and deallocate */
  fclose(fp);
 if(withTrace)  fclose(traceFile);
  free(buff);
  return(0);
}
