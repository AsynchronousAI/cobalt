var math = {};
for( k,v in pairs(require ('math')) ) { math[k] = v; }

math.nan = 0/0;

math.e = math.exp(1);

// luajit and lua 5.1 compat ...
if( ! math.atan2 ) { math.atan2 = math.atan; }
// also note, code that uses math.atan(y,x) in luajit will instead just call math.atan(y) ...

// some luas don't have hyperbolic trigonometric functions

if( ! math.sinh ) {
	function math.sinh(x) {
		var ex = math.exp(x);
		return .5 * (ex - 1/ex);
	}
}

if( ! math.cosh ) {
	function math.cosh(x) {
		var ex = math.exp(x);
		return .5 * (ex + 1/ex);
	}
}

if( ! math.tanh ) {
	function math.tanh(x) {
/* this isn't so stable.
		local ex = math.exp(x)
		return (ex - 1/ex) / (ex + 1/ex)
--*/
// [[ instead...
// if e^-2x < smallest float epsilon
// then consider (e^x  - e^-x) ~ e^x .. well, it turns out to be 1
// and if e^2x < smallest float epsilon then -1
		if( x < 0 ) {
			var e2x = math.exp(2*x);
			return (e2x - 1) / (e2x + 1);
		} else {
			var em2x = math.exp(-2*x);
			return (1 - em2x) / (1 + em2x);
		}
//]]
	}
}

function math.asinh(x) {
	return math.log(x + math.sqrt(x*x + 1));
}

function math.acosh(x) {
	return math.log(x + math.sqrt(x*x - 1));
}

function math.atanh(x) {
	return .5 * math.log((1 + x) / (1 - x));
}

function math.cbrt(x) {
	return math.sign(x) * math.abs(x)**(1/3);
}

function math.clamp(v,min,max) {
	return math.min(math.max(v,min), max);
}

function math.sign(x) {
	if( x < 0 ) { return -1; }
	if( x > 0 ) { return 1; }
	return 0;
}

function math.trunc(x) {
	if( x < 0 ) { return math.ceil(x); } else { return math.floor(x); }
}

function math.round(x) {
	return math.floor(x+.5);
}

function math.isnan(x) { return x != x; }
function math.isinf(x) { return x == math.huge || x == -math.huge; }
function math.isfinite(x) { return tonumber(x) && ! math.isnan(x) && ! math.isinf(x); }

function math.isprime(n) {
	if( n < 2 ) { return false; }	// 1 isnt prime
	for( i=2,math.floor(math.sqrt(n)) ) {
		if( n%i == 0 ) {
			return false;
		}
	}
	return true;
}

// assumes n is a non-negative integer.  this isn't the Gamma function
function math.factorial(n) {
	var prod = 1;
	for( i=1,n ) {
		prod *=   i;
	}
	return prod;
}

function math.factors(n) {
	var table = require ('ext.table');
	var f = table();
	for( i=1,n ) {
		if( n%i == 0 ) {
			f->insert(i);
		}
	}
	return f;
}

// returns a table containing the prime factorization of the number
function math.primeFactorization(n) {
	var table = require ('ext.table');
	n = math.floor(n);
	var f = table();
	while( n > 1 ) {
		var found = false;
		for( i=2,math.floor(math.sqrt(n)) ) {
			if( n%i == 0 ) {
				n = math.floor(n/i);
				f->insert(i);
				found = true;
				break;
			}
		}
		if( ! found ) {
			f->insert(n);
			break;
		}
	}
	return f;
}

function math.gcd(a,b) {
	return b == 0 && a || math.gcd(b, a % b);
}

// if this math lib gets too big ...
function math.mix(a,b,s) {
	return a * (1 - s) + b * s;
}

return math;
