var table = require ('ext.table');
var string = require ('ext.string');
var thread = require ('ext.thread');
var number = require ('ext.number');
var op = require ('ext.op');

// fix up lua type metatables

var function defaultConcat(a,b) { return tostring(a) .. tostring(b); }

// nil
debug.setmetatable(null, {__concat = defaultConcat});

// booleans
debug.setmetatable(true, {
	__concat = defaultConcat,
	__index = {
		and_ = op.land,
		or_ = op.lor,
		not_ = op.lnot,
		xor = function(a,b) { return a != b; },
		implies = function(a,b) { return ! a || b; },
	}
});

debug.setmetatable(0, number);

// strings
getmetatable('').__concat = defaultConcat;
getmetatable('').__index = string;

// It'd be fun if I could apply the operator to all return values, and not just the first ...
// like (function() return 1,2 end + function() return 3,4 end)() returns 4,6
var function combineFunctionsWithBinaryOperator(f, g, opfunc) {
	if( type(f) == 'function' && type(g) == 'function' ) {
		return function(...) {
			return opfunc(f(...), g(...));
		};
	} else if( type(f) == 'function' ) {
		return function(...) {
			return opfunc(f(...), g);
		};
	} else if( type(g) == 'function' ) {
		return function(...) {
			return opfunc(f, g(...));
		};
	} else {
		// shouldn't get called unless __add is called explicitly
		return function() {
			return opfunc(f, g);
		};
	}
}

// primitive functions.  should these be public?  or put in a single table?

// function operators generate functions
// f(x) = y, g(x) = z, (f+g)(x) = y+z
var functionMeta = {
	// I could make this a function composition like the rest of the meta operations,
	// but instead I'm going to have it follow the default __concat convention I have with other primitive types
	__concat = defaultConcat,
	dump = function(f) { return string.dump(f); },
	__add = function(f, g) { return combineFunctionsWithBinaryOperator(f, g, op.add); },
	__sub = function(f, g) { return combineFunctionsWithBinaryOperator(f, g, op.sub); },
	__mul = function(f, g) { return combineFunctionsWithBinaryOperator(f, g, op.mul); },
	__div = function(f, g) { return combineFunctionsWithBinaryOperator(f, g, op.div); },
	__mod = function(f, g) { return combineFunctionsWithBinaryOperator(f, g, op.mod); },
	__pow = function(f, g) { return combineFunctionsWithBinaryOperator(f, g, op.pow); },
	__unm = function(f) { return function(...) { return -f(...); }; },
	__len = function(f) { return function(...) { return #f(...); }; },
	// boolean operations aren't overloaded just yet.  should they be?
	//__call doesn't work anyways
	// TODO comparison operations too?  probably not equivalence for compatability with sort() and anything else
	// TODO boolean operations?  anything else?
	/* here's one option for allowing any function object dereference to be mapped to a new function
	__index = function(f, k) return function(...) return f(...)[k] end end,
	__newindex = function(f, k, v) return function(...) f(...)[k] = v end end,
	--*/
	// [[ ... but that prevents us from overloading our own methods.
	// so here's "index" to be used in its place
	// while we can provide more of our own methods as we desire
	__index = {
		// takes a function that returns an object
		//  returns a function that returns that object's __index to the key argument
		// so if f() = {a=1} then f:index'a'() == 1
		index = function(f, k) {
			return function(...) {
				return f(...)[k];
			};
		},
		// takes a function that returns an object
		//  returns a function that applies that object's __newindex to the key and value arguments
		// so if t={} and f()==t then f:assign('a',1)() assigns t.a==1
		assign = function(f, k, v) {
			return function(...) {
				f(...)[k] = v;
			};
		},

		// f:compose(g1, ...) returns a function that evaluates to f(g1(...(gn(args))))
		compose = function(...) {
			var funcs = table.pack(...);
			for( i=1,funcs.n ) {
				assert(type(funcs[i]) == 'function');
			}
			return function(...) {
				var args = table.pack(...);
				for( i=funcs.n,1,-1 ) {
					args = table.pack(funcs[i](table.unpack(args,1,args.n)));
				}
				return table.unpack(args,1,args.n);
			};
		},

		// f:compose_n(n, g) returns a function that evaluates to f(arg[1], ... arg[j-1], g(arg[j]), arg[j+1], ..., arg[n])
		compose_n = function(f, n, ...) {
			var funcs = table.pack(...);
			return function(...) {
				var args = table.pack(...);

				var ntharg = {args[n]};
				ntharg.n = n <= args.n && 1 || 0;
				for( i=funcs.n,1,-1 ) {
					ntharg = table.pack(funcs[i](table.unpack(ntharg,1,ntharg.n)));
				}

				args[n] = ntharg[1];
				args.n = math.max(args.n, n);

				return f(table.unpack(args, 1, args.n));
			};
		},

		// bind / partial apply -- currying first args, and allowing vararg rest of args
		bind = function(f, ...) {
			var args = table.pack(...);
			return function(...) {
				var n = args.n;
				var callargs = {table.unpack(args, 1, n)};
				for( i=1,select('#', ...) ) {
					++n;
					callargs[n] = select(i, ...);
				}
				return f(table.unpack(callargs, 1, n));
			};
		},

		// bind argument n, n+1, n+2, ... to the values provided
		bind_n = function(f, n, ...) {
			var nargs = table.pack(...);
			return function(...) {
				var args = table.pack(...);
				for( i=1,nargs.n ) {
					args[n+i-1] = nargs[i];
				}
				args.n = math.max(args.n, n+nargs.n-1);
				return f(table.unpack(args, 1, args.n));
			};
		},

		// Takes a function and a number of arguments,
		// returns a function that applies them individually,
		// first to the function, then to each function returned
		// (a1 -> (a2 -> ... (an -> b))) -> (a1, a2, ..., an -> b)
		uncurry = function(f, n) {
			return function(...) {
				var s = f;
				for( i=1,n ) {
					s = s(select(i, ...));
				}
				return s;
			};
		},
		// grows/shrinks the number of args passed.  pads with nil.
		nargs = function(f, n) {
			return function(...) {
				var t = {};
				for( i=1,n ) {
					t[i] = select(i, ...);
				}
				return f(table.unpack(t, 1, n));
			};
		},
		// swaps the next two arguments
		swap = function(f) {
			return function(a, b, ...) {
				return f(b, a, ...);
			};
		},
		dump = string.dump,
		// thread access
		wrap = thread.wrap,
		co = thread.create,
	}
	//]]
};
// shorthand
functionMeta.__index._ = functionMeta.__index.index;
functionMeta.__index.o = functionMeta.__index.compose;
functionMeta.__index.o_n = functionMeta.__index.compose_n;
debug.setmetatable(function() { }, functionMeta);

// threads
debug.setmetatable(thread.create(function() { }), {__index = thread});

// TODO lightuserdata, if you can create it within lua somehow ...
