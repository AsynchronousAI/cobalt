/* ============================================================================== //
// This file is apart of the Cobalt Programming Language. Cobalt is under the MIT //
// License. Read `cobalt.h` for license information.                              //
// ============================================================================== //
// This file has been generated/compiled and should not be modified.              //
// ============================================================================== */

#define INTERNAL_AOT 1
#include "aot_header.c"

// source = @init.cobalt
// main function
static
CallInfo *magic_implementation_00(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
    case 132: goto label_132;
    case 133: goto label_133;
    case 134: goto label_134;
    case 135: goto label_135;
    case 136: goto label_136;
    case 137: goto label_137;
    case 138: goto label_138;
    case 139: goto label_139;
    case 140: goto label_140;
    case 141: goto label_141;
    case 142: goto label_142;
    case 143: goto label_143;
    case 144: goto label_144;
    case 145: goto label_145;
    case 146: goto label_146;
    case 147: goto label_147;
    case 148: goto label_148;
    case 149: goto label_149;
    case 150: goto label_150;
    case 151: goto label_151;
    case 152: goto label_152;
    case 153: goto label_153;
    case 154: goto label_154;
    case 155: goto label_155;
    case 156: goto label_156;
    case 157: goto label_157;
    case 158: goto label_158;
    case 159: goto label_159;
    case 160: goto label_160;
    case 161: goto label_161;
    case 162: goto label_162;
    case 163: goto label_163;
    case 164: goto label_164;
    case 165: goto label_165;
    case 166: goto label_166;
    case 167: goto label_167;
    case 168: goto label_168;
    case 169: goto label_169;
    case 170: goto label_170;
    case 171: goto label_171;
    case 172: goto label_172;
    case 173: goto label_173;
    case 174: goto label_174;
    case 175: goto label_175;
    case 176: goto label_176;
    case 177: goto label_177;
    case 178: goto label_178;
    case 179: goto label_179;
    case 180: goto label_180;
    case 181: goto label_181;
    case 182: goto label_182;
    case 183: goto label_183;
    case 184: goto label_184;
    case 185: goto label_185;
    case 186: goto label_186;
    case 187: goto label_187;
    case 188: goto label_188;
    case 189: goto label_189;
    case 190: goto label_190;
    case 191: goto label_191;
    case 192: goto label_192;
    case 193: goto label_193;
    case 194: goto label_194;
    case 195: goto label_195;
    case 196: goto label_196;
    case 197: goto label_197;
    case 198: goto label_198;
    case 199: goto label_199;
    case 200: goto label_200;
    case 201: goto label_201;
    case 202: goto label_202;
    case 203: goto label_203;
    case 204: goto label_204;
    case 205: goto label_205;
    case 206: goto label_206;
    case 207: goto label_207;
    case 208: goto label_208;
    case 209: goto label_209;
    case 210: goto label_210;
    case 211: goto label_211;
    case 212: goto label_212;
    case 213: goto label_213;
    case 214: goto label_214;
    case 215: goto label_215;
    case 216: goto label_216;
    case 217: goto label_217;
    case 218: goto label_218;
    case 219: goto label_219;
    case 220: goto label_220;
    case 221: goto label_221;
    case 222: goto label_222;
    case 223: goto label_223;
    case 224: goto label_224;
    case 225: goto label_225;
    case 226: goto label_226;
    case 227: goto label_227;
    case 228: goto label_228;
    case 229: goto label_229;
    case 230: goto label_230;
    case 231: goto label_231;
    case 232: goto label_232;
    case 233: goto label_233;
    case 234: goto label_234;
    case 235: goto label_235;
    case 236: goto label_236;
    case 237: goto label_237;
    case 238: goto label_238;
    case 239: goto label_239;
    case 240: goto label_240;
    case 241: goto label_241;
    case 242: goto label_242;
    case 243: goto label_243;
    case 244: goto label_244;
    case 245: goto label_245;
    case 246: goto label_246;
    case 247: goto label_247;
    case 248: goto label_248;
    case 249: goto label_249;
    case 250: goto label_250;
    case 251: goto label_251;
    case 252: goto label_252;
    case 253: goto label_253;
    case 254: goto label_254;
    case 255: goto label_255;
    case 256: goto label_256;
    case 257: goto label_257;
    case 258: goto label_258;
    case 259: goto label_259;
    case 260: goto label_260;
    case 261: goto label_261;
    case 262: goto label_262;
    case 263: goto label_263;
    case 264: goto label_264;
    case 265: goto label_265;
    case 266: goto label_266;
    case 267: goto label_267;
    case 268: goto label_268;
    case 269: goto label_269;
    case 270: goto label_270;
    case 271: goto label_271;
    case 272: goto label_272;
    case 273: goto label_273;
    case 274: goto label_274;
    case 275: goto label_275;
    case 276: goto label_276;
    case 277: goto label_277;
    case 278: goto label_278;
    case 279: goto label_279;
    case 280: goto label_280;
    case 281: goto label_281;
    case 282: goto label_282;
    case 283: goto label_283;
    case 284: goto label_284;
    case 285: goto label_285;
    case 286: goto label_286;
    case 287: goto label_287;
    case 288: goto label_288;
    case 289: goto label_289;
    case 290: goto label_290;
    case 291: goto label_291;
    case 292: goto label_292;
    case 293: goto label_293;
    case 294: goto label_294;
    case 295: goto label_295;
    case 296: goto label_296;
    case 297: goto label_297;
    case 298: goto label_298;
    case 299: goto label_299;
    case 300: goto label_300;
    case 301: goto label_301;
    case 302: goto label_302;
    case 303: goto label_303;
    case 304: goto label_304;
    case 305: goto label_305;
    case 306: goto label_306;
    case 307: goto label_307;
    case 308: goto label_308;
    case 309: goto label_309;
    case 310: goto label_310;
    case 311: goto label_311;
    case 312: goto label_312;
    case 313: goto label_313;
    case 314: goto label_314;
    case 315: goto label_315;
    case 316: goto label_316;
    case 317: goto label_317;
    case 318: goto label_318;
    case 319: goto label_319;
    case 320: goto label_320;
    case 321: goto label_321;
    case 322: goto label_322;
    case 323: goto label_323;
    case 324: goto label_324;
    case 325: goto label_325;
    case 326: goto label_326;
    case 327: goto label_327;
    case 328: goto label_328;
    case 329: goto label_329;
    case 330: goto label_330;
    case 331: goto label_331;
    case 332: goto label_332;
    case 333: goto label_333;
    case 334: goto label_334;
    case 335: goto label_335;
    case 336: goto label_336;
    case 337: goto label_337;
    case 338: goto label_338;
    case 339: goto label_339;
    case 340: goto label_340;
    case 341: goto label_341;
    case 342: goto label_342;
    case 343: goto label_343;
    case 344: goto label_344;
    case 345: goto label_345;
    case 346: goto label_346;
    case 347: goto label_347;
    case 348: goto label_348;
    case 349: goto label_349;
    case 350: goto label_350;
    case 351: goto label_351;
    case 352: goto label_352;
    case 353: goto label_353;
    case 354: goto label_354;
    case 355: goto label_355;
    case 356: goto label_356;
    case 357: goto label_357;
    case 358: goto label_358;
    case 359: goto label_359;
    case 360: goto label_360;
    case 361: goto label_361;
    case 362: goto label_362;
    case 363: goto label_363;
    case 364: goto label_364;
    case 365: goto label_365;
    case 366: goto label_366;
    case 367: goto label_367;
    case 368: goto label_368;
    case 369: goto label_369;
    case 370: goto label_370;
    case 371: goto label_371;
    case 372: goto label_372;
    case 373: goto label_373;
    case 374: goto label_374;
    case 375: goto label_375;
    case 376: goto label_376;
    case 377: goto label_377;
    case 378: goto label_378;
    case 379: goto label_379;
    case 380: goto label_380;
    case 381: goto label_381;
    case 382: goto label_382;
    case 383: goto label_383;
    case 384: goto label_384;
    case 385: goto label_385;
    case 386: goto label_386;
    case 387: goto label_387;
    case 388: goto label_388;
    case 389: goto label_389;
    case 390: goto label_390;
    case 391: goto label_391;
    case 392: goto label_392;
    case 393: goto label_393;
    case 394: goto label_394;
    case 395: goto label_395;
    case 396: goto label_396;
    case 397: goto label_397;
    case 398: goto label_398;
    case 399: goto label_399;
    case 400: goto label_400;
    case 401: goto label_401;
    case 402: goto label_402;
    case 403: goto label_403;
    case 404: goto label_404;
    case 405: goto label_405;
    case 406: goto label_406;
    case 407: goto label_407;
    case 408: goto label_408;
    case 409: goto label_409;
    case 410: goto label_410;
    case 411: goto label_411;
    case 412: goto label_412;
    case 413: goto label_413;
    case 414: goto label_414;
    case 415: goto label_415;
    case 416: goto label_416;
    case 417: goto label_417;
    case 418: goto label_418;
    case 419: goto label_419;
    case 420: goto label_420;
    case 421: goto label_421;
    case 422: goto label_422;
    case 423: goto label_423;
    case 424: goto label_424;
    case 425: goto label_425;
    case 426: goto label_426;
    case 427: goto label_427;
    case 428: goto label_428;
    case 429: goto label_429;
    case 430: goto label_430;
    case 431: goto label_431;
    case 432: goto label_432;
    case 433: goto label_433;
    case 434: goto label_434;
    case 435: goto label_435;
    case 436: goto label_436;
    case 437: goto label_437;
    case 438: goto label_438;
    case 439: goto label_439;
    case 440: goto label_440;
    case 441: goto label_441;
    case 442: goto label_442;
    case 443: goto label_443;
    case 444: goto label_444;
  }

  // 0	[1]	VARARGPREP	0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000051);
    ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));
    if (l_unlikely(trap)) {  /* previous "Protect" updated trap */
      luaD_hookcall(L, ci);
      L->oldpc = 1;  /* next opcode will be seen as a "new" line */
    }
    updatebase(ci);  /* function has new base after adjustment */
  }

  // 1	[1]	NEWTABLE 	0 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000013);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 2	[1]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 3	[2]	GETTABUP 	1 0 0	; _ENV "require"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[2]	LOADK    	2 1	; "bit"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[2]	CALL     	1 2 3	; 1 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x030200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[3]	GETTABUP 	3 0 2	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0200018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[3]	TEST     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000001c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 8	[3]	JMP      	2	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_11;
  }

  // 9	[3]	GETTABUP 	3 0 2	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0200018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 10	[3]	JMP      	12	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_23;
  }

  // 11	[3]	GETTABUP 	4 0 3	; _ENV "pcall"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0300020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[3]	GETTABUP 	5 0 0	; _ENV "require"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0000028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[3]	LOADK    	6 2	; "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00010303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 14	[3]	CALL     	4 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x02030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 15	[3]	TEST     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_21
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 16	[3]	JMP      	4	; to 22
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_21;
  }

  // 17	[3]	GETTABUP 	4 0 0	; _ENV "require"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0000020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 18	[3]	LOADK    	5 2	; "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00010283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 19	[3]	CALL     	4 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x02020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[3]	JMP      	1	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_22;
  }

  // 21	[3]	GETTABUP 	4 0 4	; _ENV "thread"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0400020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 22	[3]	MOVE     	3 4
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00040180);
    setobjs2s(L, ra, RB(i));
  }

  // 23	[3]	SETTABUP 	0 2 3	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x0302000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 24	[4]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_41
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 25	[4]	JMP      	15	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80000738);
    updatetrap(ci);
    goto label_41;
  }

  // 26	[5]	NEWTABLE 	3 4 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00040193);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 27	[5]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 28	[9]	CLOSURE  	4 0	; 0x7fe610f0b980
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x0000024f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 29	[9]	SETFIELD 	3 5 4	; "lshift"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x04050192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 30	[13]	CLOSURE  	4 1	; 0x7fe610f0bb70
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x0000824f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 31	[13]	SETFIELD 	3 6 4	; "rshift"
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x04060192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 32	[35]	CLOSURE  	4 2	; 0x7fe610f0b880
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x0001024f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 33	[35]	SETFIELD 	3 7 4	; "bxor"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x04070192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 34	[39]	CLOSURE  	4 3	; 0x7fe610f0c4e0
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x0001824f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 35	[39]	SETFIELD 	3 8 4	; "bnot"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x04080192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 36	[42]	CLOSURE  	4 4	; 0x7fe610f0c570
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x0002024f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 37	[42]	SETFIELD 	3 9 4	; "band"
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x04090192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 38	[45]	CLOSURE  	4 5	; 0x7fe610f0c640
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x0002824f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 39	[45]	SETFIELD 	3 10 4	; "bor"
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x040a0192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 40	[46]	MOVE     	2 3
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00030100);
    setobjs2s(L, ra, RB(i));
  }

  // 41	[50]	GETTABUP 	3 0 3	; _ENV "pcall"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x0300018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 42	[50]	GETTABUP 	4 0 0	; _ENV "require"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0000020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[50]	LOADK    	5 12	; "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x00060283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 44	[50]	CALL     	3 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x020301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 45	[50]	SETFIELD 	0 11 3	; "PRE_FFI"
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x030b0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 46	[51]	SETFIELD 	0 13 14k	; "PRE_TEST" false
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x0e0d8012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 47	[52]	NEWTABLE 	3 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00000193);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 48	[52]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 49	[52]	SETFIELD 	0 15 3	; "ENV"
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x030f0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 50	[53]	SETFIELD 	0 16 14k	; "FAST" false
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0e108012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 51	[54]	SETFIELD 	0 17 14k	; "DEBUG" false
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x0e118012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 52	[57]	LOADK    	3 18	; "FILE"
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x00090183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 53	[58]	LOADK    	4 19	; "LINE"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00098203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 54	[59]	LOADK    	5 20	; "DATE"
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x000a0283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 55	[60]	LOADK    	6 21	; "TIME"
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x000a8303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 56	[61]	LOADK    	7 22	; "PRE_INDENT"
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x000b0383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 57	[64]	LOADK    	8 23	; "$"
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x000b8403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 58	[65]	LOADK    	9 24	; "^"
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x000c0483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 59	[66]	LOADK    	10 25	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x000c8503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 60	[67]	SELF     	11 10 26k	; "byte"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x1a0a8594);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 61	[67]	LOADI    	13 1
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x80000681);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 62	[67]	CALL     	11 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x020305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 63	[68]	LOADK    	12 27	; "\\"
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x000d8603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 64	[69]	LOADK    	13 28	; "\\\n"
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x000e0683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 65	[70]	LOADK    	14 29	; "#"
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x000e8703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 66	[71]	SELF     	15 14 26k	; "byte"
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x1a0e8794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 67	[71]	LOADI    	17 1
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x80000881);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 68	[71]	CALL     	15 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x020307c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 69	[72]	LOADK    	16 30	; "^(.-)//.-$"
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x000f0803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 70	[73]	LOADK    	17 31	; "/[*].-[*]/"
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x000f8883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 71	[74]	LOADK    	18 32	; "%s+"
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x00100903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 72	[75]	LOADK    	19 33	; "%s*"
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x00108983);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 73	[76]	LOADK    	20 34	; "[_%a][_%w]*"
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x00110a03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 74	[77]	LOADK    	21 35	; "[^%w_]+"
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x00118a83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 75	[78]	LOADK    	22 36	; "[0-9a-zA-Z.%-_/\\]+"
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x00120b03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 76	[79]	LOADK    	23 37	; ".+"
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x00128b83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 77	[80]	LOADK    	24 29	; "#"
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x000e8c03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 78	[81]	SELF     	25 24 26k	; "byte"
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x1a188c94);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 79	[81]	LOADI    	27 1
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x80000d81);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 80	[81]	CALL     	25 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x02030cc4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 81	[82]	LOADK    	26 38	; ".*"
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x00130d03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 82	[85]	LOADK    	27 39	; "include"
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x00138d83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 83	[86]	LOADK    	28 40	; "include_next"
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x00140e03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 84	[87]	LOADK    	29 41	; "define"
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x00148e83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 85	[88]	LOADK    	30 42	; "ifdef"
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x00150f03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 86	[89]	LOADK    	31 43	; "ifndef"
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x00158f83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 87	[90]	LOADK    	32 44	; "endif"
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x00161003);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 88	[91]	LOADK    	33 45	; "undef"
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x00169083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 89	[92]	LOADK    	34 46	; "if"
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x00171103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 90	[93]	LOADK    	35 47	; "else"
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x00179183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 91	[94]	LOADK    	36 48	; "elif"
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x00181203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 92	[95]	LOADK    	37 49	; "!"
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x00189283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 93	[96]	LOADK    	38 50	; "error"
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x00191303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 94	[97]	LOADK    	39 51	; "warning"
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x00199383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 95	[98]	LOADK    	40 52	; "pragma"
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x001a1403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 96	[101]	MOVE     	41 9
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x00091480);
    setobjs2s(L, ra, RB(i));
  }

  // 97	[101]	MOVE     	42 27
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x001b1500);
    setobjs2s(L, ra, RB(i));
  }

  // 98	[101]	MOVE     	43 18
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x00121580);
    setobjs2s(L, ra, RB(i));
  }

  // 99	[101]	LOADK    	44 53	; "[<]("
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x001a9603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 100	[101]	MOVE     	45 22
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x00161680);
    setobjs2s(L, ra, RB(i));
  }

  // 101	[101]	LOADK    	46 54	; ")[>]"
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x001b1703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 102	[101]	MOVE     	47 19
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x00131780);
    setobjs2s(L, ra, RB(i));
  }

  // 103	[101]	MOVE     	48 8
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x00081800);
    setobjs2s(L, ra, RB(i));
  }

  // 104	[101]	CONCAT   	41 8
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x000814b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 105	[102]	MOVE     	42 9
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x00091500);
    setobjs2s(L, ra, RB(i));
  }

  // 106	[102]	MOVE     	43 27
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x001b1580);
    setobjs2s(L, ra, RB(i));
  }

  // 107	[102]	MOVE     	44 18
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x00121600);
    setobjs2s(L, ra, RB(i));
  }

  // 108	[102]	LOADK    	45 55	; "[\"]("
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x001b9683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 109	[102]	MOVE     	46 22
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x00161700);
    setobjs2s(L, ra, RB(i));
  }

  // 110	[102]	LOADK    	47 56	; ")[\"]"
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x001c1783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 111	[102]	MOVE     	48 19
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x00131800);
    setobjs2s(L, ra, RB(i));
  }

  // 112	[102]	MOVE     	49 8
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x00081880);
    setobjs2s(L, ra, RB(i));
  }

  // 113	[102]	CONCAT   	42 8
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x00081535);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 114	[103]	MOVE     	43 9
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x00091580);
    setobjs2s(L, ra, RB(i));
  }

  // 115	[103]	MOVE     	44 28
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x001c1600);
    setobjs2s(L, ra, RB(i));
  }

  // 116	[103]	MOVE     	45 18
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x00121680);
    setobjs2s(L, ra, RB(i));
  }

  // 117	[103]	LOADK    	46 57	; "[\"<]("
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x001c9703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 118	[103]	MOVE     	47 22
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x00161780);
    setobjs2s(L, ra, RB(i));
  }

  // 119	[103]	LOADK    	48 58	; ")[\">]"
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x001d1803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 120	[103]	MOVE     	49 19
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x00131880);
    setobjs2s(L, ra, RB(i));
  }

  // 121	[103]	MOVE     	50 8
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x00081900);
    setobjs2s(L, ra, RB(i));
  }

  // 122	[103]	CONCAT   	43 8
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x000815b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 123	[104]	MOVE     	44 9
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x00091600);
    setobjs2s(L, ra, RB(i));
  }

  // 124	[104]	MOVE     	45 29
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x001d1680);
    setobjs2s(L, ra, RB(i));
  }

  // 125	[104]	CONCAT   	44 2
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x00021635);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 126	[105]	MOVE     	45 9
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x00091680);
    setobjs2s(L, ra, RB(i));
  }

  // 127	[105]	MOVE     	46 30
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x001e1700);
    setobjs2s(L, ra, RB(i));
  }

  // 128	[105]	MOVE     	47 18
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x00121780);
    setobjs2s(L, ra, RB(i));
  }

  // 129	[105]	LOADK    	48 59	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x001d9803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 130	[105]	MOVE     	49 20
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_132
  label_130: {
    aot_vmfetch(0x00141880);
    setobjs2s(L, ra, RB(i));
  }

  // 131	[105]	LOADK    	50 60	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_133
  label_131: {
    aot_vmfetch(0x001e1903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 132	[105]	MOVE     	51 19
  #undef  AOT_PC
  #define AOT_PC (code + 133)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_134
  label_132: {
    aot_vmfetch(0x00131980);
    setobjs2s(L, ra, RB(i));
  }

  // 133	[105]	MOVE     	52 8
  #undef  AOT_PC
  #define AOT_PC (code + 134)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_135
  label_133: {
    aot_vmfetch(0x00081a00);
    setobjs2s(L, ra, RB(i));
  }

  // 134	[105]	CONCAT   	45 8
  #undef  AOT_PC
  #define AOT_PC (code + 135)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_136
  label_134: {
    aot_vmfetch(0x000816b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 135	[106]	MOVE     	46 9
  #undef  AOT_PC
  #define AOT_PC (code + 136)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_137
  label_135: {
    aot_vmfetch(0x00091700);
    setobjs2s(L, ra, RB(i));
  }

  // 136	[106]	MOVE     	47 31
  #undef  AOT_PC
  #define AOT_PC (code + 137)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_138
  label_136: {
    aot_vmfetch(0x001f1780);
    setobjs2s(L, ra, RB(i));
  }

  // 137	[106]	MOVE     	48 18
  #undef  AOT_PC
  #define AOT_PC (code + 138)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_139
  label_137: {
    aot_vmfetch(0x00121800);
    setobjs2s(L, ra, RB(i));
  }

  // 138	[106]	LOADK    	49 59	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 139)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_140
  label_138: {
    aot_vmfetch(0x001d9883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 139	[106]	MOVE     	50 20
  #undef  AOT_PC
  #define AOT_PC (code + 140)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_141
  label_139: {
    aot_vmfetch(0x00141900);
    setobjs2s(L, ra, RB(i));
  }

  // 140	[106]	LOADK    	51 60	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 141)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_142
  label_140: {
    aot_vmfetch(0x001e1983);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 141	[106]	MOVE     	52 19
  #undef  AOT_PC
  #define AOT_PC (code + 142)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_143
  label_141: {
    aot_vmfetch(0x00131a00);
    setobjs2s(L, ra, RB(i));
  }

  // 142	[106]	MOVE     	53 8
  #undef  AOT_PC
  #define AOT_PC (code + 143)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_144
  label_142: {
    aot_vmfetch(0x00081a80);
    setobjs2s(L, ra, RB(i));
  }

  // 143	[106]	CONCAT   	46 8
  #undef  AOT_PC
  #define AOT_PC (code + 144)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_145
  label_143: {
    aot_vmfetch(0x00081735);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 144	[107]	MOVE     	47 9
  #undef  AOT_PC
  #define AOT_PC (code + 145)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_146
  label_144: {
    aot_vmfetch(0x00091780);
    setobjs2s(L, ra, RB(i));
  }

  // 145	[107]	MOVE     	48 32
  #undef  AOT_PC
  #define AOT_PC (code + 146)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_147
  label_145: {
    aot_vmfetch(0x00201800);
    setobjs2s(L, ra, RB(i));
  }

  // 146	[107]	MOVE     	49 19
  #undef  AOT_PC
  #define AOT_PC (code + 147)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_148
  label_146: {
    aot_vmfetch(0x00131880);
    setobjs2s(L, ra, RB(i));
  }

  // 147	[107]	MOVE     	50 8
  #undef  AOT_PC
  #define AOT_PC (code + 148)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_149
  label_147: {
    aot_vmfetch(0x00081900);
    setobjs2s(L, ra, RB(i));
  }

  // 148	[107]	CONCAT   	47 4
  #undef  AOT_PC
  #define AOT_PC (code + 149)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_150
  label_148: {
    aot_vmfetch(0x000417b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 149	[108]	MOVE     	48 9
  #undef  AOT_PC
  #define AOT_PC (code + 150)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_151
  label_149: {
    aot_vmfetch(0x00091800);
    setobjs2s(L, ra, RB(i));
  }

  // 150	[108]	MOVE     	49 33
  #undef  AOT_PC
  #define AOT_PC (code + 151)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_152
  label_150: {
    aot_vmfetch(0x00211880);
    setobjs2s(L, ra, RB(i));
  }

  // 151	[108]	MOVE     	50 18
  #undef  AOT_PC
  #define AOT_PC (code + 152)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_153
  label_151: {
    aot_vmfetch(0x00121900);
    setobjs2s(L, ra, RB(i));
  }

  // 152	[108]	LOADK    	51 59	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 153)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_154
  label_152: {
    aot_vmfetch(0x001d9983);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 153	[108]	MOVE     	52 20
  #undef  AOT_PC
  #define AOT_PC (code + 154)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_155
  label_153: {
    aot_vmfetch(0x00141a00);
    setobjs2s(L, ra, RB(i));
  }

  // 154	[108]	LOADK    	53 60	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 155)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_156
  label_154: {
    aot_vmfetch(0x001e1a83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 155	[108]	MOVE     	54 19
  #undef  AOT_PC
  #define AOT_PC (code + 156)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_157
  label_155: {
    aot_vmfetch(0x00131b00);
    setobjs2s(L, ra, RB(i));
  }

  // 156	[108]	MOVE     	55 8
  #undef  AOT_PC
  #define AOT_PC (code + 157)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_158
  label_156: {
    aot_vmfetch(0x00081b80);
    setobjs2s(L, ra, RB(i));
  }

  // 157	[108]	CONCAT   	48 8
  #undef  AOT_PC
  #define AOT_PC (code + 158)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_159
  label_157: {
    aot_vmfetch(0x00081835);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 158	[109]	MOVE     	49 9
  #undef  AOT_PC
  #define AOT_PC (code + 159)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_160
  label_158: {
    aot_vmfetch(0x00091880);
    setobjs2s(L, ra, RB(i));
  }

  // 159	[109]	MOVE     	50 34
  #undef  AOT_PC
  #define AOT_PC (code + 160)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_161
  label_159: {
    aot_vmfetch(0x00221900);
    setobjs2s(L, ra, RB(i));
  }

  // 160	[109]	MOVE     	51 18
  #undef  AOT_PC
  #define AOT_PC (code + 161)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_162
  label_160: {
    aot_vmfetch(0x00121980);
    setobjs2s(L, ra, RB(i));
  }

  // 161	[109]	LOADK    	52 61	; "(.*)"
  #undef  AOT_PC
  #define AOT_PC (code + 162)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_163
  label_161: {
    aot_vmfetch(0x001e9a03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 162	[109]	MOVE     	53 8
  #undef  AOT_PC
  #define AOT_PC (code + 163)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_164
  label_162: {
    aot_vmfetch(0x00081a80);
    setobjs2s(L, ra, RB(i));
  }

  // 163	[109]	CONCAT   	49 5
  #undef  AOT_PC
  #define AOT_PC (code + 164)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_165
  label_163: {
    aot_vmfetch(0x000518b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 164	[110]	MOVE     	50 9
  #undef  AOT_PC
  #define AOT_PC (code + 165)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_166
  label_164: {
    aot_vmfetch(0x00091900);
    setobjs2s(L, ra, RB(i));
  }

  // 165	[110]	MOVE     	51 35
  #undef  AOT_PC
  #define AOT_PC (code + 166)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_167
  label_165: {
    aot_vmfetch(0x00231980);
    setobjs2s(L, ra, RB(i));
  }

  // 166	[110]	MOVE     	52 19
  #undef  AOT_PC
  #define AOT_PC (code + 167)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_168
  label_166: {
    aot_vmfetch(0x00131a00);
    setobjs2s(L, ra, RB(i));
  }

  // 167	[110]	MOVE     	53 8
  #undef  AOT_PC
  #define AOT_PC (code + 168)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_169
  label_167: {
    aot_vmfetch(0x00081a80);
    setobjs2s(L, ra, RB(i));
  }

  // 168	[110]	CONCAT   	50 4
  #undef  AOT_PC
  #define AOT_PC (code + 169)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_170
  label_168: {
    aot_vmfetch(0x00041935);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 169	[111]	MOVE     	51 9
  #undef  AOT_PC
  #define AOT_PC (code + 170)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_171
  label_169: {
    aot_vmfetch(0x00091980);
    setobjs2s(L, ra, RB(i));
  }

  // 170	[111]	MOVE     	52 36
  #undef  AOT_PC
  #define AOT_PC (code + 171)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_172
  label_170: {
    aot_vmfetch(0x00241a00);
    setobjs2s(L, ra, RB(i));
  }

  // 171	[111]	MOVE     	53 18
  #undef  AOT_PC
  #define AOT_PC (code + 172)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_173
  label_171: {
    aot_vmfetch(0x00121a80);
    setobjs2s(L, ra, RB(i));
  }

  // 172	[111]	LOADK    	54 61	; "(.*)"
  #undef  AOT_PC
  #define AOT_PC (code + 173)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_174
  label_172: {
    aot_vmfetch(0x001e9b03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 173	[111]	MOVE     	55 8
  #undef  AOT_PC
  #define AOT_PC (code + 174)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_175
  label_173: {
    aot_vmfetch(0x00081b80);
    setobjs2s(L, ra, RB(i));
  }

  // 174	[111]	CONCAT   	51 5
  #undef  AOT_PC
  #define AOT_PC (code + 175)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_176
  label_174: {
    aot_vmfetch(0x000519b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 175	[112]	MOVE     	52 9
  #undef  AOT_PC
  #define AOT_PC (code + 176)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_177
  label_175: {
    aot_vmfetch(0x00091a00);
    setobjs2s(L, ra, RB(i));
  }

  // 176	[112]	MOVE     	53 35
  #undef  AOT_PC
  #define AOT_PC (code + 177)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_178
  label_176: {
    aot_vmfetch(0x00231a80);
    setobjs2s(L, ra, RB(i));
  }

  // 177	[112]	MOVE     	54 18
  #undef  AOT_PC
  #define AOT_PC (code + 178)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_179
  label_177: {
    aot_vmfetch(0x00121b00);
    setobjs2s(L, ra, RB(i));
  }

  // 178	[112]	MOVE     	55 34
  #undef  AOT_PC
  #define AOT_PC (code + 179)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_180
  label_178: {
    aot_vmfetch(0x00221b80);
    setobjs2s(L, ra, RB(i));
  }

  // 179	[112]	MOVE     	56 18
  #undef  AOT_PC
  #define AOT_PC (code + 180)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_181
  label_179: {
    aot_vmfetch(0x00121c00);
    setobjs2s(L, ra, RB(i));
  }

  // 180	[112]	LOADK    	57 61	; "(.*)"
  #undef  AOT_PC
  #define AOT_PC (code + 181)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_182
  label_180: {
    aot_vmfetch(0x001e9c83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 181	[112]	MOVE     	58 8
  #undef  AOT_PC
  #define AOT_PC (code + 182)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_183
  label_181: {
    aot_vmfetch(0x00081d00);
    setobjs2s(L, ra, RB(i));
  }

  // 182	[112]	CONCAT   	52 7
  #undef  AOT_PC
  #define AOT_PC (code + 183)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_184
  label_182: {
    aot_vmfetch(0x00071a35);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 183	[113]	MOVE     	53 9
  #undef  AOT_PC
  #define AOT_PC (code + 184)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_185
  label_183: {
    aot_vmfetch(0x00091a80);
    setobjs2s(L, ra, RB(i));
  }

  // 184	[113]	MOVE     	54 38
  #undef  AOT_PC
  #define AOT_PC (code + 185)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_186
  label_184: {
    aot_vmfetch(0x00261b00);
    setobjs2s(L, ra, RB(i));
  }

  // 185	[113]	MOVE     	55 18
  #undef  AOT_PC
  #define AOT_PC (code + 186)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_187
  label_185: {
    aot_vmfetch(0x00121b80);
    setobjs2s(L, ra, RB(i));
  }

  // 186	[113]	LOADK    	56 59	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 187)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_188
  label_186: {
    aot_vmfetch(0x001d9c03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 187	[113]	MOVE     	57 23
  #undef  AOT_PC
  #define AOT_PC (code + 188)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_189
  label_187: {
    aot_vmfetch(0x00171c80);
    setobjs2s(L, ra, RB(i));
  }

  // 188	[113]	LOADK    	58 60	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 189)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_190
  label_188: {
    aot_vmfetch(0x001e1d03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 189	[113]	MOVE     	59 19
  #undef  AOT_PC
  #define AOT_PC (code + 190)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_191
  label_189: {
    aot_vmfetch(0x00131d80);
    setobjs2s(L, ra, RB(i));
  }

  // 190	[113]	MOVE     	60 8
  #undef  AOT_PC
  #define AOT_PC (code + 191)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_192
  label_190: {
    aot_vmfetch(0x00081e00);
    setobjs2s(L, ra, RB(i));
  }

  // 191	[113]	CONCAT   	53 8
  #undef  AOT_PC
  #define AOT_PC (code + 192)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_193
  label_191: {
    aot_vmfetch(0x00081ab5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 192	[114]	MOVE     	54 9
  #undef  AOT_PC
  #define AOT_PC (code + 193)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_194
  label_192: {
    aot_vmfetch(0x00091b00);
    setobjs2s(L, ra, RB(i));
  }

  // 193	[114]	MOVE     	55 39
  #undef  AOT_PC
  #define AOT_PC (code + 194)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_195
  label_193: {
    aot_vmfetch(0x00271b80);
    setobjs2s(L, ra, RB(i));
  }

  // 194	[114]	MOVE     	56 18
  #undef  AOT_PC
  #define AOT_PC (code + 195)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_196
  label_194: {
    aot_vmfetch(0x00121c00);
    setobjs2s(L, ra, RB(i));
  }

  // 195	[114]	LOADK    	57 59	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 196)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_197
  label_195: {
    aot_vmfetch(0x001d9c83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 196	[114]	MOVE     	58 23
  #undef  AOT_PC
  #define AOT_PC (code + 197)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_198
  label_196: {
    aot_vmfetch(0x00171d00);
    setobjs2s(L, ra, RB(i));
  }

  // 197	[114]	LOADK    	59 60	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 198)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_199
  label_197: {
    aot_vmfetch(0x001e1d83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 198	[114]	MOVE     	60 19
  #undef  AOT_PC
  #define AOT_PC (code + 199)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_200
  label_198: {
    aot_vmfetch(0x00131e00);
    setobjs2s(L, ra, RB(i));
  }

  // 199	[114]	MOVE     	61 8
  #undef  AOT_PC
  #define AOT_PC (code + 200)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_201
  label_199: {
    aot_vmfetch(0x00081e80);
    setobjs2s(L, ra, RB(i));
  }

  // 200	[114]	CONCAT   	54 8
  #undef  AOT_PC
  #define AOT_PC (code + 201)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_202
  label_200: {
    aot_vmfetch(0x00081b35);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 201	[115]	MOVE     	55 9
  #undef  AOT_PC
  #define AOT_PC (code + 202)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_203
  label_201: {
    aot_vmfetch(0x00091b80);
    setobjs2s(L, ra, RB(i));
  }

  // 202	[115]	MOVE     	56 38
  #undef  AOT_PC
  #define AOT_PC (code + 203)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_204
  label_202: {
    aot_vmfetch(0x00261c00);
    setobjs2s(L, ra, RB(i));
  }

  // 203	[115]	MOVE     	57 19
  #undef  AOT_PC
  #define AOT_PC (code + 204)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_205
  label_203: {
    aot_vmfetch(0x00131c80);
    setobjs2s(L, ra, RB(i));
  }

  // 204	[115]	MOVE     	58 8
  #undef  AOT_PC
  #define AOT_PC (code + 205)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_206
  label_204: {
    aot_vmfetch(0x00081d00);
    setobjs2s(L, ra, RB(i));
  }

  // 205	[115]	CONCAT   	55 4
  #undef  AOT_PC
  #define AOT_PC (code + 206)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_207
  label_205: {
    aot_vmfetch(0x00041bb5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 206	[116]	MOVE     	56 9
  #undef  AOT_PC
  #define AOT_PC (code + 207)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_208
  label_206: {
    aot_vmfetch(0x00091c00);
    setobjs2s(L, ra, RB(i));
  }

  // 207	[116]	MOVE     	57 40
  #undef  AOT_PC
  #define AOT_PC (code + 208)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_209
  label_207: {
    aot_vmfetch(0x00281c80);
    setobjs2s(L, ra, RB(i));
  }

  // 208	[116]	CONCAT   	56 2
  #undef  AOT_PC
  #define AOT_PC (code + 209)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_210
  label_208: {
    aot_vmfetch(0x00021c35);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 209	[119]	MOVE     	57 9
  #undef  AOT_PC
  #define AOT_PC (code + 210)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_211
  label_209: {
    aot_vmfetch(0x00091c80);
    setobjs2s(L, ra, RB(i));
  }

  // 210	[119]	LOADK    	58 59	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 211)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_212
  label_210: {
    aot_vmfetch(0x001d9d03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 211	[119]	MOVE     	59 20
  #undef  AOT_PC
  #define AOT_PC (code + 212)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_213
  label_211: {
    aot_vmfetch(0x00141d80);
    setobjs2s(L, ra, RB(i));
  }

  // 212	[119]	LOADK    	60 62	; ")%s*$"
  #undef  AOT_PC
  #define AOT_PC (code + 213)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_214
  label_212: {
    aot_vmfetch(0x001f1e03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 213	[119]	CONCAT   	57 4
  #undef  AOT_PC
  #define AOT_PC (code + 214)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_215
  label_213: {
    aot_vmfetch(0x00041cb5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 214	[120]	MOVE     	58 9
  #undef  AOT_PC
  #define AOT_PC (code + 215)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_216
  label_214: {
    aot_vmfetch(0x00091d00);
    setobjs2s(L, ra, RB(i));
  }

  // 215	[120]	LOADK    	59 59	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 216)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_217
  label_215: {
    aot_vmfetch(0x001d9d83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 216	[120]	MOVE     	60 20
  #undef  AOT_PC
  #define AOT_PC (code + 217)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_218
  label_216: {
    aot_vmfetch(0x00141e00);
    setobjs2s(L, ra, RB(i));
  }

  // 217	[120]	LOADK    	61 60	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 218)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_219
  label_217: {
    aot_vmfetch(0x001e1e83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 218	[120]	MOVE     	62 18
  #undef  AOT_PC
  #define AOT_PC (code + 219)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_220
  label_218: {
    aot_vmfetch(0x00121f00);
    setobjs2s(L, ra, RB(i));
  }

  // 219	[120]	LOADK    	63 63	; "(.+)$"
  #undef  AOT_PC
  #define AOT_PC (code + 220)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_221
  label_219: {
    aot_vmfetch(0x001f9f83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 220	[120]	CONCAT   	58 6
  #undef  AOT_PC
  #define AOT_PC (code + 221)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_222
  label_220: {
    aot_vmfetch(0x00061d35);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 221	[121]	MOVE     	59 9
  #undef  AOT_PC
  #define AOT_PC (code + 222)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_223
  label_221: {
    aot_vmfetch(0x00091d80);
    setobjs2s(L, ra, RB(i));
  }

  // 222	[121]	LOADK    	60 59	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 223)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_224
  label_222: {
    aot_vmfetch(0x001d9e03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 223	[121]	MOVE     	61 20
  #undef  AOT_PC
  #define AOT_PC (code + 224)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_225
  label_223: {
    aot_vmfetch(0x00141e80);
    setobjs2s(L, ra, RB(i));
  }

  // 224	[121]	LOADK    	62 64	; ")%(([_%s%w,]*)%)%s*(.*)"
  #undef  AOT_PC
  #define AOT_PC (code + 225)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_226
  label_224: {
    aot_vmfetch(0x00201f03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 225	[121]	CONCAT   	59 4
  #undef  AOT_PC
  #define AOT_PC (code + 226)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_227
  label_225: {
    aot_vmfetch(0x00041db5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 226	[127]	NEWTABLE 	60 1 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 227)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_228
  label_226: {
    aot_vmfetch(0x00011e13);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 227	[127]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 228)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_229
  label_227: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 228	[127]	SETFIELD 	60 66 67k	; "lineno" 0
  #undef  AOT_PC
  #define AOT_PC (code + 229)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_230
  label_228: {
    aot_vmfetch(0x43429e12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 229	[127]	SETFIELD 	0 65 60	; "STATE"
  #undef  AOT_PC
  #define AOT_PC (code + 230)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_231
  label_229: {
    aot_vmfetch(0x3c410012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 230	[131]	CLOSURE  	60 6	; 0x7fe610f0d0b0
  #undef  AOT_PC
  #define AOT_PC (code + 231)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_232
  label_230: {
    aot_vmfetch(0x00031e4f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 231	[134]	CLOSURE  	61 7	; 0x7fe610f0d340
  #undef  AOT_PC
  #define AOT_PC (code + 232)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_233
  label_231: {
    aot_vmfetch(0x00039ecf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 232	[156]	CLOSURE  	62 8	; 0x7fe610f0d5d0
  #undef  AOT_PC
  #define AOT_PC (code + 233)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_234
  label_232: {
    aot_vmfetch(0x00041f4f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 233	[161]	CLOSURE  	63 9	; 0x7fe610f0ded0
  #undef  AOT_PC
  #define AOT_PC (code + 234)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_235
  label_233: {
    aot_vmfetch(0x00049fcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 234	[169]	CLOSURE  	64 10	; 0x7fe610f0e300
  #undef  AOT_PC
  #define AOT_PC (code + 235)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_236
  label_234: {
    aot_vmfetch(0x0005204f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 235	[175]	CLOSURE  	65 11	; 0x7fe610f0e510
  #undef  AOT_PC
  #define AOT_PC (code + 236)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_237
  label_235: {
    aot_vmfetch(0x0005a0cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 236	[181]	CLOSURE  	66 12	; 0x7fe610f0e700
  #undef  AOT_PC
  #define AOT_PC (code + 237)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_238
  label_236: {
    aot_vmfetch(0x0006214f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 237	[193]	CLOSURE  	67 13	; 0x7fe610f0e8b0
  #undef  AOT_PC
  #define AOT_PC (code + 238)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_239
  label_237: {
    aot_vmfetch(0x0006a1cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 238	[199]	CLOSURE  	68 14	; 0x7fe610f0eb60
  #undef  AOT_PC
  #define AOT_PC (code + 239)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_240
  label_238: {
    aot_vmfetch(0x0007224f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 239	[204]	CLOSURE  	69 15	; 0x7fe610f0ed50
  #undef  AOT_PC
  #define AOT_PC (code + 240)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_241
  label_239: {
    aot_vmfetch(0x0007a2cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 240	[214]	CLOSURE  	70 16	; 0x7fe610f0ef40
  #undef  AOT_PC
  #define AOT_PC (code + 241)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_242
  label_240: {
    aot_vmfetch(0x0008234f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 241	[297]	CLOSURE  	71 17	; 0x7fe610f0f2b0
  #undef  AOT_PC
  #define AOT_PC (code + 242)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_243
  label_241: {
    aot_vmfetch(0x0008a3cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 242	[300]	CLOSURE  	72 18	; 0x7fe611904420
  #undef  AOT_PC
  #define AOT_PC (code + 243)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_244
  label_242: {
    aot_vmfetch(0x0009244f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 243	[307]	NEWTABLE 	73 2 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 244)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_245
  label_243: {
    aot_vmfetch(0x00022493);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 244	[307]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 245)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_246
  label_244: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 245	[308]	SETFIELD 	73 68 14k	; "string" false
  #undef  AOT_PC
  #define AOT_PC (code + 246)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_247
  label_245: {
    aot_vmfetch(0x0e44a492);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 246	[309]	NEWTABLE 	74 3 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 247)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_248
  label_246: {
    aot_vmfetch(0x00032513);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 247	[309]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 248)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_249
  label_247: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 248	[310]	SETFIELD 	74 70 71k	; "MLCOMMENT" "^/%*.-%*/"
  #undef  AOT_PC
  #define AOT_PC (code + 249)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_250
  label_248: {
    aot_vmfetch(0x4746a512);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 249	[311]	SETFIELD 	74 72 73k	; "SLCOMMENT" "^//.-\n"
  #undef  AOT_PC
  #define AOT_PC (code + 250)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_251
  label_249: {
    aot_vmfetch(0x4948a512);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 250	[312]	SETFIELD 	74 74 75k	; "STRING_LITERAL" "^\"[^\"]*\""
  #undef  AOT_PC
  #define AOT_PC (code + 251)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_252
  label_250: {
    aot_vmfetch(0x4b4aa512);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 251	[313]	SETFIELD 	73 69 74	; "keywords"
  #undef  AOT_PC
  #define AOT_PC (code + 252)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_253
  label_251: {
    aot_vmfetch(0x4a452492);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 252	[330]	CLOSURE  	74 19	; 0x7fe611904810
  #undef  AOT_PC
  #define AOT_PC (code + 253)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_254
  label_252: {
    aot_vmfetch(0x0009a54f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 253	[333]	NEWTABLE 	75 3 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 254)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_255
  label_253: {
    aot_vmfetch(0x00032593);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 254	[333]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 255)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_256
  label_254: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 255	[334]	SETFIELD 	75 76 14k	; "string" false
  #undef  AOT_PC
  #define AOT_PC (code + 256)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_257
  label_255: {
    aot_vmfetch(0x0e4ca592);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 256	[335]	NEWTABLE 	76 0 7	; 7
  #undef  AOT_PC
  #define AOT_PC (code + 257)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_258
  label_256: {
    aot_vmfetch(0x07002613);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 257	[335]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 258)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_259
  label_257: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 258	[336]	LOADK    	77 74	; "STRING_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 259)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_260
  label_258: {
    aot_vmfetch(0x00252683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 259	[337]	LOADK    	78 78	; "CHAR_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 260)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_261
  label_259: {
    aot_vmfetch(0x00272703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 260	[338]	LOADK    	79 79	; "HEX_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 261)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_262
  label_260: {
    aot_vmfetch(0x0027a783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 261	[339]	LOADK    	80 80	; "BIN_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 262)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_263
  label_261: {
    aot_vmfetch(0x00282803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 262	[340]	LOADK    	81 81	; "OCT_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 263)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_264
  label_262: {
    aot_vmfetch(0x0028a883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 263	[341]	LOADK    	82 82	; "FPNUM_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 264)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_265
  label_263: {
    aot_vmfetch(0x00292903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 264	[343]	LOADK    	83 83	; "NUMBER_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 265)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_266
  label_264: {
    aot_vmfetch(0x0029a983);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 265	[343]	SETLIST  	76 7 0
  #undef  AOT_PC
  #define AOT_PC (code + 266)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_267
  label_265: {
    aot_vmfetch(0x0007264e);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 266	[343]	SETFIELD 	75 77 76	; "keywords_order"
  #undef  AOT_PC
  #define AOT_PC (code + 267)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_268
  label_266: {
    aot_vmfetch(0x4c4d2592);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 267	[344]	NEWTABLE 	76 4 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 268)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_269
  label_267: {
    aot_vmfetch(0x00042613);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 268	[344]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 269)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_270
  label_268: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 269	[345]	SETFIELD 	76 74 75k	; "STRING_LITERAL" "^\"[^\"]*\""
  #undef  AOT_PC
  #define AOT_PC (code + 270)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_271
  label_269: {
    aot_vmfetch(0x4b4aa612);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 270	[346]	SETFIELD 	76 78 84k	; "CHAR_LITERAL" "^L'.*'"
  #undef  AOT_PC
  #define AOT_PC (code + 271)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_272
  label_270: {
    aot_vmfetch(0x544ea612);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 271	[347]	SETFIELD 	76 79 85k	; "HEX_LITERAL" "^[%+%-]?%s*0x[a-fA-F%d]+[UL]*"
  #undef  AOT_PC
  #define AOT_PC (code + 272)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_273
  label_271: {
    aot_vmfetch(0x554fa612);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 272	[348]	SETFIELD 	76 80 86k	; "BIN_LITERAL" "^[%+%-]?%s*0b%d+[UL]*"
  #undef  AOT_PC
  #define AOT_PC (code + 273)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_274
  label_272: {
    aot_vmfetch(0x5650a612);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 273	[349]	SETFIELD 	76 81 87k	; "OCT_LITERAL" "^[%+%-]?%s*0%d+[UL]*"
  #undef  AOT_PC
  #define AOT_PC (code + 274)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_275
  label_273: {
    aot_vmfetch(0x5751a612);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 274	[350]	SETFIELD 	76 82 88k	; "FPNUM_LITERAL" "^[%+%-]?%s*%d+[%.]?%d*e[%+%-]%d*"
  #undef  AOT_PC
  #define AOT_PC (code + 275)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_276
  label_274: {
    aot_vmfetch(0x5852a612);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 275	[351]	SETFIELD 	76 83 89k	; "NUMBER_LITERAL" "^[%+%-]?%s*%d+[%.]?%d*[UL]+"
  #undef  AOT_PC
  #define AOT_PC (code + 276)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_277
  label_275: {
    aot_vmfetch(0x5953a612);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 276	[352]	SETFIELD 	75 69 76	; "keywords"
  #undef  AOT_PC
  #define AOT_PC (code + 277)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_278
  label_276: {
    aot_vmfetch(0x4c452592);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 277	[384]	CLOSURE  	76 20	; 0x7fe611905250
  #undef  AOT_PC
  #define AOT_PC (code + 278)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_279
  label_277: {
    aot_vmfetch(0x000a264f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 278	[426]	CLOSURE  	77 21	; 0x7fe611905670
  #undef  AOT_PC
  #define AOT_PC (code + 279)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_280
  label_278: {
    aot_vmfetch(0x000aa6cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 279	[429]	NEWTABLE 	78 1 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 280)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_281
  label_279: {
    aot_vmfetch(0x00012713);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 280	[429]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 281)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_282
  label_280: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 281	[430]	NEWTABLE 	79 1 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 282)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_283
  label_281: {
    aot_vmfetch(0x00012793);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 282	[430]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 283)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_284
  label_282: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 283	[431]	LOADK    	80 91	; "^defined%s*%(%s*"
  #undef  AOT_PC
  #define AOT_PC (code + 284)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_285
  label_283: {
    aot_vmfetch(0x002da803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 284	[431]	MOVE     	81 20
  #undef  AOT_PC
  #define AOT_PC (code + 285)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_286
  label_284: {
    aot_vmfetch(0x00142880);
    setobjs2s(L, ra, RB(i));
  }

  // 285	[431]	LOADK    	82 92	; "%s*%)"
  #undef  AOT_PC
  #define AOT_PC (code + 286)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_287
  label_285: {
    aot_vmfetch(0x002e2903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 286	[431]	CONCAT   	80 3
  #undef  AOT_PC
  #define AOT_PC (code + 287)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_288
  label_286: {
    aot_vmfetch(0x00032835);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 287	[431]	SETFIELD 	79 90 80	; "DEFINED"
  #undef  AOT_PC
  #define AOT_PC (code + 288)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_289
  label_287: {
    aot_vmfetch(0x505a2792);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 288	[432]	SETFIELD 	78 69 79	; "keywords"
  #undef  AOT_PC
  #define AOT_PC (code + 289)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_290
  label_288: {
    aot_vmfetch(0x4f452712);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 289	[494]	CLOSURE  	79 22	; 0x7fe6119064e0
  #undef  AOT_PC
  #define AOT_PC (code + 290)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_291
  label_289: {
    aot_vmfetch(0x000b27cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 290	[627]	CLOSURE  	80 23	; 0x7fe611906740
  #undef  AOT_PC
  #define AOT_PC (code + 291)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_292
  label_290: {
    aot_vmfetch(0x000ba84f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 291	[644]	CLOSURE  	81 24	; 0x7fe6119071e0
  #undef  AOT_PC
  #define AOT_PC (code + 292)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_293
  label_291: {
    aot_vmfetch(0x000c28cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 292	[652]	CLOSURE  	82 25	; 0x7fe611908470
  #undef  AOT_PC
  #define AOT_PC (code + 293)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_294
  label_292: {
    aot_vmfetch(0x000ca94f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 293	[669]	CLOSURE  	83 26	; 0x7fe611908690
  #undef  AOT_PC
  #define AOT_PC (code + 294)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_295
  label_293: {
    aot_vmfetch(0x000d29cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 294	[692]	NEWTABLE 	84 3 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 295)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_296
  label_294: {
    aot_vmfetch(0x00032a13);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 295	[692]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 296)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_297
  label_295: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 296	[693]	SETFIELD 	84 93 94k	; "string" true
  #undef  AOT_PC
  #define AOT_PC (code + 297)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_298
  label_296: {
    aot_vmfetch(0x5e5daa12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 297	[694]	NEWTABLE 	85 0 2	; 2
  #undef  AOT_PC
  #define AOT_PC (code + 298)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_299
  label_297: {
    aot_vmfetch(0x02002a93);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 298	[694]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 299)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_300
  label_298: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 299	[695]	LOADK    	86 95	; "CONCAT"
  #undef  AOT_PC
  #define AOT_PC (code + 300)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_301
  label_299: {
    aot_vmfetch(0x002fab03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 300	[697]	LOADK    	87 96	; "SPACE"
  #undef  AOT_PC
  #define AOT_PC (code + 301)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_302
  label_300: {
    aot_vmfetch(0x00302b83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 301	[697]	SETLIST  	85 2 0
  #undef  AOT_PC
  #define AOT_PC (code + 302)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_303
  label_301: {
    aot_vmfetch(0x00022ace);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 302	[697]	SETFIELD 	84 77 85	; "keywords_order"
  #undef  AOT_PC
  #define AOT_PC (code + 303)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_304
  label_302: {
    aot_vmfetch(0x554d2a12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 303	[698]	NEWTABLE 	85 2 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 304)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_305
  label_303: {
    aot_vmfetch(0x00022a93);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 304	[698]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 305)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_306
  label_304: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 305	[699]	SETFIELD 	85 95 97k	; "CONCAT" "^%s*##%s*"
  #undef  AOT_PC
  #define AOT_PC (code + 306)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_307
  label_305: {
    aot_vmfetch(0x615faa92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 306	[700]	SETFIELD 	85 96 98k	; "SPACE" "^%s"
  #undef  AOT_PC
  #define AOT_PC (code + 307)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_308
  label_306: {
    aot_vmfetch(0x6260aa92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 307	[701]	SETFIELD 	84 69 85	; "keywords"
  #undef  AOT_PC
  #define AOT_PC (code + 308)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_309
  label_307: {
    aot_vmfetch(0x55452a12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 308	[703]	NEWTABLE 	85 3 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 309)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_310
  label_308: {
    aot_vmfetch(0x00032a93);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 309	[703]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 310)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_311
  label_309: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 310	[704]	SETFIELD 	85 93 94k	; "string" true
  #undef  AOT_PC
  #define AOT_PC (code + 311)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_312
  label_310: {
    aot_vmfetch(0x5e5daa92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 311	[705]	NEWTABLE 	86 0 6	; 6
  #undef  AOT_PC
  #define AOT_PC (code + 312)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_313
  label_311: {
    aot_vmfetch(0x06002b13);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 312	[705]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 313)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_314
  label_312: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 313	[706]	LOADK    	87 74	; "STRING_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 314)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_315
  label_313: {
    aot_vmfetch(0x00252b83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 314	[707]	LOADK    	88 99	; "PARENTHESE"
  #undef  AOT_PC
  #define AOT_PC (code + 315)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_316
  label_314: {
    aot_vmfetch(0x0031ac03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 315	[708]	LOADK    	89 100	; "FUNCTIONAL"
  #undef  AOT_PC
  #define AOT_PC (code + 316)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_317
  label_315: {
    aot_vmfetch(0x00322c83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 316	[709]	LOADK    	90 101	; "ARGS"
  #undef  AOT_PC
  #define AOT_PC (code + 317)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_318
  label_316: {
    aot_vmfetch(0x0032ad03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 317	[710]	LOADK    	91 102	; "SINGLE_CHARACTER_ARGS"
  #undef  AOT_PC
  #define AOT_PC (code + 318)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_319
  label_317: {
    aot_vmfetch(0x00332d83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 318	[712]	LOADK    	92 103	; "COMMA"
  #undef  AOT_PC
  #define AOT_PC (code + 319)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_320
  label_318: {
    aot_vmfetch(0x0033ae03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 319	[712]	SETLIST  	86 6 0
  #undef  AOT_PC
  #define AOT_PC (code + 320)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_321
  label_319: {
    aot_vmfetch(0x00062b4e);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 320	[712]	SETFIELD 	85 77 86	; "keywords_order"
  #undef  AOT_PC
  #define AOT_PC (code + 321)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_322
  label_320: {
    aot_vmfetch(0x564d2a92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 321	[713]	NEWTABLE 	86 4 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 322)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_323
  label_321: {
    aot_vmfetch(0x00042b13);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 322	[713]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 323)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_324
  label_322: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 323	[714]	SETFIELD 	86 99 104k	; "PARENTHESE" "^%s*%b()"
  #undef  AOT_PC
  #define AOT_PC (code + 324)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_325
  label_323: {
    aot_vmfetch(0x6863ab12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 324	[715]	LOADK    	87 24	; "^"
  #undef  AOT_PC
  #define AOT_PC (code + 325)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_326
  label_324: {
    aot_vmfetch(0x000c2b83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 325	[715]	MOVE     	88 20
  #undef  AOT_PC
  #define AOT_PC (code + 326)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_327
  label_325: {
    aot_vmfetch(0x00142c00);
    setobjs2s(L, ra, RB(i));
  }

  // 326	[715]	LOADK    	89 105	; "%s*%b()"
  #undef  AOT_PC
  #define AOT_PC (code + 327)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_328
  label_326: {
    aot_vmfetch(0x0034ac83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 327	[715]	CONCAT   	87 3
  #undef  AOT_PC
  #define AOT_PC (code + 328)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_329
  label_327: {
    aot_vmfetch(0x00032bb5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 328	[715]	SETFIELD 	86 100 87	; "FUNCTIONAL"
  #undef  AOT_PC
  #define AOT_PC (code + 329)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_330
  label_328: {
    aot_vmfetch(0x57642b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 329	[716]	SETFIELD 	86 74 75k	; "STRING_LITERAL" "^\"[^\"]*\""
  #undef  AOT_PC
  #define AOT_PC (code + 330)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_331
  label_329: {
    aot_vmfetch(0x4b4aab12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 330	[717]	SETFIELD 	86 101 106k	; "ARGS" "^[^,%s][^,]*[^,%s]"
  #undef  AOT_PC
  #define AOT_PC (code + 331)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_332
  label_330: {
    aot_vmfetch(0x6a65ab12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 331	[718]	SETFIELD 	86 102 107k	; "SINGLE_CHARACTER_ARGS" "^[^,%s]"
  #undef  AOT_PC
  #define AOT_PC (code + 332)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_333
  label_331: {
    aot_vmfetch(0x6b66ab12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 332	[719]	SETFIELD 	86 103 108k	; "COMMA" "^,"
  #undef  AOT_PC
  #define AOT_PC (code + 333)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_334
  label_332: {
    aot_vmfetch(0x6c67ab12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 333	[720]	SETFIELD 	85 69 86	; "keywords"
  #undef  AOT_PC
  #define AOT_PC (code + 334)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_335
  label_333: {
    aot_vmfetch(0x56452a92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 334	[722]	NEWTABLE 	86 3 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 335)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_336
  label_334: {
    aot_vmfetch(0x00032b13);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 335	[722]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 336)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_337
  label_335: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 336	[723]	SETFIELD 	86 93 14k	; "string" false
  #undef  AOT_PC
  #define AOT_PC (code + 337)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_338
  label_336: {
    aot_vmfetch(0x0e5dab12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 337	[724]	NEWTABLE 	87 0 31	; 31
  #undef  AOT_PC
  #define AOT_PC (code + 338)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_339
  label_337: {
    aot_vmfetch(0x1f002b93);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 338	[724]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 339)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_340
  label_338: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 339	[725]	LOADK    	88 109	; "DEFINED"
  #undef  AOT_PC
  #define AOT_PC (code + 340)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_341
  label_339: {
    aot_vmfetch(0x0036ac03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 340	[726]	LOADK    	89 110	; "FUNCTIONAL_MACRO"
  #undef  AOT_PC
  #define AOT_PC (code + 341)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_342
  label_340: {
    aot_vmfetch(0x00372c83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 341	[727]	LOADK    	90 111	; "BROPEN"
  #undef  AOT_PC
  #define AOT_PC (code + 342)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_343
  label_341: {
    aot_vmfetch(0x0037ad03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 342	[728]	LOADK    	91 112	; "BRCLOSE"
  #undef  AOT_PC
  #define AOT_PC (code + 343)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_344
  label_342: {
    aot_vmfetch(0x00382d83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 343	[730]	LOADK    	92 113	; "TENARY_START"
  #undef  AOT_PC
  #define AOT_PC (code + 344)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_345
  label_343: {
    aot_vmfetch(0x0038ae03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 344	[731]	LOADK    	93 114	; "TENARY_MIDDLE"
  #undef  AOT_PC
  #define AOT_PC (code + 345)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_346
  label_344: {
    aot_vmfetch(0x00392e83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 345	[733]	LOADK    	94 115	; "EQUAL"
  #undef  AOT_PC
  #define AOT_PC (code + 346)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_347
  label_345: {
    aot_vmfetch(0x0039af03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 346	[734]	LOADK    	95 116	; "NOT_EQUAL"
  #undef  AOT_PC
  #define AOT_PC (code + 347)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_348
  label_346: {
    aot_vmfetch(0x003a2f83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 347	[735]	LOADK    	96 117	; "AND"
  #undef  AOT_PC
  #define AOT_PC (code + 348)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_349
  label_347: {
    aot_vmfetch(0x003ab003);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 348	[736]	LOADK    	97 118	; "OR"
  #undef  AOT_PC
  #define AOT_PC (code + 349)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_350
  label_348: {
    aot_vmfetch(0x003b3083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 349	[737]	LOADK    	98 119	; "BAND"
  #undef  AOT_PC
  #define AOT_PC (code + 350)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_351
  label_349: {
    aot_vmfetch(0x003bb103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 350	[738]	LOADK    	99 120	; "BOR"
  #undef  AOT_PC
  #define AOT_PC (code + 351)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_352
  label_350: {
    aot_vmfetch(0x003c3183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 351	[739]	LOADK    	100 121	; "BXOR"
  #undef  AOT_PC
  #define AOT_PC (code + 352)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_353
  label_351: {
    aot_vmfetch(0x003cb203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 352	[740]	LOADK    	101 122	; "PLUS"
  #undef  AOT_PC
  #define AOT_PC (code + 353)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_354
  label_352: {
    aot_vmfetch(0x003d3283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 353	[741]	LOADK    	102 123	; "MINUS"
  #undef  AOT_PC
  #define AOT_PC (code + 354)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_355
  label_353: {
    aot_vmfetch(0x003db303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 354	[742]	LOADK    	103 124	; "MULTIPLY"
  #undef  AOT_PC
  #define AOT_PC (code + 355)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_356
  label_354: {
    aot_vmfetch(0x003e3383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 355	[743]	LOADK    	104 125	; "DIV"
  #undef  AOT_PC
  #define AOT_PC (code + 356)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_357
  label_355: {
    aot_vmfetch(0x003eb403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 356	[744]	LOADK    	105 126	; "MOD"
  #undef  AOT_PC
  #define AOT_PC (code + 357)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_358
  label_356: {
    aot_vmfetch(0x003f3483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 357	[745]	LOADK    	106 127	; "LTE"
  #undef  AOT_PC
  #define AOT_PC (code + 358)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_359
  label_357: {
    aot_vmfetch(0x003fb503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 358	[746]	LOADK    	107 128	; "MTE"
  #undef  AOT_PC
  #define AOT_PC (code + 359)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_360
  label_358: {
    aot_vmfetch(0x00403583);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 359	[747]	LOADK    	108 129	; "LSHIFT"
  #undef  AOT_PC
  #define AOT_PC (code + 360)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_361
  label_359: {
    aot_vmfetch(0x0040b603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 360	[748]	LOADK    	109 130	; "RSHIFT"
  #undef  AOT_PC
  #define AOT_PC (code + 361)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_362
  label_360: {
    aot_vmfetch(0x00413683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 361	[749]	LOADK    	110 131	; "LT"
  #undef  AOT_PC
  #define AOT_PC (code + 362)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_363
  label_361: {
    aot_vmfetch(0x0041b703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 362	[750]	LOADK    	111 132	; "MT"
  #undef  AOT_PC
  #define AOT_PC (code + 363)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_364
  label_362: {
    aot_vmfetch(0x00423783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 363	[752]	LOADK    	112 133	; "NOT"
  #undef  AOT_PC
  #define AOT_PC (code + 364)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_365
  label_363: {
    aot_vmfetch(0x0042b803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 364	[753]	LOADK    	113 134	; "BNOT"
  #undef  AOT_PC
  #define AOT_PC (code + 365)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_366
  label_364: {
    aot_vmfetch(0x00433883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 365	[755]	LOADK    	114 74	; "STRING_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 366)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_367
  label_365: {
    aot_vmfetch(0x00253903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 366	[756]	LOADK    	115 135	; "CHAR_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 367)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_368
  label_366: {
    aot_vmfetch(0x0043b983);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 367	[757]	LOADK    	116 136	; "HEX_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 368)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_369
  label_367: {
    aot_vmfetch(0x00443a03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 368	[758]	LOADK    	117 82	; "FPNUM_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 369)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_370
  label_368: {
    aot_vmfetch(0x00293a83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 369	[760]	LOADK    	118 137	; "NUMBER_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 370)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_371
  label_369: {
    aot_vmfetch(0x0044bb03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 370	[760]	SETLIST  	87 31 0
  #undef  AOT_PC
  #define AOT_PC (code + 371)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_372
  label_370: {
    aot_vmfetch(0x001f2bce);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 371	[760]	SETFIELD 	86 77 87	; "keywords_order"
  #undef  AOT_PC
  #define AOT_PC (code + 372)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_373
  label_371: {
    aot_vmfetch(0x574d2b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 372	[761]	NEWTABLE 	87 6 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 373)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_374
  label_372: {
    aot_vmfetch(0x00062b93);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 373	[761]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 374)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_375
  label_373: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 374	[762]	SETFIELD 	87 109 138k	; "DEFINED" "^defined"
  #undef  AOT_PC
  #define AOT_PC (code + 375)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_376
  label_374: {
    aot_vmfetch(0x8a6dab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 375	[763]	LOADK    	88 24	; "^"
  #undef  AOT_PC
  #define AOT_PC (code + 376)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_377
  label_375: {
    aot_vmfetch(0x000c2c03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 376	[763]	MOVE     	89 20
  #undef  AOT_PC
  #define AOT_PC (code + 377)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_378
  label_376: {
    aot_vmfetch(0x00142c80);
    setobjs2s(L, ra, RB(i));
  }

  // 377	[763]	LOADK    	90 105	; "%s*%b()"
  #undef  AOT_PC
  #define AOT_PC (code + 378)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_379
  label_377: {
    aot_vmfetch(0x0034ad03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 378	[763]	CONCAT   	88 3
  #undef  AOT_PC
  #define AOT_PC (code + 379)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_380
  label_378: {
    aot_vmfetch(0x00032c35);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 379	[763]	SETFIELD 	87 110 88	; "FUNCTIONAL_MACRO"
  #undef  AOT_PC
  #define AOT_PC (code + 380)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_381
  label_379: {
    aot_vmfetch(0x586e2b92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 380	[764]	SETFIELD 	87 111 139k	; "BROPEN" "^[(]"
  #undef  AOT_PC
  #define AOT_PC (code + 381)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_382
  label_380: {
    aot_vmfetch(0x8b6fab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 381	[765]	SETFIELD 	87 112 140k	; "BRCLOSE" "^[)]"
  #undef  AOT_PC
  #define AOT_PC (code + 382)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_383
  label_381: {
    aot_vmfetch(0x8c70ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 382	[767]	SETFIELD 	87 113 141k	; "TENARY_START" "^%?"
  #undef  AOT_PC
  #define AOT_PC (code + 383)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_384
  label_382: {
    aot_vmfetch(0x8d71ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 383	[768]	SETFIELD 	87 114 142k	; "TENARY_MIDDLE" "^%:"
  #undef  AOT_PC
  #define AOT_PC (code + 384)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_385
  label_383: {
    aot_vmfetch(0x8e72ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 384	[770]	SETFIELD 	87 115 143k	; "EQUAL" "^=="
  #undef  AOT_PC
  #define AOT_PC (code + 385)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_386
  label_384: {
    aot_vmfetch(0x8f73ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 385	[771]	SETFIELD 	87 116 144k	; "NOT_EQUAL" "^!="
  #undef  AOT_PC
  #define AOT_PC (code + 386)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_387
  label_385: {
    aot_vmfetch(0x9074ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 386	[772]	SETFIELD 	87 117 145k	; "AND" "^&&"
  #undef  AOT_PC
  #define AOT_PC (code + 387)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_388
  label_386: {
    aot_vmfetch(0x9175ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 387	[773]	SETFIELD 	87 118 146k	; "OR" "^||"
  #undef  AOT_PC
  #define AOT_PC (code + 388)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_389
  label_387: {
    aot_vmfetch(0x9276ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 388	[774]	SETFIELD 	87 119 147k	; "BAND" "^&"
  #undef  AOT_PC
  #define AOT_PC (code + 389)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_390
  label_388: {
    aot_vmfetch(0x9377ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 389	[775]	SETFIELD 	87 120 148k	; "BOR" "^|"
  #undef  AOT_PC
  #define AOT_PC (code + 390)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_391
  label_389: {
    aot_vmfetch(0x9478ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 390	[776]	SETFIELD 	87 121 149k	; "BXOR" "^%^"
  #undef  AOT_PC
  #define AOT_PC (code + 391)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_392
  label_390: {
    aot_vmfetch(0x9579ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 391	[777]	SETFIELD 	87 122 150k	; "PLUS" "^%+"
  #undef  AOT_PC
  #define AOT_PC (code + 392)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_393
  label_391: {
    aot_vmfetch(0x967aab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 392	[778]	SETFIELD 	87 123 151k	; "MINUS" "^%-"
  #undef  AOT_PC
  #define AOT_PC (code + 393)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_394
  label_392: {
    aot_vmfetch(0x977bab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 393	[779]	SETFIELD 	87 124 152k	; "MULTIPLY" "^%*"
  #undef  AOT_PC
  #define AOT_PC (code + 394)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_395
  label_393: {
    aot_vmfetch(0x987cab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 394	[780]	SETFIELD 	87 125 153k	; "DIV" "^%/"
  #undef  AOT_PC
  #define AOT_PC (code + 395)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_396
  label_394: {
    aot_vmfetch(0x997dab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 395	[781]	SETFIELD 	87 126 154k	; "MOD" "^%%"
  #undef  AOT_PC
  #define AOT_PC (code + 396)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_397
  label_395: {
    aot_vmfetch(0x9a7eab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 396	[782]	SETFIELD 	87 127 155k	; "LTE" "^<="
  #undef  AOT_PC
  #define AOT_PC (code + 397)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_398
  label_396: {
    aot_vmfetch(0x9b7fab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 397	[783]	SETFIELD 	87 128 156k	; "MTE" "^>="
  #undef  AOT_PC
  #define AOT_PC (code + 398)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_399
  label_397: {
    aot_vmfetch(0x9c80ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 398	[784]	SETFIELD 	87 129 157k	; "LSHIFT" "^<<"
  #undef  AOT_PC
  #define AOT_PC (code + 399)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_400
  label_398: {
    aot_vmfetch(0x9d81ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 399	[785]	SETFIELD 	87 130 158k	; "RSHIFT" "^>>"
  #undef  AOT_PC
  #define AOT_PC (code + 400)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_401
  label_399: {
    aot_vmfetch(0x9e82ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 400	[786]	SETFIELD 	87 131 159k	; "LT" "^<"
  #undef  AOT_PC
  #define AOT_PC (code + 401)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_402
  label_400: {
    aot_vmfetch(0x9f83ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 401	[787]	SETFIELD 	87 132 160k	; "MT" "^>"
  #undef  AOT_PC
  #define AOT_PC (code + 402)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_403
  label_401: {
    aot_vmfetch(0xa084ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 402	[789]	SETFIELD 	87 133 161k	; "NOT" "^!"
  #undef  AOT_PC
  #define AOT_PC (code + 403)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_404
  label_402: {
    aot_vmfetch(0xa185ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 403	[790]	SETFIELD 	87 134 162k	; "BNOT" "^~"
  #undef  AOT_PC
  #define AOT_PC (code + 404)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_405
  label_403: {
    aot_vmfetch(0xa286ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 404	[792]	SETFIELD 	87 74 163k	; "STRING_LITERAL" "^L?\"[^\"]*\""
  #undef  AOT_PC
  #define AOT_PC (code + 405)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_406
  label_404: {
    aot_vmfetch(0xa34aab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 405	[793]	SETFIELD 	87 135 164k	; "CHAR_LITERAL" "^L?'.*'"
  #undef  AOT_PC
  #define AOT_PC (code + 406)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_407
  label_405: {
    aot_vmfetch(0xa487ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 406	[794]	SETFIELD 	87 136 165k	; "HEX_LITERAL" "^[%+%-]?0?x[a-fA-F%d]+[UL]*"
  #undef  AOT_PC
  #define AOT_PC (code + 407)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_408
  label_406: {
    aot_vmfetch(0xa588ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 407	[795]	SETFIELD 	87 82 166k	; "FPNUM_LITERAL" "^[%+%-]?%d+[%.]?%d*e[%+%-]%d*"
  #undef  AOT_PC
  #define AOT_PC (code + 408)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_409
  label_407: {
    aot_vmfetch(0xa652ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 408	[796]	SETFIELD 	87 137 167k	; "NUMBER_LITERAL" "^[%+%-]?0?b?%d+[%.]?%d*[UL]*"
  #undef  AOT_PC
  #define AOT_PC (code + 409)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_410
  label_408: {
    aot_vmfetch(0xa789ab92);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 409	[797]	SETFIELD 	86 69 87	; "keywords"
  #undef  AOT_PC
  #define AOT_PC (code + 410)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_411
  label_409: {
    aot_vmfetch(0x57452b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 410	[826]	CLOSURE  	87 27	; 0x7fe6119094f0
  #undef  AOT_PC
  #define AOT_PC (code + 411)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_412
  label_410: {
    aot_vmfetch(0x000dabcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 411	[880]	CLOSURE  	88 28	; 0x7fe611909980
  #undef  AOT_PC
  #define AOT_PC (code + 412)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_413
  label_411: {
    aot_vmfetch(0x000e2c4f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 412	[882]	LOADNIL  	89 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 413)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_414
  label_412: {
    aot_vmfetch(0x00002c88);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 413	[943]	CLOSURE  	90 29	; 0x7fe611909de0
  #undef  AOT_PC
  #define AOT_PC (code + 414)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_415
  label_413: {
    aot_vmfetch(0x000ead4f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 414	[943]	MOVE     	89 90
  #undef  AOT_PC
  #define AOT_PC (code + 415)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_416
  label_414: {
    aot_vmfetch(0x005a2c80);
    setobjs2s(L, ra, RB(i));
  }

  // 415	[954]	CLOSURE  	90 30	; 0x7fe61190a660
  #undef  AOT_PC
  #define AOT_PC (code + 416)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_417
  label_415: {
    aot_vmfetch(0x000f2d4f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 416	[960]	CLOSURE  	91 31	; 0x7fe61190a8e0
  #undef  AOT_PC
  #define AOT_PC (code + 417)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_418
  label_416: {
    aot_vmfetch(0x000fadcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 417	[1101]	CLOSURE  	92 32	; 0x7fe61190ac30
  #undef  AOT_PC
  #define AOT_PC (code + 418)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_419
  label_417: {
    aot_vmfetch(0x00102e4f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 418	[1120]	CLOSURE  	93 33	; 0x7fe61190b500
  #undef  AOT_PC
  #define AOT_PC (code + 419)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_420
  label_418: {
    aot_vmfetch(0x0010aecf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 419	[1145]	CLOSURE  	94 34	; 0x7fe61190b7c0
  #undef  AOT_PC
  #define AOT_PC (code + 420)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_421
  label_419: {
    aot_vmfetch(0x00112f4f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 420	[1178]	CLOSURE  	95 35	; 0x7fe61190bd60
  #undef  AOT_PC
  #define AOT_PC (code + 421)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_422
  label_420: {
    aot_vmfetch(0x0011afcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 421	[1257]	CLOSURE  	96 36	; 0x7fe61190c830
  #undef  AOT_PC
  #define AOT_PC (code + 422)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_423
  label_421: {
    aot_vmfetch(0x0012304f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 422	[1186]	SETFIELD 	0 168 96	; "init"
  #undef  AOT_PC
  #define AOT_PC (code + 423)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_424
  label_422: {
    aot_vmfetch(0x60a80012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 423	[1274]	CLOSURE  	96 37	; 0x7fe61190d870
  #undef  AOT_PC
  #define AOT_PC (code + 424)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_425
  label_423: {
    aot_vmfetch(0x0012b04f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 424	[1265]	SETFIELD 	0 169 96	; "compile"
  #undef  AOT_PC
  #define AOT_PC (code + 425)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_426
  label_424: {
    aot_vmfetch(0x60a90012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 425	[1288]	CLOSURE  	96 38	; 0x7fe61190e730
  #undef  AOT_PC
  #define AOT_PC (code + 426)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_427
  label_425: {
    aot_vmfetch(0x0013304f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 426	[1280]	SETFIELD 	0 170 96	; "compileFile"
  #undef  AOT_PC
  #define AOT_PC (code + 427)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_428
  label_426: {
    aot_vmfetch(0x60aa0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 427	[1321]	CLOSURE  	96 39	; 0x7fe61190ea00
  #undef  AOT_PC
  #define AOT_PC (code + 428)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_429
  label_427: {
    aot_vmfetch(0x0013b04f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 428	[1294]	SETFIELD 	0 171 96	; "test"
  #undef  AOT_PC
  #define AOT_PC (code + 429)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_430
  label_428: {
    aot_vmfetch(0x60ab0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 429	[1322]	GETFIELD 	96 0 172	; "PRE_TEST"
  #undef  AOT_PC
  #define AOT_PC (code + 430)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_431
  label_429: {
    aot_vmfetch(0xac00300e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 430	[1322]	TEST     	96 0
  #undef  AOT_PC
  #define AOT_PC (code + 431)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_435
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_432
  label_430: {
    aot_vmfetch(0x00003042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 431	[1322]	JMP      	3	; to 436
  #undef  AOT_PC
  #define AOT_PC (code + 432)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_433
  label_431: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_435;
  }

  // 432	[1322]	GETFIELD 	96 0 171	; "test"
  #undef  AOT_PC
  #define AOT_PC (code + 433)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_434
  label_432: {
    aot_vmfetch(0xab00300e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 433	[1322]	LOADTRUE 	97
  #undef  AOT_PC
  #define AOT_PC (code + 434)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_435
  label_433: {
    aot_vmfetch(0x00003087);
    setbtvalue(s2v(ra));
  }

  // 434	[1322]	CALL     	96 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 435)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_436
  label_434: {
    aot_vmfetch(0x01023044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 435	[1343]	CLOSURE  	96 40	; 0x7fe611905c50
  #undef  AOT_PC
  #define AOT_PC (code + 436)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_437
  label_435: {
    aot_vmfetch(0x0014304f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 436	[1343]	SETFIELD 	0 173 96	; "disable"
  #undef  AOT_PC
  #define AOT_PC (code + 437)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_438
  label_436: {
    aot_vmfetch(0x60ad0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 437	[1387]	CLOSURE  	96 41	; 0x7fe61190c560
  #undef  AOT_PC
  #define AOT_PC (code + 438)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_439
  label_437: {
    aot_vmfetch(0x0014b04f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 438	[1387]	SETFIELD 	0 174 96	; "enable"
  #undef  AOT_PC
  #define AOT_PC (code + 439)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_440
  label_438: {
    aot_vmfetch(0x60ae0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 439	[1389]	GETFIELD 	96 0 174	; "enable"
  #undef  AOT_PC
  #define AOT_PC (code + 440)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_441
  label_439: {
    aot_vmfetch(0xae00300e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 440	[1389]	CALL     	96 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 441)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_442
  label_440: {
    aot_vmfetch(0x01013044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 441	[1440]	CLOSURE  	96 42	; 0x7fe61190f360
  #undef  AOT_PC
  #define AOT_PC (code + 442)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_443
  label_441: {
    aot_vmfetch(0x0015304f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 442	[1392]	SETFIELD 	0 175 96	; "Interface"
  #undef  AOT_PC
  #define AOT_PC (code + 443)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_444
  label_442: {
    aot_vmfetch(0x60af0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 443	[1442]	RETURN   	0 2 1	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 444)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_443: {
    aot_vmfetch(0x01028046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 444	[1442]	RETURN   	96 1 1	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 445)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_444: {
    aot_vmfetch(0x0101b046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 6 - 9
static
CallInfo *magic_implementation_01(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
  }

  // 0	[7]	LTI      	1 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_07
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x007f00be);
    op_orderI(L, l_lti, luai_numlt, 0, TM_LT);
  }

  // 1	[7]	JMP      	5	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_07;
  }

  // 2	[7]	GETTABUP 	2 0 0	; bit "rshift"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 3	[7]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 4	[7]	UNM      	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010231);
    TValue *rb = vRB(i);
    lua_Number nb;
    if (ttisinteger(rb)) {
      lua_Integer ib = ivalue(rb);
      setivalue(s2v(ra), intop(-, 0, ib));
    }
    else if (tonumberns(rb, nb)) {
      setfltvalue(s2v(ra), luai_numunm(L, nb));
    }
    else
      Protect(luaT_trybinTM(L, rb, rb, ra, TM_UNM));
  }

  // 5	[7]	TAILCALL 	2 3 0	; 2 in
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00030145);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 6	[7]	RETURN   	2 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 7	[8]	LOADI    	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x80008101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 8	[8]	POW      	2 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x01020126);
    op_arithf(L, luai_numpow);
  }

  // 9	[8]	MMBIN    	2 1 10	; __pow
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0a01012e);
    Instruction pi = 0x01020126; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 10	[8]	MUL      	2 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x02000124);
    op_arith(L, l_muli, luai_nummul);
  }

  // 11	[8]	MMBIN    	0 2 8	; __mul
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0802002e);
    Instruction pi = 0x02000124; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 12	[8]	MODK     	2 2 1	; 4294967296.0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x01020119);
    op_arithK(L, luaV_mod, luaV_modf);
  }

  // 13	[8]	MMBINK   	2 1 9 0	; __mod 4294967296.0
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x09010130);
    Instruction pi = 0x01020119;  /* original arith. expression */
    TValue *imm = KB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 14	[8]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 15	[9]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 10 - 13
static
CallInfo *magic_implementation_02(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
  }

  // 0	[11]	LTI      	1 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_07
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x007f00be);
    op_orderI(L, l_lti, luai_numlt, 0, TM_LT);
  }

  // 1	[11]	JMP      	5	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_07;
  }

  // 2	[11]	GETTABUP 	2 0 0	; bit "lshift"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 3	[11]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 4	[11]	UNM      	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010231);
    TValue *rb = vRB(i);
    lua_Number nb;
    if (ttisinteger(rb)) {
      lua_Integer ib = ivalue(rb);
      setivalue(s2v(ra), intop(-, 0, ib));
    }
    else if (tonumberns(rb, nb)) {
      setfltvalue(s2v(ra), luai_numunm(L, nb));
    }
    else
      Protect(luaT_trybinTM(L, rb, rb, ra, TM_UNM));
  }

  // 5	[11]	TAILCALL 	2 3 0	; 2 in
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00030145);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 6	[11]	RETURN   	2 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 7	[12]	GETTABUP 	2 1 1	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0101010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[12]	GETFIELD 	2 2 2	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0202010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 9	[12]	MODK     	3 0 3	; 4294967296.0
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x03000199);
    op_arithK(L, luaV_mod, luaV_modf);
  }

  // 10	[12]	MMBINK   	0 3 9 0	; __mod 4294967296.0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x09030030);
    Instruction pi = 0x03000199;  /* original arith. expression */
    TValue *imm = KB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 11	[12]	LOADI    	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80008201);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 12	[12]	POW      	4 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x01040226);
    op_arithf(L, luai_numpow);
  }

  // 13	[12]	MMBIN    	4 1 10	; __pow
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0a01022e);
    Instruction pi = 0x01040226; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 14	[12]	DIV      	3 3 4
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x040301a7);
    op_arithf(L, luai_numdiv);
  }

  // 15	[12]	MMBIN    	3 4 11	; __div
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x0b0401ae);
    Instruction pi = 0x040301a7; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 16	[12]	TAILCALL 	2 2 0	; 1 in
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00020145);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 17	[12]	RETURN   	2 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_17: {
    aot_vmfetch(0x00000146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 18	[13]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_18: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 14 - 35
static
CallInfo *magic_implementation_03(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
  }

  // 0	[16]	LOADI    	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x7fff8101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 1	[17]	LOADI    	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x7fff8181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 2	[17]	LOADI    	4 31
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x800f0201);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 3	[17]	LOADI    	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x80000281);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 4	[17]	FORPREP  	3 36	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x001201ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_42; /* skip the loop */
  }

  // 5	[18]	MODK     	7 0 0	; 2
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000399);
    op_arithK(L, luaV_mod, luaV_modf);
  }

  // 6	[18]	MMBINK   	0 0 9 0	; __mod 2
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x09000030);
    Instruction pi = 0x00000399;  /* original arith. expression */
    TValue *imm = KB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 7	[18]	EQI      	7 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_21
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x007f03bd);
    int cond;
    int im = GETARG_sB(i);
    if (ttisinteger(s2v(ra)))
      cond = (ivalue(s2v(ra)) == im);
    else if (ttisfloat(s2v(ra)))
      cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));
    else
      cond = 0;  /* other types cannot be equal to a number */
    docondjump();
  }

  // 8	[18]	JMP      	12	; to 22
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_21;
  }

  // 9	[19]	MODK     	7 1 0	; 2
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00010399);
    op_arithK(L, luaV_mod, luaV_modf);
  }

  // 10	[19]	MMBINK   	1 0 9 0	; __mod 2
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x090000b0);
    Instruction pi = 0x00010399;  /* original arith. expression */
    TValue *imm = KB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 11	[19]	EQI      	7 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_35
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x008003bd);
    int cond;
    int im = GETARG_sB(i);
    if (ttisinteger(s2v(ra)))
      cond = (ivalue(s2v(ra)) == im);
    else if (ttisfloat(s2v(ra)))
      cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));
    else
      cond = 0;  /* other types cannot be equal to a number */
    docondjump();
  }

  // 12	[19]	JMP      	22	; to 36
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x80000ab8);
    updatetrap(ci);
    goto label_35;
  }

  // 13	[20]	ADDI     	1 1 -1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x7e010095);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 14	[20]	MMBINI   	1 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x078000af);
    Instruction pi = 0x7e010095;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 15	[21]	LOADI    	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80008381);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 16	[21]	POW      	7 7 6
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x060703a6);
    op_arithf(L, luai_numpow);
  }

  // 17	[21]	MMBIN    	7 6 10	; __pow
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0a0603ae);
    Instruction pi = 0x060703a6; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 18	[21]	ADD      	2 2 7
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x07020122);
    op_arith(L, l_addi, luai_numadd);
  }

  // 19	[21]	MMBIN    	2 7 6	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_35
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0607012e);
    Instruction pi = 0x07020122; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 20	[23]	JMP      	14	; to 36
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x800006b8);
    updatetrap(ci);
    goto label_35;
  }

  // 21	[24]	ADDI     	0 0 -1
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x7e000015);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 22	[24]	MMBINI   	0 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0780002f);
    Instruction pi = 0x7e000015;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 23	[25]	MODK     	7 1 0	; 2
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00010399);
    op_arithK(L, luaV_mod, luaV_modf);
  }

  // 24	[25]	MMBINK   	1 0 9 0	; __mod 2
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x090000b0);
    Instruction pi = 0x00010399;  /* original arith. expression */
    TValue *imm = KB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 25	[25]	EQI      	7 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_33
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x007f03bd);
    int cond;
    int im = GETARG_sB(i);
    if (ttisinteger(s2v(ra)))
      cond = (ivalue(s2v(ra)) == im);
    else if (ttisfloat(s2v(ra)))
      cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));
    else
      cond = 0;  /* other types cannot be equal to a number */
    docondjump();
  }

  // 26	[25]	JMP      	6	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_33;
  }

  // 27	[26]	LOADI    	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x80008381);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 28	[26]	POW      	7 7 6
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x060703a6);
    op_arithf(L, luai_numpow);
  }

  // 29	[26]	MMBIN    	7 6 10	; __pow
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0a0603ae);
    Instruction pi = 0x060703a6; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 30	[26]	ADD      	2 2 7
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x07020122);
    op_arith(L, l_addi, luai_numadd);
  }

  // 31	[26]	MMBIN    	2 7 6	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_35
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x0607012e);
    Instruction pi = 0x07020122; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 32	[27]	JMP      	2	; to 36
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_35;
  }

  // 33	[28]	ADDI     	1 1 -1
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x7e010095);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 34	[28]	MMBINI   	1 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x078000af);
    Instruction pi = 0x7e010095;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 35	[31]	MOVE     	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x00010380);
    setobjs2s(L, ra, RB(i));
  }

  // 36	[31]	DIVK     	1 7 0	; 2
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x0007009b);
    op_arithfK(L, luai_numdiv);
  }

  // 37	[31]	MMBINK   	7 0 11 0	; __div 2
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x0b0003b0);
    Instruction pi = 0x0007009b;  /* original arith. expression */
    TValue *imm = KB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 38	[32]	MOVE     	7 0
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00000380);
    setobjs2s(L, ra, RB(i));
  }

  // 39	[32]	DIVK     	0 7 0	; 2
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x0007001b);
    op_arithfK(L, luai_numdiv);
  }

  // 40	[32]	MMBINK   	7 0 11 0	; __div 2
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x0b0003b0);
    Instruction pi = 0x0007001b;  /* original arith. expression */
    TValue *imm = KB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 41	[17]	FORLOOP  	3 37	; to 6
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x001281c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_05; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_05; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 42	[34]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_42: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 43	[35]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_43: {
    aot_vmfetch(0x000101c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 36 - 39
static
CallInfo *magic_implementation_04(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
  }

  // 0	[38]	LOADI    	1 -1
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x7fff0081);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 1	[38]	SUB      	1 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x000100a3);
    op_arith(L, l_subi, luai_numsub);
  }

  // 2	[38]	MMBIN    	1 0 7	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x070000ae);
    Instruction pi = 0x000100a3; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 3	[38]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 4	[39]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_04: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 40 - 42
static
CallInfo *magic_implementation_05(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
  }

  // 0	[41]	ADD      	2 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x01000122);
    op_arith(L, l_addi, luai_numadd);
  }

  // 1	[41]	MMBIN    	0 1 6	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0601002e);
    Instruction pi = 0x01000122; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 2	[41]	GETTABUP 	3 0 0	; bit "bxor"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 3	[41]	MOVE     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000200);
    setobjs2s(L, ra, RB(i));
  }

  // 4	[41]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 5	[41]	CALL     	3 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x020301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[41]	SUB      	2 2 3
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x03020123);
    op_arith(L, l_subi, luai_numsub);
  }

  // 7	[41]	MMBIN    	2 3 7	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0703012e);
    Instruction pi = 0x03020123; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 8	[41]	DIVK     	2 2 1	; 2
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0102011b);
    op_arithfK(L, luai_numdiv);
  }

  // 9	[41]	MMBINK   	2 1 11 0	; __div 2
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0b010130);
    Instruction pi = 0x0102011b;  /* original arith. expression */
    TValue *imm = KB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 10	[41]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_10: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 11	[42]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 43 - 45
static
CallInfo *magic_implementation_06(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
  }

  // 0	[44]	GETTABUP 	2 0 0	; bit "bnot"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[44]	GETTABUP 	3 0 1	; bit "band"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0100018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[44]	GETTABUP 	4 0 0	; bit "bnot"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0000020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 3	[44]	MOVE     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000280);
    setobjs2s(L, ra, RB(i));
  }

  // 4	[44]	CALL     	4 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[44]	GETTABUP 	5 0 0	; bit "bnot"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0000028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[44]	MOVE     	6 1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010300);
    setobjs2s(L, ra, RB(i));
  }

  // 7	[44]	CALL     	5 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[44]	CALL     	3 0 0	; all in all out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x000001c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[44]	TAILCALL 	2 0 0	; -1 in
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000145);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 10	[44]	RETURN   	2 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_10: {
    aot_vmfetch(0x00000146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 11	[45]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 128 - 131
static
CallInfo *magic_implementation_07(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
  }

  // 0	[129]	GETTABUP 	1 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[129]	GETTABUP 	2 0 1	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[129]	GETFIELD 	2 2 2	; "format"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0202010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[129]	LOADK    	3 3	; "\027[1;31mpreprocessor (ERROR) [%04i] %s\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[129]	GETTABUP 	4 1 4	; preprocessor "STATE"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0401020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 5	[129]	GETFIELD 	4 4 5	; "lineno"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0504020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 6	[129]	MOVE     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000280);
    setobjs2s(L, ra, RB(i));
  }

  // 7	[129]	CALL     	2 4 0	; 3 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00040144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[129]	CALL     	1 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x010000c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[130]	GETTABUP 	1 0 6	; _ENV "os"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0600008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 10	[130]	GETFIELD 	1 1 7	; "exit"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0701008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[130]	LOADI    	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 12	[130]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 13	[131]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 132 - 134
static
CallInfo *magic_implementation_08(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
  }

  // 0	[133]	GETTABUP 	1 0 0	; _ENV "_G"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[133]	GETFIELD 	1 1 1	; "print"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[133]	GETTABUP 	2 0 2	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0200010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 3	[133]	GETFIELD 	2 2 3	; "format"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0302010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[133]	LOADK    	3 4	; "preprocessor (LOG) [%04i] %s"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00020183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[133]	GETTABUP 	4 1 5	; preprocessor "STATE"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0501020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[133]	GETFIELD 	4 4 6	; "lineno"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0604020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[133]	MOVE     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000280);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[133]	CALL     	2 4 0	; 3 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00040144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[133]	CALL     	1 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x010000c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[134]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_10: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 137 - 156
static
CallInfo *magic_implementation_09(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
  }

  // 0	[154]	CLOSURE  	2 0	; 0x7fe610f0d6a0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000014f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 1	[155]	GETTABUP 	3 0 0	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[155]	GETFIELD 	3 3 1	; "wrap"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0103018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[155]	CLOSURE  	4 1	; 0x7fe610f0de20
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0000824f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 4	[155]	TAILCALL 	3 2 0	; 1 in
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000281c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 5	[155]	RETURN   	3 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_05: {
    aot_vmfetch(0x000081c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 6	[156]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 138 - 154
static
CallInfo *magic_implementation_10(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
  }

  // 0	[139]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 1	[139]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 2	[140]	LOADK    	3 0	; "(.-)"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 3	[140]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 4	[140]	CONCAT   	3 2
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000201b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 5	[141]	LOADI    	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000201);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 6	[142]	SELF     	5 0 1k	; "find"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x01008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[142]	MOVE     	7 3
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00030380);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[142]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 9	[142]	CALL     	5 4 4	; 3 in 3 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x040402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[143]	TEST     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_30
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000002c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 11	[143]	JMP      	18	; to 31
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x800008b8);
    updatetrap(ci);
    goto label_30;
  }

  // 12	[144]	EQI      	5 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_16
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x008002bd);
    int cond;
    int im = GETARG_sB(i);
    if (ttisinteger(s2v(ra)))
      cond = (ivalue(s2v(ra)) == im);
    else if (ttisfloat(s2v(ra)))
      cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));
    else
      cond = 0;  /* other types cannot be equal to a number */
    docondjump();
  }

  // 13	[144]	JMP      	2	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_16;
  }

  // 14	[144]	EQK      	7 2 1	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_20
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x000283bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 15	[144]	JMP      	4	; to 21
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_20;
  }

  // 16	[145]	GETTABUP 	8 0 3	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0300040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[145]	GETFIELD 	8 8 4	; "yield"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0408040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 18	[145]	MOVE     	9 7
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00070480);
    setobjs2s(L, ra, RB(i));
  }

  // 19	[145]	CALL     	8 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x01020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[147]	ADDI     	4 6 1
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x80060215);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 21	[147]	MMBINI   	6 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0680032f);
    Instruction pi = 0x80060215;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 22	[148]	SELF     	8 0 1k	; "find"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x01008414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 23	[148]	MOVE     	10 3
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00030500);
    setobjs2s(L, ra, RB(i));
  }

  // 24	[148]	MOVE     	11 4
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00040580);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[148]	CALL     	8 4 4	; 3 in 3 out
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x04040444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 26	[148]	MOVE     	7 10
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x000a0380);
    setobjs2s(L, ra, RB(i));
  }

  // 27	[148]	MOVE     	6 9
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00090300);
    setobjs2s(L, ra, RB(i));
  }

  // 28	[148]	MOVE     	5 8
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00080280);
    setobjs2s(L, ra, RB(i));
  }

  // 29	[149]	JMP      	-20	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x7ffff5b8);
    updatetrap(ci);
    goto label_10;
  }

  // 30	[150]	LEN      	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00000434);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 31	[150]	LE       	4 8 0
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_41
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x0008023b);
    op_order(L, l_lei, LEnum, lessequalothers);
  }

  // 32	[150]	JMP      	8	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_41;
  }

  // 33	[151]	SELF     	8 0 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x05008414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 34	[151]	MOVE     	10 4
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00040500);
    setobjs2s(L, ra, RB(i));
  }

  // 35	[151]	CALL     	8 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x02030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 36	[151]	MOVE     	7 8
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00080380);
    setobjs2s(L, ra, RB(i));
  }

  // 37	[152]	GETTABUP 	8 0 3	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x0300040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 38	[152]	GETFIELD 	8 8 4	; "yield"
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x0408040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 39	[152]	MOVE     	9 7
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00070480);
    setobjs2s(L, ra, RB(i));
  }

  // 40	[152]	CALL     	8 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_40: {
    aot_vmfetch(0x01020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 41	[154]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_41: {
    aot_vmfetch(0x00010447);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 155 - 155
static
CallInfo *magic_implementation_11(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
  }

  // 0	[155]	GETUPVAL 	0 0	; _split
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[155]	GETUPVAL 	1 1	; str
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 2	[155]	GETUPVAL 	2 2	; pat
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[155]	CALL     	0 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x01030044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[155]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_04: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 157 - 161
static
CallInfo *magic_implementation_12(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
  }

  // 0	[158]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 1	[158]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 2	[159]	GETUPVAL 	3 0	; gsplit
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[159]	MOVE     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000200);
    setobjs2s(L, ra, RB(i));
  }

  // 4	[159]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 5	[159]	CALL     	3 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x050301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[159]	TFORPREP 	3 5	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000281cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_12;
  }

  // 7	[159]	GETTABUP 	8 1 0	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0001040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[159]	GETFIELD 	8 8 1	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0108040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 9	[159]	MOVE     	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00020480);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[159]	MOVE     	10 7
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00070500);
    setobjs2s(L, ra, RB(i));
  }

  // 11	[159]	CALL     	8 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x01030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[159]	TFORCALL 	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x010001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 13	[159]	TFORLOOP 	3 7	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000381cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_07; /* jump back */
    }
  }

  // 14	[159]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 15	[160]	RETURN   	2 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x00028146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 16	[161]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_16: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 165 - 169
static
CallInfo *magic_implementation_13(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
  }

  // 0	[166]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_04
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 1	[166]	JMP      	2	; to 5
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_04;
  }

  // 2	[166]	LOADFALSE	3
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000185);
    setbfvalue(s2v(ra));
  }

  // 3	[166]	RETURN1  	3
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000201c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 4	[167]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_07
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 5	[167]	JMP      	1	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_07;
  }

  // 6	[167]	LOADI    	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x7fff8101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 7	[168]	GETTABUP 	3 0 0	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[168]	GETFIELD 	3 3 1	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0103018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 9	[168]	MOVE     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000200);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[168]	ADDI     	5 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80020295);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 11	[168]	MMBINI   	2 1 6 1	; __add flip
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0680812f);
    Instruction pi = 0x80020295;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 12	[168]	GETTABUP 	6 0 0	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0000030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[168]	GETFIELD 	6 6 2	; "len"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0206030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 14	[168]	MOVE     	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00010380);
    setobjs2s(L, ra, RB(i));
  }

  // 15	[168]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[168]	ADD      	6 6 2
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x02060322);
    op_arith(L, l_addi, luai_numadd);
  }

  // 17	[168]	MMBIN    	6 2 6	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0602032e);
    Instruction pi = 0x02060322; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 18	[168]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[168]	EQ       	3 1 1
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000181b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 20	[168]	JMP      	1	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_22;
  }

  // 21	[168]	LFALSESKIP	3
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00000186);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 22	[168]	LOADTRUE 	3
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00000187);
    setbtvalue(s2v(ra));
  }

  // 23	[168]	RETURN1  	3
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_23: {
    aot_vmfetch(0x000201c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 24	[169]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_24: {
    aot_vmfetch(0x000101c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 172 - 175
static
CallInfo *magic_implementation_14(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
  }

  // 0	[173]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_04
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 1	[173]	JMP      	2	; to 5
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_04;
  }

  // 2	[173]	LOADFALSE	2
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000105);
    setbfvalue(s2v(ra));
  }

  // 3	[173]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 4	[174]	EQK      	1 0 1	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_18
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000080bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 5	[174]	JMP      	12	; to 19
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_18;
  }

  // 6	[174]	GETTABUP 	2 0 1	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[174]	GETFIELD 	2 2 2	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0202010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[174]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[174]	GETTABUP 	4 0 1	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0100020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 10	[174]	GETFIELD 	4 4 3	; "len"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0304020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[174]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[174]	CALL     	4 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x02020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 13	[174]	UNM      	4 4
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00040231);
    TValue *rb = vRB(i);
    lua_Number nb;
    if (ttisinteger(rb)) {
      lua_Integer ib = ivalue(rb);
      setivalue(s2v(ra), intop(-, 0, ib));
    }
    else if (tonumberns(rb, nb)) {
      setfltvalue(s2v(ra), luai_numunm(L, nb));
    }
    else
      Protect(luaT_trybinTM(L, rb, rb, ra, TM_UNM));
  }

  // 14	[174]	CALL     	2 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x02030144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 15	[174]	EQ       	2 1 1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_18
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00018139);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 16	[174]	JMP      	1	; to 19
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_18;
  }

  // 17	[174]	LFALSESKIP	2
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00000106);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 18	[174]	LOADTRUE 	2
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00000107);
    setbtvalue(s2v(ra));
  }

  // 19	[174]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_19: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 20	[175]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_20: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 178 - 181
static
CallInfo *magic_implementation_15(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
  }

  // 0	[179]	SELF     	1 0 0k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00008094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 1	[179]	LOADK    	3 1	; "^%s*()"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[179]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[180]	LEN      	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000134);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 4	[180]	LT       	2 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_09
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0001013a);
    op_order(L, l_lti, LTnum, lessthanothers);
  }

  // 5	[180]	JMP      	3	; to 10
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_09;
  }

  // 6	[180]	LOADK    	2 2	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[180]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 8	[180]	JMP      	4	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_13;
  }

  // 9	[180]	SELF     	2 0 0k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00008114);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 10	[180]	LOADK    	4 3	; ".*%S"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00018203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[180]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[180]	CALL     	2 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x02040144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 13	[180]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 14	[181]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 184 - 193
static
CallInfo *magic_implementation_16(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
  }

  // 0	[185]	LOADI    	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x7fff8101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 1	[186]	LOADI    	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x7fff8181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 2	[187]	LOADNIL  	4 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000208);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 3	[189]	GETTABUP 	5 0 0	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0000028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[189]	GETFIELD 	5 5 1	; "find"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0105028e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[189]	MOVE     	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000300);
    setobjs2s(L, ra, RB(i));
  }

  // 6	[189]	MOVE     	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010380);
    setobjs2s(L, ra, RB(i));
  }

  // 7	[189]	ADDI     	8 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x80030415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 8	[189]	MMBINI   	3 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x068001af);
    Instruction pi = 0x80030415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 9	[189]	LOADTRUE 	9
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000487);
    setbtvalue(s2v(ra));
  }

  // 10	[189]	CALL     	5 5 3	; 4 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x030502c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 11	[189]	MOVE     	3 6
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00060180);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[189]	MOVE     	4 5
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00050200);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[190]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_16
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 14	[190]	JMP      	1	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_16;
  }

  // 15	[190]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 16	[191]	ADDI     	2 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x80020115);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 17	[191]	MMBINI   	2 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_03
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0680012f);
    Instruction pi = 0x80020115;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 18	[192]	JMP      	-16	; to 4
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_18: {
    aot_vmfetch(0x7ffff7b8);
    updatetrap(ci);
    goto label_03;
  }

  // 19	[193]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_19: {
    aot_vmfetch(0x000102c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 196 - 199
static
CallInfo *magic_implementation_17(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
  }

  // 0	[198]	SELF     	1 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00008094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 1	[198]	LOADK    	3 1	; "\"("
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[198]	GETUPVAL 	4 0	; STRING_LITERAL
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[198]	LOADK    	5 2	; ")\""
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00010283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[198]	GETUPVAL 	6 1	; OPTSPACES
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 5	[198]	LOADK    	7 1	; "\"("
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00008383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[198]	GETUPVAL 	8 0	; STRING_LITERAL
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[198]	LOADK    	9 2	; ")\""
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00010483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 8	[198]	CONCAT   	3 7
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x000701b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 9	[198]	LOADK    	4 3	; "\"%1%2\""
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00018203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 10	[198]	TAILCALL 	1 4 0	; 3 in
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000400c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 11	[198]	RETURN   	1 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x000000c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 12	[199]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 202 - 204
static
CallInfo *magic_implementation_18(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
  }

  // 0	[203]	TESTSET  	1 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x000000c3);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 1	[203]	JMP      	4	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_06;
  }

  // 2	[203]	EQI      	0 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_05
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x007f003d);
    int cond;
    int im = GETARG_sB(i);
    if (ttisinteger(s2v(ra)))
      cond = (ivalue(s2v(ra)) == im);
    else if (ttisfloat(s2v(ra)))
      cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));
    else
      cond = 0;  /* other types cannot be equal to a number */
    docondjump();
  }

  // 3	[203]	JMP      	1	; to 6
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_05;
  }

  // 4	[203]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 5	[203]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 6	[203]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 7	[204]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 207 - 214
static
CallInfo *magic_implementation_19(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
  }

  // 0	[208]	GETTABUP 	1 0 0	; _ENV "pcall"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[208]	GETTABUP 	2 0 1	; _ENV "loadstring"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[208]	LOADK    	3 2	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 3	[208]	GETTABUP 	4 0 3	; _ENV "parseCInteger"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0300020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[208]	MOVE     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00000280);
    setobjs2s(L, ra, RB(i));
  }

  // 5	[208]	CALL     	4 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[208]	CONCAT   	3 2
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000201b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 7	[208]	CALL     	1 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x030300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[209]	TEST     	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_16
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x000000c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 9	[209]	JMP      	6	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_16;
  }

  // 10	[209]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_16
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 11	[209]	JMP      	4	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_16;
  }

  // 12	[210]	MOVE     	3 2
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00020180);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[210]	TAILCALL 	3 1 0	; 0 in
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000101c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 14	[210]	RETURN   	3 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_19
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x000001c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 15	[211]	JMP      	3	; to 20
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_19;
  }

  // 16	[212]	GETUPVAL 	3 1	; error
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00010189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 17	[212]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 18	[212]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_18: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[214]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_19: {
    aot_vmfetch(0x000101c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 217 - 297
static
CallInfo *magic_implementation_20(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
    case 132: goto label_132;
    case 133: goto label_133;
    case 134: goto label_134;
    case 135: goto label_135;
    case 136: goto label_136;
    case 137: goto label_137;
    case 138: goto label_138;
    case 139: goto label_139;
    case 140: goto label_140;
    case 141: goto label_141;
    case 142: goto label_142;
    case 143: goto label_143;
    case 144: goto label_144;
    case 145: goto label_145;
    case 146: goto label_146;
    case 147: goto label_147;
    case 148: goto label_148;
    case 149: goto label_149;
    case 150: goto label_150;
    case 151: goto label_151;
    case 152: goto label_152;
    case 153: goto label_153;
    case 154: goto label_154;
  }

  // 0	[218]	NEWTABLE 	2 4 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00040113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 1	[218]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 2	[220]	SETFIELD 	2 0 1k	; "identifier" "^[_%a][_%w]*"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x01008112);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 3	[221]	SETFIELD 	2 2 3k	; "number" "^[%+%-]?%d+[%.]?%d*[UL]*"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x03028112);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 4	[222]	SETFIELD 	2 4 5k	; "ignore" "^%s+"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x05048112);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 5	[223]	SETFIELD 	2 6 7k	; "string" true
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x07068112);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 6	[224]	NEWTABLE 	3 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000193);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 7	[224]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 8	[227]	SETFIELD 	2 8 3	; "keywords"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x03080112);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 9	[229]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 10	[229]	JMP      	1	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_12;
  }

  // 11	[230]	MOVE     	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00020080);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[232]	GETFIELD 	3 1 0	; "identifier"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0001018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 13	[232]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_16
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 14	[232]	JMP      	1	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_16;
  }

  // 15	[232]	GETFIELD 	3 2 0	; "identifier"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x0002018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 16	[232]	SETFIELD 	1 0 3	; "identifier"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x03000092);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 17	[233]	GETFIELD 	3 1 2	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0201018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 18	[233]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_21
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 19	[233]	JMP      	1	; to 22
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_21;
  }

  // 20	[233]	GETFIELD 	3 2 2	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0202018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 21	[233]	SETFIELD 	1 2 3	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x03020092);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 22	[234]	GETFIELD 	3 1 4	; "ignore"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0401018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 23	[234]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_26
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 24	[234]	JMP      	1	; to 27
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_26;
  }

  // 25	[234]	GETFIELD 	3 2 4	; "ignore"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x0402018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 26	[234]	SETFIELD 	1 4 3	; "ignore"
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x03040092);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 27	[235]	GETFIELD 	3 1 6	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0601018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 28	[235]	EQK      	3 9 0	; null
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_31
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x000901bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 29	[235]	JMP      	1	; to 32
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_31;
  }

  // 30	[235]	SETFIELD 	1 6 7k	; "string" true
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x07068092);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 31	[236]	GETFIELD 	3 1 8	; "keywords"
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x0801018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 32	[236]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_36
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 33	[236]	JMP      	2	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_36;
  }

  // 34	[236]	NEWTABLE 	3 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00000193);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 35	[236]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 36	[236]	SETFIELD 	1 8 3	; "keywords"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x03080092);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 37	[238]	LEN      	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x000001b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 38	[239]	LOADI    	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x80000201);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 39	[240]	LOADNIL  	5 2	; 3 out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00020288);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 40	[246]	CLOSURE  	8 0	; 0x7fe610f0f930
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x0000044f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 41	[250]	CLOSURE  	9 1	; 0x7fe610f0fa80
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x000084cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 42	[252]	LOADNIL  	10 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x00000508);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 43	[253]	GETFIELD 	11 1 10	; "keywords_order"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0a01058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 44	[253]	TEST     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_49
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x000005c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 45	[253]	JMP      	3	; to 50
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_49;
  }

  // 46	[264]	CLOSURE  	11 2	; 0x7fe610f0fb50
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x000105cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 47	[264]	MOVE     	10 11
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x000b0500);
    setobjs2s(L, ra, RB(i));
  }

  // 48	[265]	JMP      	2	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_51;
  }

  // 49	[274]	CLOSURE  	11 3	; 0x7fe6119040a0
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x000185cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 50	[274]	MOVE     	10 11
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x000b0500);
    setobjs2s(L, ra, RB(i));
  }

  // 51	[278]	LT       	3 4 0
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_58
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x000401ba);
    op_order(L, l_lti, LTnum, lessthanothers);
  }

  // 52	[278]	JMP      	5	; to 59
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_58;
  }

  // 53	[278]	LOADK    	11 11	; "eof"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00058583);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 54	[278]	LOADNIL  	12 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x00000608);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 55	[278]	MOVE     	13 3
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x00030680);
    setobjs2s(L, ra, RB(i));
  }

  // 56	[278]	MOVE     	14 3
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x00030700);
    setobjs2s(L, ra, RB(i));
  }

  // 57	[278]	RETURN   	11 5 0	; 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x000585c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 58	[279]	MOVE     	11 10
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x000a0580);
    setobjs2s(L, ra, RB(i));
  }

  // 59	[279]	CALL     	11 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x020105c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 60	[279]	TEST     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_71
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x000005c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 61	[279]	JMP      	9	; to 72
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_71;
  }

  // 62	[280]	GETTABUP 	11 0 12	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x0c00058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 63	[280]	GETFIELD 	11 11 13	; "yield"
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x0d0b058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 64	[280]	MOVE     	12 7
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x00070600);
    setobjs2s(L, ra, RB(i));
  }

  // 65	[280]	MOVE     	13 9
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x00090680);
    setobjs2s(L, ra, RB(i));
  }

  // 66	[280]	CALL     	13 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x020106c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 67	[280]	MOVE     	14 5
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x00050700);
    setobjs2s(L, ra, RB(i));
  }

  // 68	[280]	MOVE     	15 6
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x00060780);
    setobjs2s(L, ra, RB(i));
  }

  // 69	[280]	CALL     	11 5 1	; 4 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_151
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x010505c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 70	[281]	JMP      	80	; to 152
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x800027b8);
    updatetrap(ci);
    goto label_151;
  }

  // 71	[281]	MOVE     	11 8
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x00080580);
    setobjs2s(L, ra, RB(i));
  }

  // 72	[281]	GETFIELD 	12 1 4	; "ignore"
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x0401060e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 73	[281]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 74	[281]	TEST     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_85
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x000005c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 75	[281]	JMP      	9	; to 86
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_85;
  }

  // 76	[282]	GETTABUP 	11 0 12	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x0c00058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 77	[282]	GETFIELD 	11 11 13	; "yield"
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x0d0b058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 78	[282]	LOADK    	12 4	; "ignore"
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x00020603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 79	[282]	MOVE     	13 9
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x00090680);
    setobjs2s(L, ra, RB(i));
  }

  // 80	[282]	CALL     	13 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x020106c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 81	[282]	MOVE     	14 5
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x00050700);
    setobjs2s(L, ra, RB(i));
  }

  // 82	[282]	MOVE     	15 6
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x00060780);
    setobjs2s(L, ra, RB(i));
  }

  // 83	[282]	CALL     	11 5 1	; 4 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_151
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x010505c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 84	[283]	JMP      	66	; to 152
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x800020b8);
    updatetrap(ci);
    goto label_151;
  }

  // 85	[283]	MOVE     	11 8
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x00080580);
    setobjs2s(L, ra, RB(i));
  }

  // 86	[283]	GETFIELD 	12 1 2	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x0201060e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 87	[283]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 88	[283]	TEST     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_101
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x000005c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 89	[283]	JMP      	11	; to 102
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x80000538);
    updatetrap(ci);
    goto label_101;
  }

  // 90	[284]	GETTABUP 	11 0 12	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x0c00058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 91	[284]	GETFIELD 	11 11 13	; "yield"
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x0d0b058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 92	[284]	LOADK    	12 2	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x00010603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 93	[284]	GETTABUP 	13 0 14	; _ENV "tonumber"
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x0e00068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 94	[284]	MOVE     	14 9
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x00090700);
    setobjs2s(L, ra, RB(i));
  }

  // 95	[284]	CALL     	14 1 0	; 0 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x00010744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 96	[284]	CALL     	13 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x020006c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 97	[284]	MOVE     	14 5
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x00050700);
    setobjs2s(L, ra, RB(i));
  }

  // 98	[284]	MOVE     	15 6
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x00060780);
    setobjs2s(L, ra, RB(i));
  }

  // 99	[284]	CALL     	11 5 1	; 4 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_151
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x010505c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 100	[285]	JMP      	50	; to 152
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x800018b8);
    updatetrap(ci);
    goto label_151;
  }

  // 101	[285]	MOVE     	11 8
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x00080580);
    setobjs2s(L, ra, RB(i));
  }

  // 102	[285]	GETFIELD 	12 1 0	; "identifier"
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x0001060e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 103	[285]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 104	[285]	TEST     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_115
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x000005c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 105	[285]	JMP      	9	; to 116
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_115;
  }

  // 106	[286]	GETTABUP 	11 0 12	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x0c00058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 107	[286]	GETFIELD 	11 11 13	; "yield"
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x0d0b058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 108	[286]	LOADK    	12 0	; "identifier"
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x00000603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 109	[286]	MOVE     	13 9
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x00090680);
    setobjs2s(L, ra, RB(i));
  }

  // 110	[286]	CALL     	13 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x020106c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 111	[286]	MOVE     	14 5
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x00050700);
    setobjs2s(L, ra, RB(i));
  }

  // 112	[286]	MOVE     	15 6
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x00060780);
    setobjs2s(L, ra, RB(i));
  }

  // 113	[286]	CALL     	11 5 1	; 4 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_151
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x010505c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 114	[287]	JMP      	36	; to 152
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x800011b8);
    updatetrap(ci);
    goto label_151;
  }

  // 115	[287]	GETFIELD 	11 1 6	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x0601058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 116	[287]	TEST     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_141
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x000005c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 117	[287]	JMP      	23	; to 142
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x80000b38);
    updatetrap(ci);
    goto label_141;
  }

  // 118	[287]	MOVE     	11 8
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x00080580);
    setobjs2s(L, ra, RB(i));
  }

  // 119	[287]	LOADK    	12 15	; "^\"[^\"]*\""
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x00078603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 120	[287]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 121	[287]	TEST     	11 1
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_128
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x000085c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 122	[287]	JMP      	5	; to 129
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_128;
  }

  // 123	[287]	MOVE     	11 8
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x00080580);
    setobjs2s(L, ra, RB(i));
  }

  // 124	[287]	LOADK    	12 16	; "^'[^']*'"
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x00080603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 125	[287]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 126	[287]	TEST     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_141
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x000005c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 127	[287]	JMP      	13	; to 142
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_141;
  }

  // 128	[289]	GETTABUP 	11 0 12	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x0c00058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 129	[289]	GETFIELD 	11 11 13	; "yield"
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x0d0b058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 130	[289]	LOADK    	12 6	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_132
  label_130: {
    aot_vmfetch(0x00030603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 131	[289]	MOVE     	13 9
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_133
  label_131: {
    aot_vmfetch(0x00090680);
    setobjs2s(L, ra, RB(i));
  }

  // 132	[289]	CALL     	13 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 133)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_134
  label_132: {
    aot_vmfetch(0x020106c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 133	[289]	SELF     	13 13 17k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 134)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_135
  label_133: {
    aot_vmfetch(0x110d8694);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 134	[289]	LOADI    	15 2
  #undef  AOT_PC
  #define AOT_PC (code + 135)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_136
  label_134: {
    aot_vmfetch(0x80008781);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 135	[289]	LOADI    	16 -2
  #undef  AOT_PC
  #define AOT_PC (code + 136)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_137
  label_135: {
    aot_vmfetch(0x7ffe8801);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 136	[289]	CALL     	13 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 137)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_138
  label_136: {
    aot_vmfetch(0x020406c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 137	[289]	MOVE     	14 5
  #undef  AOT_PC
  #define AOT_PC (code + 138)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_139
  label_137: {
    aot_vmfetch(0x00050700);
    setobjs2s(L, ra, RB(i));
  }

  // 138	[289]	MOVE     	15 6
  #undef  AOT_PC
  #define AOT_PC (code + 139)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_140
  label_138: {
    aot_vmfetch(0x00060780);
    setobjs2s(L, ra, RB(i));
  }

  // 139	[289]	CALL     	11 5 1	; 4 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 140)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_151
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_141
  label_139: {
    aot_vmfetch(0x010505c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 140	[290]	JMP      	10	; to 152
  #undef  AOT_PC
  #define AOT_PC (code + 141)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_142
  label_140: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_151;
  }

  // 141	[291]	MOVE     	5 4
  #undef  AOT_PC
  #define AOT_PC (code + 142)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_143
  label_141: {
    aot_vmfetch(0x00040280);
    setobjs2s(L, ra, RB(i));
  }

  // 142	[292]	MOVE     	6 4
  #undef  AOT_PC
  #define AOT_PC (code + 143)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_144
  label_142: {
    aot_vmfetch(0x00040300);
    setobjs2s(L, ra, RB(i));
  }

  // 143	[293]	GETTABUP 	11 0 12	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 144)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_145
  label_143: {
    aot_vmfetch(0x0c00058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 144	[293]	GETFIELD 	11 11 13	; "yield"
  #undef  AOT_PC
  #define AOT_PC (code + 145)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_146
  label_144: {
    aot_vmfetch(0x0d0b058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 145	[293]	LOADK    	12 18	; "unknown"
  #undef  AOT_PC
  #define AOT_PC (code + 146)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_147
  label_145: {
    aot_vmfetch(0x00090603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 146	[293]	MOVE     	13 9
  #undef  AOT_PC
  #define AOT_PC (code + 147)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_148
  label_146: {
    aot_vmfetch(0x00090680);
    setobjs2s(L, ra, RB(i));
  }

  // 147	[293]	CALL     	13 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 148)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_149
  label_147: {
    aot_vmfetch(0x020106c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 148	[293]	MOVE     	14 5
  #undef  AOT_PC
  #define AOT_PC (code + 149)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_150
  label_148: {
    aot_vmfetch(0x00050700);
    setobjs2s(L, ra, RB(i));
  }

  // 149	[293]	MOVE     	15 6
  #undef  AOT_PC
  #define AOT_PC (code + 150)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_151
  label_149: {
    aot_vmfetch(0x00060780);
    setobjs2s(L, ra, RB(i));
  }

  // 150	[293]	CALL     	11 5 1	; 4 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 151)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_152
  label_150: {
    aot_vmfetch(0x010505c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 151	[295]	ADDI     	4 6 1
  #undef  AOT_PC
  #define AOT_PC (code + 152)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_153
  label_151: {
    aot_vmfetch(0x80060215);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 152	[295]	MMBINI   	6 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 153)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_154
  label_152: {
    aot_vmfetch(0x0680032f);
    Instruction pi = 0x80060215;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 153	[296]	JMP      	-103	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 154)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_153: {
    aot_vmfetch(0x7fffcc38);
    updatetrap(ci);
    goto label_51;
  }

  // 154	[297]	RETURN   	11 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 155)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_154: {
    aot_vmfetch(0x000185c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 243 - 246
static
CallInfo *magic_implementation_21(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
  }

  // 0	[244]	GETUPVAL 	1 2	; str
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[244]	SELF     	1 1 0k	; "find"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00018094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[244]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[244]	GETUPVAL 	4 3	; i
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00030209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[244]	CALL     	1 4 3	; 3 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x030400c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[244]	SETUPVAL 	2 1	; i2
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0001010a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 6	[244]	SETUPVAL 	1 0	; i1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0000008a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 7	[245]	GETUPVAL 	1 0	; i1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 8	[245]	EQK      	1 1 0	; null
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 9	[245]	JMP      	1	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_11;
  }

  // 10	[245]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 11	[245]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 12	[245]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 13	[246]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 248 - 250
static
CallInfo *magic_implementation_22(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
  }

  // 0	[249]	GETUPVAL 	0 0	; str
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[249]	SELF     	0 0 0k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[249]	GETUPVAL 	2 1	; i
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[249]	GETUPVAL 	3 2	; i2
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00020189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[249]	TAILCALL 	0 4 0	; 3 in
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00040045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 5	[249]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_05: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 6	[250]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 254 - 264
static
CallInfo *magic_implementation_23(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
  }

  // 0	[255]	GETTABUP 	0 0 0	; _ENV "ipairs"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[255]	GETTABUP 	1 1 1	; setup "keywords_order"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0101008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[255]	CALL     	0 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x05020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[255]	TFORPREP 	0 14	; to 19
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0007004b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_18;
  }

  // 4	[256]	GETTABUP 	6 0 2	; _ENV "assert"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0200030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 5	[256]	GETTABUP 	7 1 3	; setup "keywords"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0301038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[256]	GETTABLE 	7 7 5
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0507038c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[256]	CALL     	6 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x01020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[257]	GETTABUP 	6 1 3	; setup "keywords"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0301030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 9	[257]	GETTABLE 	6 6 5
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0506030c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 10	[258]	GETUPVAL 	7 2	; find
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00020389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 11	[258]	MOVE     	8 6
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00060400);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[258]	CALL     	7 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x020203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 13	[259]	TEST     	7 0
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_18
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000003c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 14	[259]	JMP      	3	; to 19
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_18;
  }

  // 15	[260]	SETUPVAL 	5 3	; keyword
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x0003028a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 16	[261]	LOADTRUE 	8
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00000407);
    setbtvalue(s2v(ra));
  }

  // 17	[261]	RETURN   	8 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00028446);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 18	[255]	TFORCALL 	0 2
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0200004c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 19	[255]	TFORLOOP 	0 16	; to 5
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0008004d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_04; /* jump back */
    }
  }

  // 20	[263]	CLOSE    	0
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_20: {
    aot_vmfetch(0x00000036);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 21	[264]	RETURN   	0 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_21: {
    aot_vmfetch(0x00018046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 266 - 274
static
CallInfo *magic_implementation_24(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
  }

  // 0	[267]	GETTABUP 	0 0 0	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[267]	GETTABUP 	1 1 1	; setup "keywords"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0101008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[267]	CALL     	0 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x05020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[267]	TFORPREP 	0 8	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0004004b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_12;
  }

  // 4	[268]	GETUPVAL 	6 2	; find
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00020309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 5	[268]	MOVE     	7 5
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00050380);
    setobjs2s(L, ra, RB(i));
  }

  // 6	[268]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[269]	TEST     	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000342);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 8	[269]	JMP      	3	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_12;
  }

  // 9	[270]	SETUPVAL 	4 3	; keyword
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0003020a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 10	[271]	LOADTRUE 	7
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000387);
    setbtvalue(s2v(ra));
  }

  // 11	[271]	RETURN   	7 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000283c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 12	[267]	TFORCALL 	0 2
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0200004c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 13	[267]	TFORLOOP 	0 10	; to 5
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0005004d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_04; /* jump back */
    }
  }

  // 14	[273]	CLOSE    	0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x00000036);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 15	[274]	RETURN   	0 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x00018046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 298 - 300
static
CallInfo *magic_implementation_25(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
  }

  // 0	[299]	GETTABUP 	2 0 0	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[299]	GETFIELD 	2 2 1	; "wrap"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0102010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[299]	CLOSURE  	3 0	; 0x7fe6119046a0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x000001cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 3	[299]	TAILCALL 	2 2 0	; 1 in
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00028145);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 4	[299]	RETURN   	2 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_04: {
    aot_vmfetch(0x00008146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 5	[300]	RETURN   	2 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_05: {
    aot_vmfetch(0x00018146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 299 - 299
static
CallInfo *magic_implementation_26(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
  }

  // 0	[299]	GETUPVAL 	0 0	; _tokenizer
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[299]	GETUPVAL 	1 1	; str
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 2	[299]	GETUPVAL 	2 2	; setup
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[299]	CALL     	0 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x01030044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[299]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_04: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 316 - 330
static
CallInfo *magic_implementation_27(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
  }

  // 0	[317]	NEWTABLE 	1 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000093);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 1	[317]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 2	[318]	GETUPVAL 	2 0	; tokenizer
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[318]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 4	[318]	GETUPVAL 	4 1	; PRE_TOKENIZE_COMMENT
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 5	[318]	CALL     	2 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x05030144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[318]	TFORPREP 	2 36	; to 44
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0012014b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_43;
  }

  // 7	[319]	EQK      	6 0 0	; "MLCOMMENT"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_27
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0000033c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 8	[319]	JMP      	18	; to 28
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x800008b8);
    updatetrap(ci);
    goto label_27;
  }

  // 9	[320]	GETUPVAL 	10 2	; findn
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00020509);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 10	[320]	SELF     	11 0 1k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x01008594);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[320]	MOVE     	13 8
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00080680);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[320]	MOVE     	14 9
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00090700);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[320]	CALL     	11 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x020405c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[320]	LOADK    	12 2	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00010603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 15	[320]	CALL     	10 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x02030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[321]	GETTABUP 	11 3 3	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0303058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[321]	GETFIELD 	11 11 4	; "rep"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x040b058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 18	[321]	LOADK    	12 2	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00010603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 19	[321]	MOVE     	13 10
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000a0680);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[321]	CALL     	11 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x020305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 21	[322]	GETTABUP 	12 3 5	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0503060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 22	[322]	GETFIELD 	12 12 6	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x060c060e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 23	[322]	MOVE     	13 1
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00010680);
    setobjs2s(L, ra, RB(i));
  }

  // 24	[322]	MOVE     	14 11
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x000b0700);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[322]	CALL     	12 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_43
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x01030644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 26	[323]	JMP      	16	; to 44
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x800007b8);
    updatetrap(ci);
    goto label_43;
  }

  // 27	[323]	EQK      	6 7 0	; "SLCOMMENT"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_35
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0007033c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 28	[323]	JMP      	6	; to 36
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_35;
  }

  // 29	[324]	GETTABUP 	10 3 5	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0503050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 30	[324]	GETFIELD 	10 10 6	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x060a050e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 31	[324]	MOVE     	11 1
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x00010580);
    setobjs2s(L, ra, RB(i));
  }

  // 32	[324]	LOADK    	12 2	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x00010603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 33	[324]	CALL     	10 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_43
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x01030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 34	[325]	JMP      	8	; to 44
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_43;
  }

  // 35	[326]	GETTABUP 	10 3 5	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x0503050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 36	[326]	GETFIELD 	10 10 6	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x060a050e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 37	[326]	MOVE     	11 1
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00010580);
    setobjs2s(L, ra, RB(i));
  }

  // 38	[326]	SELF     	12 0 1k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x01008614);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 39	[326]	MOVE     	14 8
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00080700);
    setobjs2s(L, ra, RB(i));
  }

  // 40	[326]	MOVE     	15 9
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00090780);
    setobjs2s(L, ra, RB(i));
  }

  // 41	[326]	CALL     	12 4 0	; 3 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x00040644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 42	[326]	CALL     	10 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x01000544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 43	[318]	TFORCALL 	2 4
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0400014c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 44	[318]	TFORLOOP 	2 38	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x0013014d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_07; /* jump back */
    }
  }

  // 45	[328]	CLOSE    	2
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x00000136);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 46	[329]	GETTABUP 	2 3 5	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x0503010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 47	[329]	GETFIELD 	2 2 8	; "concat"
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x0802010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 48	[329]	MOVE     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x00010180);
    setobjs2s(L, ra, RB(i));
  }

  // 49	[329]	TAILCALL 	2 2 0	; 1 in
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00028145);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 50	[329]	RETURN   	2 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_50: {
    aot_vmfetch(0x00008146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 51	[330]	RETURN   	2 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_51: {
    aot_vmfetch(0x00018146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 354 - 384
static
CallInfo *magic_implementation_28(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
  }

  // 0	[356]	NEWTABLE 	1 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000093);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 1	[356]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 2	[357]	LOADNIL  	2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000108);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 3	[358]	GETUPVAL 	3 0	; tokenizer
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[358]	MOVE     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00000200);
    setobjs2s(L, ra, RB(i));
  }

  // 5	[358]	GETUPVAL 	5 1	; PRE_TOKENIZE_INTEGER
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[358]	CALL     	3 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x050301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[358]	TFORPREP 	3 105	; to 114
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x003481cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_113;
  }

  // 8	[360]	EQK      	7 0 0	; "CHAR_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_30
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x000003bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 9	[360]	JMP      	20	; to 31
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x800009b8);
    updatetrap(ci);
    goto label_30;
  }

  // 10	[361]	GETTABUP 	11 2 1	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0102058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 11	[361]	GETFIELD 	11 11 2	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020b058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 12	[361]	MOVE     	12 1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00010600);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[361]	GETTABUP 	13 2 3	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0302068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 14	[361]	GETTABUP 	14 2 4	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0402070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 15	[361]	GETFIELD 	14 14 5	; "byte"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x050e070e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 16	[361]	GETTABUP 	15 2 6	; _ENV "loadstring"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0602078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[361]	LOADK    	16 7	; "return \""
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00038803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 18	[361]	SELF     	17 8 8k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x08088894);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[361]	LOADK    	19 9	; "^L%'(.+)%'"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00048983);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 20	[361]	LOADK    	20 10	; "%1"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00050a03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 21	[361]	CALL     	17 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x020408c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 22	[361]	LOADK    	18 11	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00058903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 23	[361]	CONCAT   	16 3
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00030835);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 24	[361]	CALL     	15 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x020207c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 25	[361]	CALL     	15 1 0	; 0 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x000107c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 26	[361]	CALL     	14 0 0	; all in all out
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00000744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 27	[361]	CALL     	13 0 0	; all in all out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000006c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 28	[361]	CALL     	11 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_113
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x010005c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 29	[362]	JMP      	83	; to 114
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x80002938);
    updatetrap(ci);
    goto label_113;
  }

  // 30	[362]	EQK      	7 12 0	; "HEX_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x000c03bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 31	[362]	JMP      	19	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x80000938);
    updatetrap(ci);
    goto label_51;
  }

  // 32	[363]	SELF     	11 8 13k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x0d088594);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 33	[363]	LOADK    	13 14	; "([%+%-]?)0x([a-fA-F%d]+)[UL]*"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x00070683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 34	[363]	CALL     	11 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x030305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 35	[363]	MOVE     	8 12
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x000c0400);
    setobjs2s(L, ra, RB(i));
  }

  // 36	[363]	MOVE     	2 11
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x000b0100);
    setobjs2s(L, ra, RB(i));
  }

  // 37	[364]	GETTABUP 	11 2 15	; _ENV "tonumber"
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x0f02058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 38	[364]	MOVE     	12 8
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00080600);
    setobjs2s(L, ra, RB(i));
  }

  // 39	[364]	LOADI    	13 16
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x80078681);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 40	[364]	CALL     	11 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x020305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 41	[365]	GETTABUP 	12 2 1	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x0102060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 42	[365]	GETFIELD 	12 12 2	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x020c060e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 43	[365]	MOVE     	13 1
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x00010680);
    setobjs2s(L, ra, RB(i));
  }

  // 44	[365]	MOVE     	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x00020700);
    setobjs2s(L, ra, RB(i));
  }

  // 45	[365]	GETTABUP 	15 2 3	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x0302078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 46	[365]	MOVE     	16 11
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x000b0800);
    setobjs2s(L, ra, RB(i));
  }

  // 47	[365]	CALL     	15 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x020207c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 48	[365]	CONCAT   	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x00020735);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 49	[365]	CALL     	12 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_113
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x01030644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 50	[366]	JMP      	62	; to 114
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x80001eb8);
    updatetrap(ci);
    goto label_113;
  }

  // 51	[366]	EQK      	7 16 0	; "NUMBER_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_63
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x001003bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 52	[366]	JMP      	10	; to 64
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_63;
  }

  // 53	[367]	SELF     	11 8 13k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x0d088594);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 54	[367]	LOADK    	13 17	; "([^UL]+)[UL]+"
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x00088683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 55	[367]	CALL     	11 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x020305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 56	[367]	MOVE     	8 11
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x000b0400);
    setobjs2s(L, ra, RB(i));
  }

  // 57	[368]	GETTABUP 	11 2 1	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x0102058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 58	[368]	GETFIELD 	11 11 2	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x020b058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 59	[368]	MOVE     	12 1
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x00010600);
    setobjs2s(L, ra, RB(i));
  }

  // 60	[368]	MOVE     	13 8
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x00080680);
    setobjs2s(L, ra, RB(i));
  }

  // 61	[368]	CALL     	11 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_113
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x010305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 62	[369]	JMP      	50	; to 114
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x800018b8);
    updatetrap(ci);
    goto label_113;
  }

  // 63	[369]	EQK      	7 18 0	; "BIN_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_84
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x001203bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 64	[369]	JMP      	19	; to 85
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x80000938);
    updatetrap(ci);
    goto label_84;
  }

  // 65	[370]	SELF     	11 8 13k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x0d088594);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 66	[370]	LOADK    	13 19	; "([%+%-]?)0b([01]+)[UL]*"
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x00098683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 67	[370]	CALL     	11 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x030305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 68	[370]	MOVE     	8 12
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x000c0400);
    setobjs2s(L, ra, RB(i));
  }

  // 69	[370]	MOVE     	2 11
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x000b0100);
    setobjs2s(L, ra, RB(i));
  }

  // 70	[371]	GETTABUP 	11 2 15	; _ENV "tonumber"
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x0f02058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 71	[371]	MOVE     	12 8
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x00080600);
    setobjs2s(L, ra, RB(i));
  }

  // 72	[371]	LOADI    	13 2
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x80008681);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 73	[371]	CALL     	11 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x020305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 74	[372]	GETTABUP 	12 2 1	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x0102060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 75	[372]	GETFIELD 	12 12 2	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x020c060e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 76	[372]	MOVE     	13 1
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x00010680);
    setobjs2s(L, ra, RB(i));
  }

  // 77	[372]	MOVE     	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x00020700);
    setobjs2s(L, ra, RB(i));
  }

  // 78	[372]	GETTABUP 	15 2 3	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x0302078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 79	[372]	MOVE     	16 11
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x000b0800);
    setobjs2s(L, ra, RB(i));
  }

  // 80	[372]	CALL     	15 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x020207c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 81	[372]	CONCAT   	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x00020735);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 82	[372]	CALL     	12 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_113
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x01030644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 83	[373]	JMP      	29	; to 114
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x80000e38);
    updatetrap(ci);
    goto label_113;
  }

  // 84	[373]	EQK      	7 20 0	; "OCT_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_105
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x001403bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 85	[373]	JMP      	19	; to 106
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x80000938);
    updatetrap(ci);
    goto label_105;
  }

  // 86	[374]	SELF     	11 8 13k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x0d088594);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 87	[374]	LOADK    	13 21	; "([%+%-]?)(0%d+)[UL]*"
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x000a8683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 88	[374]	CALL     	11 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x030305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 89	[374]	MOVE     	8 12
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x000c0400);
    setobjs2s(L, ra, RB(i));
  }

  // 90	[374]	MOVE     	2 11
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x000b0100);
    setobjs2s(L, ra, RB(i));
  }

  // 91	[375]	GETTABUP 	11 2 15	; _ENV "tonumber"
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x0f02058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 92	[375]	MOVE     	12 8
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x00080600);
    setobjs2s(L, ra, RB(i));
  }

  // 93	[375]	LOADI    	13 8
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x80038681);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 94	[375]	CALL     	11 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x020305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 95	[376]	GETTABUP 	12 2 1	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x0102060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 96	[376]	GETFIELD 	12 12 2	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x020c060e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 97	[376]	MOVE     	13 1
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x00010680);
    setobjs2s(L, ra, RB(i));
  }

  // 98	[376]	MOVE     	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x00020700);
    setobjs2s(L, ra, RB(i));
  }

  // 99	[376]	GETTABUP 	15 2 3	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x0302078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 100	[376]	MOVE     	16 11
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x000b0800);
    setobjs2s(L, ra, RB(i));
  }

  // 101	[376]	CALL     	15 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x020207c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 102	[376]	CONCAT   	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x00020735);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 103	[376]	CALL     	12 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_113
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x01030644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 104	[377]	JMP      	8	; to 114
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_113;
  }

  // 105	[378]	GETTABUP 	11 2 1	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x0102058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 106	[378]	GETFIELD 	11 11 2	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x020b058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 107	[378]	MOVE     	12 1
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x00010600);
    setobjs2s(L, ra, RB(i));
  }

  // 108	[378]	SELF     	13 0 22k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x16008694);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 109	[378]	MOVE     	15 9
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x00090780);
    setobjs2s(L, ra, RB(i));
  }

  // 110	[378]	MOVE     	16 10
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x000a0800);
    setobjs2s(L, ra, RB(i));
  }

  // 111	[378]	CALL     	13 4 0	; 3 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x000406c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 112	[378]	CALL     	11 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x010005c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 113	[358]	TFORCALL 	3 4
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x040001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 114	[358]	TFORLOOP 	3 107	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x003581cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_08; /* jump back */
    }
  }

  // 115	[380]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 116	[381]	GETTABUP 	3 2 1	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x0102018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 117	[381]	GETFIELD 	3 3 23	; "concat"
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x1703018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 118	[381]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 119	[381]	CALL     	3 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x020201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 120	[383]	RETURN   	3 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_120: {
    aot_vmfetch(0x000281c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 121	[384]	RETURN   	4 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_121: {
    aot_vmfetch(0x00018246);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 388 - 426
static
CallInfo *magic_implementation_29(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
  }

  // 0	[423]	CLOSURE  	1 0	; 0x7fe611905bc0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x000000cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 1	[425]	GETTABUP 	2 1 0	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0001010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[425]	GETFIELD 	2 2 1	; "wrap"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0102010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[425]	CLOSURE  	3 1	; 0x7fe6119060e0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000081cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 4	[425]	TAILCALL 	2 2 0	; 1 in
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00028145);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 5	[425]	RETURN   	2 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_05: {
    aot_vmfetch(0x00008146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 6	[426]	RETURN   	2 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x00018146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 389 - 423
static
CallInfo *magic_implementation_30(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
  }

  // 0	[390]	GETUPVAL 	1 0	; removeComments
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[390]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[390]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[390]	MOVE     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00010000);
    setobjs2s(L, ra, RB(i));
  }

  // 4	[393]	LOADI    	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000081);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 5	[394]	GTI      	1 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_16
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x007f00c0);
    op_orderI(L, l_gti, luai_numgt, 1, TM_LT);
  }

  // 6	[394]	JMP      	9	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_16;
  }

  // 7	[394]	GETTABUP 	2 1 0	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0001010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[394]	GETFIELD 	2 2 1	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0102010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 9	[394]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[394]	LOADK    	4 2	; "^(.-)\\\n(.-)$"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00010203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[394]	LOADK    	5 3	; "%1 %2\n"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00018283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 12	[394]	CALL     	2 4 3	; 3 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x03040144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 13	[394]	MOVE     	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00030080);
    setobjs2s(L, ra, RB(i));
  }

  // 14	[394]	MOVE     	0 2
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_05
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00020000);
    setobjs2s(L, ra, RB(i));
  }

  // 15	[394]	JMP      	-11	; to 6
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x7ffffa38);
    updatetrap(ci);
    goto label_05;
  }

  // 16	[397]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 17	[397]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 18	[398]	GETUPVAL 	3 2	; gsplit
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00020189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 19	[398]	MOVE     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00000200);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[398]	GETUPVAL 	5 3	; NEWL
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00030289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 21	[398]	CALL     	3 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x050301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 22	[398]	TFORPREP 	3 58	; to 82
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x001d01cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_81;
  }

  // 23	[400]	GETUPVAL 	8 4	; trim
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00040409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 24	[400]	MOVE     	9 7
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00070480);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[400]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 26	[400]	MOVE     	7 8
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00080380);
    setobjs2s(L, ra, RB(i));
  }

  // 27	[401]	LEN      	8 7
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00070434);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 28	[401]	GTI      	8 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_74
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x007f0440);
    op_orderI(L, l_gti, luai_numgt, 1, TM_LT);
  }

  // 29	[401]	JMP      	44	; to 75
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x800015b8);
    updatetrap(ci);
    goto label_74;
  }

  // 30	[402]	SELF     	8 7 4k	; "byte"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x04078414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 31	[402]	LOADI    	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x80000501);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 32	[402]	CALL     	8 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x02030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 33	[402]	GETUPVAL 	9 5	; CMD_BYTE
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x00050489);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 34	[402]	EQ       	8 9 0
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_60
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00090439);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 35	[402]	JMP      	24	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x80000bb8);
    updatetrap(ci);
    goto label_60;
  }

  // 36	[403]	SELF     	8 7 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x01078414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 37	[403]	LOADK    	10 5	; "#%s*(.*)"
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00028503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 38	[403]	LOADK    	11 6	; "#%1"
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00030583);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 39	[403]	CALL     	8 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x02040444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 40	[403]	MOVE     	7 8
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00080380);
    setobjs2s(L, ra, RB(i));
  }

  // 41	[404]	LEN      	8 2
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x00020434);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 42	[404]	GTI      	8 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_55
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x007f0440);
    op_orderI(L, l_gti, luai_numgt, 1, TM_LT);
  }

  // 43	[404]	JMP      	11	; to 56
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x80000538);
    updatetrap(ci);
    goto label_55;
  }

  // 44	[405]	GETTABUP 	8 1 7	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x0701040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 45	[405]	GETFIELD 	8 8 8	; "yield"
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x0808040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 46	[405]	GETTABUP 	9 1 9	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x0901048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 47	[405]	GETFIELD 	9 9 10	; "concat"
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x0a09048e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 48	[405]	MOVE     	10 2
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x00020500);
    setobjs2s(L, ra, RB(i));
  }

  // 49	[405]	GETUPVAL 	11 3	; NEWL
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00030589);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 50	[405]	CALL     	9 3 0	; 2 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x000304c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 51	[405]	CALL     	8 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x01000444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 52	[406]	NEWTABLE 	8 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x00000413);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 53	[406]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 54	[406]	MOVE     	2 8
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x00080100);
    setobjs2s(L, ra, RB(i));
  }

  // 55	[408]	GETTABUP 	8 1 7	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x0701040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 56	[408]	GETFIELD 	8 8 8	; "yield"
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x0808040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 57	[408]	MOVE     	9 7
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00070480);
    setobjs2s(L, ra, RB(i));
  }

  // 58	[408]	CALL     	8 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_81
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x01020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 59	[409]	JMP      	21	; to 82
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x80000a38);
    updatetrap(ci);
    goto label_81;
  }

  // 60	[410]	GETTABUP 	8 6 11	; preprocessor "FAST"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x0b06040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 61	[410]	TEST     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_69
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x00000442);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 62	[410]	JMP      	6	; to 70
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_69;
  }

  // 63	[411]	GETTABUP 	8 1 9	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x0901040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 64	[411]	GETFIELD 	8 8 12	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x0c08040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 65	[411]	MOVE     	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x00020480);
    setobjs2s(L, ra, RB(i));
  }

  // 66	[411]	MOVE     	10 7
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x00070500);
    setobjs2s(L, ra, RB(i));
  }

  // 67	[411]	CALL     	8 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_81
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x01030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 68	[412]	JMP      	12	; to 82
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_81;
  }

  // 69	[413]	GETTABUP 	8 1 7	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x0701040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 70	[413]	GETFIELD 	8 8 8	; "yield"
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x0808040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 71	[413]	MOVE     	9 7
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x00070480);
    setobjs2s(L, ra, RB(i));
  }

  // 72	[413]	CALL     	8 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_81
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x01020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 73	[416]	JMP      	7	; to 82
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_81;
  }

  // 74	[416]	GETTABUP 	8 6 11	; preprocessor "FAST"
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x0b06040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 75	[416]	TEST     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_81
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x00008442);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 76	[416]	JMP      	4	; to 82
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_81;
  }

  // 77	[417]	GETTABUP 	8 1 7	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x0701040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 78	[417]	GETFIELD 	8 8 8	; "yield"
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x0808040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 79	[417]	MOVE     	9 7
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x00070480);
    setobjs2s(L, ra, RB(i));
  }

  // 80	[417]	CALL     	8 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x01020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 81	[398]	TFORCALL 	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x010001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 82	[398]	TFORLOOP 	3 60	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x001e01cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_23; /* jump back */
    }
  }

  // 83	[419]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 84	[420]	LEN      	3 2
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x000201b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 85	[420]	GTI      	3 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_95
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x007f01c0);
    op_orderI(L, l_gti, luai_numgt, 1, TM_LT);
  }

  // 86	[420]	JMP      	8	; to 96
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_95;
  }

  // 87	[421]	GETTABUP 	3 1 7	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x0701018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 88	[421]	GETFIELD 	3 3 8	; "yield"
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x0803018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 89	[421]	GETTABUP 	4 1 9	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x0901020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 90	[421]	GETFIELD 	4 4 10	; "concat"
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x0a04020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 91	[421]	MOVE     	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x00020280);
    setobjs2s(L, ra, RB(i));
  }

  // 92	[421]	GETUPVAL 	6 3	; NEWL
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x00030309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 93	[421]	CALL     	4 3 0	; 2 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x00030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 94	[421]	CALL     	3 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_94: {
    aot_vmfetch(0x010001c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 95	[423]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_95: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 425 - 425
static
CallInfo *magic_implementation_31(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[425]	GETUPVAL 	0 0	; _screener
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[425]	GETUPVAL 	1 1	; input
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 2	[425]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[425]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 434 - 494
static
CallInfo *magic_implementation_32(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
    case 132: goto label_132;
    case 133: goto label_133;
    case 134: goto label_134;
    case 135: goto label_135;
    case 136: goto label_136;
    case 137: goto label_137;
    case 138: goto label_138;
    case 139: goto label_139;
    case 140: goto label_140;
    case 141: goto label_141;
    case 142: goto label_142;
    case 143: goto label_143;
    case 144: goto label_144;
    case 145: goto label_145;
    case 146: goto label_146;
    case 147: goto label_147;
  }

  // 0	[436]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 1	[436]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 2	[437]	NEWTABLE 	3 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000193);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 3	[437]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 4	[438]	LOADNIL  	4 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00000208);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 5	[440]	GETUPVAL 	5 0	; tokenizer
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[440]	MOVE     	6 1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010300);
    setobjs2s(L, ra, RB(i));
  }

  // 7	[440]	GETUPVAL 	7 1	; PRE_TOKENIZE_APPLY_MACRO
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00010389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 8	[440]	CALL     	5 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x050302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[440]	TFORPREP 	5 118	; to 129
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x003b02cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_128;
  }

  // 10	[442]	EQK      	9 0 0	; "identifier"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_109
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000004bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 11	[442]	JMP      	97	; to 110
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80003038);
    updatetrap(ci);
    goto label_109;
  }

  // 12	[443]	MOVE     	13 10
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000a0680);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[444]	GETFIELD 	14 0 1	; "defines"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0100070e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 14	[444]	GETTABLE 	14 14 10
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0a0e070c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[445]	TEST     	14 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_103
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000742);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 16	[445]	JMP      	86	; to 104
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x80002ab8);
    updatetrap(ci);
    goto label_103;
  }

  // 17	[446]	GETTABUP 	15 2 2	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0202078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 18	[446]	MOVE     	16 14
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x000e0800);
    setobjs2s(L, ra, RB(i));
  }

  // 19	[446]	CALL     	15 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x020207c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[446]	EQK      	15 3 0	; "boolean"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_25
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x000307bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 21	[446]	JMP      	3	; to 26
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_25;
  }

  // 22	[447]	LOADK    	13 4	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00020683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 23	[448]	LOADTRUE 	4
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_103
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00000207);
    setbtvalue(s2v(ra));
  }

  // 24	[449]	JMP      	78	; to 104
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x800026b8);
    updatetrap(ci);
    goto label_103;
  }

  // 25	[449]	GETTABUP 	15 2 2	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x0202078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 26	[449]	MOVE     	16 14
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x000e0800);
    setobjs2s(L, ra, RB(i));
  }

  // 27	[449]	CALL     	15 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x020207c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 28	[449]	EQK      	15 5 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_36
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x000507bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 29	[449]	JMP      	6	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_36;
  }

  // 30	[450]	MOVE     	13 14
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x000e0680);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[451]	EQ       	13 10 0
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_34
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000a06b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 32	[451]	JMP      	1	; to 35
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_34;
  }

  // 33	[451]	LFALSESKIP	4
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x00000206);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 34	[451]	LOADTRUE 	4
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_103
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00000207);
    setbtvalue(s2v(ra));
  }

  // 35	[452]	JMP      	67	; to 104
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x80002138);
    updatetrap(ci);
    goto label_103;
  }

  // 36	[452]	GETTABUP 	15 2 2	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x0202078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 37	[452]	MOVE     	16 14
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x000e0800);
    setobjs2s(L, ra, RB(i));
  }

  // 38	[452]	CALL     	15 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x020207c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 39	[452]	EQK      	15 6 0	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_50
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x000607bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 40	[452]	JMP      	9	; to 51
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_50;
  }

  // 41	[453]	GETTABUP 	15 2 7	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x0702078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 42	[453]	MOVE     	16 14
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x000e0800);
    setobjs2s(L, ra, RB(i));
  }

  // 43	[453]	CALL     	15 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x020207c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 44	[453]	MOVE     	13 15
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x000f0680);
    setobjs2s(L, ra, RB(i));
  }

  // 45	[454]	EQ       	13 10 0
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_48
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000a06b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 46	[454]	JMP      	1	; to 49
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_48;
  }

  // 47	[454]	LFALSESKIP	4
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00000206);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 48	[454]	LOADTRUE 	4
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_103
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x00000207);
    setbtvalue(s2v(ra));
  }

  // 49	[455]	JMP      	53	; to 104
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x80001a38);
    updatetrap(ci);
    goto label_103;
  }

  // 50	[455]	GETTABUP 	15 2 2	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0202078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 51	[455]	MOVE     	16 14
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x000e0800);
    setobjs2s(L, ra, RB(i));
  }

  // 52	[455]	CALL     	15 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x020207c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 53	[455]	EQK      	15 8 0	; "function"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_103
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x000807bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 54	[455]	JMP      	48	; to 104
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x800017b8);
    updatetrap(ci);
    goto label_103;
  }

  // 55	[456]	SELF     	15 1 9k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x09018794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 56	[456]	MOVE     	17 11
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x000b0880);
    setobjs2s(L, ra, RB(i));
  }

  // 57	[456]	CALL     	15 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x020307c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 58	[456]	SELF     	15 15 10k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x0a0f8794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 59	[456]	LOADK    	17 11	; "^[_%a][_%w]*%s*%b()"
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x00058883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 60	[456]	LOADK    	18 12	; "%1"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x00060903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 61	[456]	CALL     	15 4 3	; 3 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x030407c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 62	[458]	GTI      	16 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_85
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x007f0840);
    op_orderI(L, l_gti, luai_numgt, 1, TM_LT);
  }

  // 63	[458]	JMP      	21	; to 86
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x80000a38);
    updatetrap(ci);
    goto label_85;
  }

  // 64	[459]	MOVE     	17 14
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x000e0880);
    setobjs2s(L, ra, RB(i));
  }

  // 65	[459]	MOVE     	18 15
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x000f0900);
    setobjs2s(L, ra, RB(i));
  }

  // 66	[459]	CALL     	17 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x020208c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 67	[459]	MOVE     	13 17
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x00110680);
    setobjs2s(L, ra, RB(i));
  }

  // 68	[461]	LOADTRUE 	4
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x00000207);
    setbtvalue(s2v(ra));
  }

  // 69	[462]	GETTABUP 	17 2 13	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x0d02088b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 70	[462]	GETFIELD 	17 17 14	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x0e11088e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 71	[462]	MOVE     	18 2
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x00020900);
    setobjs2s(L, ra, RB(i));
  }

  // 72	[462]	MOVE     	19 13
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x000d0980);
    setobjs2s(L, ra, RB(i));
  }

  // 73	[462]	CALL     	17 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x010308c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 74	[463]	GETTABUP 	17 2 13	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x0d02088b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 75	[463]	GETFIELD 	17 17 14	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x0e11088e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 76	[463]	MOVE     	18 2
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x00020900);
    setobjs2s(L, ra, RB(i));
  }

  // 77	[463]	SELF     	19 1 9k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x09018994);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 78	[463]	LEN      	21 15
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x000f0ab4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 79	[463]	ADD      	21 12 21
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x150c0aa2);
    op_arith(L, l_addi, luai_numadd);
  }

  // 80	[463]	MMBIN    	12 21 6	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x0615062e);
    Instruction pi = 0x150c0aa2; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 81	[463]	CALL     	19 3 0	; 2 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x000309c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 82	[463]	CALL     	17 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_130
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x010008c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 83	[464]	JMP      	46	; to 131
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_103
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x800016b8);
    updatetrap(ci);
    goto label_130;
  }

  // 84	[465]	JMP      	18	; to 104
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x800008b8);
    updatetrap(ci);
    goto label_103;
  }

  // 85	[466]	SELF     	17 1 9k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x09018894);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 86	[466]	MOVE     	19 11
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x000b0980);
    setobjs2s(L, ra, RB(i));
  }

  // 87	[466]	CALL     	17 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x020308c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 88	[466]	SELF     	17 17 15k	; "find"
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x0f118894);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 89	[466]	LOADK    	19 16	; "^[_%a][_%w]*%s*%("
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x00080983);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 90	[466]	CALL     	17 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x020308c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 91	[466]	TEST     	17 0
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_97
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x000008c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 92	[466]	JMP      	4	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_97;
  }

  // 93	[469]	MOVE     	17 1
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x00010880);
    setobjs2s(L, ra, RB(i));
  }

  // 94	[469]	LOADTRUE 	18
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x00000907);
    setbtvalue(s2v(ra));
  }

  // 95	[469]	RETURN   	17 3 0	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_103
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x000388c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 96	[470]	JMP      	6	; to 104
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_103;
  }

  // 97	[474]	GETUPVAL 	17 3	; print
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x00030889);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 98	[474]	MOVE     	18 10
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x000a0900);
    setobjs2s(L, ra, RB(i));
  }

  // 99	[474]	LOADK    	19 17	; ": macro name but used as C declaration in:"
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x00088983);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 100	[474]	MOVE     	20 1
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x00010a00);
    setobjs2s(L, ra, RB(i));
  }

  // 101	[474]	CONCAT   	18 3
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x00030935);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 102	[474]	CALL     	17 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x010208c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 103	[479]	GETTABUP 	15 2 13	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x0d02078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 104	[479]	GETFIELD 	15 15 14	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x0e0f078e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 105	[479]	MOVE     	16 2
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x00020800);
    setobjs2s(L, ra, RB(i));
  }

  // 106	[479]	MOVE     	17 13
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x000d0880);
    setobjs2s(L, ra, RB(i));
  }

  // 107	[479]	CALL     	15 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_128
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x010307c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 108	[480]	JMP      	19	; to 129
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x80000938);
    updatetrap(ci);
    goto label_128;
  }

  // 109	[480]	EQK      	9 18 0	; "DEFINED"
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_120
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x001204bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 110	[480]	JMP      	9	; to 121
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_120;
  }

  // 111	[481]	GETTABUP 	13 2 13	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x0d02068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 112	[481]	GETFIELD 	13 13 14	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x0e0d068e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 113	[481]	MOVE     	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x00020700);
    setobjs2s(L, ra, RB(i));
  }

  // 114	[481]	SELF     	15 1 9k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x09018794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 115	[481]	MOVE     	17 11
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x000b0880);
    setobjs2s(L, ra, RB(i));
  }

  // 116	[481]	MOVE     	18 12
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x000c0900);
    setobjs2s(L, ra, RB(i));
  }

  // 117	[481]	CALL     	15 4 0	; 3 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x000407c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 118	[481]	CALL     	13 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_128
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x010006c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 119	[482]	JMP      	8	; to 129
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_128;
  }

  // 120	[483]	GETTABUP 	13 2 13	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x0d02068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 121	[483]	GETFIELD 	13 13 14	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x0e0d068e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 122	[483]	MOVE     	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x00020700);
    setobjs2s(L, ra, RB(i));
  }

  // 123	[483]	SELF     	15 1 9k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x09018794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 124	[483]	MOVE     	17 11
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x000b0880);
    setobjs2s(L, ra, RB(i));
  }

  // 125	[483]	MOVE     	18 12
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x000c0900);
    setobjs2s(L, ra, RB(i));
  }

  // 126	[483]	CALL     	15 4 0	; 3 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x000407c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 127	[483]	CALL     	13 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x010006c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 128	[440]	TFORCALL 	5 4
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x040002cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 129	[440]	TFORLOOP 	5 120	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x003c02cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_10; /* jump back */
    }
  }

  // 130	[485]	CLOSE    	5
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_132
  label_130: {
    aot_vmfetch(0x000002b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 131	[486]	GETTABUP 	5 2 13	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_133
  label_131: {
    aot_vmfetch(0x0d02028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 132	[486]	GETFIELD 	5 5 19	; "concat"
  #undef  AOT_PC
  #define AOT_PC (code + 133)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_134
  label_132: {
    aot_vmfetch(0x1305028e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 133	[486]	MOVE     	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 134)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_135
  label_133: {
    aot_vmfetch(0x00020300);
    setobjs2s(L, ra, RB(i));
  }

  // 134	[486]	CALL     	5 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 135)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_136
  label_134: {
    aot_vmfetch(0x020202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 135	[486]	MOVE     	1 5
  #undef  AOT_PC
  #define AOT_PC (code + 136)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_137
  label_135: {
    aot_vmfetch(0x00050080);
    setobjs2s(L, ra, RB(i));
  }

  // 136	[487]	TEST     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 137)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_00
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_138
  label_136: {
    aot_vmfetch(0x00008242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 137	[487]	JMP      	-138	; to 1
  #undef  AOT_PC
  #define AOT_PC (code + 138)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_140
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_139
  label_137: {
    aot_vmfetch(0x7fffbab8);
    updatetrap(ci);
    goto label_00;
  }

  // 138	[488]	JMP      	1	; to 141
  #undef  AOT_PC
  #define AOT_PC (code + 139)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_00
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_140
  label_138: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_140;
  }

  // 139	[490]	JMP      	-140	; to 1
  #undef  AOT_PC
  #define AOT_PC (code + 140)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_141
  label_139: {
    aot_vmfetch(0x7fffb9b8);
    updatetrap(ci);
    goto label_00;
  }

  // 140	[493]	GETUPVAL 	2 4	; parseCInteger
  #undef  AOT_PC
  #define AOT_PC (code + 141)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_142
  label_140: {
    aot_vmfetch(0x00040109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 141	[493]	GETUPVAL 	3 5	; concatStringLiteral
  #undef  AOT_PC
  #define AOT_PC (code + 142)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_143
  label_141: {
    aot_vmfetch(0x00050189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 142	[493]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 143)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_144
  label_142: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 143	[493]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 144)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_145
  label_143: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 144	[493]	CALL     	2 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 145)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_146
  label_144: {
    aot_vmfetch(0x02000144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 145	[493]	LOADFALSE	3
  #undef  AOT_PC
  #define AOT_PC (code + 146)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_147
  label_145: {
    aot_vmfetch(0x00000185);
    setbfvalue(s2v(ra));
  }

  // 146	[493]	RETURN   	2 3 0	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 147)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_146: {
    aot_vmfetch(0x00038146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 147	[494]	RETURN   	2 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 148)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_147: {
    aot_vmfetch(0x00018146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 497 - 627
static
CallInfo *magic_implementation_33(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
    case 132: goto label_132;
    case 133: goto label_133;
    case 134: goto label_134;
    case 135: goto label_135;
    case 136: goto label_136;
    case 137: goto label_137;
    case 138: goto label_138;
    case 139: goto label_139;
    case 140: goto label_140;
    case 141: goto label_141;
    case 142: goto label_142;
    case 143: goto label_143;
    case 144: goto label_144;
    case 145: goto label_145;
    case 146: goto label_146;
    case 147: goto label_147;
    case 148: goto label_148;
    case 149: goto label_149;
    case 150: goto label_150;
    case 151: goto label_151;
    case 152: goto label_152;
    case 153: goto label_153;
    case 154: goto label_154;
    case 155: goto label_155;
    case 156: goto label_156;
    case 157: goto label_157;
    case 158: goto label_158;
    case 159: goto label_159;
    case 160: goto label_160;
    case 161: goto label_161;
    case 162: goto label_162;
    case 163: goto label_163;
    case 164: goto label_164;
    case 165: goto label_165;
    case 166: goto label_166;
    case 167: goto label_167;
    case 168: goto label_168;
    case 169: goto label_169;
    case 170: goto label_170;
    case 171: goto label_171;
    case 172: goto label_172;
    case 173: goto label_173;
    case 174: goto label_174;
    case 175: goto label_175;
    case 176: goto label_176;
    case 177: goto label_177;
    case 178: goto label_178;
    case 179: goto label_179;
    case 180: goto label_180;
    case 181: goto label_181;
    case 182: goto label_182;
    case 183: goto label_183;
    case 184: goto label_184;
    case 185: goto label_185;
    case 186: goto label_186;
    case 187: goto label_187;
    case 188: goto label_188;
    case 189: goto label_189;
    case 190: goto label_190;
    case 191: goto label_191;
    case 192: goto label_192;
    case 193: goto label_193;
    case 194: goto label_194;
    case 195: goto label_195;
    case 196: goto label_196;
    case 197: goto label_197;
    case 198: goto label_198;
    case 199: goto label_199;
    case 200: goto label_200;
    case 201: goto label_201;
    case 202: goto label_202;
    case 203: goto label_203;
    case 204: goto label_204;
    case 205: goto label_205;
    case 206: goto label_206;
    case 207: goto label_207;
    case 208: goto label_208;
    case 209: goto label_209;
    case 210: goto label_210;
    case 211: goto label_211;
    case 212: goto label_212;
    case 213: goto label_213;
    case 214: goto label_214;
    case 215: goto label_215;
    case 216: goto label_216;
    case 217: goto label_217;
    case 218: goto label_218;
    case 219: goto label_219;
    case 220: goto label_220;
    case 221: goto label_221;
    case 222: goto label_222;
    case 223: goto label_223;
    case 224: goto label_224;
    case 225: goto label_225;
    case 226: goto label_226;
    case 227: goto label_227;
    case 228: goto label_228;
    case 229: goto label_229;
    case 230: goto label_230;
    case 231: goto label_231;
    case 232: goto label_232;
    case 233: goto label_233;
    case 234: goto label_234;
    case 235: goto label_235;
    case 236: goto label_236;
    case 237: goto label_237;
    case 238: goto label_238;
    case 239: goto label_239;
    case 240: goto label_240;
    case 241: goto label_241;
    case 242: goto label_242;
    case 243: goto label_243;
    case 244: goto label_244;
    case 245: goto label_245;
    case 246: goto label_246;
    case 247: goto label_247;
    case 248: goto label_248;
    case 249: goto label_249;
    case 250: goto label_250;
    case 251: goto label_251;
    case 252: goto label_252;
    case 253: goto label_253;
    case 254: goto label_254;
    case 255: goto label_255;
    case 256: goto label_256;
    case 257: goto label_257;
    case 258: goto label_258;
    case 259: goto label_259;
    case 260: goto label_260;
    case 261: goto label_261;
    case 262: goto label_262;
    case 263: goto label_263;
    case 264: goto label_264;
    case 265: goto label_265;
    case 266: goto label_266;
    case 267: goto label_267;
    case 268: goto label_268;
    case 269: goto label_269;
    case 270: goto label_270;
    case 271: goto label_271;
    case 272: goto label_272;
    case 273: goto label_273;
    case 274: goto label_274;
    case 275: goto label_275;
    case 276: goto label_276;
    case 277: goto label_277;
    case 278: goto label_278;
    case 279: goto label_279;
    case 280: goto label_280;
    case 281: goto label_281;
    case 282: goto label_282;
    case 283: goto label_283;
    case 284: goto label_284;
    case 285: goto label_285;
    case 286: goto label_286;
    case 287: goto label_287;
    case 288: goto label_288;
    case 289: goto label_289;
    case 290: goto label_290;
    case 291: goto label_291;
    case 292: goto label_292;
    case 293: goto label_293;
    case 294: goto label_294;
    case 295: goto label_295;
  }

  // 0	[498]	TEST     	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_05
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x000000c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 1	[498]	JMP      	3	; to 6
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_05;
  }

  // 2	[498]	LEN      	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010134);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 3	[498]	EQI      	2 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x007f013d);
    int cond;
    int im = GETARG_sB(i);
    if (ttisinteger(s2v(ra)))
      cond = (ivalue(s2v(ra)) == im);
    else if (ttisfloat(s2v(ra)))
      cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));
    else
      cond = 0;  /* other types cannot be equal to a number */
    docondjump();
  }

  // 4	[498]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[498]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 6	[499]	LOADNIL  	2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000108);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 7	[500]	SELF     	3 1 0k	; "byte"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00018194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[500]	LOADI    	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000281);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 9	[500]	CALL     	3 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x020301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[500]	GETUPVAL 	4 0	; CMD_BYTE
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 11	[500]	EQ       	3 4 0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_17
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000401b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 12	[500]	JMP      	4	; to 18
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_17;
  }

  // 13	[500]	SELF     	3 1 1k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x01018194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 14	[500]	LOADI    	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80008281);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 15	[500]	CALL     	3 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x020301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[500]	MOVE     	2 3
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00030100);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[504]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_132
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 18	[504]	JMP      	113	; to 133
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x80003838);
    updatetrap(ci);
    goto label_132;
  }

  // 19	[505]	SELF     	3 2 2k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x02028194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 20	[505]	GETUPVAL 	5 1	; IFDEF
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00010289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 21	[505]	CALL     	3 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x020301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 22	[506]	SELF     	4 2 2k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x02028214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 23	[506]	GETUPVAL 	6 2	; IF
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00020309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 24	[506]	CALL     	4 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x02030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 25	[507]	SELF     	5 2 2k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x02028294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 26	[507]	GETUPVAL 	7 3	; IFNDEF
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00030389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 27	[507]	CALL     	5 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x020302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 28	[508]	SELF     	6 2 2k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x02028314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 29	[508]	GETUPVAL 	8 4	; ELIF
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00040409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 30	[508]	CALL     	6 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x02030344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 31	[509]	SELF     	7 2 2k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x02028394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 32	[509]	GETUPVAL 	9 5	; ELSEIF
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x00050489);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 33	[509]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 34	[510]	SELF     	8 2 2k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x02028414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 35	[510]	GETUPVAL 	10 6	; ELSE
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x00060509);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 36	[510]	CALL     	8 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x02030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 37	[511]	SELF     	9 2 2k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x02028494);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 38	[511]	GETUPVAL 	11 7	; ENDIF
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00070589);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 39	[511]	CALL     	9 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x020304c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 40	[512]	TESTSET  	10 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_53
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00038543);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 41	[512]	JMP      	11	; to 54
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x80000538);
    updatetrap(ci);
    goto label_53;
  }

  // 42	[512]	TESTSET  	10 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_53
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x00048543);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 43	[512]	JMP      	9	; to 54
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_53;
  }

  // 44	[512]	TESTSET  	10 5 1
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_53
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x00058543);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 45	[512]	JMP      	7	; to 54
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_53;
  }

  // 46	[512]	TESTSET  	10 6 1
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_53
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x00068543);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 47	[512]	JMP      	5	; to 54
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_53;
  }

  // 48	[512]	TESTSET  	10 7 1
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_53
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x00078543);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 49	[512]	JMP      	3	; to 54
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_53;
  }

  // 50	[512]	TESTSET  	10 8 1
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_53
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x00088543);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 51	[512]	JMP      	1	; to 54
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_53;
  }

  // 52	[512]	MOVE     	10 9
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x00090500);
    setobjs2s(L, ra, RB(i));
  }

  // 53	[514]	TEST     	10 0
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_132
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00000542);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 54	[514]	JMP      	77	; to 133
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x80002638);
    updatetrap(ci);
    goto label_132;
  }

  // 55	[515]	SELF     	11 0 3k	; "skip"
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x03008594);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 56	[515]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 57	[516]	TEST     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_64
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x000001c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 58	[516]	JMP      	5	; to 65
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_64;
  }

  // 59	[516]	SELF     	12 0 4k	; "openBlock"
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x04008614);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 60	[516]	SELF     	14 0 5k	; "defined"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x05008714);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 61	[516]	MOVE     	16 3
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x00030800);
    setobjs2s(L, ra, RB(i));
  }

  // 62	[516]	CALL     	14 3 0	; 2 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x00030744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 63	[516]	CALL     	12 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x01000644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 64	[518]	TEST     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_78
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x00000242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 65	[518]	JMP      	12	; to 79
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_78;
  }

  // 66	[518]	SELF     	12 0 4k	; "openBlock"
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x04008614);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 67	[518]	TEST     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_72
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x000005c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 68	[518]	JMP      	3	; to 73
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_72;
  }

  // 69	[518]	LOADTRUE 	14
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x00000707);
    setbtvalue(s2v(ra));
  }

  // 70	[518]	TEST     	14 1
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_77
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x00008742);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 71	[518]	JMP      	5	; to 78
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_77;
  }

  // 72	[518]	GETUPVAL 	14 8	; CBoolean
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x00080709);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 73	[518]	SELF     	15 0 6k	; "parseExpr"
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x06008794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 74	[518]	MOVE     	17 4
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x00040880);
    setobjs2s(L, ra, RB(i));
  }

  // 75	[518]	CALL     	15 3 0	; 2 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x000307c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 76	[518]	CALL     	14 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x02000744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 77	[518]	CALL     	12 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x01030644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 78	[519]	TEST     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_86
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x000002c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 79	[519]	JMP      	6	; to 87
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_86;
  }

  // 80	[519]	SELF     	12 0 4k	; "openBlock"
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x04008614);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 81	[519]	SELF     	14 0 5k	; "defined"
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x05008714);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 82	[519]	MOVE     	16 5
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x00050800);
    setobjs2s(L, ra, RB(i));
  }

  // 83	[519]	CALL     	14 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x02030744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 84	[519]	NOT      	14 14
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x000e0733);
    TValue *rb = vRB(i);
    if (l_isfalse(rb))
      setbtvalue(s2v(ra));
    else
      setbfvalue(s2v(ra));
  }

  // 85	[519]	CALL     	12 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x01030644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 86	[520]	TEST     	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_104
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x00000342);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 87	[520]	JMP      	16	; to 105
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x800007b8);
    updatetrap(ci);
    goto label_104;
  }

  // 88	[520]	SELF     	12 0 7k	; "elseBlock"
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x07008614);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 89	[520]	TEST     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_98
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x000005c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 90	[520]	JMP      	7	; to 99
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_98;
  }

  // 91	[520]	GETFIELD 	14 0 8	; "stack"
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x0800070e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 92	[520]	LEN      	14 14
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x000e0734);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 93	[520]	LT       	11 14 0
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_98
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x000e05ba);
    op_order(L, l_lti, LTnum, lessthanothers);
  }

  // 94	[520]	JMP      	3	; to 99
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_98;
  }

  // 95	[520]	LOADTRUE 	14
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x00000707);
    setbtvalue(s2v(ra));
  }

  // 96	[520]	TEST     	14 1
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_103
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x00008742);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 97	[520]	JMP      	5	; to 104
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_103;
  }

  // 98	[520]	GETUPVAL 	14 8	; CBoolean
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x00080709);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 99	[520]	SELF     	15 0 6k	; "parseExpr"
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x06008794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 100	[520]	MOVE     	17 6
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x00060880);
    setobjs2s(L, ra, RB(i));
  }

  // 101	[520]	CALL     	15 3 0	; 2 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x000307c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 102	[520]	CALL     	14 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x02000744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 103	[520]	CALL     	12 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x01030644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 104	[521]	TEST     	7 0
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_122
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x000003c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 105	[521]	JMP      	16	; to 123
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x800007b8);
    updatetrap(ci);
    goto label_122;
  }

  // 106	[521]	SELF     	12 0 7k	; "elseBlock"
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x07008614);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 107	[521]	TEST     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_116
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x000005c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 108	[521]	JMP      	7	; to 117
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_116;
  }

  // 109	[521]	GETFIELD 	14 0 8	; "stack"
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x0800070e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 110	[521]	LEN      	14 14
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x000e0734);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 111	[521]	LT       	11 14 0
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_116
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x000e05ba);
    op_order(L, l_lti, LTnum, lessthanothers);
  }

  // 112	[521]	JMP      	3	; to 117
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_116;
  }

  // 113	[521]	LOADTRUE 	14
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x00000707);
    setbtvalue(s2v(ra));
  }

  // 114	[521]	TEST     	14 1
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_121
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x00008742);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 115	[521]	JMP      	5	; to 122
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_121;
  }

  // 116	[521]	GETUPVAL 	14 8	; CBoolean
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x00080709);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 117	[521]	SELF     	15 0 6k	; "parseExpr"
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x06008794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 118	[521]	MOVE     	17 7
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x00070880);
    setobjs2s(L, ra, RB(i));
  }

  // 119	[521]	CALL     	15 3 0	; 2 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x000307c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 120	[521]	CALL     	14 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x02000744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 121	[521]	CALL     	12 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x01030644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 122	[522]	TEST     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_127
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x00000442);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 123	[522]	JMP      	3	; to 128
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_127;
  }

  // 124	[522]	SELF     	12 0 7k	; "elseBlock"
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x07008614);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 125	[522]	LOADTRUE 	14
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x00000707);
    setbtvalue(s2v(ra));
  }

  // 126	[522]	CALL     	12 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x01030644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 127	[523]	TEST     	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_131
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x000004c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 128	[523]	JMP      	2	; to 132
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_131;
  }

  // 129	[523]	SELF     	12 0 9k	; "closeBlock"
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x09008614);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 130	[523]	CALL     	12 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_132
  label_130: {
    aot_vmfetch(0x01020644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 131	[524]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_133
  label_131: {
    aot_vmfetch(0x00010647);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 132	[530]	SELF     	3 0 3k	; "skip"
  #undef  AOT_PC
  #define AOT_PC (code + 133)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_134
  label_132: {
    aot_vmfetch(0x03008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 133	[530]	CALL     	3 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 134)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_135
  label_133: {
    aot_vmfetch(0x020201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 134	[530]	TEST     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 135)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_137
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_136
  label_134: {
    aot_vmfetch(0x000001c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 135	[530]	JMP      	1	; to 138
  #undef  AOT_PC
  #define AOT_PC (code + 136)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_137
  label_135: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_137;
  }

  // 136	[532]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 137)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_138
  label_136: {
    aot_vmfetch(0x000101c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 137	[537]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 138)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_276
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_139
  label_137: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 138	[537]	JMP      	137	; to 277
  #undef  AOT_PC
  #define AOT_PC (code + 139)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_140
  label_138: {
    aot_vmfetch(0x80004438);
    updatetrap(ci);
    goto label_276;
  }

  // 139	[539]	SELF     	3 2 2k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 140)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_141
  label_139: {
    aot_vmfetch(0x02028194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 140	[539]	GETUPVAL 	5 9	; UNDEF
  #undef  AOT_PC
  #define AOT_PC (code + 141)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_142
  label_140: {
    aot_vmfetch(0x00090289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 141	[539]	CALL     	3 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 142)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_143
  label_141: {
    aot_vmfetch(0x020301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 142	[540]	GETTABUP 	4 10 10	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 143)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_144
  label_142: {
    aot_vmfetch(0x0a0a020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 143	[540]	MOVE     	5 3
  #undef  AOT_PC
  #define AOT_PC (code + 144)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_145
  label_143: {
    aot_vmfetch(0x00030280);
    setobjs2s(L, ra, RB(i));
  }

  // 144	[540]	CALL     	4 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 145)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_146
  label_144: {
    aot_vmfetch(0x02020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 145	[540]	EQK      	4 11 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 146)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_151
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_147
  label_145: {
    aot_vmfetch(0x000b023c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 146	[540]	JMP      	4	; to 152
  #undef  AOT_PC
  #define AOT_PC (code + 147)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_148
  label_146: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_151;
  }

  // 147	[541]	SELF     	4 0 12k	; "undefine"
  #undef  AOT_PC
  #define AOT_PC (code + 148)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_149
  label_147: {
    aot_vmfetch(0x0c008214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 148	[541]	MOVE     	6 3
  #undef  AOT_PC
  #define AOT_PC (code + 149)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_150
  label_148: {
    aot_vmfetch(0x00030300);
    setobjs2s(L, ra, RB(i));
  }

  // 149	[541]	CALL     	4 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 150)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_151
  label_149: {
    aot_vmfetch(0x01030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 150	[542]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 151)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_152
  label_150: {
    aot_vmfetch(0x00010247);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 151	[546]	SELF     	4 2 2k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 152)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_153
  label_151: {
    aot_vmfetch(0x02028214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 152	[546]	GETUPVAL 	6 11	; DEFINE
  #undef  AOT_PC
  #define AOT_PC (code + 153)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_154
  label_152: {
    aot_vmfetch(0x000b0309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 153	[546]	CALL     	4 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 154)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_155
  label_153: {
    aot_vmfetch(0x02030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 154	[546]	TEST     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 155)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_208
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_156
  label_154: {
    aot_vmfetch(0x00000242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 155	[546]	JMP      	52	; to 209
  #undef  AOT_PC
  #define AOT_PC (code + 156)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_157
  label_155: {
    aot_vmfetch(0x800019b8);
    updatetrap(ci);
    goto label_208;
  }

  // 156	[547]	GETUPVAL 	4 12	; trim
  #undef  AOT_PC
  #define AOT_PC (code + 157)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_158
  label_156: {
    aot_vmfetch(0x000c0209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 157	[547]	SELF     	5 2 1k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 158)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_159
  label_157: {
    aot_vmfetch(0x01028294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 158	[547]	GETUPVAL 	7 11	; DEFINE
  #undef  AOT_PC
  #define AOT_PC (code + 159)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_160
  label_158: {
    aot_vmfetch(0x000b0389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 159	[547]	SELF     	7 7 13k	; "len"
  #undef  AOT_PC
  #define AOT_PC (code + 160)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_161
  label_159: {
    aot_vmfetch(0x0d078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 160	[547]	CALL     	7 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 161)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_162
  label_160: {
    aot_vmfetch(0x020203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 161	[547]	ADDI     	7 7 1
  #undef  AOT_PC
  #define AOT_PC (code + 162)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_163
  label_161: {
    aot_vmfetch(0x80070395);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 162	[547]	MMBINI   	7 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 163)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_164
  label_162: {
    aot_vmfetch(0x068003af);
    Instruction pi = 0x80070395;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 163	[547]	CALL     	5 3 0	; 2 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 164)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_165
  label_163: {
    aot_vmfetch(0x000302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 164	[547]	CALL     	4 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 165)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_166
  label_164: {
    aot_vmfetch(0x02000244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 165	[548]	LOADNIL  	5 1	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 166)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_167
  label_165: {
    aot_vmfetch(0x00010288);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 166	[551]	SELF     	7 4 2k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 167)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_168
  label_166: {
    aot_vmfetch(0x02048394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 167	[551]	GETUPVAL 	9 13	; TRUEMACRO
  #undef  AOT_PC
  #define AOT_PC (code + 168)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_169
  label_167: {
    aot_vmfetch(0x000d0489);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 168	[551]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 169)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_170
  label_168: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 169	[551]	MOVE     	5 7
  #undef  AOT_PC
  #define AOT_PC (code + 170)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_171
  label_169: {
    aot_vmfetch(0x00070280);
    setobjs2s(L, ra, RB(i));
  }

  // 170	[552]	TEST     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 171)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_177
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_172
  label_170: {
    aot_vmfetch(0x000002c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 171	[552]	JMP      	5	; to 178
  #undef  AOT_PC
  #define AOT_PC (code + 172)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_173
  label_171: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_177;
  }

  // 172	[553]	SELF     	7 0 14k	; "define"
  #undef  AOT_PC
  #define AOT_PC (code + 173)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_174
  label_172: {
    aot_vmfetch(0x0e008394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 173	[553]	MOVE     	9 5
  #undef  AOT_PC
  #define AOT_PC (code + 174)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_175
  label_173: {
    aot_vmfetch(0x00050480);
    setobjs2s(L, ra, RB(i));
  }

  // 174	[553]	LOADTRUE 	10
  #undef  AOT_PC
  #define AOT_PC (code + 175)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_176
  label_174: {
    aot_vmfetch(0x00000507);
    setbtvalue(s2v(ra));
  }

  // 175	[553]	CALL     	7 4 1	; 3 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 176)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_207
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_177
  label_175: {
    aot_vmfetch(0x010403c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 176	[554]	JMP      	30	; to 208
  #undef  AOT_PC
  #define AOT_PC (code + 177)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_178
  label_176: {
    aot_vmfetch(0x80000eb8);
    updatetrap(ci);
    goto label_207;
  }

  // 177	[557]	SELF     	7 4 2k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 178)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_179
  label_177: {
    aot_vmfetch(0x02048394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 178	[557]	GETUPVAL 	9 14	; REPLMACRO
  #undef  AOT_PC
  #define AOT_PC (code + 179)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_180
  label_178: {
    aot_vmfetch(0x000e0489);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 179	[557]	CALL     	7 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 180)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_181
  label_179: {
    aot_vmfetch(0x030303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 180	[557]	MOVE     	6 8
  #undef  AOT_PC
  #define AOT_PC (code + 181)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_182
  label_180: {
    aot_vmfetch(0x00080300);
    setobjs2s(L, ra, RB(i));
  }

  // 181	[557]	MOVE     	5 7
  #undef  AOT_PC
  #define AOT_PC (code + 182)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_183
  label_181: {
    aot_vmfetch(0x00070280);
    setobjs2s(L, ra, RB(i));
  }

  // 182	[558]	TEST     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 183)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_191
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_184
  label_182: {
    aot_vmfetch(0x000002c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 183	[558]	JMP      	7	; to 192
  #undef  AOT_PC
  #define AOT_PC (code + 184)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_185
  label_183: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_191;
  }

  // 184	[558]	TEST     	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 185)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_191
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_186
  label_184: {
    aot_vmfetch(0x00000342);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 185	[558]	JMP      	5	; to 192
  #undef  AOT_PC
  #define AOT_PC (code + 186)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_187
  label_185: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_191;
  }

  // 186	[559]	SELF     	7 0 14k	; "define"
  #undef  AOT_PC
  #define AOT_PC (code + 187)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_188
  label_186: {
    aot_vmfetch(0x0e008394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 187	[559]	MOVE     	9 5
  #undef  AOT_PC
  #define AOT_PC (code + 188)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_189
  label_187: {
    aot_vmfetch(0x00050480);
    setobjs2s(L, ra, RB(i));
  }

  // 188	[559]	MOVE     	10 6
  #undef  AOT_PC
  #define AOT_PC (code + 189)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_190
  label_188: {
    aot_vmfetch(0x00060500);
    setobjs2s(L, ra, RB(i));
  }

  // 189	[559]	CALL     	7 4 1	; 3 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 190)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_207
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_191
  label_189: {
    aot_vmfetch(0x010403c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 190	[560]	JMP      	16	; to 208
  #undef  AOT_PC
  #define AOT_PC (code + 191)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_192
  label_190: {
    aot_vmfetch(0x800007b8);
    updatetrap(ci);
    goto label_207;
  }

  // 191	[563]	SELF     	7 0 16k	; "parseFunction"
  #undef  AOT_PC
  #define AOT_PC (code + 192)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_193
  label_191: {
    aot_vmfetch(0x10008394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 192	[563]	MOVE     	9 4
  #undef  AOT_PC
  #define AOT_PC (code + 193)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_194
  label_192: {
    aot_vmfetch(0x00040480);
    setobjs2s(L, ra, RB(i));
  }

  // 193	[563]	CALL     	7 3 4	; 2 in 3 out
  #undef  AOT_PC
  #define AOT_PC (code + 194)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_195
  label_193: {
    aot_vmfetch(0x040303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 194	[563]	SETTABUP 	10 15 9	; _ENV "source"
  #undef  AOT_PC
  #define AOT_PC (code + 195)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_196
  label_194: {
    aot_vmfetch(0x090f050f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 195	[563]	MOVE     	6 8
  #undef  AOT_PC
  #define AOT_PC (code + 196)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_197
  label_195: {
    aot_vmfetch(0x00080300);
    setobjs2s(L, ra, RB(i));
  }

  // 196	[563]	MOVE     	5 7
  #undef  AOT_PC
  #define AOT_PC (code + 197)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_198
  label_196: {
    aot_vmfetch(0x00070280);
    setobjs2s(L, ra, RB(i));
  }

  // 197	[564]	TEST     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 198)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_207
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_199
  label_197: {
    aot_vmfetch(0x000002c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 198	[564]	JMP      	8	; to 208
  #undef  AOT_PC
  #define AOT_PC (code + 199)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_200
  label_198: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_207;
  }

  // 199	[564]	TEST     	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 200)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_207
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_201
  label_199: {
    aot_vmfetch(0x00000342);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 200	[564]	JMP      	6	; to 208
  #undef  AOT_PC
  #define AOT_PC (code + 201)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_202
  label_200: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_207;
  }

  // 201	[566]	SELF     	7 0 14k	; "define"
  #undef  AOT_PC
  #define AOT_PC (code + 202)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_203
  label_201: {
    aot_vmfetch(0x0e008394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 202	[566]	MOVE     	9 5
  #undef  AOT_PC
  #define AOT_PC (code + 203)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_204
  label_202: {
    aot_vmfetch(0x00050480);
    setobjs2s(L, ra, RB(i));
  }

  // 203	[566]	MOVE     	10 6
  #undef  AOT_PC
  #define AOT_PC (code + 204)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_205
  label_203: {
    aot_vmfetch(0x00060500);
    setobjs2s(L, ra, RB(i));
  }

  // 204	[566]	LOADFALSE	11
  #undef  AOT_PC
  #define AOT_PC (code + 205)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_206
  label_204: {
    aot_vmfetch(0x00000585);
    setbfvalue(s2v(ra));
  }

  // 205	[566]	GETTABUP 	12 10 15	; _ENV "source"
  #undef  AOT_PC
  #define AOT_PC (code + 206)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_207
  label_205: {
    aot_vmfetch(0x0f0a060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 206	[566]	CALL     	7 6 1	; 5 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 207)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_208
  label_206: {
    aot_vmfetch(0x010603c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 207	[572]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 208)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_209
  label_207: {
    aot_vmfetch(0x000103c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 208	[576]	SELF     	4 2 2k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 209)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_210
  label_208: {
    aot_vmfetch(0x02028214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 209	[576]	GETUPVAL 	6 15	; INCLUDE
  #undef  AOT_PC
  #define AOT_PC (code + 210)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_211
  label_209: {
    aot_vmfetch(0x000f0309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 210	[576]	CALL     	4 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 211)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_212
  label_210: {
    aot_vmfetch(0x02030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 211	[577]	TEST     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 212)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_217
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_213
  label_211: {
    aot_vmfetch(0x00000242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 212	[577]	JMP      	4	; to 218
  #undef  AOT_PC
  #define AOT_PC (code + 213)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_214
  label_212: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_217;
  }

  // 213	[578]	SELF     	5 0 17k	; "includeFile"
  #undef  AOT_PC
  #define AOT_PC (code + 214)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_215
  label_213: {
    aot_vmfetch(0x11008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 214	[578]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 215)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_216
  label_214: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 215	[578]	TAILCALL 	5 3 0	; 2 in
  #undef  AOT_PC
  #define AOT_PC (code + 216)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_217
  label_215: {
    aot_vmfetch(0x000302c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 216	[578]	RETURN   	5 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 217)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_218
  label_216: {
    aot_vmfetch(0x000002c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 217	[580]	SELF     	5 2 2k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 218)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_219
  label_217: {
    aot_vmfetch(0x02028294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 218	[580]	GETUPVAL 	7 16	; LOCAL_INCLUDE
  #undef  AOT_PC
  #define AOT_PC (code + 219)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_220
  label_218: {
    aot_vmfetch(0x00100389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 219	[580]	CALL     	5 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 220)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_221
  label_219: {
    aot_vmfetch(0x020302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 220	[580]	MOVE     	4 5
  #undef  AOT_PC
  #define AOT_PC (code + 221)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_222
  label_220: {
    aot_vmfetch(0x00050200);
    setobjs2s(L, ra, RB(i));
  }

  // 221	[581]	TEST     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 222)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_229
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_223
  label_221: {
    aot_vmfetch(0x00000242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 222	[581]	JMP      	6	; to 230
  #undef  AOT_PC
  #define AOT_PC (code + 223)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_224
  label_222: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_229;
  }

  // 223	[582]	SELF     	5 0 17k	; "includeFile"
  #undef  AOT_PC
  #define AOT_PC (code + 224)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_225
  label_223: {
    aot_vmfetch(0x11008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 224	[582]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 225)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_226
  label_224: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 225	[582]	LOADFALSE	8
  #undef  AOT_PC
  #define AOT_PC (code + 226)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_227
  label_225: {
    aot_vmfetch(0x00000405);
    setbfvalue(s2v(ra));
  }

  // 226	[582]	LOADTRUE 	9
  #undef  AOT_PC
  #define AOT_PC (code + 227)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_228
  label_226: {
    aot_vmfetch(0x00000487);
    setbtvalue(s2v(ra));
  }

  // 227	[582]	TAILCALL 	5 5 0	; 4 in
  #undef  AOT_PC
  #define AOT_PC (code + 228)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_229
  label_227: {
    aot_vmfetch(0x000502c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 228	[582]	RETURN   	5 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 229)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_230
  label_228: {
    aot_vmfetch(0x000002c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 229	[584]	SELF     	5 2 2k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 230)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_231
  label_229: {
    aot_vmfetch(0x02028294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 230	[584]	GETUPVAL 	7 17	; INCLUDE_NEXT
  #undef  AOT_PC
  #define AOT_PC (code + 231)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_232
  label_230: {
    aot_vmfetch(0x00110389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 231	[584]	CALL     	5 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 232)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_233
  label_231: {
    aot_vmfetch(0x020302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 232	[584]	MOVE     	4 5
  #undef  AOT_PC
  #define AOT_PC (code + 233)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_234
  label_232: {
    aot_vmfetch(0x00050200);
    setobjs2s(L, ra, RB(i));
  }

  // 233	[585]	TEST     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 234)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_240
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_235
  label_233: {
    aot_vmfetch(0x00000242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 234	[585]	JMP      	5	; to 241
  #undef  AOT_PC
  #define AOT_PC (code + 235)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_236
  label_234: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_240;
  }

  // 235	[587]	SELF     	5 0 17k	; "includeFile"
  #undef  AOT_PC
  #define AOT_PC (code + 236)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_237
  label_235: {
    aot_vmfetch(0x11008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 236	[587]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 237)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_238
  label_236: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 237	[587]	LOADTRUE 	8
  #undef  AOT_PC
  #define AOT_PC (code + 238)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_239
  label_237: {
    aot_vmfetch(0x00000407);
    setbtvalue(s2v(ra));
  }

  // 238	[587]	TAILCALL 	5 4 0	; 3 in
  #undef  AOT_PC
  #define AOT_PC (code + 239)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_240
  label_238: {
    aot_vmfetch(0x000402c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 239	[587]	RETURN   	5 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 240)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_241
  label_239: {
    aot_vmfetch(0x000002c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 240	[591]	SELF     	5 2 2k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 241)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_242
  label_240: {
    aot_vmfetch(0x02028294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 241	[591]	GETUPVAL 	7 18	; PRAGMA
  #undef  AOT_PC
  #define AOT_PC (code + 242)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_243
  label_241: {
    aot_vmfetch(0x00120389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 242	[591]	CALL     	5 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 243)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_244
  label_242: {
    aot_vmfetch(0x020302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 243	[591]	TEST     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 244)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_246
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_245
  label_243: {
    aot_vmfetch(0x000002c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 244	[591]	JMP      	1	; to 247
  #undef  AOT_PC
  #define AOT_PC (code + 245)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_246
  label_244: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_246;
  }

  // 245	[591]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 246)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_247
  label_245: {
    aot_vmfetch(0x000102c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 246	[594]	SELF     	5 2 2k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 247)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_248
  label_246: {
    aot_vmfetch(0x02028294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 247	[594]	GETUPVAL 	7 19	; ERROR
  #undef  AOT_PC
  #define AOT_PC (code + 248)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_249
  label_247: {
    aot_vmfetch(0x00130389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 248	[594]	CALL     	5 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 249)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_250
  label_248: {
    aot_vmfetch(0x020302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 249	[595]	SELF     	6 2 2k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 250)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_251
  label_249: {
    aot_vmfetch(0x02028314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 250	[595]	GETUPVAL 	8 20	; ERROR_NOTEXT
  #undef  AOT_PC
  #define AOT_PC (code + 251)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_252
  label_250: {
    aot_vmfetch(0x00140409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 251	[595]	CALL     	6 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 252)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_253
  label_251: {
    aot_vmfetch(0x02030344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 252	[596]	SELF     	7 2 2k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 253)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_254
  label_252: {
    aot_vmfetch(0x02028394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 253	[596]	GETUPVAL 	9 21	; WARNING
  #undef  AOT_PC
  #define AOT_PC (code + 254)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_255
  label_253: {
    aot_vmfetch(0x00150489);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 254	[596]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 255)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_256
  label_254: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 255	[597]	TEST     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 256)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_260
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_257
  label_255: {
    aot_vmfetch(0x000002c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 256	[597]	JMP      	3	; to 261
  #undef  AOT_PC
  #define AOT_PC (code + 257)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_258
  label_256: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_260;
  }

  // 257	[597]	GETUPVAL 	8 22	; error
  #undef  AOT_PC
  #define AOT_PC (code + 258)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_259
  label_257: {
    aot_vmfetch(0x00160409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 258	[597]	MOVE     	9 5
  #undef  AOT_PC
  #define AOT_PC (code + 259)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_260
  label_258: {
    aot_vmfetch(0x00050480);
    setobjs2s(L, ra, RB(i));
  }

  // 259	[597]	CALL     	8 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 260)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_261
  label_259: {
    aot_vmfetch(0x01020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 260	[598]	TEST     	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 261)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_265
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_262
  label_260: {
    aot_vmfetch(0x00000342);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 261	[598]	JMP      	3	; to 266
  #undef  AOT_PC
  #define AOT_PC (code + 262)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_263
  label_261: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_265;
  }

  // 262	[598]	GETUPVAL 	8 22	; error
  #undef  AOT_PC
  #define AOT_PC (code + 263)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_264
  label_262: {
    aot_vmfetch(0x00160409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 263	[598]	LOADK    	9 18	; "<ERROR MESSAGE NOT SET>"
  #undef  AOT_PC
  #define AOT_PC (code + 264)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_265
  label_263: {
    aot_vmfetch(0x00090483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 264	[598]	CALL     	8 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 265)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_266
  label_264: {
    aot_vmfetch(0x01020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 265	[599]	TEST     	7 0
  #undef  AOT_PC
  #define AOT_PC (code + 266)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_271
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_267
  label_265: {
    aot_vmfetch(0x000003c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 266	[599]	JMP      	4	; to 272
  #undef  AOT_PC
  #define AOT_PC (code + 267)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_268
  label_266: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_271;
  }

  // 267	[600]	GETUPVAL 	8 23	; print
  #undef  AOT_PC
  #define AOT_PC (code + 268)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_269
  label_267: {
    aot_vmfetch(0x00170409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 268	[600]	MOVE     	9 7
  #undef  AOT_PC
  #define AOT_PC (code + 269)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_270
  label_268: {
    aot_vmfetch(0x00070480);
    setobjs2s(L, ra, RB(i));
  }

  // 269	[600]	CALL     	8 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 270)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_271
  label_269: {
    aot_vmfetch(0x01020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 270	[601]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 271)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_272
  label_270: {
    aot_vmfetch(0x00010447);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 271	[605]	GETUPVAL 	8 22	; error
  #undef  AOT_PC
  #define AOT_PC (code + 272)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_273
  label_271: {
    aot_vmfetch(0x00160409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 272	[605]	LOADK    	9 19	; "unknown directive: "
  #undef  AOT_PC
  #define AOT_PC (code + 273)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_274
  label_272: {
    aot_vmfetch(0x00098483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 273	[605]	MOVE     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 274)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_275
  label_273: {
    aot_vmfetch(0x00010500);
    setobjs2s(L, ra, RB(i));
  }

  // 274	[605]	CONCAT   	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 275)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_276
  label_274: {
    aot_vmfetch(0x000204b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 275	[605]	CALL     	8 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 276)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_277
  label_275: {
    aot_vmfetch(0x01020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 276	[608]	GETFIELD 	3 0 20	; "incompleteLine"
  #undef  AOT_PC
  #define AOT_PC (code + 277)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_278
  label_276: {
    aot_vmfetch(0x1400018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 277	[608]	TEST     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 278)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_284
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_279
  label_277: {
    aot_vmfetch(0x000001c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 278	[608]	JMP      	5	; to 285
  #undef  AOT_PC
  #define AOT_PC (code + 279)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_280
  label_278: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_284;
  }

  // 279	[610]	GETFIELD 	3 0 20	; "incompleteLine"
  #undef  AOT_PC
  #define AOT_PC (code + 280)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_281
  label_279: {
    aot_vmfetch(0x1400018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 280	[610]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 281)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_282
  label_280: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 281	[610]	CONCAT   	3 2
  #undef  AOT_PC
  #define AOT_PC (code + 282)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_283
  label_281: {
    aot_vmfetch(0x000201b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 282	[610]	MOVE     	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 283)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_284
  label_282: {
    aot_vmfetch(0x00030080);
    setobjs2s(L, ra, RB(i));
  }

  // 283	[611]	SETFIELD 	0 20 21k	; "incompleteLine" null
  #undef  AOT_PC
  #define AOT_PC (code + 284)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_285
  label_283: {
    aot_vmfetch(0x15148012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 284	[617]	SELF     	3 0 22k	; "apply"
  #undef  AOT_PC
  #define AOT_PC (code + 285)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_286
  label_284: {
    aot_vmfetch(0x16008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 285	[617]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 286)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_287
  label_285: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 286	[617]	CALL     	3 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 287)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_288
  label_286: {
    aot_vmfetch(0x030301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 287	[619]	TEST     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 288)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_293
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_289
  label_287: {
    aot_vmfetch(0x00000242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 288	[619]	JMP      	4	; to 294
  #undef  AOT_PC
  #define AOT_PC (code + 289)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_290
  label_288: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_293;
  }

  // 289	[620]	SETFIELD 	0 20 1	; "incompleteLine"
  #undef  AOT_PC
  #define AOT_PC (code + 290)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_291
  label_289: {
    aot_vmfetch(0x01140012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 290	[621]	LOADK    	5 23	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 291)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_292
  label_290: {
    aot_vmfetch(0x000b8283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 291	[621]	RETURN1  	5
  #undef  AOT_PC
  #define AOT_PC (code + 292)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_294
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_293
  label_291: {
    aot_vmfetch(0x000202c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 292	[622]	JMP      	1	; to 295
  #undef  AOT_PC
  #define AOT_PC (code + 293)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_294
  label_292: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_294;
  }

  // 293	[623]	RETURN1  	3
  #undef  AOT_PC
  #define AOT_PC (code + 294)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_295
  label_293: {
    aot_vmfetch(0x000201c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 294	[626]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 295)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_294: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 295	[627]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 296)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_295: {
    aot_vmfetch(0x000102c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 629 - 644
static
CallInfo *magic_implementation_34(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
  }

  // 0	[642]	CLOSURE  	1 0	; 0x7fe611907d00
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x000000cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 1	[643]	GETTABUP 	2 3 0	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0003010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[643]	GETFIELD 	2 2 1	; "wrap"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0102010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[643]	CLOSURE  	3 1	; 0x7fe6119083e0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000081cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 4	[643]	TAILCALL 	2 2 0	; 1 in
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00028145);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 5	[643]	RETURN   	2 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_05: {
    aot_vmfetch(0x00008146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 6	[644]	RETURN   	2 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x00018146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 630 - 642
static
CallInfo *magic_implementation_35(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
  }

  // 0	[631]	SELF     	1 0 0k	; "defined"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00008094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 1	[631]	GETUPVAL 	3 0	; FILE
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 2	[631]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[631]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 4	[631]	JMP      	5	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_10;
  }

  // 5	[631]	SELF     	1 0 1k	; "define"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x01008094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 6	[631]	GETUPVAL 	3 0	; FILE
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[631]	LOADK    	4 2	; "<USER_CHUNK>"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00010203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 8	[631]	LOADTRUE 	5
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000287);
    setbtvalue(s2v(ra));
  }

  // 9	[631]	CALL     	1 5 1	; 4 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x010500c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[632]	SELF     	1 0 3k	; "getIndent"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x03008094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[632]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[634]	SELF     	2 0 4k	; "getLine"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x04008114);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 13	[634]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[635]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_17
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 15	[635]	JMP      	1	; to 18
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_17;
  }

  // 16	[635]	JMP      	25	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x80000c38);
    updatetrap(ci);
    goto label_42;
  }

  // 17	[636]	GETUPVAL 	3 1	; processLine
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00010189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 18	[636]	MOVE     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00000200);
    setobjs2s(L, ra, RB(i));
  }

  // 19	[636]	MOVE     	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00020280);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[636]	CALL     	3 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x020301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 21	[637]	GETTABUP 	4 2 5	; preprocessor "FAST"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0502020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 22	[637]	TEST     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_27
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00008242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 23	[637]	JMP      	3	; to 28
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_27;
  }

  // 24	[637]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_27
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 25	[637]	JMP      	1	; to 28
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_27;
  }

  // 26	[637]	LOADK    	3 6	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00030183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 27	[638]	GETTABUP 	4 2 7	; preprocessor "DEBUG"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0702020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 28	[638]	TEST     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_35
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00000242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 29	[638]	JMP      	5	; to 36
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_35;
  }

  // 30	[638]	MOVE     	4 3
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00030200);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[638]	LOADK    	5 8	; " -- "
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x00040283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 32	[638]	MOVE     	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x00020300);
    setobjs2s(L, ra, RB(i));
  }

  // 33	[638]	CONCAT   	4 3
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x00030235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 34	[638]	MOVE     	3 4
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00040180);
    setobjs2s(L, ra, RB(i));
  }

  // 35	[639]	TEST     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x000001c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 36	[639]	JMP      	-25	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x7ffff338);
    updatetrap(ci);
    goto label_12;
  }

  // 37	[639]	GETTABUP 	4 3 9	; _ENV "coroutine"
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x0903020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 38	[639]	GETFIELD 	4 4 10	; "yield"
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x0a04020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 39	[639]	MOVE     	5 3
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00030280);
    setobjs2s(L, ra, RB(i));
  }

  // 40	[639]	CALL     	4 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x01020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 41	[640]	JMP      	-30	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x7ffff0b8);
    updatetrap(ci);
    goto label_12;
  }

  // 42	[641]	SELF     	2 0 3k	; "getIndent"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x03008114);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 43	[641]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 44	[641]	EQ       	1 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_54
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x000280b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 45	[641]	JMP      	8	; to 55
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_54;
  }

  // 46	[641]	GETUPVAL 	2 4	; error
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x00040109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 47	[641]	LOADK    	3 11	; "indentation level must be balanced within a file. was:"
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00058183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 48	[641]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 49	[641]	LOADK    	5 12	; " is:"
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00060283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 50	[641]	SELF     	6 0 3k	; "getIndent"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 51	[641]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 52	[641]	CONCAT   	3 4
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x000401b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 53	[641]	CALL     	2 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_53: {
    aot_vmfetch(0x01020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 54	[642]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_54: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 643 - 643
static
CallInfo *magic_implementation_36(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[643]	GETUPVAL 	0 0	; _doWork
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[643]	GETUPVAL 	1 1	; state
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 2	[643]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[643]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 646 - 652
static
CallInfo *magic_implementation_37(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
  }

  // 0	[647]	GETTABUP 	4 0 0	; preprocessor "compileFile"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[647]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[647]	GETFIELD 	6 0 1	; "defines"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0100030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[647]	GETFIELD 	7 0 2	; "macro_sources"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0200038e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[647]	MOVE     	8 2
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00020400);
    setobjs2s(L, ra, RB(i));
  }

  // 5	[647]	MOVE     	9 3
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00030480);
    setobjs2s(L, ra, RB(i));
  }

  // 6	[647]	CALL     	4 6 3	; 5 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x03060244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[649]	GETFIELD 	6 5 1	; "defines"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0105030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[649]	SETFIELD 	0 1 6	; "defines"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x06010012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 9	[651]	RETURN1  	4
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x00020248);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 10	[652]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_10: {
    aot_vmfetch(0x00010347);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 655 - 669
static
CallInfo *magic_implementation_38(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
  }

  // 0	[657]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_38
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 1	[657]	JMP      	36	; to 39
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x800011b8);
    updatetrap(ci);
    goto label_38;
  }

  // 2	[657]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_38
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 3	[657]	JMP      	34	; to 39
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x800010b8);
    updatetrap(ci);
    goto label_38;
  }

  // 4	[658]	GETTABUP 	5 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0000028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 5	[658]	MOVE     	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00020300);
    setobjs2s(L, ra, RB(i));
  }

  // 6	[658]	CALL     	5 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x020202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[658]	EQK      	5 1 0	; "function"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_27
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000102bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 8	[658]	JMP      	18	; to 28
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x800008b8);
    updatetrap(ci);
    goto label_27;
  }

  // 9	[659]	GETTABUP 	5 0 2	; _ENV "assert"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0200028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 10	[659]	MOVE     	6 4
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00040300);
    setobjs2s(L, ra, RB(i));
  }

  // 11	[659]	LOADK    	7 3	; "macro source should specify to check identity"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00018383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 12	[659]	CALL     	5 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x010302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 13	[660]	GETFIELD 	5 0 4	; "macro_sources"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0400028e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 14	[660]	GETTABLE 	5 5 1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0105028c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[661]	TEST     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000002c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 16	[661]	JMP      	7	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_24;
  }

  // 17	[661]	EQ       	5 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x000482b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 18	[661]	JMP      	5	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_24;
  }

  // 19	[661]	GETUPVAL 	6 1	; error
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00010309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 20	[661]	LOADK    	7 5	; "already defined: "
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00028383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 21	[661]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[661]	CONCAT   	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000203b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 23	[661]	CALL     	6 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x01020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[662]	GETFIELD 	6 0 4	; "macro_sources"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0400030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 25	[662]	SETTABLE 	6 1 4
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_38
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x04010310);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 26	[663]	JMP      	11	; to 39
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x80000538);
    updatetrap(ci);
    goto label_38;
  }

  // 27	[664]	GETFIELD 	5 0 6	; "defines"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0600028e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 28	[664]	GETTABLE 	5 5 1
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x0105028c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 29	[665]	TEST     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_38
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x000002c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 30	[665]	JMP      	7	; to 39
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_38;
  }

  // 31	[665]	EQ       	5 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_38
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000282b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 32	[665]	JMP      	5	; to 39
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_38;
  }

  // 33	[665]	GETUPVAL 	6 1	; error
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x00010309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 34	[665]	LOADK    	7 5	; "already defined: "
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00028383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 35	[665]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 36	[665]	CONCAT   	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x000203b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 37	[665]	CALL     	6 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x01020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 38	[668]	GETFIELD 	5 0 6	; "defines"
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x0600028e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 39	[668]	SELF     	6 0 7k	; "prepareMacro"
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x07008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 40	[668]	MOVE     	8 2
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00020400);
    setobjs2s(L, ra, RB(i));
  }

  // 41	[668]	CALL     	6 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x02030344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 42	[668]	SETTABLE 	5 1 6
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_42: {
    aot_vmfetch(0x06010290);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 43	[669]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_43: {
    aot_vmfetch(0x000102c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 800 - 826
static
CallInfo *magic_implementation_39(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
  }

  // 0	[801]	LOADFALSE	2
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000105);
    setbfvalue(s2v(ra));
  }

  // 1	[802]	LOADFALSE	3
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000185);
    setbfvalue(s2v(ra));
  }

  // 2	[803]	LOADFALSE	4
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000205);
    setbfvalue(s2v(ra));
  }

  // 3	[804]	LOADNIL  	5 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000288);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 4	[806]	MOVE     	6 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010300);
    setobjs2s(L, ra, RB(i));
  }

  // 5	[806]	LOADNIL  	7 2	; 3 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00020388);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 6	[806]	TFORPREP 	6 15	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0007834b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_22;
  }

  // 7	[807]	EQK      	10 0 0	; "BROPEN"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0000053c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 8	[807]	JMP      	1	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_10;
  }

  // 9	[808]	LOADTRUE 	3
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000187);
    setbtvalue(s2v(ra));
  }

  // 10	[810]	EQK      	10 1 0	; "identifier"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_16
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0001053c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 11	[810]	JMP      	4	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_16;
  }

  // 12	[811]	MOVE     	5 11
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000b0280);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[812]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_16
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 14	[812]	JMP      	1	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_16;
  }

  // 15	[812]	JMP      	8	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_24;
  }

  // 16	[814]	EQK      	10 2 0	; "BRCLOSE"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0002053c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 17	[814]	JMP      	4	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_22;
  }

  // 18	[814]	TEST     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x000002c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 19	[814]	JMP      	2	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_22;
  }

  // 20	[815]	LOADTRUE 	4
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00000207);
    setbtvalue(s2v(ra));
  }

  // 21	[816]	JMP      	2	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_24;
  }

  // 22	[806]	TFORCALL 	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0200034c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 23	[806]	TFORLOOP 	6 17	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x0008834d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_07; /* jump back */
    }
  }

  // 24	[818]	CLOSE    	6
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00000336);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 25	[821]	TEST     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_39
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x000002c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 26	[821]	JMP      	12	; to 40
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_39;
  }

  // 27	[821]	TEST     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_31
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000001c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 28	[821]	JMP      	2	; to 32
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_31;
  }

  // 29	[821]	TEST     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_35
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00008242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 30	[821]	JMP      	4	; to 36
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_35;
  }

  // 31	[821]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_39
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 32	[821]	JMP      	6	; to 40
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_39;
  }

  // 33	[821]	TEST     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_39
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x00008242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 34	[821]	JMP      	4	; to 40
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_39;
  }

  // 35	[822]	SELF     	6 0 3k	; "defined"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 36	[822]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 37	[822]	TAILCALL 	6 3 0	; 2 in
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00038345);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 38	[822]	RETURN   	6 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00008346);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 39	[825]	GETUPVAL 	6 0	; error
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00000309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 40	[825]	LOADK    	7 4	; "expression parse error: defined(ident)"
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00020383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 41	[825]	CALL     	6 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_41: {
    aot_vmfetch(0x01020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 42	[826]	RETURN   	6 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_42: {
    aot_vmfetch(0x00018346);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 846 - 880
static
CallInfo *magic_implementation_40(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
  }

  // 0	[847]	TEST     	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_18
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x000000c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 1	[847]	JMP      	16	; to 19
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x800007b8);
    updatetrap(ci);
    goto label_18;
  }

  // 2	[848]	EQK      	0 0 1	; "-"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0000803c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 3	[848]	JMP      	4	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_08;
  }

  // 4	[848]	EQK      	0 1 1	; "!"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0001803c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 5	[848]	JMP      	2	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_08;
  }

  // 6	[848]	EQK      	0 2 0	; "~"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0002003c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 7	[848]	JMP      	3	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_11;
  }

  // 8	[849]	LOADI    	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80008101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 9	[849]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_97
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 10	[850]	JMP      	86	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80002ab8);
    updatetrap(ci);
    goto label_97;
  }

  // 11	[851]	GETTABUP 	2 0 3	; _ENV "assert"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0300010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[851]	LOADFALSE	3
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000185);
    setbfvalue(s2v(ra));
  }

  // 13	[851]	LOADK    	4 4	; "unsupported unary operator:"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00020203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 14	[851]	MOVE     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000280);
    setobjs2s(L, ra, RB(i));
  }

  // 15	[851]	CONCAT   	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00020235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 16	[851]	CALL     	2 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_97
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x01030144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 17	[853]	JMP      	79	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x80002738);
    updatetrap(ci);
    goto label_97;
  }

  // 18	[854]	EQK      	0 5 1	; "*"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0005803c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 19	[854]	JMP      	4	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_24;
  }

  // 20	[854]	EQK      	0 6 1	; "/"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0006803c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 21	[854]	JMP      	2	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_24;
  }

  // 22	[854]	EQK      	0 7 0	; "%"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_27
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0007003c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 23	[854]	JMP      	3	; to 28
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_27;
  }

  // 24	[855]	LOADI    	2 3
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x80010101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 25	[855]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_97
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 26	[856]	JMP      	70	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x800022b8);
    updatetrap(ci);
    goto label_97;
  }

  // 27	[856]	EQK      	0 8 1	; "+"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_31
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0008803c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 28	[856]	JMP      	2	; to 32
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_31;
  }

  // 29	[856]	EQK      	0 0 0	; "-"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_34
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0000003c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 30	[856]	JMP      	3	; to 35
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_34;
  }

  // 31	[857]	LOADI    	2 4
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x80018101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 32	[857]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_97
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 33	[858]	JMP      	63	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x80001f38);
    updatetrap(ci);
    goto label_97;
  }

  // 34	[858]	EQK      	0 9 1	; ">>"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_38
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x0009803c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 35	[858]	JMP      	2	; to 39
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_38;
  }

  // 36	[858]	EQK      	0 10 0	; "<<"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_41
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x000a003c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 37	[858]	JMP      	3	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_41;
  }

  // 38	[859]	LOADI    	2 5
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x80020101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 39	[859]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_97
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 40	[860]	JMP      	56	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x80001bb8);
    updatetrap(ci);
    goto label_97;
  }

  // 41	[860]	EQK      	0 11 1	; "<"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_49
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x000b803c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 42	[860]	JMP      	6	; to 50
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_49;
  }

  // 43	[860]	EQK      	0 12 1	; ">"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_49
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x000c803c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 44	[860]	JMP      	4	; to 50
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_49;
  }

  // 45	[860]	EQK      	0 13 1	; "<="
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_49
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000d803c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 46	[860]	JMP      	2	; to 50
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_49;
  }

  // 47	[860]	EQK      	0 14 0	; ">="
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_52
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x000e003c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 48	[860]	JMP      	3	; to 53
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_52;
  }

  // 49	[861]	LOADI    	2 6
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x80028101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 50	[861]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_97
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 51	[862]	JMP      	45	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x80001638);
    updatetrap(ci);
    goto label_97;
  }

  // 52	[862]	EQK      	0 15 1	; "=="
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_56
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x000f803c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 53	[862]	JMP      	2	; to 57
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_56;
  }

  // 54	[862]	EQK      	0 16 0	; "!="
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_59
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x0010003c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 55	[862]	JMP      	3	; to 60
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_59;
  }

  // 56	[863]	LOADI    	2 7
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x80030101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 57	[863]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_97
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 58	[864]	JMP      	38	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x800012b8);
    updatetrap(ci);
    goto label_97;
  }

  // 59	[864]	EQK      	0 17 0	; "&"
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_64
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x0011003c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 60	[864]	JMP      	3	; to 65
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_64;
  }

  // 61	[865]	LOADI    	2 8
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x80038101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 62	[865]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_97
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 63	[866]	JMP      	33	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x80001038);
    updatetrap(ci);
    goto label_97;
  }

  // 64	[866]	EQK      	0 18 0	; "^"
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_69
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x0012003c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 65	[866]	JMP      	3	; to 70
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_69;
  }

  // 66	[867]	LOADI    	2 9
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x80040101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 67	[867]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_97
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 68	[868]	JMP      	28	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x80000db8);
    updatetrap(ci);
    goto label_97;
  }

  // 69	[868]	EQK      	0 19 0	; "|"
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_74
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x0013003c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 70	[868]	JMP      	3	; to 75
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_74;
  }

  // 71	[869]	LOADI    	2 10
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x80048101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 72	[869]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_97
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 73	[870]	JMP      	23	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x80000b38);
    updatetrap(ci);
    goto label_97;
  }

  // 74	[870]	EQK      	0 20 0	; "&&"
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_79
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x0014003c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 75	[870]	JMP      	3	; to 80
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_79;
  }

  // 76	[871]	LOADI    	2 11
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x80050101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 77	[871]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_97
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 78	[872]	JMP      	18	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x800008b8);
    updatetrap(ci);
    goto label_97;
  }

  // 79	[872]	EQK      	0 21 0	; "||"
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_84
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x0015003c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 80	[872]	JMP      	3	; to 85
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_84;
  }

  // 81	[873]	LOADI    	2 12
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x80058101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 82	[873]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_97
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 83	[874]	JMP      	13	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_97;
  }

  // 84	[874]	EQK      	0 22 1	; "?"
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_88
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x0016803c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 85	[874]	JMP      	2	; to 89
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_88;
  }

  // 86	[874]	EQK      	0 23 0	; ":"
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_91
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x0017003c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 87	[874]	JMP      	3	; to 92
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_91;
  }

  // 88	[875]	LOADI    	2 13
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x80060101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 89	[875]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_97
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 90	[876]	JMP      	6	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_97;
  }

  // 91	[877]	GETTABUP 	2 0 3	; _ENV "assert"
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x0300010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 92	[877]	LOADFALSE	3
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x00000185);
    setbfvalue(s2v(ra));
  }

  // 93	[877]	LOADK    	4 24	; "unsupported operator:"
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x000c0203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 94	[877]	MOVE     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x00000280);
    setobjs2s(L, ra, RB(i));
  }

  // 95	[877]	CONCAT   	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x00020235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 96	[877]	CALL     	2 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_96: {
    aot_vmfetch(0x01030144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 97	[880]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_97: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 883 - 943
static
CallInfo *magic_implementation_41(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
    case 132: goto label_132;
    case 133: goto label_133;
    case 134: goto label_134;
    case 135: goto label_135;
    case 136: goto label_136;
    case 137: goto label_137;
    case 138: goto label_138;
    case 139: goto label_139;
    case 140: goto label_140;
    case 141: goto label_141;
    case 142: goto label_142;
    case 143: goto label_143;
    case 144: goto label_144;
    case 145: goto label_145;
    case 146: goto label_146;
    case 147: goto label_147;
    case 148: goto label_148;
    case 149: goto label_149;
    case 150: goto label_150;
    case 151: goto label_151;
    case 152: goto label_152;
    case 153: goto label_153;
    case 154: goto label_154;
    case 155: goto label_155;
    case 156: goto label_156;
    case 157: goto label_157;
    case 158: goto label_158;
    case 159: goto label_159;
    case 160: goto label_160;
    case 161: goto label_161;
    case 162: goto label_162;
    case 163: goto label_163;
    case 164: goto label_164;
    case 165: goto label_165;
    case 166: goto label_166;
    case 167: goto label_167;
    case 168: goto label_168;
    case 169: goto label_169;
    case 170: goto label_170;
    case 171: goto label_171;
    case 172: goto label_172;
    case 173: goto label_173;
    case 174: goto label_174;
    case 175: goto label_175;
    case 176: goto label_176;
    case 177: goto label_177;
    case 178: goto label_178;
    case 179: goto label_179;
    case 180: goto label_180;
    case 181: goto label_181;
    case 182: goto label_182;
    case 183: goto label_183;
    case 184: goto label_184;
    case 185: goto label_185;
    case 186: goto label_186;
    case 187: goto label_187;
    case 188: goto label_188;
    case 189: goto label_189;
    case 190: goto label_190;
    case 191: goto label_191;
    case 192: goto label_192;
    case 193: goto label_193;
    case 194: goto label_194;
    case 195: goto label_195;
    case 196: goto label_196;
    case 197: goto label_197;
    case 198: goto label_198;
    case 199: goto label_199;
    case 200: goto label_200;
    case 201: goto label_201;
    case 202: goto label_202;
    case 203: goto label_203;
    case 204: goto label_204;
    case 205: goto label_205;
    case 206: goto label_206;
    case 207: goto label_207;
    case 208: goto label_208;
    case 209: goto label_209;
    case 210: goto label_210;
    case 211: goto label_211;
    case 212: goto label_212;
    case 213: goto label_213;
    case 214: goto label_214;
    case 215: goto label_215;
    case 216: goto label_216;
    case 217: goto label_217;
    case 218: goto label_218;
    case 219: goto label_219;
    case 220: goto label_220;
    case 221: goto label_221;
    case 222: goto label_222;
    case 223: goto label_223;
    case 224: goto label_224;
    case 225: goto label_225;
    case 226: goto label_226;
    case 227: goto label_227;
    case 228: goto label_228;
    case 229: goto label_229;
    case 230: goto label_230;
    case 231: goto label_231;
    case 232: goto label_232;
    case 233: goto label_233;
    case 234: goto label_234;
    case 235: goto label_235;
    case 236: goto label_236;
    case 237: goto label_237;
    case 238: goto label_238;
    case 239: goto label_239;
    case 240: goto label_240;
    case 241: goto label_241;
    case 242: goto label_242;
    case 243: goto label_243;
    case 244: goto label_244;
    case 245: goto label_245;
    case 246: goto label_246;
    case 247: goto label_247;
    case 248: goto label_248;
    case 249: goto label_249;
    case 250: goto label_250;
    case 251: goto label_251;
    case 252: goto label_252;
    case 253: goto label_253;
    case 254: goto label_254;
    case 255: goto label_255;
    case 256: goto label_256;
    case 257: goto label_257;
    case 258: goto label_258;
    case 259: goto label_259;
    case 260: goto label_260;
    case 261: goto label_261;
    case 262: goto label_262;
    case 263: goto label_263;
    case 264: goto label_264;
    case 265: goto label_265;
    case 266: goto label_266;
    case 267: goto label_267;
    case 268: goto label_268;
    case 269: goto label_269;
    case 270: goto label_270;
    case 271: goto label_271;
    case 272: goto label_272;
    case 273: goto label_273;
    case 274: goto label_274;
    case 275: goto label_275;
    case 276: goto label_276;
    case 277: goto label_277;
    case 278: goto label_278;
    case 279: goto label_279;
    case 280: goto label_280;
    case 281: goto label_281;
    case 282: goto label_282;
    case 283: goto label_283;
    case 284: goto label_284;
    case 285: goto label_285;
    case 286: goto label_286;
    case 287: goto label_287;
    case 288: goto label_288;
    case 289: goto label_289;
    case 290: goto label_290;
    case 291: goto label_291;
    case 292: goto label_292;
    case 293: goto label_293;
    case 294: goto label_294;
    case 295: goto label_295;
    case 296: goto label_296;
    case 297: goto label_297;
    case 298: goto label_298;
    case 299: goto label_299;
    case 300: goto label_300;
  }

  // 0	[884]	GETFIELD 	1 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 1	[884]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_38
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 2	[884]	JMP      	35	; to 39
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80001138);
    updatetrap(ci);
    goto label_38;
  }

  // 3	[885]	GETFIELD 	1 0 1	; "v"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0100008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[886]	GETFIELD 	2 0 2	; "uops"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0200010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[886]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_37
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 6	[886]	JMP      	30	; to 38
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000eb8);
    updatetrap(ci);
    goto label_37;
  }

  // 7	[887]	GETTABUP 	2 0 3	; _ENV "ipairs"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0300010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[887]	GETFIELD 	3 0 2	; "uops"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0200018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 9	[887]	CALL     	2 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x05020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[887]	TFORPREP 	2 23	; to 35
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000b814b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_34;
  }

  // 11	[889]	EQK      	7 4 0	; "-"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_15
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000403bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 12	[889]	JMP      	2	; to 16
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_15;
  }

  // 13	[890]	UNM      	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_34
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000100b1);
    TValue *rb = vRB(i);
    lua_Number nb;
    if (ttisinteger(rb)) {
      lua_Integer ib = ivalue(rb);
      setivalue(s2v(ra), intop(-, 0, ib));
    }
    else if (tonumberns(rb, nb)) {
      setfltvalue(s2v(ra), luai_numunm(L, nb));
    }
    else
      Protect(luaT_trybinTM(L, rb, rb, ra, TM_UNM));
  }

  // 14	[891]	JMP      	19	; to 35
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80000938);
    updatetrap(ci);
    goto label_34;
  }

  // 15	[891]	EQK      	7 5 0	; "!"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_19
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000503bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 16	[891]	JMP      	2	; to 20
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_19;
  }

  // 17	[892]	NOT      	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_34
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x000100b3);
    TValue *rb = vRB(i);
    if (l_isfalse(rb))
      setbtvalue(s2v(ra));
    else
      setbfvalue(s2v(ra));
  }

  // 18	[893]	JMP      	15	; to 35
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x80000738);
    updatetrap(ci);
    goto label_34;
  }

  // 19	[893]	EQK      	7 6 0	; "~"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_26
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000603bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 20	[893]	JMP      	5	; to 27
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_26;
  }

  // 21	[894]	GETTABUP 	8 1 7	; bit "bnot"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0701040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 22	[894]	MOVE     	9 1
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00010480);
    setobjs2s(L, ra, RB(i));
  }

  // 23	[894]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[894]	MOVE     	1 8
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_34
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00080080);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[895]	JMP      	8	; to 35
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_34;
  }

  // 26	[896]	GETTABUP 	8 0 8	; _ENV "assert"
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x0800040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 27	[896]	LOADFALSE	9
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00000485);
    setbfvalue(s2v(ra));
  }

  // 28	[896]	LOADK    	10 9	; "invalid uop:"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00048503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 29	[896]	GETTABUP 	11 0 10	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0a00058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 30	[896]	MOVE     	12 7
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00070600);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[896]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[896]	CONCAT   	10 2
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x00020535);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 33	[896]	CALL     	8 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x01030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 34	[887]	TFORCALL 	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x0200014c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 35	[887]	TFORLOOP 	2 25	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x000c814d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_11; /* jump back */
    }
  }

  // 36	[898]	CLOSE    	2
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00000136);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 37	[901]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 38	[904]	GETFIELD 	1 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 39	[904]	EQK      	1 11 0	; "+"
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x000b00bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 40	[904]	JMP      	10	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_51;
  }

  // 41	[905]	GETUPVAL 	1 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 42	[905]	GETFIELD 	2 0 12	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0c00010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 43	[905]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 44	[905]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 45	[905]	GETFIELD 	3 0 13	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x0d00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 46	[905]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 47	[905]	ADD      	1 1 2
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x020100a2);
    op_arith(L, l_addi, luai_numadd);
  }

  // 48	[905]	MMBIN    	1 2 6	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x060200ae);
    Instruction pi = 0x020100a2; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 49	[905]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_300
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 50	[906]	JMP      	249	; to 301
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x80007c38);
    updatetrap(ci);
    goto label_300;
  }

  // 51	[906]	GETFIELD 	1 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 52	[906]	EQK      	1 4 0	; "-"
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_64
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x000400bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 53	[906]	JMP      	10	; to 65
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_64;
  }

  // 54	[907]	GETUPVAL 	1 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 55	[907]	GETFIELD 	2 0 12	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x0c00010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 56	[907]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 57	[907]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 58	[907]	GETFIELD 	3 0 13	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x0d00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 59	[907]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 60	[907]	SUB      	1 1 2
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x020100a3);
    op_arith(L, l_subi, luai_numsub);
  }

  // 61	[907]	MMBIN    	1 2 7	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x070200ae);
    Instruction pi = 0x020100a3; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 62	[907]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_300
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 63	[908]	JMP      	236	; to 301
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x800075b8);
    updatetrap(ci);
    goto label_300;
  }

  // 64	[908]	GETFIELD 	1 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 65	[908]	EQK      	1 14 0	; "*"
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_77
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x000e00bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 66	[908]	JMP      	10	; to 78
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_77;
  }

  // 67	[909]	GETUPVAL 	1 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 68	[909]	GETFIELD 	2 0 12	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x0c00010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 69	[909]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 70	[909]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 71	[909]	GETFIELD 	3 0 13	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x0d00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 72	[909]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 73	[909]	MUL      	1 1 2
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x020100a4);
    op_arith(L, l_muli, luai_nummul);
  }

  // 74	[909]	MMBIN    	1 2 8	; __mul
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x080200ae);
    Instruction pi = 0x020100a4; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 75	[909]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_300
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 76	[910]	JMP      	223	; to 301
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x80006f38);
    updatetrap(ci);
    goto label_300;
  }

  // 77	[910]	GETFIELD 	1 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 78	[910]	EQK      	1 15 0	; "/"
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_90
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x000f00bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 79	[910]	JMP      	10	; to 91
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_90;
  }

  // 80	[911]	GETUPVAL 	1 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 81	[911]	GETFIELD 	2 0 12	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x0c00010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 82	[911]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 83	[911]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 84	[911]	GETFIELD 	3 0 13	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x0d00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 85	[911]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 86	[911]	DIV      	1 1 2
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x020100a7);
    op_arithf(L, luai_numdiv);
  }

  // 87	[911]	MMBIN    	1 2 11	; __div
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x0b0200ae);
    Instruction pi = 0x020100a7; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 88	[911]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_300
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 89	[912]	JMP      	210	; to 301
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x800068b8);
    updatetrap(ci);
    goto label_300;
  }

  // 90	[912]	GETFIELD 	1 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 91	[912]	EQK      	1 16 0	; "%"
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_103
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x001000bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 92	[912]	JMP      	10	; to 104
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_103;
  }

  // 93	[913]	GETUPVAL 	1 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 94	[913]	GETFIELD 	2 0 12	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x0c00010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 95	[913]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 96	[913]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 97	[913]	GETFIELD 	3 0 13	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x0d00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 98	[913]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 99	[913]	MOD      	1 1 2
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x020100a5);
    op_arith(L, luaV_mod, luaV_modf);
  }

  // 100	[913]	MMBIN    	1 2 9	; __mod
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x090200ae);
    Instruction pi = 0x020100a5; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 101	[913]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_300
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 102	[914]	JMP      	197	; to 301
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x80006238);
    updatetrap(ci);
    goto label_300;
  }

  // 103	[914]	GETFIELD 	1 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 104	[914]	EQK      	1 17 0	; "=="
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_118
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x001100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 105	[914]	JMP      	12	; to 119
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_118;
  }

  // 106	[915]	GETUPVAL 	1 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 107	[915]	GETFIELD 	2 0 12	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x0c00010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 108	[915]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 109	[915]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 110	[915]	GETFIELD 	3 0 13	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x0d00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 111	[915]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 112	[915]	EQ       	1 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_115
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x000280b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 113	[915]	JMP      	1	; to 116
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_115;
  }

  // 114	[915]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 115	[915]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 116	[915]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_300
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 117	[916]	JMP      	182	; to 301
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x80005ab8);
    updatetrap(ci);
    goto label_300;
  }

  // 118	[916]	GETFIELD 	1 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 119	[916]	EQK      	1 18 0	; "!="
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_133
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x001200bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 120	[916]	JMP      	12	; to 134
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_133;
  }

  // 121	[917]	GETUPVAL 	1 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 122	[917]	GETFIELD 	2 0 12	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x0c00010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 123	[917]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 124	[917]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 125	[917]	GETFIELD 	3 0 13	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x0d00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 126	[917]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 127	[917]	EQ       	1 2 0
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_130
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x000200b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 128	[917]	JMP      	1	; to 131
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_130;
  }

  // 129	[917]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 130	[917]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_132
  label_130: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 131	[917]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_300
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_133
  label_131: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 132	[918]	JMP      	167	; to 301
  #undef  AOT_PC
  #define AOT_PC (code + 133)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_134
  label_132: {
    aot_vmfetch(0x80005338);
    updatetrap(ci);
    goto label_300;
  }

  // 133	[918]	GETFIELD 	1 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 134)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_135
  label_133: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 134	[918]	EQK      	1 19 0	; "<<"
  #undef  AOT_PC
  #define AOT_PC (code + 135)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_146
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_136
  label_134: {
    aot_vmfetch(0x001300bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 135	[918]	JMP      	10	; to 147
  #undef  AOT_PC
  #define AOT_PC (code + 136)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_137
  label_135: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_146;
  }

  // 136	[919]	GETTABUP 	1 1 20	; bit "lshift"
  #undef  AOT_PC
  #define AOT_PC (code + 137)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_138
  label_136: {
    aot_vmfetch(0x1401008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 137	[919]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 138)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_139
  label_137: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 138	[919]	GETFIELD 	3 0 12	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 139)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_140
  label_138: {
    aot_vmfetch(0x0c00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 139	[919]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 140)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_141
  label_139: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 140	[919]	GETUPVAL 	3 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 141)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_142
  label_140: {
    aot_vmfetch(0x00020189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 141	[919]	GETFIELD 	4 0 13	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 142)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_143
  label_141: {
    aot_vmfetch(0x0d00020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 142	[919]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 143)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_144
  label_142: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 143	[919]	TAILCALL 	1 0 0	; -1 in
  #undef  AOT_PC
  #define AOT_PC (code + 144)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_145
  label_143: {
    aot_vmfetch(0x000080c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 144	[919]	RETURN   	1 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 145)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_300
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_146
  label_144: {
    aot_vmfetch(0x000080c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 145	[920]	JMP      	154	; to 301
  #undef  AOT_PC
  #define AOT_PC (code + 146)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_147
  label_145: {
    aot_vmfetch(0x80004cb8);
    updatetrap(ci);
    goto label_300;
  }

  // 146	[920]	GETFIELD 	1 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 147)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_148
  label_146: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 147	[920]	EQK      	1 21 0	; ">>"
  #undef  AOT_PC
  #define AOT_PC (code + 148)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_159
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_149
  label_147: {
    aot_vmfetch(0x001500bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 148	[920]	JMP      	10	; to 160
  #undef  AOT_PC
  #define AOT_PC (code + 149)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_150
  label_148: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_159;
  }

  // 149	[921]	GETTABUP 	1 1 22	; bit "rshift"
  #undef  AOT_PC
  #define AOT_PC (code + 150)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_151
  label_149: {
    aot_vmfetch(0x1601008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 150	[921]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 151)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_152
  label_150: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 151	[921]	GETFIELD 	3 0 12	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 152)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_153
  label_151: {
    aot_vmfetch(0x0c00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 152	[921]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 153)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_154
  label_152: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 153	[921]	GETUPVAL 	3 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 154)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_155
  label_153: {
    aot_vmfetch(0x00020189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 154	[921]	GETFIELD 	4 0 13	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 155)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_156
  label_154: {
    aot_vmfetch(0x0d00020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 155	[921]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 156)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_157
  label_155: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 156	[921]	TAILCALL 	1 0 0	; -1 in
  #undef  AOT_PC
  #define AOT_PC (code + 157)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_158
  label_156: {
    aot_vmfetch(0x000080c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 157	[921]	RETURN   	1 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 158)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_300
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_159
  label_157: {
    aot_vmfetch(0x000080c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 158	[922]	JMP      	141	; to 301
  #undef  AOT_PC
  #define AOT_PC (code + 159)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_160
  label_158: {
    aot_vmfetch(0x80004638);
    updatetrap(ci);
    goto label_300;
  }

  // 159	[922]	GETFIELD 	1 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 160)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_161
  label_159: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 160	[922]	EQK      	1 23 0	; "&&"
  #undef  AOT_PC
  #define AOT_PC (code + 161)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_176
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_162
  label_160: {
    aot_vmfetch(0x001700bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 161	[922]	JMP      	14	; to 177
  #undef  AOT_PC
  #define AOT_PC (code + 162)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_163
  label_161: {
    aot_vmfetch(0x800006b8);
    updatetrap(ci);
    goto label_176;
  }

  // 162	[923]	GETUPVAL 	1 3	; CBoolean
  #undef  AOT_PC
  #define AOT_PC (code + 163)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_164
  label_162: {
    aot_vmfetch(0x00030089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 163	[923]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 164)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_165
  label_163: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 164	[923]	GETFIELD 	3 0 12	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 165)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_166
  label_164: {
    aot_vmfetch(0x0c00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 165	[923]	CALL     	2 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 166)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_167
  label_165: {
    aot_vmfetch(0x00020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 166	[923]	CALL     	1 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 167)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_168
  label_166: {
    aot_vmfetch(0x020000c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 167	[923]	TEST     	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 168)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_174
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_169
  label_167: {
    aot_vmfetch(0x000000c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 168	[923]	JMP      	5	; to 175
  #undef  AOT_PC
  #define AOT_PC (code + 169)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_170
  label_168: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_174;
  }

  // 169	[923]	GETUPVAL 	1 3	; CBoolean
  #undef  AOT_PC
  #define AOT_PC (code + 170)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_171
  label_169: {
    aot_vmfetch(0x00030089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 170	[923]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 171)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_172
  label_170: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 171	[923]	GETFIELD 	3 0 13	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 172)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_173
  label_171: {
    aot_vmfetch(0x0d00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 172	[923]	CALL     	2 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 173)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_174
  label_172: {
    aot_vmfetch(0x00020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 173	[923]	CALL     	1 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 174)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_175
  label_173: {
    aot_vmfetch(0x020000c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 174	[923]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 175)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_300
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_176
  label_174: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 175	[924]	JMP      	124	; to 301
  #undef  AOT_PC
  #define AOT_PC (code + 176)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_177
  label_175: {
    aot_vmfetch(0x80003db8);
    updatetrap(ci);
    goto label_300;
  }

  // 176	[924]	GETFIELD 	1 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 177)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_178
  label_176: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 177	[924]	EQK      	1 24 0	; "||"
  #undef  AOT_PC
  #define AOT_PC (code + 178)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_193
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_179
  label_177: {
    aot_vmfetch(0x001800bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 178	[924]	JMP      	14	; to 194
  #undef  AOT_PC
  #define AOT_PC (code + 179)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_180
  label_178: {
    aot_vmfetch(0x800006b8);
    updatetrap(ci);
    goto label_193;
  }

  // 179	[925]	GETUPVAL 	1 3	; CBoolean
  #undef  AOT_PC
  #define AOT_PC (code + 180)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_181
  label_179: {
    aot_vmfetch(0x00030089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 180	[925]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 181)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_182
  label_180: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 181	[925]	GETFIELD 	3 0 12	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 182)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_183
  label_181: {
    aot_vmfetch(0x0c00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 182	[925]	CALL     	2 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 183)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_184
  label_182: {
    aot_vmfetch(0x00020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 183	[925]	CALL     	1 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 184)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_185
  label_183: {
    aot_vmfetch(0x020000c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 184	[925]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 185)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_191
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_186
  label_184: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 185	[925]	JMP      	5	; to 192
  #undef  AOT_PC
  #define AOT_PC (code + 186)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_187
  label_185: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_191;
  }

  // 186	[925]	GETUPVAL 	1 3	; CBoolean
  #undef  AOT_PC
  #define AOT_PC (code + 187)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_188
  label_186: {
    aot_vmfetch(0x00030089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 187	[925]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 188)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_189
  label_187: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 188	[925]	GETFIELD 	3 0 13	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 189)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_190
  label_188: {
    aot_vmfetch(0x0d00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 189	[925]	CALL     	2 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 190)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_191
  label_189: {
    aot_vmfetch(0x00020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 190	[925]	CALL     	1 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 191)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_192
  label_190: {
    aot_vmfetch(0x020000c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 191	[925]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 192)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_300
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_193
  label_191: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 192	[926]	JMP      	107	; to 301
  #undef  AOT_PC
  #define AOT_PC (code + 193)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_194
  label_192: {
    aot_vmfetch(0x80003538);
    updatetrap(ci);
    goto label_300;
  }

  // 193	[926]	GETFIELD 	1 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 194)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_195
  label_193: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 194	[926]	EQK      	1 25 0	; "&"
  #undef  AOT_PC
  #define AOT_PC (code + 195)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_206
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_196
  label_194: {
    aot_vmfetch(0x001900bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 195	[926]	JMP      	10	; to 207
  #undef  AOT_PC
  #define AOT_PC (code + 196)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_197
  label_195: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_206;
  }

  // 196	[927]	GETTABUP 	1 1 26	; bit "band"
  #undef  AOT_PC
  #define AOT_PC (code + 197)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_198
  label_196: {
    aot_vmfetch(0x1a01008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 197	[927]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 198)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_199
  label_197: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 198	[927]	GETFIELD 	3 0 12	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 199)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_200
  label_198: {
    aot_vmfetch(0x0c00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 199	[927]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 200)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_201
  label_199: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 200	[927]	GETUPVAL 	3 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 201)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_202
  label_200: {
    aot_vmfetch(0x00020189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 201	[927]	GETFIELD 	4 0 13	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 202)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_203
  label_201: {
    aot_vmfetch(0x0d00020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 202	[927]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 203)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_204
  label_202: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 203	[927]	TAILCALL 	1 0 0	; -1 in
  #undef  AOT_PC
  #define AOT_PC (code + 204)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_205
  label_203: {
    aot_vmfetch(0x000080c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 204	[927]	RETURN   	1 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 205)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_300
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_206
  label_204: {
    aot_vmfetch(0x000080c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 205	[928]	JMP      	94	; to 301
  #undef  AOT_PC
  #define AOT_PC (code + 206)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_207
  label_205: {
    aot_vmfetch(0x80002eb8);
    updatetrap(ci);
    goto label_300;
  }

  // 206	[928]	GETFIELD 	1 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 207)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_208
  label_206: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 207	[928]	EQK      	1 27 0	; "|"
  #undef  AOT_PC
  #define AOT_PC (code + 208)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_219
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_209
  label_207: {
    aot_vmfetch(0x001b00bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 208	[928]	JMP      	10	; to 220
  #undef  AOT_PC
  #define AOT_PC (code + 209)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_210
  label_208: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_219;
  }

  // 209	[929]	GETTABUP 	1 1 28	; bit "bor"
  #undef  AOT_PC
  #define AOT_PC (code + 210)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_211
  label_209: {
    aot_vmfetch(0x1c01008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 210	[929]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 211)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_212
  label_210: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 211	[929]	GETFIELD 	3 0 12	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 212)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_213
  label_211: {
    aot_vmfetch(0x0c00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 212	[929]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 213)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_214
  label_212: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 213	[929]	GETUPVAL 	3 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 214)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_215
  label_213: {
    aot_vmfetch(0x00020189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 214	[929]	GETFIELD 	4 0 13	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 215)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_216
  label_214: {
    aot_vmfetch(0x0d00020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 215	[929]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 216)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_217
  label_215: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 216	[929]	TAILCALL 	1 0 0	; -1 in
  #undef  AOT_PC
  #define AOT_PC (code + 217)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_218
  label_216: {
    aot_vmfetch(0x000080c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 217	[929]	RETURN   	1 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 218)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_300
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_219
  label_217: {
    aot_vmfetch(0x000080c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 218	[930]	JMP      	81	; to 301
  #undef  AOT_PC
  #define AOT_PC (code + 219)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_220
  label_218: {
    aot_vmfetch(0x80002838);
    updatetrap(ci);
    goto label_300;
  }

  // 219	[930]	GETFIELD 	1 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 220)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_221
  label_219: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 220	[930]	EQK      	1 29 0	; "^"
  #undef  AOT_PC
  #define AOT_PC (code + 221)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_232
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_222
  label_220: {
    aot_vmfetch(0x001d00bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 221	[930]	JMP      	10	; to 233
  #undef  AOT_PC
  #define AOT_PC (code + 222)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_223
  label_221: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_232;
  }

  // 222	[931]	GETTABUP 	1 1 30	; bit "bxor"
  #undef  AOT_PC
  #define AOT_PC (code + 223)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_224
  label_222: {
    aot_vmfetch(0x1e01008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 223	[931]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 224)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_225
  label_223: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 224	[931]	GETFIELD 	3 0 12	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 225)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_226
  label_224: {
    aot_vmfetch(0x0c00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 225	[931]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 226)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_227
  label_225: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 226	[931]	GETUPVAL 	3 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 227)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_228
  label_226: {
    aot_vmfetch(0x00020189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 227	[931]	GETFIELD 	4 0 13	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 228)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_229
  label_227: {
    aot_vmfetch(0x0d00020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 228	[931]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 229)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_230
  label_228: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 229	[931]	TAILCALL 	1 0 0	; -1 in
  #undef  AOT_PC
  #define AOT_PC (code + 230)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_231
  label_229: {
    aot_vmfetch(0x000080c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 230	[931]	RETURN   	1 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 231)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_300
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_232
  label_230: {
    aot_vmfetch(0x000080c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 231	[932]	JMP      	68	; to 301
  #undef  AOT_PC
  #define AOT_PC (code + 232)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_233
  label_231: {
    aot_vmfetch(0x800021b8);
    updatetrap(ci);
    goto label_300;
  }

  // 232	[932]	GETFIELD 	1 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 233)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_234
  label_232: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 233	[932]	EQK      	1 31 0	; "<="
  #undef  AOT_PC
  #define AOT_PC (code + 234)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_247
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_235
  label_233: {
    aot_vmfetch(0x001f00bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 234	[932]	JMP      	12	; to 248
  #undef  AOT_PC
  #define AOT_PC (code + 235)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_236
  label_234: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_247;
  }

  // 235	[933]	GETUPVAL 	1 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 236)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_237
  label_235: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 236	[933]	GETFIELD 	2 0 12	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 237)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_238
  label_236: {
    aot_vmfetch(0x0c00010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 237	[933]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 238)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_239
  label_237: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 238	[933]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 239)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_240
  label_238: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 239	[933]	GETFIELD 	3 0 13	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 240)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_241
  label_239: {
    aot_vmfetch(0x0d00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 240	[933]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 241)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_242
  label_240: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 241	[933]	LE       	1 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 242)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_244
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_243
  label_241: {
    aot_vmfetch(0x000280bb);
    op_order(L, l_lei, LEnum, lessequalothers);
  }

  // 242	[933]	JMP      	1	; to 245
  #undef  AOT_PC
  #define AOT_PC (code + 243)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_244
  label_242: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_244;
  }

  // 243	[933]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 244)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_245
  label_243: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 244	[933]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 245)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_246
  label_244: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 245	[933]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 246)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_300
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_247
  label_245: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 246	[934]	JMP      	53	; to 301
  #undef  AOT_PC
  #define AOT_PC (code + 247)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_248
  label_246: {
    aot_vmfetch(0x80001a38);
    updatetrap(ci);
    goto label_300;
  }

  // 247	[934]	GETFIELD 	1 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 248)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_249
  label_247: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 248	[934]	EQK      	1 32 0	; ">="
  #undef  AOT_PC
  #define AOT_PC (code + 249)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_262
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_250
  label_248: {
    aot_vmfetch(0x002000bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 249	[934]	JMP      	12	; to 263
  #undef  AOT_PC
  #define AOT_PC (code + 250)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_251
  label_249: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_262;
  }

  // 250	[935]	GETUPVAL 	1 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 251)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_252
  label_250: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 251	[935]	GETFIELD 	2 0 12	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 252)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_253
  label_251: {
    aot_vmfetch(0x0c00010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 252	[935]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 253)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_254
  label_252: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 253	[935]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 254)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_255
  label_253: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 254	[935]	GETFIELD 	3 0 13	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 255)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_256
  label_254: {
    aot_vmfetch(0x0d00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 255	[935]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 256)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_257
  label_255: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 256	[935]	LE       	2 1 1
  #undef  AOT_PC
  #define AOT_PC (code + 257)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_259
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_258
  label_256: {
    aot_vmfetch(0x0001813b);
    op_order(L, l_lei, LEnum, lessequalothers);
  }

  // 257	[935]	JMP      	1	; to 260
  #undef  AOT_PC
  #define AOT_PC (code + 258)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_259
  label_257: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_259;
  }

  // 258	[935]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 259)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_260
  label_258: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 259	[935]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 260)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_261
  label_259: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 260	[935]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 261)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_300
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_262
  label_260: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 261	[936]	JMP      	38	; to 301
  #undef  AOT_PC
  #define AOT_PC (code + 262)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_263
  label_261: {
    aot_vmfetch(0x800012b8);
    updatetrap(ci);
    goto label_300;
  }

  // 262	[936]	GETFIELD 	1 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 263)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_264
  label_262: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 263	[936]	EQK      	1 33 0	; "<"
  #undef  AOT_PC
  #define AOT_PC (code + 264)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_277
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_265
  label_263: {
    aot_vmfetch(0x002100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 264	[936]	JMP      	12	; to 278
  #undef  AOT_PC
  #define AOT_PC (code + 265)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_266
  label_264: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_277;
  }

  // 265	[937]	GETUPVAL 	1 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 266)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_267
  label_265: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 266	[937]	GETFIELD 	2 0 12	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 267)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_268
  label_266: {
    aot_vmfetch(0x0c00010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 267	[937]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 268)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_269
  label_267: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 268	[937]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 269)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_270
  label_268: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 269	[937]	GETFIELD 	3 0 13	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 270)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_271
  label_269: {
    aot_vmfetch(0x0d00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 270	[937]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 271)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_272
  label_270: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 271	[937]	LT       	1 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 272)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_274
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_273
  label_271: {
    aot_vmfetch(0x000280ba);
    op_order(L, l_lti, LTnum, lessthanothers);
  }

  // 272	[937]	JMP      	1	; to 275
  #undef  AOT_PC
  #define AOT_PC (code + 273)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_274
  label_272: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_274;
  }

  // 273	[937]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 274)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_275
  label_273: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 274	[937]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 275)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_276
  label_274: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 275	[937]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 276)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_300
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_277
  label_275: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 276	[938]	JMP      	23	; to 301
  #undef  AOT_PC
  #define AOT_PC (code + 277)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_278
  label_276: {
    aot_vmfetch(0x80000b38);
    updatetrap(ci);
    goto label_300;
  }

  // 277	[938]	GETFIELD 	1 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 278)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_279
  label_277: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 278	[938]	EQK      	1 34 0	; ">"
  #undef  AOT_PC
  #define AOT_PC (code + 279)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_292
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_280
  label_278: {
    aot_vmfetch(0x002200bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 279	[938]	JMP      	12	; to 293
  #undef  AOT_PC
  #define AOT_PC (code + 280)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_281
  label_279: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_292;
  }

  // 280	[939]	GETUPVAL 	1 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 281)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_282
  label_280: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 281	[939]	GETFIELD 	2 0 12	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 282)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_283
  label_281: {
    aot_vmfetch(0x0c00010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 282	[939]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 283)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_284
  label_282: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 283	[939]	GETUPVAL 	2 2	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 284)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_285
  label_283: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 284	[939]	GETFIELD 	3 0 13	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 285)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_286
  label_284: {
    aot_vmfetch(0x0d00018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 285	[939]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 286)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_287
  label_285: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 286	[939]	LT       	2 1 1
  #undef  AOT_PC
  #define AOT_PC (code + 287)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_289
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_288
  label_286: {
    aot_vmfetch(0x0001813a);
    op_order(L, l_lti, LTnum, lessthanothers);
  }

  // 287	[939]	JMP      	1	; to 290
  #undef  AOT_PC
  #define AOT_PC (code + 288)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_289
  label_287: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_289;
  }

  // 288	[939]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 289)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_290
  label_288: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 289	[939]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 290)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_291
  label_289: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 290	[939]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 291)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_300
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_292
  label_290: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 291	[940]	JMP      	8	; to 301
  #undef  AOT_PC
  #define AOT_PC (code + 292)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_293
  label_291: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_300;
  }

  // 292	[941]	GETTABUP 	1 0 8	; _ENV "assert"
  #undef  AOT_PC
  #define AOT_PC (code + 293)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_294
  label_292: {
    aot_vmfetch(0x0800008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 293	[941]	LOADFALSE	2
  #undef  AOT_PC
  #define AOT_PC (code + 294)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_295
  label_293: {
    aot_vmfetch(0x00000105);
    setbfvalue(s2v(ra));
  }

  // 294	[941]	LOADK    	3 35	; "invalid op:"
  #undef  AOT_PC
  #define AOT_PC (code + 295)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_296
  label_294: {
    aot_vmfetch(0x00118183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 295	[941]	GETTABUP 	4 0 10	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 296)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_297
  label_295: {
    aot_vmfetch(0x0a00020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 296	[941]	GETFIELD 	5 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 297)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_298
  label_296: {
    aot_vmfetch(0x0000028e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 297	[941]	CALL     	4 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 298)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_299
  label_297: {
    aot_vmfetch(0x02020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 298	[941]	CONCAT   	3 2
  #undef  AOT_PC
  #define AOT_PC (code + 299)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_300
  label_298: {
    aot_vmfetch(0x000201b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 299	[941]	CALL     	1 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 300)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_299: {
    aot_vmfetch(0x010300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 300	[943]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 301)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_300: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 945 - 954
static
CallInfo *magic_implementation_42(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
  }

  // 0	[947]	GETFIELD 	2 0 0	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 1	[947]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 2	[947]	JMP      	9	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_12;
  }

  // 3	[948]	GETTABUP 	2 0 1	; _ENV "assert"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[948]	GETFIELD 	3 0 2	; "v"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0200018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[948]	NOT      	3 3
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000301b3);
    TValue *rb = vRB(i);
    if (l_isfalse(rb))
      setbtvalue(s2v(ra));
    else
      setbfvalue(s2v(ra));
  }

  // 6	[948]	GETTABUP 	4 0 3	; _ENV "debug"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0300020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[948]	GETFIELD 	4 4 4	; "traceback"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0404020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[948]	CALL     	4 1 0	; 0 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[948]	CALL     	2 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x01000144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[949]	SETFIELD 	0 2 1	; "v"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_25
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x01020012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 11	[950]	JMP      	13	; to 26
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_25;
  }

  // 12	[951]	GETTABUP 	2 0 1	; _ENV "assert"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[951]	GETFIELD 	3 0 5	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0500018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 14	[951]	TEST     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_18
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x000001c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 15	[951]	JMP      	2	; to 19
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_18;
  }

  // 16	[951]	GETFIELD 	3 0 6	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0600018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 17	[951]	NOT      	3 3
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x000301b3);
    TValue *rb = vRB(i);
    if (l_isfalse(rb))
      setbtvalue(s2v(ra));
    else
      setbfvalue(s2v(ra));
  }

  // 18	[951]	CALL     	2 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x01020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[952]	NEWTABLE 	2 2 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00020113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 20	[952]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 21	[952]	SETFIELD 	2 2 1	; "v"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x01020112);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 22	[952]	GETFIELD 	3 0 7	; "uops"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0700018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 23	[952]	SETFIELD 	2 7 3	; "uops"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x03070112);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 24	[952]	SETFIELD 	0 6 2	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_24: {
    aot_vmfetch(0x02060012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 25	[954]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_25: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 956 - 960
static
CallInfo *magic_implementation_43(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
  }

  // 0	[958]	GETFIELD 	2 0 0	; "uops"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 1	[958]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 2	[958]	JMP      	3	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_06;
  }

  // 3	[958]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 4	[958]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 5	[958]	SETFIELD 	0 0 2	; "uops"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02000012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 6	[959]	GETTABUP 	2 0 1	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[959]	GETFIELD 	2 2 2	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0202010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[959]	GETFIELD 	3 0 0	; "uops"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0000018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 9	[959]	LOADI    	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x80000201);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 10	[959]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 11	[959]	CALL     	2 4 1	; 3 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x01040144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[960]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 962 - 1101
static
CallInfo *magic_implementation_44(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
    case 132: goto label_132;
    case 133: goto label_133;
    case 134: goto label_134;
    case 135: goto label_135;
    case 136: goto label_136;
    case 137: goto label_137;
    case 138: goto label_138;
    case 139: goto label_139;
    case 140: goto label_140;
    case 141: goto label_141;
    case 142: goto label_142;
    case 143: goto label_143;
    case 144: goto label_144;
    case 145: goto label_145;
    case 146: goto label_146;
    case 147: goto label_147;
    case 148: goto label_148;
    case 149: goto label_149;
    case 150: goto label_150;
    case 151: goto label_151;
    case 152: goto label_152;
    case 153: goto label_153;
    case 154: goto label_154;
    case 155: goto label_155;
    case 156: goto label_156;
    case 157: goto label_157;
    case 158: goto label_158;
    case 159: goto label_159;
    case 160: goto label_160;
    case 161: goto label_161;
    case 162: goto label_162;
    case 163: goto label_163;
    case 164: goto label_164;
    case 165: goto label_165;
    case 166: goto label_166;
    case 167: goto label_167;
    case 168: goto label_168;
    case 169: goto label_169;
    case 170: goto label_170;
    case 171: goto label_171;
    case 172: goto label_172;
    case 173: goto label_173;
    case 174: goto label_174;
    case 175: goto label_175;
    case 176: goto label_176;
    case 177: goto label_177;
    case 178: goto label_178;
    case 179: goto label_179;
    case 180: goto label_180;
    case 181: goto label_181;
    case 182: goto label_182;
    case 183: goto label_183;
    case 184: goto label_184;
    case 185: goto label_185;
    case 186: goto label_186;
    case 187: goto label_187;
    case 188: goto label_188;
    case 189: goto label_189;
    case 190: goto label_190;
    case 191: goto label_191;
    case 192: goto label_192;
    case 193: goto label_193;
    case 194: goto label_194;
    case 195: goto label_195;
    case 196: goto label_196;
    case 197: goto label_197;
    case 198: goto label_198;
    case 199: goto label_199;
    case 200: goto label_200;
    case 201: goto label_201;
    case 202: goto label_202;
    case 203: goto label_203;
    case 204: goto label_204;
    case 205: goto label_205;
    case 206: goto label_206;
    case 207: goto label_207;
    case 208: goto label_208;
    case 209: goto label_209;
    case 210: goto label_210;
    case 211: goto label_211;
    case 212: goto label_212;
    case 213: goto label_213;
    case 214: goto label_214;
    case 215: goto label_215;
    case 216: goto label_216;
    case 217: goto label_217;
    case 218: goto label_218;
    case 219: goto label_219;
    case 220: goto label_220;
    case 221: goto label_221;
    case 222: goto label_222;
    case 223: goto label_223;
    case 224: goto label_224;
    case 225: goto label_225;
    case 226: goto label_226;
    case 227: goto label_227;
    case 228: goto label_228;
    case 229: goto label_229;
    case 230: goto label_230;
    case 231: goto label_231;
    case 232: goto label_232;
    case 233: goto label_233;
    case 234: goto label_234;
    case 235: goto label_235;
    case 236: goto label_236;
    case 237: goto label_237;
    case 238: goto label_238;
    case 239: goto label_239;
    case 240: goto label_240;
    case 241: goto label_241;
    case 242: goto label_242;
    case 243: goto label_243;
    case 244: goto label_244;
    case 245: goto label_245;
    case 246: goto label_246;
    case 247: goto label_247;
    case 248: goto label_248;
    case 249: goto label_249;
    case 250: goto label_250;
    case 251: goto label_251;
    case 252: goto label_252;
    case 253: goto label_253;
    case 254: goto label_254;
    case 255: goto label_255;
    case 256: goto label_256;
    case 257: goto label_257;
    case 258: goto label_258;
    case 259: goto label_259;
    case 260: goto label_260;
    case 261: goto label_261;
    case 262: goto label_262;
    case 263: goto label_263;
    case 264: goto label_264;
    case 265: goto label_265;
    case 266: goto label_266;
    case 267: goto label_267;
    case 268: goto label_268;
    case 269: goto label_269;
    case 270: goto label_270;
    case 271: goto label_271;
    case 272: goto label_272;
    case 273: goto label_273;
    case 274: goto label_274;
    case 275: goto label_275;
    case 276: goto label_276;
    case 277: goto label_277;
    case 278: goto label_278;
    case 279: goto label_279;
    case 280: goto label_280;
  }

  // 0	[963]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 1	[963]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 2	[964]	MOVE     	3 2
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00020180);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[966]	GETTABUP 	4 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0000020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[966]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 5	[966]	CALL     	4 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[966]	EQK      	4 1 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0001023c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 7	[966]	JMP      	5	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_13;
  }

  // 8	[968]	GETUPVAL 	4 1	; tokenizer
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 9	[968]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[968]	GETUPVAL 	6 2	; PRE_TOKENIZE_EXPR
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00020309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 11	[968]	CALL     	4 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x02030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[968]	MOVE     	1 4
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00040080);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[971]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 14	[971]	LOADNIL  	5 2	; 3 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00020288);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 15	[971]	TFORPREP 	4 257	; to 274
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x0080824b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_273;
  }

  // 16	[974]	EQK      	8 2 1	; "NOT"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_20
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0002843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 17	[974]	JMP      	2	; to 21
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_20;
  }

  // 18	[975]	EQK      	8 3 0	; "BNOT"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0003043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 19	[975]	JMP      	4	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_24;
  }

  // 20	[976]	GETUPVAL 	10 3	; setUnaryOp
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00030509);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 21	[976]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[976]	MOVE     	12 9
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00090600);
    setobjs2s(L, ra, RB(i));
  }

  // 23	[976]	CALL     	10 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x01030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[978]	EQK      	8 4 0	; "BROPEN"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_32
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0004043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 25	[978]	JMP      	6	; to 33
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_32;
  }

  // 26	[979]	GETUPVAL 	10 4	; setValue
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00040509);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 27	[979]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 28	[979]	SELF     	12 0 5k	; "parseExpr"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x05008614);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 29	[979]	MOVE     	14 1
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00010700);
    setobjs2s(L, ra, RB(i));
  }

  // 30	[979]	CALL     	12 3 0	; 2 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00030644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 31	[979]	CALL     	10 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x01000544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[981]	EQK      	8 6 0	; "BRCLOSE"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_35
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x0006043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 33	[981]	JMP      	1	; to 36
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_275
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_35;
  }

  // 34	[983]	JMP      	240	; to 276
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x800077b8);
    updatetrap(ci);
    goto label_275;
  }

  // 35	[985]	EQK      	8 7 0	; "STRING_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_50
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x0007043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 36	[985]	JMP      	13	; to 51
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_50;
  }

  // 37	[986]	GETUPVAL 	10 4	; setValue
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00040509);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 38	[986]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 39	[986]	SELF     	12 9 8k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x08098614);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 40	[986]	GETI     	14 9 1
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x0109070d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 41	[986]	EQK      	14 9 0	; "L"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_46
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x0009073c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 42	[986]	JMP      	3	; to 47
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_46;
  }

  // 43	[986]	LOADI    	14 3
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x80010701);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 44	[986]	TEST     	14 1
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_47
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x00008742);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 45	[986]	JMP      	1	; to 48
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_47;
  }

  // 46	[986]	LOADI    	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x80008701);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 47	[986]	LOADI    	15 -2
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x7ffe8781);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 48	[986]	CALL     	12 4 0	; 3 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x00040644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 49	[986]	CALL     	10 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x01000544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 50	[988]	EQK      	8 10 1	; "NUMBER_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_58
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x000a843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 51	[988]	JMP      	6	; to 59
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_58;
  }

  // 52	[988]	EQK      	8 11 1	; "HEX_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_58
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x000b843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 53	[988]	JMP      	4	; to 59
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_58;
  }

  // 54	[988]	EQK      	8 12 1	; "FPNUM_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_58
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x000c843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 55	[988]	JMP      	2	; to 59
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_58;
  }

  // 56	[988]	EQK      	8 13 0	; "CHAR_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_66
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x000d043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 57	[988]	JMP      	8	; to 67
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_66;
  }

  // 58	[989]	GETUPVAL 	10 4	; setValue
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00040509);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 59	[989]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 60	[989]	GETTABUP 	12 0 14	; _ENV "tonumber"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x0e00060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 61	[989]	GETUPVAL 	13 5	; parseCInteger
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x00050689);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 62	[989]	MOVE     	14 9
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x00090700);
    setobjs2s(L, ra, RB(i));
  }

  // 63	[989]	CALL     	13 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x000206c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 64	[989]	CALL     	12 0 0	; all in all out
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x00000644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 65	[989]	CALL     	10 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x01000544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 66	[993]	EQK      	8 15 0	; "TENARY_START"
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_82
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x000f043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 67	[993]	JMP      	14	; to 83
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x800006b8);
    updatetrap(ci);
    goto label_82;
  }

  // 68	[994]	SELF     	10 0 5k	; "parseExpr"
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x05008514);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 69	[994]	MOVE     	12 1
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x00010600);
    setobjs2s(L, ra, RB(i));
  }

  // 70	[994]	CALL     	10 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x02030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 71	[995]	SELF     	11 0 5k	; "parseExpr"
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x05008594);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 72	[995]	MOVE     	13 1
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x00010680);
    setobjs2s(L, ra, RB(i));
  }

  // 73	[995]	CALL     	11 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x020305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 74	[996]	GETUPVAL 	12 6	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x00060609);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 75	[996]	MOVE     	13 3
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x00030680);
    setobjs2s(L, ra, RB(i));
  }

  // 76	[996]	CALL     	12 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x02020644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 77	[996]	TEST     	12 0
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_81
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x00000642);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 78	[996]	JMP      	2	; to 82
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_81;
  }

  // 79	[997]	RETURN   	10 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_82
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x00028546);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 80	[998]	JMP      	1	; to 83
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_82;
  }

  // 81	[999]	RETURN   	11 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x000285c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 82	[1002]	EQK      	8 16 0	; "TENARY_MIDDLE"
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_85
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x0010043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 83	[1002]	JMP      	1	; to 86
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_275
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_85;
  }

  // 84	[1003]	JMP      	190	; to 276
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x80005eb8);
    updatetrap(ci);
    goto label_275;
  }

  // 85	[1006]	EQK      	8 17 1	; "EQUAL"
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_121
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x0011843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 86	[1006]	JMP      	34	; to 122
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x800010b8);
    updatetrap(ci);
    goto label_121;
  }

  // 87	[1007]	EQK      	8 18 1	; "NOT_EQUAL"
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_121
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x0012843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 88	[1007]	JMP      	32	; to 122
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x80000fb8);
    updatetrap(ci);
    goto label_121;
  }

  // 89	[1008]	EQK      	8 19 1	; "AND"
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_121
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x0013843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 90	[1008]	JMP      	30	; to 122
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x80000eb8);
    updatetrap(ci);
    goto label_121;
  }

  // 91	[1009]	EQK      	8 20 1	; "OR"
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_121
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x0014843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 92	[1009]	JMP      	28	; to 122
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x80000db8);
    updatetrap(ci);
    goto label_121;
  }

  // 93	[1010]	EQK      	8 21 1	; "BAND"
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_121
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x0015843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 94	[1010]	JMP      	26	; to 122
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x80000cb8);
    updatetrap(ci);
    goto label_121;
  }

  // 95	[1011]	EQK      	8 22 1	; "BOR"
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_121
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x0016843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 96	[1011]	JMP      	24	; to 122
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x80000bb8);
    updatetrap(ci);
    goto label_121;
  }

  // 97	[1012]	EQK      	8 23 1	; "BXOR"
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_121
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x0017843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 98	[1012]	JMP      	22	; to 122
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x80000ab8);
    updatetrap(ci);
    goto label_121;
  }

  // 99	[1013]	EQK      	8 24 1	; "PLUS"
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_121
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x0018843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 100	[1013]	JMP      	20	; to 122
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x800009b8);
    updatetrap(ci);
    goto label_121;
  }

  // 101	[1014]	EQK      	8 25 1	; "MINUS"
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_121
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x0019843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 102	[1014]	JMP      	18	; to 122
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x800008b8);
    updatetrap(ci);
    goto label_121;
  }

  // 103	[1015]	EQK      	8 26 1	; "MULTIPLY"
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_121
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x001a843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 104	[1015]	JMP      	16	; to 122
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x800007b8);
    updatetrap(ci);
    goto label_121;
  }

  // 105	[1016]	EQK      	8 27 1	; "DIV"
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_121
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x001b843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 106	[1016]	JMP      	14	; to 122
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x800006b8);
    updatetrap(ci);
    goto label_121;
  }

  // 107	[1017]	EQK      	8 28 1	; "MOD"
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_121
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x001c843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 108	[1017]	JMP      	12	; to 122
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_121;
  }

  // 109	[1018]	EQK      	8 29 1	; "LTE"
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_121
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x001d843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 110	[1018]	JMP      	10	; to 122
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_121;
  }

  // 111	[1019]	EQK      	8 30 1	; "MTE"
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_121
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x001e843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 112	[1019]	JMP      	8	; to 122
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_121;
  }

  // 113	[1020]	EQK      	8 31 1	; "LSHIFT"
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_121
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x001f843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 114	[1020]	JMP      	6	; to 122
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_121;
  }

  // 115	[1021]	EQK      	8 32 1	; "RSHIFT"
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_121
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x0020843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 116	[1021]	JMP      	4	; to 122
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_121;
  }

  // 117	[1022]	EQK      	8 33 1	; "LT"
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_121
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x0021843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 118	[1022]	JMP      	2	; to 122
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_121;
  }

  // 119	[1023]	EQK      	8 34 0	; "MT"
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_241
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x0022043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 120	[1023]	JMP      	120	; to 242
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x80003bb8);
    updatetrap(ci);
    goto label_241;
  }

  // 121	[1024]	GETFIELD 	10 2 35	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x2302050e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 122	[1024]	TEST     	10 0
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_182
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x00000542);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 123	[1024]	JMP      	58	; to 183
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x80001cb8);
    updatetrap(ci);
    goto label_182;
  }

  // 124	[1025]	GETFIELD 	10 2 36	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x2402050e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 125	[1025]	TEST     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_147
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x00008542);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 126	[1025]	JMP      	20	; to 148
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x800009b8);
    updatetrap(ci);
    goto label_147;
  }

  // 127	[1026]	GETTABUP 	10 0 37	; _ENV "assert"
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x2500050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 128	[1026]	EQK      	8 25 1	; "MINUS"
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_131
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x0019843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 129	[1026]	JMP      	1	; to 132
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_131;
  }

  // 130	[1026]	LFALSESKIP	11
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_132
  label_130: {
    aot_vmfetch(0x00000586);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 131	[1026]	LOADTRUE 	11
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_133
  label_131: {
    aot_vmfetch(0x00000587);
    setbtvalue(s2v(ra));
  }

  // 132	[1026]	LOADK    	12 38	; "error: operators come consequently: "
  #undef  AOT_PC
  #define AOT_PC (code + 133)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_134
  label_132: {
    aot_vmfetch(0x00130603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 133	[1026]	GETTABUP 	13 0 39	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 134)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_135
  label_133: {
    aot_vmfetch(0x2700068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 134	[1026]	GETFIELD 	14 2 35	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 135)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_136
  label_134: {
    aot_vmfetch(0x2302070e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 135	[1026]	CALL     	13 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 136)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_137
  label_135: {
    aot_vmfetch(0x020206c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 136	[1026]	LOADK    	14 40	; " and "
  #undef  AOT_PC
  #define AOT_PC (code + 137)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_138
  label_136: {
    aot_vmfetch(0x00140703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 137	[1026]	GETTABUP 	15 0 39	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 138)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_139
  label_137: {
    aot_vmfetch(0x2700078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 138	[1026]	MOVE     	16 9
  #undef  AOT_PC
  #define AOT_PC (code + 139)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_140
  label_138: {
    aot_vmfetch(0x00090800);
    setobjs2s(L, ra, RB(i));
  }

  // 139	[1026]	CALL     	15 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 140)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_141
  label_139: {
    aot_vmfetch(0x020207c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 140	[1026]	CONCAT   	12 4
  #undef  AOT_PC
  #define AOT_PC (code + 141)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_142
  label_140: {
    aot_vmfetch(0x00040635);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 141	[1026]	CALL     	10 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 142)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_143
  label_141: {
    aot_vmfetch(0x01030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 142	[1028]	GETUPVAL 	10 3	; setUnaryOp
  #undef  AOT_PC
  #define AOT_PC (code + 143)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_144
  label_142: {
    aot_vmfetch(0x00030509);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 143	[1028]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 144)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_145
  label_143: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 144	[1028]	MOVE     	12 9
  #undef  AOT_PC
  #define AOT_PC (code + 145)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_146
  label_144: {
    aot_vmfetch(0x00090600);
    setobjs2s(L, ra, RB(i));
  }

  // 145	[1028]	CALL     	10 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 146)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_241
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_147
  label_145: {
    aot_vmfetch(0x01030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 146	[1029]	JMP      	94	; to 242
  #undef  AOT_PC
  #define AOT_PC (code + 147)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_148
  label_146: {
    aot_vmfetch(0x80002eb8);
    updatetrap(ci);
    goto label_241;
  }

  // 147	[1031]	MOVE     	10 2
  #undef  AOT_PC
  #define AOT_PC (code + 148)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_149
  label_147: {
    aot_vmfetch(0x00020500);
    setobjs2s(L, ra, RB(i));
  }

  // 148	[1032]	TEST     	10 0
  #undef  AOT_PC
  #define AOT_PC (code + 149)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_161
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_150
  label_148: {
    aot_vmfetch(0x00000542);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 149	[1032]	JMP      	11	; to 162
  #undef  AOT_PC
  #define AOT_PC (code + 150)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_151
  label_149: {
    aot_vmfetch(0x80000538);
    updatetrap(ci);
    goto label_161;
  }

  // 150	[1034]	GETUPVAL 	11 7	; combination_order
  #undef  AOT_PC
  #define AOT_PC (code + 151)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_152
  label_150: {
    aot_vmfetch(0x00070589);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 151	[1034]	GETFIELD 	12 10 35	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 152)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_153
  label_151: {
    aot_vmfetch(0x230a060e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 152	[1034]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 153)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_154
  label_152: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 153	[1034]	GETUPVAL 	12 7	; combination_order
  #undef  AOT_PC
  #define AOT_PC (code + 154)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_155
  label_153: {
    aot_vmfetch(0x00070609);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 154	[1034]	MOVE     	13 9
  #undef  AOT_PC
  #define AOT_PC (code + 155)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_156
  label_154: {
    aot_vmfetch(0x00090680);
    setobjs2s(L, ra, RB(i));
  }

  // 155	[1034]	CALL     	12 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 156)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_157
  label_155: {
    aot_vmfetch(0x02020644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 156	[1034]	LT       	12 11 0
  #undef  AOT_PC
  #define AOT_PC (code + 157)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_159
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_158
  label_156: {
    aot_vmfetch(0x000b063a);
    op_order(L, l_lti, LTnum, lessthanothers);
  }

  // 157	[1034]	JMP      	1	; to 160
  #undef  AOT_PC
  #define AOT_PC (code + 158)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_161
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_159
  label_157: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_159;
  }

  // 158	[1036]	JMP      	2	; to 162
  #undef  AOT_PC
  #define AOT_PC (code + 159)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_160
  label_158: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_161;
  }

  // 159	[1038]	GETFIELD 	10 10 41	; "parent"
  #undef  AOT_PC
  #define AOT_PC (code + 160)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_148
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_161
  label_159: {
    aot_vmfetch(0x290a050e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 160	[1039]	JMP      	-13	; to 149
  #undef  AOT_PC
  #define AOT_PC (code + 161)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_162
  label_160: {
    aot_vmfetch(0x7ffff938);
    updatetrap(ci);
    goto label_148;
  }

  // 161	[1040]	TEST     	10 0
  #undef  AOT_PC
  #define AOT_PC (code + 162)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_174
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_163
  label_161: {
    aot_vmfetch(0x00000542);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 162	[1040]	JMP      	11	; to 175
  #undef  AOT_PC
  #define AOT_PC (code + 163)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_164
  label_162: {
    aot_vmfetch(0x80000538);
    updatetrap(ci);
    goto label_174;
  }

  // 163	[1041]	NEWTABLE 	11 3 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 164)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_165
  label_163: {
    aot_vmfetch(0x00030593);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 164	[1041]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 165)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_166
  label_164: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 165	[1042]	SETFIELD 	11 35 9	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 166)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_167
  label_165: {
    aot_vmfetch(0x09230592);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 166	[1043]	GETFIELD 	12 10 36	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 167)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_168
  label_166: {
    aot_vmfetch(0x240a060e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 167	[1043]	SETFIELD 	11 42 12	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 168)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_169
  label_167: {
    aot_vmfetch(0x0c2a0592);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 168	[1044]	SETFIELD 	11 41 10	; "parent"
  #undef  AOT_PC
  #define AOT_PC (code + 169)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_170
  label_168: {
    aot_vmfetch(0x0a290592);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 169	[1045]	MOVE     	2 11
  #undef  AOT_PC
  #define AOT_PC (code + 170)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_171
  label_169: {
    aot_vmfetch(0x000b0100);
    setobjs2s(L, ra, RB(i));
  }

  // 170	[1046]	GETFIELD 	11 10 36	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 171)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_172
  label_170: {
    aot_vmfetch(0x240a058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 171	[1046]	SETFIELD 	11 41 2	; "parent"
  #undef  AOT_PC
  #define AOT_PC (code + 172)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_173
  label_171: {
    aot_vmfetch(0x02290592);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 172	[1047]	SETFIELD 	10 36 2	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 173)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_241
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_174
  label_172: {
    aot_vmfetch(0x02240512);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 173	[1048]	JMP      	67	; to 242
  #undef  AOT_PC
  #define AOT_PC (code + 174)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_175
  label_173: {
    aot_vmfetch(0x80002138);
    updatetrap(ci);
    goto label_241;
  }

  // 174	[1049]	NEWTABLE 	11 2 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 175)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_176
  label_174: {
    aot_vmfetch(0x00020593);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 175	[1049]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 176)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_177
  label_175: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 176	[1050]	SETFIELD 	11 35 9	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 177)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_178
  label_176: {
    aot_vmfetch(0x09230592);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 177	[1051]	SETFIELD 	11 42 3	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 178)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_179
  label_177: {
    aot_vmfetch(0x032a0592);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 178	[1052]	MOVE     	2 11
  #undef  AOT_PC
  #define AOT_PC (code + 179)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_180
  label_178: {
    aot_vmfetch(0x000b0100);
    setobjs2s(L, ra, RB(i));
  }

  // 179	[1053]	SETFIELD 	3 41 2	; "parent"
  #undef  AOT_PC
  #define AOT_PC (code + 180)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_181
  label_179: {
    aot_vmfetch(0x02290192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 180	[1054]	MOVE     	3 2
  #undef  AOT_PC
  #define AOT_PC (code + 181)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_241
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_182
  label_180: {
    aot_vmfetch(0x00020180);
    setobjs2s(L, ra, RB(i));
  }

  // 181	[1057]	JMP      	59	; to 242
  #undef  AOT_PC
  #define AOT_PC (code + 182)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_183
  label_181: {
    aot_vmfetch(0x80001d38);
    updatetrap(ci);
    goto label_241;
  }

  // 182	[1057]	GETFIELD 	10 2 43	; "v"
  #undef  AOT_PC
  #define AOT_PC (code + 183)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_184
  label_182: {
    aot_vmfetch(0x2b02050e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 183	[1057]	EQK      	10 44 1	; null
  #undef  AOT_PC
  #define AOT_PC (code + 184)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_228
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_185
  label_183: {
    aot_vmfetch(0x002c853c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 184	[1057]	JMP      	43	; to 229
  #undef  AOT_PC
  #define AOT_PC (code + 185)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_186
  label_184: {
    aot_vmfetch(0x80001538);
    updatetrap(ci);
    goto label_228;
  }

  // 185	[1058]	LOADNIL  	10 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 186)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_187
  label_185: {
    aot_vmfetch(0x00000508);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 186	[1059]	GETFIELD 	11 2 45	; "uops"
  #undef  AOT_PC
  #define AOT_PC (code + 187)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_188
  label_186: {
    aot_vmfetch(0x2d02058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 187	[1059]	TEST     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 188)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_206
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_189
  label_187: {
    aot_vmfetch(0x000005c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 188	[1059]	JMP      	17	; to 207
  #undef  AOT_PC
  #define AOT_PC (code + 189)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_190
  label_188: {
    aot_vmfetch(0x80000838);
    updatetrap(ci);
    goto label_206;
  }

  // 189	[1060]	GETTABUP 	11 0 46	; _ENV "ipairs"
  #undef  AOT_PC
  #define AOT_PC (code + 190)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_191
  label_189: {
    aot_vmfetch(0x2e00058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 190	[1060]	GETFIELD 	12 2 45	; "uops"
  #undef  AOT_PC
  #define AOT_PC (code + 191)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_192
  label_190: {
    aot_vmfetch(0x2d02060e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 191	[1060]	CALL     	11 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 192)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_193
  label_191: {
    aot_vmfetch(0x050205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 192	[1060]	TFORPREP 	11 10	; to 204
  #undef  AOT_PC
  #define AOT_PC (code + 193)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_194
  label_192: {
    aot_vmfetch(0x000505cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_203;
  }

  // 193	[1061]	GETUPVAL 	17 7	; combination_order
  #undef  AOT_PC
  #define AOT_PC (code + 194)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_195
  label_193: {
    aot_vmfetch(0x00070889);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 194	[1061]	MOVE     	18 16
  #undef  AOT_PC
  #define AOT_PC (code + 195)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_196
  label_194: {
    aot_vmfetch(0x00100900);
    setobjs2s(L, ra, RB(i));
  }

  // 195	[1061]	LOADTRUE 	19
  #undef  AOT_PC
  #define AOT_PC (code + 196)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_197
  label_195: {
    aot_vmfetch(0x00000987);
    setbtvalue(s2v(ra));
  }

  // 196	[1061]	CALL     	17 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 197)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_198
  label_196: {
    aot_vmfetch(0x020308c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 197	[1061]	GETUPVAL 	18 7	; combination_order
  #undef  AOT_PC
  #define AOT_PC (code + 198)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_199
  label_197: {
    aot_vmfetch(0x00070909);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 198	[1061]	MOVE     	19 9
  #undef  AOT_PC
  #define AOT_PC (code + 199)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_200
  label_198: {
    aot_vmfetch(0x00090980);
    setobjs2s(L, ra, RB(i));
  }

  // 199	[1061]	CALL     	18 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 200)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_201
  label_199: {
    aot_vmfetch(0x02020944);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 200	[1061]	LT       	18 17 0
  #undef  AOT_PC
  #define AOT_PC (code + 201)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_203
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_202
  label_200: {
    aot_vmfetch(0x0011093a);
    op_order(L, l_lti, LTnum, lessthanothers);
  }

  // 201	[1061]	JMP      	1	; to 204
  #undef  AOT_PC
  #define AOT_PC (code + 202)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_203
  label_201: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_203;
  }

  // 202	[1063]	MOVE     	10 16
  #undef  AOT_PC
  #define AOT_PC (code + 203)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_204
  label_202: {
    aot_vmfetch(0x00100500);
    setobjs2s(L, ra, RB(i));
  }

  // 203	[1060]	TFORCALL 	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 204)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_205
  label_203: {
    aot_vmfetch(0x020005cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 204	[1060]	TFORLOOP 	11 12	; to 194
  #undef  AOT_PC
  #define AOT_PC (code + 205)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_206
  label_204: {
    aot_vmfetch(0x000605cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_193; /* jump back */
    }
  }

  // 205	[1065]	CLOSE    	11
  #undef  AOT_PC
  #define AOT_PC (code + 206)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_207
  label_205: {
    aot_vmfetch(0x000005b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 206	[1067]	TEST     	10 0
  #undef  AOT_PC
  #define AOT_PC (code + 207)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_217
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_208
  label_206: {
    aot_vmfetch(0x00000542);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 207	[1067]	JMP      	9	; to 218
  #undef  AOT_PC
  #define AOT_PC (code + 208)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_209
  label_207: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_217;
  }

  // 208	[1068]	GETTABUP 	11 0 37	; _ENV "assert"
  #undef  AOT_PC
  #define AOT_PC (code + 209)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_210
  label_208: {
    aot_vmfetch(0x2500058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 209	[1068]	LOADFALSE	12
  #undef  AOT_PC
  #define AOT_PC (code + 210)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_211
  label_209: {
    aot_vmfetch(0x00000605);
    setbfvalue(s2v(ra));
  }

  // 210	[1068]	LOADK    	13 47	; "TODO: can we do something about this case??:"
  #undef  AOT_PC
  #define AOT_PC (code + 211)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_212
  label_210: {
    aot_vmfetch(0x00178683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 211	[1068]	MOVE     	14 9
  #undef  AOT_PC
  #define AOT_PC (code + 212)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_213
  label_211: {
    aot_vmfetch(0x00090700);
    setobjs2s(L, ra, RB(i));
  }

  // 212	[1068]	LOADK    	15 48	; " is stronger than "
  #undef  AOT_PC
  #define AOT_PC (code + 213)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_214
  label_212: {
    aot_vmfetch(0x00180783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 213	[1068]	MOVE     	16 10
  #undef  AOT_PC
  #define AOT_PC (code + 214)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_215
  label_213: {
    aot_vmfetch(0x000a0800);
    setobjs2s(L, ra, RB(i));
  }

  // 214	[1068]	CONCAT   	13 4
  #undef  AOT_PC
  #define AOT_PC (code + 215)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_216
  label_214: {
    aot_vmfetch(0x000406b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 215	[1068]	CALL     	11 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 216)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_241
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_217
  label_215: {
    aot_vmfetch(0x010305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 216	[1069]	JMP      	24	; to 242
  #undef  AOT_PC
  #define AOT_PC (code + 217)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_218
  label_216: {
    aot_vmfetch(0x80000bb8);
    updatetrap(ci);
    goto label_241;
  }

  // 217	[1070]	NEWTABLE 	11 2 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 218)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_219
  label_217: {
    aot_vmfetch(0x00020593);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 218	[1070]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 219)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_220
  label_218: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 219	[1070]	GETFIELD 	12 2 43	; "v"
  #undef  AOT_PC
  #define AOT_PC (code + 220)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_221
  label_219: {
    aot_vmfetch(0x2b02060e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 220	[1070]	SETFIELD 	11 43 12	; "v"
  #undef  AOT_PC
  #define AOT_PC (code + 221)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_222
  label_220: {
    aot_vmfetch(0x0c2b0592);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 221	[1070]	GETFIELD 	12 2 45	; "uops"
  #undef  AOT_PC
  #define AOT_PC (code + 222)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_223
  label_221: {
    aot_vmfetch(0x2d02060e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 222	[1070]	SETFIELD 	11 45 12	; "uops"
  #undef  AOT_PC
  #define AOT_PC (code + 223)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_224
  label_222: {
    aot_vmfetch(0x0c2d0592);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 223	[1070]	SETFIELD 	2 42 11	; "l"
  #undef  AOT_PC
  #define AOT_PC (code + 224)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_225
  label_223: {
    aot_vmfetch(0x0b2a0112);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 224	[1071]	SETFIELD 	2 43 44k	; "v" null
  #undef  AOT_PC
  #define AOT_PC (code + 225)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_226
  label_224: {
    aot_vmfetch(0x2c2b8112);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 225	[1072]	SETFIELD 	2 45 44k	; "uops" null
  #undef  AOT_PC
  #define AOT_PC (code + 226)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_227
  label_225: {
    aot_vmfetch(0x2c2d8112);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 226	[1073]	SETFIELD 	2 35 9	; "op"
  #undef  AOT_PC
  #define AOT_PC (code + 227)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_241
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_228
  label_226: {
    aot_vmfetch(0x09230112);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 227	[1075]	JMP      	13	; to 242
  #undef  AOT_PC
  #define AOT_PC (code + 228)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_229
  label_227: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_241;
  }

  // 228	[1076]	GETTABUP 	10 0 37	; _ENV "assert"
  #undef  AOT_PC
  #define AOT_PC (code + 229)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_230
  label_228: {
    aot_vmfetch(0x2500050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 229	[1076]	EQK      	8 25 1	; "MINUS"
  #undef  AOT_PC
  #define AOT_PC (code + 230)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_232
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_231
  label_229: {
    aot_vmfetch(0x0019843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 230	[1076]	JMP      	1	; to 233
  #undef  AOT_PC
  #define AOT_PC (code + 231)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_232
  label_230: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_232;
  }

  // 231	[1076]	LFALSESKIP	11
  #undef  AOT_PC
  #define AOT_PC (code + 232)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_233
  label_231: {
    aot_vmfetch(0x00000586);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 232	[1076]	LOADTRUE 	11
  #undef  AOT_PC
  #define AOT_PC (code + 233)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_234
  label_232: {
    aot_vmfetch(0x00000587);
    setbtvalue(s2v(ra));
  }

  // 233	[1076]	LOADK    	12 49	; "error: invalid unary operator:"
  #undef  AOT_PC
  #define AOT_PC (code + 234)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_235
  label_233: {
    aot_vmfetch(0x00188603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 234	[1076]	MOVE     	13 9
  #undef  AOT_PC
  #define AOT_PC (code + 235)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_236
  label_234: {
    aot_vmfetch(0x00090680);
    setobjs2s(L, ra, RB(i));
  }

  // 235	[1076]	CONCAT   	12 2
  #undef  AOT_PC
  #define AOT_PC (code + 236)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_237
  label_235: {
    aot_vmfetch(0x00020635);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 236	[1076]	CALL     	10 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 237)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_238
  label_236: {
    aot_vmfetch(0x01030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 237	[1077]	GETUPVAL 	10 3	; setUnaryOp
  #undef  AOT_PC
  #define AOT_PC (code + 238)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_239
  label_237: {
    aot_vmfetch(0x00030509);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 238	[1077]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 239)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_240
  label_238: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 239	[1077]	MOVE     	12 9
  #undef  AOT_PC
  #define AOT_PC (code + 240)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_241
  label_239: {
    aot_vmfetch(0x00090600);
    setobjs2s(L, ra, RB(i));
  }

  // 240	[1077]	CALL     	10 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 241)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_242
  label_240: {
    aot_vmfetch(0x01030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 241	[1080]	EQK      	8 50 0	; "DEFINED"
  #undef  AOT_PC
  #define AOT_PC (code + 242)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_251
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_243
  label_241: {
    aot_vmfetch(0x0032043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 242	[1080]	JMP      	8	; to 252
  #undef  AOT_PC
  #define AOT_PC (code + 243)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_244
  label_242: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_251;
  }

  // 243	[1081]	GETUPVAL 	10 4	; setValue
  #undef  AOT_PC
  #define AOT_PC (code + 244)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_245
  label_243: {
    aot_vmfetch(0x00040509);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 244	[1081]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 245)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_246
  label_244: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 245	[1081]	GETUPVAL 	12 8	; parseDefined
  #undef  AOT_PC
  #define AOT_PC (code + 246)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_247
  label_245: {
    aot_vmfetch(0x00080609);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 246	[1081]	MOVE     	13 0
  #undef  AOT_PC
  #define AOT_PC (code + 247)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_248
  label_246: {
    aot_vmfetch(0x00000680);
    setobjs2s(L, ra, RB(i));
  }

  // 247	[1081]	MOVE     	14 1
  #undef  AOT_PC
  #define AOT_PC (code + 248)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_249
  label_247: {
    aot_vmfetch(0x00010700);
    setobjs2s(L, ra, RB(i));
  }

  // 248	[1081]	CALL     	12 3 0	; 2 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 249)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_250
  label_248: {
    aot_vmfetch(0x00030644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 249	[1081]	CALL     	10 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 250)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_273
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_251
  label_249: {
    aot_vmfetch(0x01000544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 250	[1082]	JMP      	22	; to 274
  #undef  AOT_PC
  #define AOT_PC (code + 251)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_252
  label_250: {
    aot_vmfetch(0x80000ab8);
    updatetrap(ci);
    goto label_273;
  }

  // 251	[1082]	EQK      	8 51 1	; "identifier"
  #undef  AOT_PC
  #define AOT_PC (code + 252)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_255
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_253
  label_251: {
    aot_vmfetch(0x0033843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 252	[1082]	JMP      	2	; to 256
  #undef  AOT_PC
  #define AOT_PC (code + 253)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_254
  label_252: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_255;
  }

  // 253	[1082]	EQK      	8 52 0	; "FUNCTIONAL_MACRO"
  #undef  AOT_PC
  #define AOT_PC (code + 254)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_273
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_255
  label_253: {
    aot_vmfetch(0x0034043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 254	[1082]	JMP      	18	; to 274
  #undef  AOT_PC
  #define AOT_PC (code + 255)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_256
  label_254: {
    aot_vmfetch(0x800008b8);
    updatetrap(ci);
    goto label_273;
  }

  // 255	[1084]	SELF     	10 0 53k	; "apply"
  #undef  AOT_PC
  #define AOT_PC (code + 256)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_257
  label_255: {
    aot_vmfetch(0x35008514);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 256	[1084]	MOVE     	12 9
  #undef  AOT_PC
  #define AOT_PC (code + 257)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_258
  label_256: {
    aot_vmfetch(0x00090600);
    setobjs2s(L, ra, RB(i));
  }

  // 257	[1084]	CALL     	10 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 258)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_259
  label_257: {
    aot_vmfetch(0x02030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 258	[1086]	EQ       	10 9 1
  #undef  AOT_PC
  #define AOT_PC (code + 259)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_269
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_260
  label_258: {
    aot_vmfetch(0x00098539);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 259	[1086]	JMP      	9	; to 270
  #undef  AOT_PC
  #define AOT_PC (code + 260)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_261
  label_259: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_269;
  }

  // 260	[1087]	SELF     	11 0 5k	; "parseExpr"
  #undef  AOT_PC
  #define AOT_PC (code + 261)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_262
  label_260: {
    aot_vmfetch(0x05008594);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 261	[1087]	MOVE     	13 10
  #undef  AOT_PC
  #define AOT_PC (code + 262)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_263
  label_261: {
    aot_vmfetch(0x000a0680);
    setobjs2s(L, ra, RB(i));
  }

  // 262	[1087]	CALL     	11 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 263)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_264
  label_262: {
    aot_vmfetch(0x020305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 263	[1087]	MOVE     	10 11
  #undef  AOT_PC
  #define AOT_PC (code + 264)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_265
  label_263: {
    aot_vmfetch(0x000b0500);
    setobjs2s(L, ra, RB(i));
  }

  // 264	[1089]	GETUPVAL 	11 4	; setValue
  #undef  AOT_PC
  #define AOT_PC (code + 265)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_266
  label_264: {
    aot_vmfetch(0x00040589);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 265	[1089]	MOVE     	12 2
  #undef  AOT_PC
  #define AOT_PC (code + 266)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_267
  label_265: {
    aot_vmfetch(0x00020600);
    setobjs2s(L, ra, RB(i));
  }

  // 266	[1089]	MOVE     	13 10
  #undef  AOT_PC
  #define AOT_PC (code + 267)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_268
  label_266: {
    aot_vmfetch(0x000a0680);
    setobjs2s(L, ra, RB(i));
  }

  // 267	[1089]	CALL     	11 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 268)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_273
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_269
  label_267: {
    aot_vmfetch(0x010305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 268	[1090]	JMP      	4	; to 274
  #undef  AOT_PC
  #define AOT_PC (code + 269)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_270
  label_268: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_273;
  }

  // 269	[1093]	GETUPVAL 	11 4	; setValue
  #undef  AOT_PC
  #define AOT_PC (code + 270)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_271
  label_269: {
    aot_vmfetch(0x00040589);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 270	[1093]	MOVE     	12 2
  #undef  AOT_PC
  #define AOT_PC (code + 271)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_272
  label_270: {
    aot_vmfetch(0x00020600);
    setobjs2s(L, ra, RB(i));
  }

  // 271	[1093]	LOADI    	13 0
  #undef  AOT_PC
  #define AOT_PC (code + 272)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_273
  label_271: {
    aot_vmfetch(0x7fff8681);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 272	[1093]	CALL     	11 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 273)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_274
  label_272: {
    aot_vmfetch(0x010305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 273	[971]	TFORCALL 	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 274)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_275
  label_273: {
    aot_vmfetch(0x0200024c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 274	[971]	TFORLOOP 	4 259	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 275)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_276
  label_274: {
    aot_vmfetch(0x0081824d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_16; /* jump back */
    }
  }

  // 275	[1096]	CLOSE    	4
  #undef  AOT_PC
  #define AOT_PC (code + 276)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_277
  label_275: {
    aot_vmfetch(0x00000236);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 276	[1098]	GETUPVAL 	4 6	; evaluate
  #undef  AOT_PC
  #define AOT_PC (code + 277)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_278
  label_276: {
    aot_vmfetch(0x00060209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 277	[1098]	MOVE     	5 3
  #undef  AOT_PC
  #define AOT_PC (code + 278)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_279
  label_277: {
    aot_vmfetch(0x00030280);
    setobjs2s(L, ra, RB(i));
  }

  // 278	[1098]	CALL     	4 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 279)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_280
  label_278: {
    aot_vmfetch(0x02020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 279	[1100]	RETURN   	4 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 280)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_279: {
    aot_vmfetch(0x00028246);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 280	[1101]	RETURN   	5 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 281)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_280: {
    aot_vmfetch(0x000182c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1104 - 1120
static
CallInfo *magic_implementation_45(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
  }

  // 0	[1105]	GETTABUP 	2 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1105]	MOVE     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00010180);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1105]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1105]	EQK      	2 1 1	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0001813c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[1105]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[1105]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 6	[1107]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 7	[1107]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 8	[1108]	LOADNIL  	3 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000188);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 9	[1109]	GETUPVAL 	4 1	; tokenizer
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00010209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 10	[1109]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 11	[1109]	GETUPVAL 	6 2	; PRE_TOKENIZE_MACRO
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00020309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 12	[1109]	CALL     	4 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x05030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 13	[1109]	TFORPREP 	4 12	; to 27
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0006024b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_26;
  }

  // 14	[1110]	EQK      	8 2 0	; "CONCAT"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_18
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0002043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 15	[1110]	JMP      	2	; to 19
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_18;
  }

  // 16	[1112]	LOADTRUE 	3
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_26
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00000187);
    setbtvalue(s2v(ra));
  }

  // 17	[1113]	JMP      	8	; to 27
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_26;
  }

  // 18	[1114]	GETTABUP 	12 0 3	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0300060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 19	[1114]	GETFIELD 	12 12 4	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x040c060e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 20	[1114]	MOVE     	13 2
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00020680);
    setobjs2s(L, ra, RB(i));
  }

  // 21	[1114]	SELF     	14 1 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x05018714);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 22	[1114]	MOVE     	16 10
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000a0800);
    setobjs2s(L, ra, RB(i));
  }

  // 23	[1114]	MOVE     	17 11
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x000b0880);
    setobjs2s(L, ra, RB(i));
  }

  // 24	[1114]	CALL     	14 4 0	; 3 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00040744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 25	[1114]	CALL     	12 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x01000644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 26	[1109]	TFORCALL 	4 4
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x0400024c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 27	[1109]	TFORLOOP 	4 14	; to 15
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0007024d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_14; /* jump back */
    }
  }

  // 28	[1116]	CLOSE    	4
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00000236);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 29	[1117]	GETTABUP 	4 0 3	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0300020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 30	[1117]	GETFIELD 	4 4 6	; "concat"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x0604020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 31	[1117]	MOVE     	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x00020280);
    setobjs2s(L, ra, RB(i));
  }

  // 32	[1117]	CALL     	4 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x02020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 33	[1117]	MOVE     	1 4
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x00040080);
    setobjs2s(L, ra, RB(i));
  }

  // 34	[1118]	NOT      	4 3
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00030233);
    TValue *rb = vRB(i);
    if (l_isfalse(rb))
      setbtvalue(s2v(ra));
    else
      setbfvalue(s2v(ra));
  }

  // 35	[1118]	TEST     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x00000242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 36	[1118]	JMP      	-31	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x7ffff038);
    updatetrap(ci);
    goto label_06;
  }

  // 37	[1119]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_37: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 38	[1120]	RETURN   	2 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_38: {
    aot_vmfetch(0x00018146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1123 - 1145
static
CallInfo *magic_implementation_46(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
  }

  // 0	[1124]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 1	[1124]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 2	[1125]	SELF     	3 0 0k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[1125]	LOADI    	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x80008281);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 4	[1125]	LOADI    	6 -2
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x7ffe8301);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 5	[1125]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[1125]	MOVE     	0 3
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00030000);
    setobjs2s(L, ra, RB(i));
  }

  // 7	[1127]	LOADNIL  	3 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000188);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 8	[1128]	GETUPVAL 	4 0	; tokenizer
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 9	[1128]	MOVE     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000280);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[1128]	GETUPVAL 	6 1	; PRE_TOKENIZE_MACRO_ARGS
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00010309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 11	[1128]	CALL     	4 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x05030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[1128]	TFORPREP 	4 27	; to 41
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000d824b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_40;
  }

  // 13	[1130]	EQK      	8 1 1	; "ARGS"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0001843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 14	[1130]	JMP      	8	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_23;
  }

  // 15	[1130]	EQK      	8 2 1	; "PARENTHESE"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x0002843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 16	[1130]	JMP      	6	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_23;
  }

  // 17	[1130]	EQK      	8 3 1	; "STRING_LITERAL"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0003843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 18	[1130]	JMP      	4	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_23;
  }

  // 19	[1131]	EQK      	8 4 1	; "FUNCTIONAL"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0004843c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 20	[1131]	JMP      	2	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_23;
  }

  // 21	[1131]	EQK      	8 5 0	; "SINGLE_CHARACTER_ARGS"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_30
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0005043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 22	[1131]	JMP      	7	; to 31
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_30;
  }

  // 23	[1132]	GETTABUP 	12 2 6	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x0602060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 24	[1132]	GETFIELD 	12 12 7	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x070c060e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 25	[1132]	MOVE     	13 2
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00020680);
    setobjs2s(L, ra, RB(i));
  }

  // 26	[1132]	MOVE     	14 9
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00090700);
    setobjs2s(L, ra, RB(i));
  }

  // 27	[1132]	CALL     	12 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x01030644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 28	[1133]	LOADFALSE	3
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_40
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00000185);
    setbfvalue(s2v(ra));
  }

  // 29	[1134]	JMP      	10	; to 41
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_40;
  }

  // 30	[1134]	EQK      	8 8 0	; "COMMA"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_40
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x0008043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 31	[1134]	JMP      	8	; to 41
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_40;
  }

  // 32	[1135]	TEST     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_39
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x000001c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 33	[1135]	JMP      	5	; to 40
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_39;
  }

  // 34	[1137]	GETTABUP 	12 2 6	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x0602060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 35	[1137]	GETFIELD 	12 12 7	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x070c060e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 36	[1137]	MOVE     	13 2
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00020680);
    setobjs2s(L, ra, RB(i));
  }

  // 37	[1137]	LOADK    	14 9	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00048703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 38	[1137]	CALL     	12 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x01030644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 39	[1139]	LOADTRUE 	3
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00000187);
    setbtvalue(s2v(ra));
  }

  // 40	[1128]	TFORCALL 	4 4
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x0400024c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 41	[1128]	TFORLOOP 	4 29	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x000e824d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_13; /* jump back */
    }
  }

  // 42	[1141]	CLOSE    	4
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x00000236);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 43	[1142]	SELF     	4 1 10k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0a018214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 44	[1142]	LOADK    	6 11	; "%$(%d+)"
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x00058303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 45	[1142]	CLOSURE  	7 0	; 0x7fe61190bc90
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000003cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 46	[1142]	CALL     	4 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x02040244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 47	[1144]	RETURN   	4 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_47: {
    aot_vmfetch(0x00028246);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 48	[1145]	RETURN   	5 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_48: {
    aot_vmfetch(0x000182c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1142 - 1142
static
CallInfo *magic_implementation_47(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
  }

  // 0	[1142]	GETTABUP 	1 1 0	; _ENV "tonumber"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0001008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1142]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1142]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1142]	GETUPVAL 	2 0	; args
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[1142]	GETTABLE 	1 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0102008c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[1142]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 6	[1142]	JMP      	1	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_08;
  }

  // 7	[1142]	LOADK    	1 1	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 8	[1142]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 9	[1142]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1148 - 1178
static
CallInfo *magic_implementation_48(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
  }

  // 0	[1149]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_03
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 1	[1149]	JMP      	1	; to 4
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_03;
  }

  // 2	[1149]	RETURN   	2 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00018146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 3	[1150]	LOADNIL  	2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000108);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 4	[1151]	SELF     	3 1 0k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00018194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[1151]	GETUPVAL 	5 0	; FUNCMACRO
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[1151]	CALL     	3 3 4	; 2 in 3 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x040301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[1152]	TEST     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000001c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 8	[1152]	JMP      	4	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_13;
  }

  // 9	[1152]	TEST     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 10	[1152]	JMP      	2	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_13;
  }

  // 11	[1152]	TEST     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_14
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000082c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 12	[1152]	JMP      	1	; to 15
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_14;
  }

  // 13	[1152]	RETURN   	6 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00018346);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 14	[1155]	LOADI    	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x7fff8301);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 15	[1156]	SELF     	7 4 1k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x01048394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 16	[1156]	GETUPVAL 	9 1	; IDENTIFIER
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00010489);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 17	[1156]	CALL     	7 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x050303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[1156]	TFORPREP 	7 10	; to 30
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x000503cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_29;
  }

  // 19	[1157]	ADDI     	6 6 1
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x80060315);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 20	[1157]	MMBINI   	6 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0680032f);
    Instruction pi = 0x80060315;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 21	[1159]	SELF     	12 5 2k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x02058614);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 22	[1159]	LOADK    	14 3	; "(#*)(%s*)("
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00018703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 23	[1159]	MOVE     	15 11
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x000b0780);
    setobjs2s(L, ra, RB(i));
  }

  // 24	[1159]	LOADK    	16 4	; ")([_%w]?)"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00020803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 25	[1159]	CONCAT   	14 3
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00030735);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 26	[1165]	CLOSURE  	15 0	; 0x7fe61190c120
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x000007cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 27	[1159]	CALL     	12 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x02040644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 28	[1165]	MOVE     	5 12
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x000c0280);
    setobjs2s(L, ra, RB(i));
  }

  // 29	[1156]	TFORCALL 	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x010003cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 30	[1156]	TFORLOOP 	7 12	; to 20
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x000603cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_19; /* jump back */
    }
  }

  // 31	[1166]	CLOSE    	7
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000003b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 32	[1168]	SELF     	7 5 2k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x02058394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 33	[1168]	LOADK    	9 5	; "%s*##%s*"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x00028483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 34	[1168]	LOADK    	10 6	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00030503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 35	[1168]	CALL     	7 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x020403c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 36	[1168]	MOVE     	5 7
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00070280);
    setobjs2s(L, ra, RB(i));
  }

  // 37	[1175]	CLOSURE  	7 1	; 0x7fe61190c4b0
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x000083cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 38	[1177]	MOVE     	8 3
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00030400);
    setobjs2s(L, ra, RB(i));
  }

  // 39	[1177]	MOVE     	9 7
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00070480);
    setobjs2s(L, ra, RB(i));
  }

  // 40	[1177]	MOVE     	10 5
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00050500);
    setobjs2s(L, ra, RB(i));
  }

  // 41	[1177]	RETURN   	8 4 0	; 3 out
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_41: {
    aot_vmfetch(0x00048446);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 42	[1178]	RETURN   	8 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_42: {
    aot_vmfetch(0x00018446);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1159 - 1165
static
CallInfo *magic_implementation_49(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
  }

  // 0	[1160]	LEN      	4 3
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00030234);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 1	[1160]	LEI      	4 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_19
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x007f023f);
    op_orderI(L, l_lei, luai_numle, 0, TM_LE);
  }

  // 2	[1160]	JMP      	16	; to 20
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x800007b8);
    updatetrap(ci);
    goto label_19;
  }

  // 3	[1161]	LEN      	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000234);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 4	[1161]	EQI      	4 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0080023d);
    int cond;
    int im = GETARG_sB(i);
    if (ttisinteger(s2v(ra)))
      cond = (ivalue(s2v(ra)) == im);
    else if (ttisfloat(s2v(ra)))
      cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));
    else
      cond = 0;  /* other types cannot be equal to a number */
    docondjump();
  }

  // 5	[1161]	JMP      	6	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_12;
  }

  // 6	[1161]	LOADK    	4 0	; "\"$"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[1161]	GETUPVAL 	5 0	; noargs
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 8	[1161]	LOADK    	6 1	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00008303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[1161]	CONCAT   	4 3
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00030235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 10	[1161]	TEST     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_17
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00008242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 11	[1161]	JMP      	5	; to 18
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_17;
  }

  // 12	[1161]	MOVE     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000200);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[1161]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 14	[1161]	LOADK    	6 2	; "$"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00010303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 15	[1161]	GETUPVAL 	7 0	; noargs
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 16	[1161]	CONCAT   	4 4
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00040235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 17	[1161]	RETURN1  	4
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_25
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00020248);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 18	[1162]	JMP      	6	; to 26
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_25;
  }

  // 19	[1163]	MOVE     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00000200);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[1163]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 21	[1163]	MOVE     	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00020300);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[1163]	MOVE     	7 3
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00030380);
    setobjs2s(L, ra, RB(i));
  }

  // 23	[1163]	CONCAT   	4 4
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00040235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 24	[1163]	RETURN1  	4
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_24: {
    aot_vmfetch(0x00020248);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 25	[1165]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_25: {
    aot_vmfetch(0x00010247);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1171 - 1175
static
CallInfo *magic_implementation_50(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
  }

  // 0	[1172]	SELF     	1 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00008094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 1	[1172]	GETUPVAL 	3 0	; name
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 2	[1172]	LOADK    	4 1	; "%s*(%b())"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 3	[1172]	CONCAT   	3 2
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000201b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 4	[1174]	CLOSURE  	4 0	; 0x7fe61190c6e0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0000024f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 5	[1172]	TAILCALL 	1 4 0	; 3 in
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000400c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 6	[1174]	RETURN   	1 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x000000c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 7	[1175]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1172 - 1174
static
CallInfo *magic_implementation_51(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
  }

  // 0	[1173]	GETUPVAL 	1 0	; replaceArgs
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1173]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1173]	GETUPVAL 	3 1	; repl
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[1173]	TAILCALL 	1 3 0	; 2 in
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000300c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 4	[1173]	RETURN   	1 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_04: {
    aot_vmfetch(0x000000c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 5	[1174]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_05: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1186 - 1257
static
CallInfo *magic_implementation_52(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
  }

  // 0	[1188]	NEWTABLE 	3 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000193);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 1	[1188]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 2	[1189]	NEWTABLE 	4 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000213);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 3	[1189]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 4	[1189]	SETFIELD 	3 0 4	; "defines"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x04000192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 5	[1190]	GETUPVAL 	4 0	; screener
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[1190]	MOVE     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000280);
    setobjs2s(L, ra, RB(i));
  }

  // 7	[1190]	CALL     	4 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x02020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[1190]	SETFIELD 	3 1 4	; "screener"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x04010192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 9	[1191]	SETFIELD 	3 2 3k	; "lineno" 0
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x03028192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 10	[1192]	NEWTABLE 	4 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000213);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 11	[1192]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 12	[1192]	SETFIELD 	3 4 4	; "stack"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x04040192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 13	[1193]	NEWTABLE 	4 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000213);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 14	[1193]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 15	[1193]	SETFIELD 	3 5 4	; "once"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x04050192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 16	[1194]	TESTSET  	4 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_20
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00028243);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 17	[1194]	JMP      	2	; to 21
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_20;
  }

  // 18	[1194]	NEWTABLE 	4 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00000213);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 19	[1194]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 20	[1194]	SETFIELD 	3 6 4	; "macro_sources"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x04060192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 21	[1197]	GETUPVAL 	4 1	; define
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00010209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 22	[1197]	SETFIELD 	3 7 4	; "define"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x04070192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 23	[1201]	CLOSURE  	4 0	; 0x7fe61190cbc0
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x0000024f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 24	[1201]	SETFIELD 	3 8 4	; "undefine"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x04080192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 25	[1204]	CLOSURE  	4 1	; 0x7fe61190cd40
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x0000824f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 26	[1204]	SETFIELD 	3 9 4	; "defined"
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x04090192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 27	[1205]	GETUPVAL 	4 2	; apply
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00020209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 28	[1205]	SETFIELD 	3 10 4	; "apply"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x040a0192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 29	[1206]	GETUPVAL 	4 3	; includeFile
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00030209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 30	[1206]	SETFIELD 	3 11 4	; "includeFile"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x040b0192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 31	[1207]	GETUPVAL 	4 4	; doWork
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x00040209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 32	[1207]	SETFIELD 	3 12 4	; "doWork"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x040c0192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 33	[1210]	CLOSURE  	4 2	; 0x7fe61190d0e0
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x0001024f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 34	[1210]	SETFIELD 	3 13 4	; "getIndent"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x040d0192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 35	[1215]	CLOSURE  	4 3	; 0x7fe61190d2b0
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x0001824f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 36	[1215]	SETFIELD 	3 14 4	; "openBlock"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x040e0192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 37	[1223]	CLOSURE  	4 4	; 0x7fe61190d5d0
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x0002024f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 38	[1223]	SETFIELD 	3 15 4	; "elseBlock"
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x040f0192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 39	[1229]	CLOSURE  	4 5	; 0x7fe61190ca90
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x0002824f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 40	[1229]	SETFIELD 	3 16 4	; "closeBlock"
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x04100192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 41	[1235]	CLOSURE  	4 6	; 0x7fe61190dcf0
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x0003024f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 42	[1235]	SETFIELD 	3 17 4	; "skip"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x04110192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 43	[1240]	CLOSURE  	4 7	; 0x7fe61190df90
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0003824f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 44	[1240]	SETFIELD 	3 18 4	; "getLine"
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x04120192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 45	[1241]	GETUPVAL 	4 8	; prepareMacro
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x00080209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 46	[1241]	SETFIELD 	3 19 4	; "prepareMacro"
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x04130192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 47	[1242]	GETUPVAL 	4 9	; parseExpr
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00090209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 48	[1242]	SETFIELD 	3 20 4	; "parseExpr"
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x04140192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 49	[1243]	GETUPVAL 	4 10	; parseFunction
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x000a0209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 50	[1243]	SETFIELD 	3 21 4	; "parseFunction"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x04150192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 51	[1246]	SELF     	4 3 22k	; "define"
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x16038214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 52	[1246]	GETUPVAL 	6 11	; DATE
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x000b0309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 53	[1246]	GETTABUP 	7 12 23	; _ENV "os"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x170c038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 54	[1246]	GETFIELD 	7 7 24	; "date"
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x1807038e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 55	[1246]	LOADK    	8 25	; "%B %d %Y"
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x000c8403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 56	[1246]	CALL     	7 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x020203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 57	[1246]	LOADTRUE 	8
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00000407);
    setbtvalue(s2v(ra));
  }

  // 58	[1246]	CALL     	4 5 1	; 4 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x01050244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 59	[1247]	SELF     	4 3 22k	; "define"
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x16038214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 60	[1247]	GETUPVAL 	6 13	; TIME
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x000d0309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 61	[1247]	GETTABUP 	7 12 23	; _ENV "os"
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x170c038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 62	[1247]	GETFIELD 	7 7 24	; "date"
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x1807038e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 63	[1247]	LOADK    	8 26	; "%H:%M:%S"
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x000d0403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 64	[1247]	CALL     	7 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x020203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 65	[1247]	LOADTRUE 	8
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x00000407);
    setbtvalue(s2v(ra));
  }

  // 66	[1247]	CALL     	4 5 1	; 4 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x01050244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 67	[1248]	SELF     	4 3 22k	; "define"
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x16038214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 68	[1248]	GETUPVAL 	6 7	; LINE
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x00070309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 69	[1248]	GETFIELD 	7 3 27	; "lineno"
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x1b03038e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 70	[1248]	LOADTRUE 	8
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x00000407);
    setbtvalue(s2v(ra));
  }

  // 71	[1248]	CALL     	4 5 1	; 4 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x01050244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 72	[1249]	SELF     	4 3 22k	; "define"
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x16038214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 73	[1249]	GETUPVAL 	6 5	; PRE_INDENT
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x00050309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 74	[1249]	SELF     	7 3 28k	; "getIndent"
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x1c038394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 75	[1249]	CALL     	7 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x020203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 76	[1249]	LOADTRUE 	8
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x00000407);
    setbtvalue(s2v(ra));
  }

  // 77	[1249]	CALL     	4 5 1	; 4 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x01050244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 78	[1250]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_83
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 79	[1250]	JMP      	3	; to 84
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_83;
  }

  // 80	[1250]	NEWTABLE 	4 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x00000213);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 81	[1250]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 82	[1250]	MOVE     	1 4
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x00040080);
    setobjs2s(L, ra, RB(i));
  }

  // 83	[1251]	GETTABUP 	4 12 29	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x1d0c020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 84	[1251]	GETTABUP 	5 14 30	; preprocessor "ENV"
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x1e0e028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 85	[1251]	CALL     	4 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x05020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 86	[1251]	TFORPREP 	4 5	; to 93
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x0002824b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_92;
  }

  // 87	[1251]	SELF     	10 3 22k	; "define"
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x16038514);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 88	[1251]	MOVE     	12 8
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x00080600);
    setobjs2s(L, ra, RB(i));
  }

  // 89	[1251]	MOVE     	13 9
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x00090680);
    setobjs2s(L, ra, RB(i));
  }

  // 90	[1251]	LOADTRUE 	14
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x00000707);
    setbtvalue(s2v(ra));
  }

  // 91	[1251]	CALL     	10 5 1	; 4 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x01050544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 92	[1251]	TFORCALL 	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x0200024c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 93	[1251]	TFORLOOP 	4 7	; to 88
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x0003824d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_87; /* jump back */
    }
  }

  // 94	[1251]	CLOSE    	4
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x00000236);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 95	[1252]	GETTABUP 	4 12 29	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x1d0c020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 96	[1252]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 97	[1252]	CALL     	4 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x05020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 98	[1252]	TFORPREP 	4 5	; to 105
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x0002824b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_104;
  }

  // 99	[1252]	SELF     	10 3 22k	; "define"
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x16038514);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 100	[1252]	MOVE     	12 8
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x00080600);
    setobjs2s(L, ra, RB(i));
  }

  // 101	[1252]	MOVE     	13 9
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x00090680);
    setobjs2s(L, ra, RB(i));
  }

  // 102	[1252]	LOADTRUE 	14
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x00000707);
    setbtvalue(s2v(ra));
  }

  // 103	[1252]	CALL     	10 5 1	; 4 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x01050544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 104	[1252]	TFORCALL 	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x0200024c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 105	[1252]	TFORLOOP 	4 7	; to 100
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x0003824d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_99; /* jump back */
    }
  }

  // 106	[1252]	CLOSE    	4
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x00000236);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 107	[1254]	GETTABUP 	4 14 31	; preprocessor "PRE_TEST"
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x1f0e020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 108	[1254]	TEST     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_111
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x00000242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 109	[1254]	JMP      	1	; to 112
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_111;
  }

  // 110	[1254]	SETTABUP 	14 32 3	; preprocessor "STATE"
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x0320070f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 111	[1256]	RETURN   	3 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_111: {
    aot_vmfetch(0x000281c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 112	[1257]	RETURN   	4 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_112: {
    aot_vmfetch(0x00018246);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1198 - 1201
static
CallInfo *magic_implementation_53(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
  }

  // 0	[1199]	SELF     	2 0 0k	; "define"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00008114);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 1	[1199]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1199]	LOADNIL  	5 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000288);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 3	[1199]	CALL     	2 4 1	; 3 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x01040144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[1200]	GETFIELD 	2 0 1	; "macro_sources"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[1200]	SETTABLE 	2 1 2k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_05: {
    aot_vmfetch(0x02018110);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 6	[1201]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1202 - 1204
static
CallInfo *magic_implementation_54(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
  }

  // 0	[1203]	GETFIELD 	2 0 0	; "defines"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 1	[1203]	GETTABLE 	2 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0102010c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[1203]	EQK      	2 1 0	; null
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_05
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0001013c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 3	[1203]	JMP      	1	; to 6
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_05;
  }

  // 4	[1203]	LFALSESKIP	2
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00000106);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 5	[1203]	LOADTRUE 	2
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000107);
    setbtvalue(s2v(ra));
  }

  // 6	[1203]	RETURN1  	2
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x00020148);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 7	[1204]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1208 - 1210
static
CallInfo *magic_implementation_55(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1209]	GETFIELD 	1 0 0	; "stack"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 1	[1209]	LEN      	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x000100b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 2	[1209]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 3	[1210]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1211 - 1215
static
CallInfo *magic_implementation_56(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
  }

  // 0	[1212]	GETFIELD 	2 0 0	; "stack"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 1	[1212]	GETFIELD 	3 0 0	; "stack"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0000018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[1212]	LEN      	3 3
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x000301b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 3	[1212]	ADDI     	3 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x80030195);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 4	[1212]	MMBINI   	3 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x068001af);
    Instruction pi = 0x80030195;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 5	[1212]	SETTABLE 	2 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x01030110);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 6	[1213]	GETFIELD 	2 0 1	; "once"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0100010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[1213]	GETFIELD 	3 0 1	; "once"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0100018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[1213]	LEN      	3 3
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x000301b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 9	[1213]	ADDI     	3 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x80030195);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 10	[1213]	MMBINI   	3 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x068001af);
    Instruction pi = 0x80030195;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 11	[1213]	SETTABLE 	2 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x01030110);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 12	[1214]	SELF     	2 0 2k	; "define"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x02008114);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 13	[1214]	GETUPVAL 	4 0	; PRE_INDENT
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 14	[1214]	SELF     	5 0 3k	; "getIndent"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x03008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[1214]	CALL     	5 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x020202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[1214]	LOADTRUE 	6
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00000307);
    setbtvalue(s2v(ra));
  }

  // 17	[1214]	CALL     	2 5 1	; 4 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_17: {
    aot_vmfetch(0x01050144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[1215]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_18: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1216 - 1223
static
CallInfo *magic_implementation_57(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
  }

  // 0	[1217]	GETFIELD 	2 0 0	; "once"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 1	[1217]	GETFIELD 	3 0 0	; "once"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0000018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[1217]	LEN      	3 3
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x000301b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 3	[1217]	GETTABLE 	2 2 3
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0302010c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[1217]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 5	[1217]	JMP      	5	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_11;
  }

  // 6	[1218]	GETFIELD 	2 0 1	; "stack"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0100010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[1218]	GETFIELD 	3 0 1	; "stack"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0100018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[1218]	LEN      	3 3
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x000301b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 9	[1218]	SETTABLE 	2 3 2k	; false
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_21
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x02038110);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 10	[1219]	JMP      	10	; to 22
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_21;
  }

  // 11	[1220]	GETFIELD 	2 0 1	; "stack"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0100010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 12	[1220]	GETFIELD 	3 0 1	; "stack"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0100018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 13	[1220]	LEN      	3 3
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000301b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 14	[1220]	SETTABLE 	2 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x01030110);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 15	[1221]	TEST     	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_21
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000000c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 16	[1221]	JMP      	4	; to 22
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_21;
  }

  // 17	[1221]	GETFIELD 	2 0 0	; "once"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0000010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 18	[1221]	GETFIELD 	3 0 0	; "once"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0000018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[1221]	LEN      	3 3
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000301b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 20	[1221]	SETTABLE 	2 3 3k	; true
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_20: {
    aot_vmfetch(0x03038110);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 21	[1223]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_21: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1224 - 1229
static
CallInfo *magic_implementation_58(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
  }

  // 0	[1225]	GETFIELD 	1 0 0	; "stack"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 1	[1225]	GETFIELD 	2 0 0	; "stack"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0000010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[1225]	LEN      	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00020134);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 3	[1225]	SETTABLE 	1 2 1k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x01028090);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 4	[1226]	GETFIELD 	1 0 2	; "once"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0200008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[1226]	GETFIELD 	2 0 2	; "once"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 6	[1226]	LEN      	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00020134);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 7	[1226]	SETTABLE 	1 2 1k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x01028090);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 8	[1227]	SELF     	1 0 3k	; "define"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x03008094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 9	[1227]	GETUPVAL 	3 0	; PRE_INDENT
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 10	[1227]	SELF     	4 0 4k	; "getIndent"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x04008214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[1227]	CALL     	4 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x02020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[1227]	LOADTRUE 	5
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000287);
    setbtvalue(s2v(ra));
  }

  // 13	[1227]	CALL     	1 5 1	; 4 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x010500c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[1228]	SELF     	1 0 4k	; "getIndent"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x04008094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[1228]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[1228]	LTI      	1 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_21
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x007f00be);
    op_orderI(L, l_lti, luai_numlt, 0, TM_LT);
  }

  // 17	[1228]	JMP      	3	; to 22
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_21;
  }

  // 18	[1228]	GETUPVAL 	1 1	; error
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 19	[1228]	LOADK    	2 5	; "Unopened block detected. Indentaion problem."
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00028103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 20	[1228]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_20: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 21	[1229]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_21: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1230 - 1235
static
CallInfo *magic_implementation_59(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
  }

  // 0	[1231]	LOADI    	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x80000081);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 1	[1231]	GETFIELD 	2 0 0	; "stack"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0000010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[1231]	LEN      	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00020134);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 3	[1231]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 4	[1231]	FORPREP  	1 5	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000280ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_11; /* skip the loop */
  }

  // 5	[1232]	GETFIELD 	5 0 0	; "stack"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0000028e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 6	[1232]	GETTABLE 	5 5 4
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0405028c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[1232]	TEST     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000082c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 8	[1232]	JMP      	1	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_10;
  }

  // 9	[1232]	RETURN1  	4
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00020248);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 10	[1231]	FORLOOP  	1 6	; to 6
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000300c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_05; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_05; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 11	[1234]	LOADFALSE	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000085);
    setbfvalue(s2v(ra));
  }

  // 12	[1234]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 13	[1235]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1236 - 1240
static
CallInfo *magic_implementation_60(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
  }

  // 0	[1237]	GETFIELD 	1 0 0	; "lineno"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 1	[1237]	ADDI     	1 1 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x80010095);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 2	[1237]	MMBINI   	1 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x068000af);
    Instruction pi = 0x80010095;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 3	[1237]	SETFIELD 	0 0 1	; "lineno"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x01000012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 4	[1238]	SELF     	1 0 1k	; "define"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x01008094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[1238]	GETUPVAL 	3 0	; LINE
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[1238]	GETFIELD 	4 0 0	; "lineno"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0000020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[1238]	LOADTRUE 	5
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000287);
    setbtvalue(s2v(ra));
  }

  // 8	[1238]	CALL     	1 5 1	; 4 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x010500c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[1239]	GETFIELD 	1 0 2	; "screener"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0200008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 10	[1239]	TAILCALL 	1 1 0	; 0 in
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000100c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 11	[1239]	RETURN   	1 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x000000c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 12	[1240]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1265 - 1274
static
CallInfo *magic_implementation_61(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
  }

  // 0	[1266]	GETTABUP 	3 0 0	; preprocessor "init"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1266]	MOVE     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000200);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1266]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[1266]	MOVE     	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00020300);
    setobjs2s(L, ra, RB(i));
  }

  // 4	[1266]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[1267]	NEWTABLE 	4 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000213);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 6	[1267]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 7	[1268]	SELF     	5 3 1k	; "doWork"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x01038294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[1268]	CALL     	5 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x050202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[1268]	TFORPREP 	5 5	; to 16
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000282cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_15;
  }

  // 10	[1269]	GETTABUP 	10 1 2	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0201050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 11	[1269]	GETFIELD 	10 10 3	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x030a050e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 12	[1269]	MOVE     	11 4
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00040580);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[1269]	MOVE     	12 9
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00090600);
    setobjs2s(L, ra, RB(i));
  }

  // 14	[1269]	CALL     	10 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x01030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 15	[1268]	TFORCALL 	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x010002cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 16	[1268]	TFORLOOP 	5 7	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x000382cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_10; /* jump back */
    }
  }

  // 17	[1270]	CLOSE    	5
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x000002b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 18	[1271]	GETTABUP 	5 1 2	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0201028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 19	[1271]	GETFIELD 	5 5 4	; "concat"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0405028e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 20	[1271]	MOVE     	6 4
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00040300);
    setobjs2s(L, ra, RB(i));
  }

  // 21	[1271]	GETUPVAL 	7 2	; NEWL
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00020389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 22	[1271]	CALL     	5 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x020302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 23	[1272]	GETTABUP 	6 0 5	; preprocessor "DEBUG"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x0500030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 24	[1272]	TEST     	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_29
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00000342);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 25	[1272]	JMP      	3	; to 30
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_29;
  }

  // 26	[1272]	GETUPVAL 	6 3	; print
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00030309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 27	[1272]	MOVE     	7 5
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00050380);
    setobjs2s(L, ra, RB(i));
  }

  // 28	[1272]	CALL     	6 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x01020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 29	[1273]	MOVE     	6 5
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00050300);
    setobjs2s(L, ra, RB(i));
  }

  // 30	[1273]	MOVE     	7 3
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00030380);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[1273]	RETURN   	6 3 0	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_31: {
    aot_vmfetch(0x00038346);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 32	[1274]	RETURN   	6 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_32: {
    aot_vmfetch(0x00018346);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1280 - 1288
static
CallInfo *magic_implementation_62(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
  }

  // 0	[1281]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_05
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 1	[1281]	JMP      	3	; to 6
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_05;
  }

  // 2	[1281]	GETUPVAL 	5 0	; error
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[1281]	LOADK    	6 0	; "processFile() arg1 has to be a string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1281]	CALL     	5 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x010202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[1282]	GETTABUP 	5 1 1	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0101028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[1282]	GETFIELD 	5 5 2	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0205028e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[1282]	MOVE     	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000300);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[1282]	LOADK    	7 3	; "r"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00018383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[1282]	CALL     	5 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x020302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[1283]	TEST     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_17
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000082c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 11	[1283]	JMP      	5	; to 18
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_17;
  }

  // 12	[1283]	GETUPVAL 	6 0	; error
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 13	[1283]	LOADK    	7 4	; "file not found: "
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00020383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 14	[1283]	MOVE     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000400);
    setobjs2s(L, ra, RB(i));
  }

  // 15	[1283]	CONCAT   	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000203b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 16	[1283]	CALL     	6 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x01020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 17	[1284]	SELF     	6 5 5k	; "read"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x05058314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 18	[1284]	LOADK    	8 6	; "*a"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00030403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 19	[1284]	CALL     	6 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x02030344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[1285]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_25
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 21	[1285]	JMP      	3	; to 26
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_25;
  }

  // 22	[1285]	NEWTABLE 	7 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00000393);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 23	[1285]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 24	[1285]	MOVE     	1 7
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00070080);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[1286]	GETUPVAL 	7 2	; FILE
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00020389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 26	[1286]	SETTABLE 	1 7 0
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00070090);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 27	[1287]	GETTABUP 	7 3 7	; preprocessor "compile"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0703038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 28	[1287]	MOVE     	8 6
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00060400);
    setobjs2s(L, ra, RB(i));
  }

  // 29	[1287]	MOVE     	9 1
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00010480);
    setobjs2s(L, ra, RB(i));
  }

  // 30	[1287]	MOVE     	10 2
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00020500);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[1287]	TAILCALL 	7 4 0	; 3 in
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000403c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 32	[1287]	RETURN   	7 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_32: {
    aot_vmfetch(0x000003c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 33	[1288]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_33: {
    aot_vmfetch(0x000103c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1294 - 1321
static
CallInfo *magic_implementation_63(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
  }

  // 0	[1295]	LOADI    	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x7fff8081);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 1	[1299]	CLOSURE  	2 0	; 0x7fe61190eb60
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0000014f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 2	[1302]	GETTABUP 	3 0 0	; _ENV "_G"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 3	[1302]	NEWTABLE 	4 3 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00030213);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 4	[1302]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 5	[1303]	SETFIELD 	4 2 3k	; "assertTrueCalls" 0
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x03028212);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 6	[1304]	SETFIELD 	4 4 3k	; "assertTrueCount" 0
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x03048212);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 7	[1307]	CLOSURE  	5 1	; 0x7fe611907d90
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000082cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 8	[1307]	SETFIELD 	4 5 5	; "assertTrue"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x05050212);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 9	[1308]	SETFIELD 	3 1 4	; "preprocessor_test"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x04010192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 10	[1310]	LOADK    	3 6	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00030183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[1311]	SETTABUP 	1 7 8k	; preprocessor "FAST" false
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0807808f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 12	[1312]	SETTABUP 	1 9 10k	; preprocessor "SELF_TEST" true
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0a09808f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 13	[1313]	GETTABUP 	4 1 11	; preprocessor "compile"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0b01020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 14	[1313]	MOVE     	5 3
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00030280);
    setobjs2s(L, ra, RB(i));
  }

  // 15	[1313]	CALL     	4 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x02020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[1314]	SETTABUP 	1 9 12k	; preprocessor "SELF_TEST" null
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0c09808f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 17	[1316]	GETTABUP 	5 0 13	; _ENV "assert"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0d00028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 18	[1316]	GETTABUP 	6 0 14	; _ENV "loadstring"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0e00030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 19	[1316]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[1316]	LOADK    	8 15	; "testlua"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00078403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 21	[1316]	CALL     	6 3 0	; 2 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00030344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 22	[1316]	CALL     	5 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x020002c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 23	[1316]	CALL     	5 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x010102c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[1317]	GETTABUP 	5 0 16	; _ENV "preprocessor_test"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x1000028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 25	[1317]	GETUPVAL 	6 2	; findn
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00020309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 26	[1317]	MOVE     	7 3
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00030380);
    setobjs2s(L, ra, RB(i));
  }

  // 27	[1317]	LOADK    	8 17	; "preprocessor_test.assertTrue()"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00088403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 28	[1317]	CALL     	6 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x02030344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 29	[1317]	SETFIELD 	5 2 6	; "assertTrueCalls"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x06020292);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 30	[1318]	GETTABUP 	5 0 13	; _ENV "assert"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x0d00028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 31	[1318]	GETTABUP 	6 0 16	; _ENV "preprocessor_test"
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x1000030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 32	[1318]	GETFIELD 	6 6 18	; "assertTrueCount"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x1206030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 33	[1318]	GETTABUP 	7 0 16	; _ENV "preprocessor_test"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x1000038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 34	[1318]	GETFIELD 	7 7 2	; "assertTrueCalls"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x0207038e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 35	[1318]	EQ       	6 7 1
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_38
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x00078339);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 36	[1318]	JMP      	1	; to 39
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_38;
  }

  // 37	[1318]	LFALSESKIP	6
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00000306);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 38	[1318]	LOADTRUE 	6
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00000307);
    setbtvalue(s2v(ra));
  }

  // 39	[1318]	LOADK    	7 19	; "assertTrue calls:"
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00098383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 40	[1318]	GETTABUP 	8 0 16	; _ENV "preprocessor_test"
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x1000040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 41	[1318]	GETFIELD 	8 8 2	; "assertTrueCalls"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x0208040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 42	[1318]	LOADK    	9 20	; " count:"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x000a0483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 43	[1318]	GETTABUP 	10 0 16	; _ENV "preprocessor_test"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x1000050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 44	[1318]	GETFIELD 	10 10 18	; "assertTrueCount"
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x120a050e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 45	[1318]	CONCAT   	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000403b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 46	[1318]	CALL     	5 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x010302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 47	[1319]	GETTABUP 	5 0 0	; _ENV "_G"
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x0000028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 48	[1319]	SETFIELD 	5 16 12k	; "preprocessor_test" null
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x0c108292);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 49	[1320]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_54
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 50	[1320]	JMP      	3	; to 55
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_54;
  }

  // 51	[1320]	GETUPVAL 	5 3	; print
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00030289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 52	[1320]	LOADK    	6 21	; "Test run suscessully"
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x000a8303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 53	[1320]	CALL     	5 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_53: {
    aot_vmfetch(0x010202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 54	[1321]	RETURN   	5 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_54: {
    aot_vmfetch(0x000182c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1296 - 1299
static
CallInfo *magic_implementation_64(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[1297]	GETUPVAL 	0 0	; testLabelCount
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1297]	ADDI     	0 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x80000015);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 2	[1297]	MMBINI   	0 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0680002f);
    Instruction pi = 0x80000015;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 3	[1297]	SETUPVAL 	0 0	; testLabelCount
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0000000a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 4	[1298]	LOADK    	0 0	; " preprocessor_assert_"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00000003);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[1298]	GETUPVAL 	1 0	; testLabelCount
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[1298]	CONCAT   	0 2
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00020035);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 7	[1298]	RETURN1  	0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x00020048);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[1299]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1305 - 1307
static
CallInfo *magic_implementation_65(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
  }

  // 0	[1306]	GETTABUP 	0 0 0	; _ENV "preprocessor_test"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1306]	GETTABUP 	1 0 0	; _ENV "preprocessor_test"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[1306]	GETFIELD 	1 1 1	; "assertTrueCount"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[1306]	ADDI     	1 1 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x80010095);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 4	[1306]	MMBINI   	1 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x068000af);
    Instruction pi = 0x80010095;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 5	[1306]	SETFIELD 	0 1 1	; "assertTrueCount"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_05: {
    aot_vmfetch(0x01010012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 6	[1307]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1330 - 1343
static
CallInfo *magic_implementation_66(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
  }

  // 0	[1336]	GETTABUP 	0 0 0	; preprocessor "PRE_FFI"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1336]	TEST     	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 2	[1336]	JMP      	20	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x800009b8);
    updatetrap(ci);
    goto label_23;
  }

  // 3	[1336]	GETTABUP 	0 1 1	; _ENV "pcall"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0101000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[1336]	GETTABUP 	1 1 2	; _ENV "require"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0201008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 5	[1336]	LOADK    	2 3	; "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00018103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[1336]	CALL     	0 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x02030044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[1336]	TEST     	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 8	[1336]	JMP      	14	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x800006b8);
    updatetrap(ci);
    goto label_23;
  }

  // 9	[1337]	GETTABUP 	0 1 2	; _ENV "require"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0201000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 10	[1337]	LOADK    	1 3	; "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00018083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[1337]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[1337]	SETTABUP 	1 3 0	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0003008f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 13	[1338]	GETTABUP 	0 1 3	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0301000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 14	[1338]	GETFIELD 	0 0 4	; "preprocessor_cdef_backup"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0400000e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[1338]	TEST     	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 16	[1338]	JMP      	6	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_23;
  }

  // 17	[1339]	GETTABUP 	0 1 3	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0301000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 18	[1339]	GETTABUP 	1 1 3	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0301008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 19	[1339]	GETFIELD 	1 1 4	; "preprocessor_cdef_backup"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0401008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 20	[1339]	SETFIELD 	0 5 1	; "cdef"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x01050012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 21	[1340]	GETTABUP 	0 1 3	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0301000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 22	[1340]	SETFIELD 	0 4 6k	; "preprocessor_cdef_backup" null
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_22: {
    aot_vmfetch(0x06048012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 23	[1343]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_23: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1346 - 1387
static
CallInfo *magic_implementation_67(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
  }

  // 0	[1350]	GETTABUP 	0 0 0	; _ENV "_G"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1350]	GETTABUP 	1 0 0	; _ENV "_G"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[1350]	GETFIELD 	1 1 2	; "loadstring"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0201008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[1350]	SETFIELD 	0 1 1	; "loadstring_preprocessor_backup"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x01010012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 4	[1351]	GETTABUP 	0 0 0	; _ENV "_G"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 5	[1353]	CLOSURE  	1 0	; 0x7fe61190d660
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000000cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 6	[1353]	SETFIELD 	0 2 1	; "loadstring"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x01020012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 7	[1356]	GETTABUP 	0 1 3	; preprocessor "PRE_FFI"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0301000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[1356]	TEST     	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 9	[1356]	JMP      	32	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x80000fb8);
    updatetrap(ci);
    goto label_42;
  }

  // 10	[1356]	GETTABUP 	0 0 4	; _ENV "pcall"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0400000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 11	[1356]	GETTABUP 	1 0 5	; _ENV "require"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0500008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[1356]	LOADK    	2 6	; "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00030103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[1356]	CALL     	0 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x02030044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[1356]	TEST     	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 15	[1356]	JMP      	26	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000cb8);
    updatetrap(ci);
    goto label_42;
  }

  // 16	[1357]	GETTABUP 	0 0 5	; _ENV "require"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0500000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[1357]	LOADK    	1 6	; "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00030083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 18	[1357]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[1357]	SETTABUP 	0 6 0	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0006000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 20	[1358]	GETTABUP 	0 0 6	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0600000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 21	[1358]	GETFIELD 	0 0 7	; "preprocessor_cdef_backup"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0700000e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 22	[1358]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 23	[1358]	JMP      	18	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x800008b8);
    updatetrap(ci);
    goto label_42;
  }

  // 24	[1359]	GETTABUP 	0 0 6	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0600000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 25	[1359]	GETFIELD 	0 0 8	; "preprocessor_defs"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x0800000e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 26	[1359]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_32
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 27	[1359]	JMP      	4	; to 33
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_32;
  }

  // 28	[1359]	GETTABUP 	0 0 6	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x0600000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 29	[1359]	NEWTABLE 	1 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00000093);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 30	[1359]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 31	[1359]	SETFIELD 	0 8 1	; "preprocessor_defs"
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x01080012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 32	[1360]	GETTABUP 	0 0 6	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x0600000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 33	[1365]	CLOSURE  	1 1	; 0x7fe61190dde0
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x000080cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 34	[1365]	SETFIELD 	0 9 1	; "preprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x01090012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 35	[1366]	GETTABUP 	0 0 10	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x0a00000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 36	[1366]	GETTABUP 	1 0 10	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x0a00008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 37	[1366]	GETFIELD 	1 1 11	; "cdef"
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x0b01008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 38	[1366]	SETFIELD 	0 7 1	; "preprocessor_cdef_backup"
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x01070012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 39	[1367]	GETTABUP 	0 0 10	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x0a00000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 40	[1384]	CLOSURE  	1 2	; 0x7fe61190f160
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x000100cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 41	[1384]	SETFIELD 	0 11 1	; "cdef"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_41: {
    aot_vmfetch(0x010b0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 42	[1387]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_42: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1351 - 1353
static
CallInfo *magic_implementation_68(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
  }

  // 0	[1352]	GETTABUP 	2 0 0	; _ENV "loadstring_preprocessor_backup"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1352]	GETTABUP 	3 1 1	; preprocessor "compile"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0101018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[1352]	MOVE     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000200);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[1352]	CALL     	3 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x020201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[1352]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 5	[1352]	TAILCALL 	2 3 0	; 2 in
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00030145);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 6	[1352]	RETURN   	2 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x00000146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 7	[1353]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1360 - 1365
static
CallInfo *magic_implementation_69(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
  }

  // 0	[1361]	GETTABUP 	1 0 0	; preprocessor "compile"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1361]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1361]	GETTABUP 	3 1 1	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0101018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 3	[1361]	GETFIELD 	3 3 2	; "preprocessor_defs"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0203018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[1361]	GETTABUP 	4 1 1	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0101020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 5	[1361]	GETFIELD 	4 4 3	; "preprocessor_macro_sources"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0304020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 6	[1361]	CALL     	1 4 3	; 3 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x030400c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[1362]	GETTABUP 	3 1 1	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0101018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[1362]	GETFIELD 	4 2 4	; "defines"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0402020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 9	[1362]	SETFIELD 	3 2 4	; "preprocessor_defs"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x04020192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 10	[1363]	GETTABUP 	3 1 1	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0101018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 11	[1363]	GETFIELD 	4 2 5	; "macro_sources"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0502020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 12	[1363]	SETFIELD 	3 3 4	; "preprocessor_macro_sources"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x04030192);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 13	[1364]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 14	[1365]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000101c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1367 - 1384
static
CallInfo *magic_implementation_70(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
  }

  // 0	[1369]	GETTABUP 	1 0 0	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1369]	GETFIELD 	1 1 1	; "preprocessor_cdef_backup"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[1369]	GETTABUP 	2 0 0	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 3	[1369]	GETFIELD 	2 2 2	; "preprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0202010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[1369]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 5	[1369]	CALL     	2 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[1369]	TAILCALL 	1 0 0	; -1 in
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000000c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 7	[1369]	RETURN   	1 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_48
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000000c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[1370]	JMP      	39	; to 49
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80001338);
    updatetrap(ci);
    goto label_48;
  }

  // 9	[1371]	SELF     	1 0 3k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x03008094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 10	[1371]	LOADK    	3 4	; "#include [\"<].-([^/]+%.h)[\">]"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00020183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[1371]	LOADK    	4 5	; "%1"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00028203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 12	[1371]	CALL     	1 4 3	; 3 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x030400c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 13	[1372]	GETTABUP 	3 0 0	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 14	[1372]	GETFIELD 	3 3 2	; "preprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0203018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[1372]	MOVE     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000200);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[1372]	CALL     	3 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x020201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 17	[1372]	MOVE     	0 3
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00030000);
    setobjs2s(L, ra, RB(i));
  }

  // 18	[1373]	GTI      	2 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_43
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x007f0140);
    op_orderI(L, l_gti, luai_numgt, 1, TM_LT);
  }

  // 19	[1373]	JMP      	23	; to 44
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x80000b38);
    updatetrap(ci);
    goto label_43;
  }

  // 20	[1374]	GETTABUP 	3 0 6	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0600018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 21	[1374]	GETFIELD 	3 3 7	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0703018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 22	[1374]	LOADK    	4 8	; "./tmp/"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00040203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 23	[1374]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 24	[1374]	CONCAT   	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00020235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 25	[1374]	LOADK    	5 9	; "w"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00048283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 26	[1374]	CALL     	3 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x020301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 27	[1375]	TEST     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_35
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000001c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 28	[1375]	JMP      	6	; to 36
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_35;
  }

  // 29	[1376]	SELF     	4 3 10k	; "write"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0a038214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 30	[1376]	MOVE     	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00000300);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[1376]	CALL     	4 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x01030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[1377]	SELF     	4 3 11k	; "close"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x0b038214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 33	[1377]	CALL     	4 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_43
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x01020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 34	[1378]	JMP      	8	; to 44
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_43;
  }

  // 35	[1379]	GETTABUP 	4 0 12	; _ENV "assert"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x0c00020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 36	[1379]	SELF     	5 1 13k	; "find"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x0d018294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 37	[1379]	LOADK    	7 14	; "/"
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00070383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 38	[1379]	CALL     	5 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x020302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 39	[1379]	LOADK    	6 15	; "cannot open: ./tmp/"
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00078303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 40	[1379]	MOVE     	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00010380);
    setobjs2s(L, ra, RB(i));
  }

  // 41	[1379]	CONCAT   	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x00020335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 42	[1379]	CALL     	4 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x01030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 43	[1382]	GETTABUP 	3 0 0	; _ENV "ffi"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 44	[1382]	GETFIELD 	3 3 1	; "preprocessor_cdef_backup"
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x0103018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 45	[1382]	MOVE     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x00000200);
    setobjs2s(L, ra, RB(i));
  }

  // 46	[1382]	TAILCALL 	3 2 0	; 1 in
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x000201c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 47	[1382]	RETURN   	3 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_47: {
    aot_vmfetch(0x000001c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 48	[1384]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_48: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1392 - 1440
static
CallInfo *magic_implementation_71(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
  }

  // 0	[1392]	VARARGPREP	1
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x000000d1);
    ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));
    if (l_unlikely(trap)) {  /* previous "Protect" updated trap */
      luaD_hookcall(L, ci);
      L->oldpc = 1;  /* next opcode will be seen as a "new" line */
    }
    updatebase(ci);  /* function has new base after adjustment */
  }

  // 1	[1393]	NEWTABLE 	1 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000093);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 2	[1393]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 3	[1393]	VARARG   	2 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000150);
    int n = GETARG_C(i) - 1;  /* required results */
    Protect(luaT_getvarargs(L, ci, ra, n));
  }

  // 4	[1393]	SETLIST  	1 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000000ce);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 5	[1393]	SETTABUP 	0 0 1	; _ENV "args"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0100000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 6	[1396]	GETTABUP 	1 0 0	; _ENV "args"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[1396]	GETI     	1 1 1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0101008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 8	[1396]	SETTABUP 	0 1 1	; _ENV "filename"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0101000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 9	[1399]	SETTABUP 	0 2 3k	; _ENV "outfile" ""
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0302800f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 10	[1401]	GETTABUP 	1 0 4	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0400008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 11	[1401]	GETFIELD 	1 1 5	; "remove"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0501008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 12	[1401]	GETTABUP 	2 0 0	; _ENV "args"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[1401]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 14	[1401]	CALL     	1 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x010300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 15	[1402]	NEWTABLE 	1 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000093);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 16	[1402]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 17	[1402]	SETTABUP 	0 6 1	; _ENV "flags"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0106000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 18	[1404]	GETTABUP 	1 0 7	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0700008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 19	[1404]	GETTABUP 	2 0 0	; _ENV "args"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 20	[1404]	CALL     	1 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x050200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 21	[1404]	TFORPREP 	1 76	; to 99
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x002600cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_98;
  }

  // 22	[1405]	EQK      	6 8 0	; "-d"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_26
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0008033c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 23	[1405]	JMP      	2	; to 27
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_26;
  }

  // 24	[1406]	SETTABUP 	1 9 10k	; preprocessor "DEBUG" true
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_98
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0a09808f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 25	[1407]	JMP      	72	; to 99
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x800023b8);
    updatetrap(ci);
    goto label_98;
  }

  // 26	[1407]	EQK      	6 11 0	; "-t"
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_30
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x000b033c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 27	[1407]	JMP      	2	; to 31
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_30;
  }

  // 28	[1408]	SETTABUP 	1 12 10k	; preprocessor "PRE_TEST" true
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_98
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x0a0c808f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 29	[1409]	JMP      	68	; to 99
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x800021b8);
    updatetrap(ci);
    goto label_98;
  }

  // 30	[1409]	EQK      	6 13 0	; "-f"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_34
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x000d033c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 31	[1409]	JMP      	2	; to 35
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_34;
  }

  // 32	[1410]	SETTABUP 	1 14 10k	; preprocessor "FAST" true
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_98
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x0a0e808f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 33	[1411]	JMP      	64	; to 99
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x80001fb8);
    updatetrap(ci);
    goto label_98;
  }

  // 34	[1411]	EQK      	6 15 0	; "-o"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x000f033c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 35	[1411]	JMP      	6	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_42;
  }

  // 36	[1412]	GETTABUP 	7 0 0	; _ENV "args"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x0000038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 37	[1412]	ADDI     	8 5 1
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x80050415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 38	[1412]	MMBINI   	5 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x068002af);
    Instruction pi = 0x80050415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 39	[1412]	GETTABLE 	7 7 8
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x0807038c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 40	[1412]	SETTABUP 	0 2 7	; _ENV "outfile"
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_98
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x0702000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 41	[1413]	JMP      	56	; to 99
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x80001bb8);
    updatetrap(ci);
    goto label_98;
  }

  // 42	[1413]	EQK      	6 16 0	; "-D"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_74
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0010033c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 43	[1413]	JMP      	30	; to 75
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x80000eb8);
    updatetrap(ci);
    goto label_74;
  }

  // 44	[1414]	SELF     	7 6 18k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x12068394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 45	[1414]	LOADI    	9 3
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x80010481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 46	[1414]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 47	[1414]	SETTABUP 	0 17 7	; _ENV "rest"
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x0711000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 48	[1415]	GETTABUP 	7 0 17	; _ENV "rest"
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x1100038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 49	[1415]	SELF     	7 7 18k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x12078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 50	[1415]	LOADI    	9 1
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x80000481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 51	[1415]	GETTABUP 	10 0 17	; _ENV "rest"
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x1100050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 52	[1415]	SELF     	10 10 20k	; "find"
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x140a8514);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 53	[1415]	LOADK    	12 21	; "="
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x000a8603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 54	[1415]	CALL     	10 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x02030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 55	[1415]	ADDI     	10 10 -1
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x7e0a0515);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 56	[1415]	MMBINI   	10 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x0780052f);
    Instruction pi = 0x7e0a0515;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 57	[1415]	CALL     	7 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x020403c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 58	[1415]	SETTABUP 	0 19 7	; _ENV "key"
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x0713000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 59	[1416]	GETTABUP 	7 0 17	; _ENV "rest"
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x1100038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 60	[1416]	SELF     	7 7 18k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x12078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 61	[1416]	GETTABUP 	9 0 17	; _ENV "rest"
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x1100048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 62	[1416]	SELF     	9 9 20k	; "find"
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x14098494);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 63	[1416]	LOADK    	11 21	; "="
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x000a8583);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 64	[1416]	CALL     	9 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x020304c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 65	[1416]	ADDI     	9 9 1
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x80090495);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 66	[1416]	MMBINI   	9 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x068004af);
    Instruction pi = 0x80090495;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 67	[1416]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 68	[1416]	SETTABUP 	0 22 7	; _ENV "value"
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x0716000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 69	[1417]	GETTABUP 	7 0 6	; _ENV "flags"
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x0600038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 70	[1417]	GETTABUP 	8 0 19	; _ENV "key"
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x1300040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 71	[1417]	GETTABUP 	9 0 22	; _ENV "value"
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x1600048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 72	[1417]	SETTABLE 	7 8 9
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_98
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x09080390);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 73	[1418]	JMP      	24	; to 99
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x80000bb8);
    updatetrap(ci);
    goto label_98;
  }

  // 74	[1418]	EQK      	6 23 0	; "-h"
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_98
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x0017033c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 75	[1418]	JMP      	22	; to 99
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x80000ab8);
    updatetrap(ci);
    goto label_98;
  }

  // 76	[1419]	GETUPVAL 	7 2	; print
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x00020389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 77	[1419]	LOADK    	8 24	; "Usage: cobaltpre [flags] <filename>"
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x000c0403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 78	[1419]	CALL     	7 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x010203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 79	[1420]	GETUPVAL 	7 2	; print
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x00020389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 80	[1420]	LOADK    	8 25	; "Flags:"
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x000c8403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 81	[1420]	CALL     	7 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x010203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 82	[1421]	GETUPVAL 	7 2	; print
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x00020389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 83	[1421]	LOADK    	8 26	; "  -d: Enable debug output"
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x000d0403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 84	[1421]	CALL     	7 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x010203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 85	[1422]	GETUPVAL 	7 2	; print
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x00020389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 86	[1422]	LOADK    	8 27	; "  -t: Run unit tests"
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x000d8403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 87	[1422]	CALL     	7 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x010203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 88	[1423]	GETUPVAL 	7 2	; print
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x00020389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 89	[1423]	LOADK    	8 28	; "  -f: Enable fast mode"
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x000e0403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 90	[1423]	CALL     	7 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x010203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 91	[1424]	GETUPVAL 	7 2	; print
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x00020389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 92	[1424]	LOADK    	8 29	; "  -o: Output to file"
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x000e8403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 93	[1424]	CALL     	7 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x010203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 94	[1425]	GETUPVAL 	7 2	; print
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x00020389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 95	[1425]	LOADK    	8 30	; "  -h: Show this help"
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x000f0403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 96	[1425]	CALL     	7 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x010203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 97	[1426]	RETURN   	7 1 2	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x020183c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 98	[1404]	TFORCALL 	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x020000cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 99	[1404]	TFORLOOP 	1 78	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x002700cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_22; /* jump back */
    }
  }

  // 100	[1428]	CLOSE    	1
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x000000b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 101	[1431]	GETTABUP 	1 1 32	; preprocessor "compileFile"
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x2001008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 102	[1431]	GETTABUP 	2 0 1	; _ENV "filename"
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 103	[1431]	GETTABUP 	3 0 6	; _ENV "flags"
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x0600018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 104	[1431]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 105	[1431]	SETTABUP 	0 31 1	; _ENV "compiled"
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x011f000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 106	[1433]	GETTABUP 	1 0 2	; _ENV "outfile"
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 107	[1433]	EQK      	1 3 1	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_112
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x000380bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 108	[1433]	JMP      	3	; to 113
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_112;
  }

  // 109	[1433]	GETTABUP 	1 0 2	; _ENV "outfile"
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 110	[1433]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_116
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 111	[1433]	JMP      	4	; to 117
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_116;
  }

  // 112	[1434]	GETUPVAL 	1 3	; error
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x00030089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 113	[1434]	LOADK    	2 33	; "No file to output to"
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x00108103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 114	[1434]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_129
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 115	[1435]	JMP      	13	; to 130
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_129;
  }

  // 116	[1436]	GETTABUP 	1 0 35	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x2300008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 117	[1436]	GETFIELD 	1 1 36	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x2401008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 118	[1436]	GETTABUP 	2 0 2	; _ENV "outfile"
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x0200010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 119	[1436]	LOADK    	3 37	; "w"
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x00128183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 120	[1436]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 121	[1436]	SETTABUP 	0 34 1	; _ENV "file"
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x0122000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 122	[1437]	GETTABUP 	1 0 34	; _ENV "file"
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x2200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 123	[1437]	SELF     	1 1 38k	; "write"
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x26018094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 124	[1437]	GETTABUP 	3 0 31	; _ENV "compiled"
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x1f00018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 125	[1437]	CALL     	1 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x010300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 126	[1438]	GETTABUP 	1 0 34	; _ENV "file"
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x2200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 127	[1438]	SELF     	1 1 39k	; "close"
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x27018094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 128	[1438]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_128: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 129	[1440]	RETURN   	1 1 2	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_129: {
    aot_vmfetch(0x020180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

static AotCompiledFunction AOT_FUNCTIONS[] = {
  magic_implementation_00,
  magic_implementation_01,
  magic_implementation_02,
  magic_implementation_03,
  magic_implementation_04,
  magic_implementation_05,
  magic_implementation_06,
  magic_implementation_07,
  magic_implementation_08,
  magic_implementation_09,
  magic_implementation_10,
  magic_implementation_11,
  magic_implementation_12,
  magic_implementation_13,
  magic_implementation_14,
  magic_implementation_15,
  magic_implementation_16,
  magic_implementation_17,
  magic_implementation_18,
  magic_implementation_19,
  magic_implementation_20,
  magic_implementation_21,
  magic_implementation_22,
  magic_implementation_23,
  magic_implementation_24,
  magic_implementation_25,
  magic_implementation_26,
  magic_implementation_27,
  magic_implementation_28,
  magic_implementation_29,
  magic_implementation_30,
  magic_implementation_31,
  magic_implementation_32,
  magic_implementation_33,
  magic_implementation_34,
  magic_implementation_35,
  magic_implementation_36,
  magic_implementation_37,
  magic_implementation_38,
  magic_implementation_39,
  magic_implementation_40,
  magic_implementation_41,
  magic_implementation_42,
  magic_implementation_43,
  magic_implementation_44,
  magic_implementation_45,
  magic_implementation_46,
  magic_implementation_47,
  magic_implementation_48,
  magic_implementation_49,
  magic_implementation_50,
  magic_implementation_51,
  magic_implementation_52,
  magic_implementation_53,
  magic_implementation_54,
  magic_implementation_55,
  magic_implementation_56,
  magic_implementation_57,
  magic_implementation_58,
  magic_implementation_59,
  magic_implementation_60,
  magic_implementation_61,
  magic_implementation_62,
  magic_implementation_63,
  magic_implementation_64,
  magic_implementation_65,
  magic_implementation_66,
  magic_implementation_67,
  magic_implementation_68,
  magic_implementation_69,
  magic_implementation_70,
  magic_implementation_71,
  NULL
};

static const char AOT_MODULE_SOURCE_CODE[] = {
  118,  97, 114,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,
   32,  61,  32, 123, 125,  59,  10, 118,  97, 114,  32, 111, 107,  44,  32,  98,
  105, 116,  32,  61,  32, 114, 101, 113, 117, 105, 114, 101,  40,  34,  98, 105,
  116,  34,  41,  59,  10,  99, 111, 114, 111, 117, 116, 105, 110, 101,  32,  61,
   32,  99, 111, 114, 111, 117, 116, 105, 110, 101,  32,  63,  32,  99, 111, 114,
  111, 117, 116, 105, 110, 101,  32,  58,  32,  40, 112,  99,  97, 108, 108,  40,
  114, 101, 113, 117, 105, 114, 101,  44,  32,  34,  99, 111, 114, 111, 117, 116,
  105, 110, 101,  34,  41,  32,  63,  32, 114, 101, 113, 117, 105, 114, 101,  40,
   34,  99, 111, 114, 111, 117, 116, 105, 110, 101,  34,  41,  32,  58,  32, 116,
  104, 114, 101,  97, 100,  41,  59,  32,  47,  42,  32, 102, 111, 114,  32,  98,
  101, 116,  97,  32, 118, 101, 114, 115, 105, 111, 110, 115,  32, 111, 102,  32,
   99, 111,  98,  97, 108, 116,  32,  42,  47,  10, 105, 102,  40,  32,  33,  32,
  111, 107,  32,  41,  32, 123,  10,  98, 105, 116,  32,  61,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 108, 115, 104, 105, 102, 116,  32,  61,  32,
  102, 117, 110,  99, 116, 105, 111, 110,  32,  40, 120,  44,  32, 121,  41,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  40,  32, 121,  32,  60,  32,  48,  32,  41,  32, 123,  32,
  114, 101, 116, 117, 114, 110,  32,  98, 105, 116,  46, 114, 115, 104, 105, 102,
  116,  40, 120,  44,  45, 121,  41,  59,  32, 125,  32,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117,
  114, 110,  32,  40, 120,  32,  42,  32,  50,  42,  42, 121,  41,  32,  37,  32,
   40,  50,  42,  42,  51,  50,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 115, 104, 105,
  102, 116,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32,  40, 120,
   44,  32, 121,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 121,  32,  60,  32,  48,
   32,  41,  32, 123,  32, 114, 101, 116, 117, 114, 110,  32,  98, 105, 116,  46,
  108, 115, 104, 105, 102, 116,  40, 120,  44,  45, 121,  41,  59,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  32, 109,  97, 116, 104,  46, 102, 108, 111, 111,
  114,  40, 120,  32,  37,  32,  40,  50,  42,  42,  51,  50,  41,  32,  47,  32,
   40,  50,  42,  42, 121,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  98, 120, 111, 114,
   32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32,  40, 120,  44,  32,
  121,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32, 102, 114, 111, 109,  32, 104, 116, 116,
  112,  58,  47,  47, 108, 117,  97,  45, 117, 115, 101, 114, 115,  46, 111, 114,
  103,  47, 119, 105, 107, 105,  47,  66, 105, 116,  85, 116, 105, 108, 115,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 122,  32,  61,  32,  48,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  40,  32,
  105,  32,  61,  32,  48,  44,  32,  51,  49,  32,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 105, 102,  40,  32,  40, 120,  32,  37,  32,  50,
   32,  61,  61,  32,  48,  41,  32,  41,  32, 123,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32, 120,  32, 104,  97, 100,  32,  97,  32,  39,  48,  39,  32, 105,
  110,  32,  98, 105, 116,  32, 105,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,  40,  32, 121,  32,
   37,  32,  50,  32,  61,  61,  32,  49,  41,  32,  41,  32, 123,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,
   47,  32, 121,  32, 104,  97, 100,  32,  97,  32,  39,  49,  39,  32, 105, 110,
   32,  98, 105, 116,  32, 105,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  45,
   45, 121,  32,  32,  32,  32,  59,  32,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 122,  32,  61,  32, 122,  32,  43,  32,  50,  32,  42,  42,  32, 105,  59,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 115, 101, 116,  32,  98, 105,
  116,  32, 105,  32, 111, 102,  32, 122,  32, 116, 111,  32,  39,  49,  39,  32,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115,
  101,  32, 123,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 120,  32, 104,  97,
  100,  32,  97,  32,  39,  49,  39,  32, 105, 110,  32,  98, 105, 116,  32, 105,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  45,  45, 120,  32,  32,  32,  32,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,  40, 121,
   32,  37,  32,  50,  32,  61,  61,  32,  48,  41,  32,  41,  32, 123,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32, 121,  32, 104,  97, 100,  32,  97,  32,  39,  48,  39,  32, 105,
  110,  32,  98, 105, 116,  32, 105,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  122,  32,  61,  32, 122,  32,  43,  32,  50,  32,  42,  42,  32, 105,  59,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  47,  47,  32, 115, 101, 116,  32,  98, 105, 116,
   32, 105,  32, 111, 102,  32, 122,  32, 116, 111,  32,  39,  49,  39,  32,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  32, 101, 108, 115, 101,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  45,  45, 121,  32,  32,  32,  32,  59,  32,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 121,
   32,  47,  61,  32,  32,  32,  50,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 120,  32,  47,  61,  32,  32,  32,  50,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116,
  117, 114, 110,  32, 122,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  98, 110, 111, 116,  32,  61,
   32, 102, 117, 110,  99, 116, 105, 111, 110,  32,  40, 120,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32, 105, 102,  32, 119, 111, 114, 100,  32, 115, 105, 122, 101,  32,
  105, 115,  32, 110, 111, 116,  32, 100, 101, 102, 105, 110, 101, 100,  44,  32,
   73,  32, 116, 104, 105, 110, 107,  32, 105, 116,  32,  98, 101, 116, 116, 101,
  114,  32, 116, 104,  97, 110,  32,  48, 120,  70,  70,  70,  70,  70,  70,  70,
   70,  32,  45,  32, 120,  46,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  45,  49,
   32,  45,  32, 120,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  44,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  98,  97, 110, 100,  32,  61,  32,
  102, 117, 110,  99, 116, 105, 111, 110,  32,  40, 120,  44,  32, 121,  41,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 114, 101, 116, 117, 114, 110,  32,  40,  40, 120,  32,  43,  32, 121,
   41,  32,  45,  32,  98, 105, 116,  46,  98, 120, 111, 114,  40, 120,  44,  32,
  121,  41,  41,  32,  47,  32,  50,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  98, 111, 114,  32,
   61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32,  40, 120,  44,  32, 121,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  98, 105, 116,  46,  98,
  110, 111, 116,  40,  98, 105, 116,  46,  98,  97, 110, 100,  40,  98, 105, 116,
   46,  98, 110, 111, 116,  40, 120,  41,  44,  32,  98, 105, 116,  46,  98, 110,
  111, 116,  40, 121,  41,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  44,  10, 125,  59,  10, 125,  10,  10,  47,  47,  32,  67,  79,  78,
   70,  73,  71,  10, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,
   46,  80,  82,  69,  95,  70,  70,  73,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  61,  32, 112,  99,  97, 108, 108,  40, 114, 101, 113, 117, 105, 114, 101,
   44,  32,  34, 102, 102, 105,  34,  41,  59,  32,  32,  32,  47,  47,  32, 119,
  104, 101, 116, 104, 101, 114,  32, 116, 111,  32, 117, 115, 101,  32, 112, 114,
  101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32, 116, 111,  32, 112, 114,
  101, 112, 114, 111,  99, 101, 115, 115,  32,  76, 117,  97,  74,  73,  84,  32,
  102, 102, 105,  32,  99, 111, 100, 101,  32,  40, 102, 102, 105,  46,  99, 100,
  101, 102,  41,  10, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,
   46,  80,  82,  69,  95,  84,  69,  83,  84,  32,  32,  32,  32,  32,  32,  32,
   32,  61,  32, 102,  97, 108, 115, 101,  59,  32,  32,  32,  47,  47,  32, 119,
  104, 101, 116, 104, 101, 114,  32, 116, 111,  32, 114, 117, 110,  32, 112, 114,
  101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32, 117, 110, 105, 116,  32,
  116, 101, 115, 116, 115,  32, 119, 104, 101, 110,  32, 108, 111,  97, 100, 105,
  110, 103,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32,
  109, 111, 100, 117, 108, 101,  10, 112, 114, 101, 112, 114, 111,  99, 101, 115,
  115, 111, 114,  46,  69,  78,  86,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  61,  32, 123, 125,  59,  32,  32,  32,  32,  32,  32,
   47,  47,  32, 115, 116,  97, 116, 105,  99,  32, 112, 114, 101, 100, 101, 102,
  105, 110, 101, 115,  32,  40, 101, 110, 118,  45, 108, 105, 107, 101,  41,  10,
  112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46,  70,  65,  83,
   84,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  61,  32,
  102,  97, 108, 115, 101,  59,  32,  32,  32,  47,  47,  32, 112, 101, 114, 102,
   46,  32, 116, 119, 101,  97, 107, 115,  32, 119, 104, 101, 110,  32, 101, 110,
   97,  98, 108, 101, 100,  46,  32,  99, 111, 110,  58,  32,  98, 114, 101,  97,
  107, 115,  32, 109, 105, 110, 111, 114,  32, 115, 116, 117, 102, 102,  32, 108,
  105, 107, 101,  32,  76,  73,  78,  69,  32, 109,  97,  99, 114, 111, 115,  10,
  112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46,  68,  69,  66,
   85,  71,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  61,  32,
  102,  97, 108, 115, 101,  59,  10,  10,  47,  47,  32,  80,  82,  69,  68,  69,
   70,  73,  78,  69,  83,  10, 118,  97, 114,  32,  70,  73,  76,  69,  32,  32,
   61,  32,  34,  70,  73,  76,  69,  34,  59,  10, 118,  97, 114,  32,  76,  73,
   78,  69,  32,  32,  32,  32,  32,  32,  32,  32,  61,  32,  34,  76,  73,  78,
   69,  34,  59,  10, 118,  97, 114,  32,  68,  65,  84,  69,  32,  32,  32,  32,
   32,  32,  32,  32,  61,  32,  34,  68,  65,  84,  69,  34,  59,  10, 118,  97,
  114,  32,  84,  73,  77,  69,  32,  32,  32,  32,  32,  32,  32,  32,  61,  32,
   34,  84,  73,  77,  69,  34,  59,  10, 118,  97, 114,  32,  80,  82,  69,  95,
   73,  78,  68,  69,  78,  84,  32,  32,  61,  32,  34,  80,  82,  69,  95,  73,
   78,  68,  69,  78,  84,  34,  59,  10,  10,  47,  47,  32,  66,  78,  70,  32,
   76,  69,  65,  86,  69,  83,  10, 118,  97, 114,  32,  69,  78,  68,  76,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  61,  32,  34,  36,  34,
   59,  10, 118,  97, 114,  32,  83,  84,  65,  82,  84,  76,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  61,  32,  34,  94,  34,  59,  10, 118,  97, 114,
   32,  78,  69,  87,  76,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  61,  32,  34,  92, 110,  34,  59,  10, 118,  97, 114,  32,  78,  69,  87,
   76,  95,  66,  89,  84,  69,  32,  32,  32,  32,  32,  32,  32,  61,  32,  78,
   69,  87,  76,  45,  62,  98, 121, 116, 101,  40,  49,  41,  59,  10, 118,  97,
  114,  32,  78,  69,  87,  76,  95,  69,  83,  67,  32,  32,  32,  32,  32,  32,
   32,  32,  61,  32,  34,  92,  92,  34,  59,  10, 118,  97, 114,  32,  78,  69,
   87,  77,  76,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  61,  32,
   34,  92,  92,  92, 110,  34,  59,  10, 118,  97, 114,  32,  67,  77,  68,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  61,  32,  34,  35,
   34,  59,  10, 118,  97, 114,  32,  67,  77,  68,  95,  66,  89,  84,  69,  32,
   32,  32,  32,  32,  32,  32,  32,  61,  32,  67,  77,  68,  45,  62,  98, 121,
  116, 101,  40,  49,  41,  59,  10, 118,  97, 114,  32,  67,  79,  77,  77,  69,
   78,  84,  32,  32,  32,  32,  32,  32,  32,  32,  32,  61,  32,  34,  94,  40,
   46,  45,  41,  47,  47,  46,  45,  36,  34,  59,  10, 118,  97, 114,  32,  77,
   76,  67,  79,  77,  77,  69,  78,  84,  32,  32,  32,  32,  32,  32,  32,  61,
   32,  34,  47,  91,  42,  93,  46,  45,  91,  42,  93,  47,  34,  59,  10, 118,
   97, 114,  32,  87,  72,  73,  84,  69,  83,  80,  65,  67,  69,  83,  32,  32,
   32,  32,  32,  61,  32,  34,  37, 115,  43,  34,  59,  10, 118,  97, 114,  32,
   79,  80,  84,  83,  80,  65,  67,  69,  83,  32,  32,  32,  32,  32,  32,  32,
   61,  32,  34,  37, 115,  42,  34,  59,  10, 118,  97, 114,  32,  73,  68,  69,
   78,  84,  73,  70,  73,  69,  82,  32,  32,  32,  32,  32,  32,  61,  32,  34,
   91,  95,  37,  97,  93,  91,  95,  37, 119,  93,  42,  34,  59,  10, 118,  97,
  114,  32,  78,  79,  73,  68,  69,  78,  84,  73,  70,  73,  69,  82,  32,  32,
   32,  32,  61,  32,  34,  91,  94,  37, 119,  95,  93,  43,  34,  59,  10, 118,
   97, 114,  32,  70,  73,  76,  69,  78,  65,  77,  69,  32,  32,  32,  32,  32,
   32,  32,  32,  61,  32,  34,  91,  48,  45,  57,  97,  45, 122,  65,  45,  90,
   46,  37,  45,  95,  47,  92,  92,  93,  43,  34,  59,  10, 118,  97, 114,  32,
   84,  69,  88,  84,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   61,  32,  34,  46,  43,  34,  59,  10, 118,  97, 114,  32,  83,  84,  82,  73,
   78,  71,  73,  70,  89,  32,  32,  32,  32,  32,  32,  32,  61,  32,  34,  35,
   34,  59,  10, 118,  97, 114,  32,  83,  84,  82,  73,  78,  71,  73,  70,  89,
   95,  66,  89,  84,  69,  32,  32,  61,  32,  83,  84,  82,  73,  78,  71,  73,
   70,  89,  45,  62,  98, 121, 116, 101,  40,  49,  41,  59,  10, 118,  97, 114,
   32,  83,  84,  82,  73,  78,  71,  95,  76,  73,  84,  69,  82,  65,  76,  32,
   32,  61,  32,  34,  46,  42,  34,  59,  10,  10,  47,  47,  32,  66,  78,  70,
   32,  87,  79,  82,  68,  83,  10, 118,  97, 114,  32,  95,  73,  78,  67,  76,
   85,  68,  69,  32,  32,  32,  32,  32,  32,  32,  32,  61,  32,  34, 105, 110,
   99, 108, 117, 100, 101,  34,  59,  10, 118,  97, 114,  32,  95,  73,  78,  67,
   76,  85,  68,  69,  95,  78,  69,  88,  84,  32,  32,  32,  61,  32,  34, 105,
  110,  99, 108, 117, 100, 101,  95, 110, 101, 120, 116,  34,  59,  10, 118,  97,
  114,  32,  95,  68,  69,  70,  73,  78,  69,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  61,  32,  34, 100, 101, 102, 105, 110, 101,  34,  59,  10, 118,  97,
  114,  32,  95,  73,  70,  68,  69,  70,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  61,  32,  34, 105, 102, 100, 101, 102,  34,  59,  10, 118,  97, 114,
   32,  95,  73,  70,  78,  68,  69,  70,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  61,  32,  34, 105, 102, 110, 100, 101, 102,  34,  59,  10, 118,  97, 114,
   32,  95,  69,  78,  68,  73,  70,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  61,  32,  34, 101, 110, 100, 105, 102,  34,  59,  10, 118,  97, 114,  32,
   95,  85,  78,  68,  69,  70,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   61,  32,  34, 117, 110, 100, 101, 102,  34,  59,  10, 118,  97, 114,  32,  95,
   73,  70,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  61,
   32,  34, 105, 102,  34,  59,  10, 118,  97, 114,  32,  95,  69,  76,  83,  69,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  61,  32,  34, 101, 108,
  115, 101,  34,  59,  10, 118,  97, 114,  32,  95,  69,  76,  73,  70,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  61,  32,  34, 101, 108, 105, 102,
   34,  59,  10, 118,  97, 114,  32,  95,  78,  79,  84,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  61,  32,  34,  33,  34,  59,  10, 118,  97,
  114,  32,  95,  69,  82,  82,  79,  82,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  61,  32,  34, 101, 114, 114, 111, 114,  34,  59,  10, 118,  97, 114,
   32,  95,  87,  65,  82,  78,  73,  78,  71,  32,  32,  32,  32,  32,  32,  32,
   32,  61,  32,  34, 119,  97, 114, 110, 105, 110, 103,  34,  59,  10, 118,  97,
  114,  32,  95,  80,  82,  65,  71,  77,  65,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  61,  32,  34, 112, 114,  97, 103, 109,  97,  34,  59,  10,  10,  47,
   47,  32,  66,  78,  70,  32,  82,  85,  76,  69,  83,  10, 118,  97, 114,  32,
   73,  78,  67,  76,  85,  68,  69,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   61,  32,  83,  84,  65,  82,  84,  76,  46,  46,  95,  73,  78,  67,  76,  85,
   68,  69,  46,  46,  87,  72,  73,  84,  69,  83,  80,  65,  67,  69,  83,  46,
   46,  34,  91,  60,  93,  40,  34,  46,  46,  70,  73,  76,  69,  78,  65,  77,
   69,  46,  46,  34,  41,  91,  62,  93,  34,  46,  46,  79,  80,  84,  83,  80,
   65,  67,  69,  83,  46,  46,  69,  78,  68,  76,  59,  10, 118,  97, 114,  32,
   76,  79,  67,  65,  76,  95,  73,  78,  67,  76,  85,  68,  69,  32,  32,  32,
   61,  32,  83,  84,  65,  82,  84,  76,  46,  46,  95,  73,  78,  67,  76,  85,
   68,  69,  46,  46,  87,  72,  73,  84,  69,  83,  80,  65,  67,  69,  83,  46,
   46,  34,  91,  92,  34,  93,  40,  34,  46,  46,  70,  73,  76,  69,  78,  65,
   77,  69,  46,  46,  34,  41,  91,  92,  34,  93,  34,  46,  46,  79,  80,  84,
   83,  80,  65,  67,  69,  83,  46,  46,  69,  78,  68,  76,  59,  10, 118,  97,
  114,  32,  73,  78,  67,  76,  85,  68,  69,  95,  78,  69,  88,  84,  32,  32,
   32,  32,  61,  32,  83,  84,  65,  82,  84,  76,  46,  46,  95,  73,  78,  67,
   76,  85,  68,  69,  95,  78,  69,  88,  84,  46,  46,  87,  72,  73,  84,  69,
   83,  80,  65,  67,  69,  83,  46,  46,  34,  91,  92,  34,  60,  93,  40,  34,
   46,  46,  70,  73,  76,  69,  78,  65,  77,  69,  46,  46,  34,  41,  91,  92,
   34,  62,  93,  34,  46,  46,  79,  80,  84,  83,  80,  65,  67,  69,  83,  46,
   46,  69,  78,  68,  76,  59,  10, 118,  97, 114,  32,  68,  69,  70,  73,  78,
   69,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  61,  32,  83,  84,  65,
   82,  84,  76,  46,  46,  95,  68,  69,  70,  73,  78,  69,  59,  10, 118,  97,
  114,  32,  73,  70,  68,  69,  70,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  61,  32,  83,  84,  65,  82,  84,  76,  46,  46,  95,  73,  70,  68,
   69,  70,  46,  46,  87,  72,  73,  84,  69,  83,  80,  65,  67,  69,  83,  46,
   46,  34,  40,  34,  46,  46,  73,  68,  69,  78,  84,  73,  70,  73,  69,  82,
   46,  46,  34,  41,  34,  46,  46,  79,  80,  84,  83,  80,  65,  67,  69,  83,
   46,  46,  69,  78,  68,  76,  59,  10, 118,  97, 114,  32,  73,  70,  78,  68,
   69,  70,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  61,  32,  83,  84,
   65,  82,  84,  76,  46,  46,  95,  73,  70,  78,  68,  69,  70,  46,  46,  87,
   72,  73,  84,  69,  83,  80,  65,  67,  69,  83,  46,  46,  34,  40,  34,  46,
   46,  73,  68,  69,  78,  84,  73,  70,  73,  69,  82,  46,  46,  34,  41,  34,
   46,  46,  79,  80,  84,  83,  80,  65,  67,  69,  83,  46,  46,  69,  78,  68,
   76,  59,  10, 118,  97, 114,  32,  69,  78,  68,  73,  70,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  61,  32,  83,  84,  65,  82,  84,  76,  46,
   46,  95,  69,  78,  68,  73,  70,  46,  46,  79,  80,  84,  83,  80,  65,  67,
   69,  83,  46,  46,  69,  78,  68,  76,  59,  10, 118,  97, 114,  32,  85,  78,
   68,  69,  70,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  61,  32,
   83,  84,  65,  82,  84,  76,  46,  46,  95,  85,  78,  68,  69,  70,  46,  46,
   87,  72,  73,  84,  69,  83,  80,  65,  67,  69,  83,  46,  46,  34,  40,  34,
   46,  46,  73,  68,  69,  78,  84,  73,  70,  73,  69,  82,  46,  46,  34,  41,
   34,  46,  46,  79,  80,  84,  83,  80,  65,  67,  69,  83,  46,  46,  69,  78,
   68,  76,  59,  10, 118,  97, 114,  32,  73,  70,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  61,  32,  83,  84,  65,  82,  84,  76,
   46,  46,  95,  73,  70,  46,  46,  87,  72,  73,  84,  69,  83,  80,  65,  67,
   69,  83,  46,  46,  34,  40,  46,  42,  41,  34,  46,  46,  69,  78,  68,  76,
   59,  10, 118,  97, 114,  32,  69,  76,  83,  69,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  61,  32,  83,  84,  65,  82,  84,  76,  46,  46,
   95,  69,  76,  83,  69,  46,  46,  79,  80,  84,  83,  80,  65,  67,  69,  83,
   46,  46,  69,  78,  68,  76,  59,  10, 118,  97, 114,  32,  69,  76,  73,  70,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  61,  32,  83,  84,
   65,  82,  84,  76,  46,  46,  95,  69,  76,  73,  70,  46,  46,  87,  72,  73,
   84,  69,  83,  80,  65,  67,  69,  83,  46,  46,  34,  40,  46,  42,  41,  34,
   46,  46,  69,  78,  68,  76,  59,  10, 118,  97, 114,  32,  69,  76,  83,  69,
   73,  70,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  61,  32,  83,  84,
   65,  82,  84,  76,  46,  46,  95,  69,  76,  83,  69,  46,  46,  87,  72,  73,
   84,  69,  83,  80,  65,  67,  69,  83,  46,  46,  95,  73,  70,  46,  46,  87,
   72,  73,  84,  69,  83,  80,  65,  67,  69,  83,  46,  46,  34,  40,  46,  42,
   41,  34,  46,  46,  69,  78,  68,  76,  59,  10, 118,  97, 114,  32,  69,  82,
   82,  79,  82,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  61,  32,
   83,  84,  65,  82,  84,  76,  46,  46,  95,  69,  82,  82,  79,  82,  46,  46,
   87,  72,  73,  84,  69,  83,  80,  65,  67,  69,  83,  46,  46,  34,  40,  34,
   46,  46,  84,  69,  88,  84,  46,  46,  34,  41,  34,  46,  46,  79,  80,  84,
   83,  80,  65,  67,  69,  83,  46,  46,  69,  78,  68,  76,  59,  10, 118,  97,
  114,  32,  87,  65,  82,  78,  73,  78,  71,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  61,  32,  83,  84,  65,  82,  84,  76,  46,  46,  95,  87,  65,  82,
   78,  73,  78,  71,  46,  46,  87,  72,  73,  84,  69,  83,  80,  65,  67,  69,
   83,  46,  46,  34,  40,  34,  46,  46,  84,  69,  88,  84,  46,  46,  34,  41,
   34,  46,  46,  79,  80,  84,  83,  80,  65,  67,  69,  83,  46,  46,  69,  78,
   68,  76,  59,  10, 118,  97, 114,  32,  69,  82,  82,  79,  82,  95,  78,  79,
   84,  69,  88,  84,  32,  32,  32,  32,  61,  32,  83,  84,  65,  82,  84,  76,
   46,  46,  95,  69,  82,  82,  79,  82,  46,  46,  79,  80,  84,  83,  80,  65,
   67,  69,  83,  46,  46,  69,  78,  68,  76,  59,  32,  32,  47,  47,  62,  32,
  110, 111, 116,  32, 114, 101, 113, 117, 105, 114, 101, 100,  32, 119, 104, 101,
  110,  32, 119, 101,  32, 104,  97, 118, 101,  32,  80,  79,  83,  73,  88,  32,
  114, 101, 103, 101, 120,  10, 118,  97, 114,  32,  80,  82,  65,  71,  77,  65,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  61,  32,  83,  84,  65,  82,
   84,  76,  46,  46,  95,  80,  82,  65,  71,  77,  65,  59,  10,  10,  47,  47,
   32, 115, 112, 101, 101, 100, 117, 112, 115,  10, 118,  97, 114,  32,  84,  82,
   85,  69,  77,  65,  67,  82,  79,  32,  61,  32,  83,  84,  65,  82,  84,  76,
   46,  46,  34,  40,  34,  46,  46,  73,  68,  69,  78,  84,  73,  70,  73,  69,
   82,  46,  46,  34,  41,  37, 115,  42,  36,  34,  59,  10, 118,  97, 114,  32,
   82,  69,  80,  76,  77,  65,  67,  82,  79,  32,  61,  32,  83,  84,  65,  82,
   84,  76,  46,  46,  34,  40,  34,  46,  46,  73,  68,  69,  78,  84,  73,  70,
   73,  69,  82,  46,  46,  34,  41,  34,  46,  46,  87,  72,  73,  84,  69,  83,
   80,  65,  67,  69,  83,  46,  46,  34,  40,  46,  43,  41,  36,  34,  59,  10,
  118,  97, 114,  32,  70,  85,  78,  67,  77,  65,  67,  82,  79,  32,  61,  32,
   83,  84,  65,  82,  84,  76,  46,  46,  34,  40,  34,  46,  46,  73,  68,  69,
   78,  84,  73,  70,  73,  69,  82,  46,  46,  34,  41,  37,  40,  40,  91,  95,
   37, 115,  37, 119,  44,  93,  42,  41,  37,  41,  37, 115,  42,  40,  46,  42,
   41,  34,  59,  10,  10,  10,  47,  47,  32,  45,  45,  45,  45,  45,  45,  45,
   45,  45,  45,  45,  45,  10,  47,  47,  32,  76,  79,  67,  65,  76,  32,  85,
   84,  73,  76,  83,  10,  47,  47,  32,  45,  45,  45,  45,  45,  45,  45,  45,
   45,  45,  45,  45,  10, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111,
  114,  46,  83,  84,  65,  84,  69,  32,  61,  32, 123, 108, 105, 110, 101, 110,
  111,  32,  61,  32,  48, 125,  59,  32,  47,  47,  32,  99, 117, 114, 114, 101,
  110, 116,  32, 115, 116,  97, 116, 101,  32, 102, 111, 114,  32, 100, 101,  98,
  117, 103, 103, 105, 110, 103,  32, 116, 104, 101,  32, 108,  97, 115, 116,  32,
  111, 112, 101, 114,  97, 116, 105, 111, 110,  10, 118,  97, 114,  32, 102, 117,
  110,  99, 116, 105, 111, 110,  32, 101, 114, 114, 111, 114,  40, 109, 115, 103,
   41,  32, 123,  32,  10,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40, 115,
  116, 114, 105, 110, 103,  46, 102, 111, 114, 109,  97, 116,  40,  34,  92, 120,
   49,  98,  91,  49,  59,  51,  49, 109, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  32,  40,  69,  82,  82,  79,  82,  41,  32,  91,  37,  48,
   52, 105,  93,  32,  37, 115,  92, 120,  49,  98,  91,  48, 109,  34,  44,  32,
  112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46,  83,  84,  65,
   84,  69,  46, 108, 105, 110, 101, 110, 111,  44,  32, 109, 115, 103,  41,  41,
   59,  32,  10,  32,  32,  32,  32, 111, 115,  46, 101, 120, 105, 116,  40,  49,
   41,  59,  10, 125,  10, 118,  97, 114,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  32, 112, 114, 105, 110, 116,  40, 109, 115, 103,  41,  32, 123,  32,  10,
   32,  32,  32,  32,  95,  71,  46, 112, 114, 105, 110, 116,  40, 115, 116, 114,
  105, 110, 103,  46, 102, 111, 114, 109,  97, 116,  40,  34, 112, 114, 101, 112,
  114, 111,  99, 101, 115, 115, 111, 114,  32,  40,  76,  79,  71,  41,  32,  91,
   37,  48,  52, 105,  93,  32,  37, 115,  34,  44,  32, 112, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 111, 114,  46,  83,  84,  65,  84,  69,  46, 108, 105,
  110, 101, 110, 111,  44,  32, 109, 115, 103,  41,  41,  59,  10,  32, 125,  10,
   10,  47,  47,  32, 115, 112, 108, 105, 116, 115,  32,  97,  32, 115, 116, 114,
  105, 110, 103,  32, 117, 115, 105, 110, 103,  32,  97,  32, 112,  97, 116, 116,
  101, 114, 110,  32, 105, 110, 116, 111,  32,  97,  32, 116,  97,  98, 108, 101,
   32, 111, 102,  32, 115, 117,  98, 115, 116, 114, 105, 110, 103, 115,  10, 118,
   97, 114,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32, 103, 115, 112, 108,
  105, 116,  40, 115, 116, 114,  44,  32, 112,  97, 116,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  32,  95, 115, 112, 108, 105, 116,  40, 115, 116, 114,  44,  32,
  112,  97, 116,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 116,  32,  61,  32, 123,
  125,  59,  32,  32,  47,  47,  32,  78,  79,  84,  69,  58,  32, 117, 115, 101,
   32, 123, 110,  32,  61,  32,  48, 125,  32, 105, 110,  32,  76, 117,  97,  45,
   53,  46,  48,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 118,  97, 114,  32, 102, 112,  97, 116,  32,  61,  32,  34,
   40,  46,  45,  41,  34,  46,  46, 112,  97, 116,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,
  108,  97, 115, 116,  95, 101, 110, 100,  32,  61,  32,  49,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32, 115,  44,  32, 101,  44,  32,  99,  97, 112,  32,  61,  32, 115, 116,
  114,  45,  62, 102, 105, 110, 100,  40, 102, 112,  97, 116,  44,  32,  49,  41,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 119, 104, 105, 108, 101,  40,  32, 115,  32,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 115,  32,  33,  61,  32,
   49,  32, 124, 124,  32,  99,  97, 112,  32,  33,  61,  32,  34,  34,  32,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  99, 111, 114, 111, 117, 116, 105, 110, 101,  46, 121, 105, 101,
  108, 100,  40,  99,  97, 112,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108,  97, 115, 116,  95,
  101, 110, 100,  32,  61,  32, 101,  32,  43,  32,  49,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 115,  44,  32, 101,  44,  32,  99,  97, 112,  32,  61,
   32, 115, 116, 114,  45,  62, 102, 105, 110, 100,  40, 102, 112,  97, 116,  44,
   32, 108,  97, 115, 116,  95, 101, 110, 100,  41,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,
   40,  32, 108,  97, 115, 116,  95, 101, 110, 100,  32,  60,  61,  32,  35, 115,
  116, 114,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99,
   97, 112,  32,  61,  32, 115, 116, 114,  45,  62, 115, 117,  98,  40, 108,  97,
  115, 116,  95, 101, 110, 100,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  99, 111, 114, 111, 117, 116, 105, 110, 101,  46, 121, 105, 101, 108, 100,
   40,  99,  97, 112,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114,
  110,  32,  99, 111, 114, 111, 117, 116, 105, 110, 101,  46, 119, 114,  97, 112,
   40, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41,  32, 123,  32,  95, 115,
  112, 108, 105, 116,  40, 115, 116, 114,  44,  32, 112,  97, 116,  41,  59,  32,
  125,  41,  59,  10, 125,  10, 118,  97, 114,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  32, 115, 112, 108, 105, 116,  40, 115, 116, 114,  44,  32, 112,  97,
  116,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,
   32, 116,  32,  61,  32, 123, 125,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 102, 111, 114,  40,  32, 115, 116, 114,  32, 105, 110,  32, 103, 115, 112,
  108, 105, 116,  40, 115, 116, 114,  44,  32, 112,  97, 116,  41,  32,  41,  32,
  123,  32, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40, 116,
   44,  32, 115, 116, 114,  41,  59,  32, 125,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 114, 101, 116, 117, 114, 110,  32, 116,  59,  10, 125,  10,  10,  47,
   47,  32,  67, 104, 101,  99, 107, 115,  32, 119, 104, 101, 116, 104, 101, 114,
   32,  97,  32, 115, 116, 114, 105, 110, 103,  32, 115, 116,  97, 114, 116, 115,
   32, 119, 105, 116, 104,  32,  97,  32, 103, 105, 118, 101, 110,  32, 115, 117,
   98, 115, 116, 114, 105, 110, 103,  10,  47,  47,  32, 111, 102, 102, 115, 101,
  116,  32, 105, 115,  32, 111, 112, 116, 105, 111, 110,  97, 108,  10, 118,  97,
  114,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32, 115, 116, 114, 115, 119,
   40, 115, 116, 114,  44,  32, 112,  97, 116,  44,  32, 111, 102, 102, 115, 101,
  116,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,
   32,  33,  32, 115, 116, 114,  32,  41,  32, 123,  32, 114, 101, 116, 117, 114,
  110,  32, 102,  97, 108, 115, 101,  59,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 102,  40,  32,  33,  32, 111, 102, 102, 115, 101, 116,  32,
   41,  32, 123,  32, 111, 102, 102, 115, 101, 116,  32,  61,  32,  48,  59,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32, 115, 116, 114, 105, 110, 103,  46, 115, 117,  98,  40, 115, 116, 114,  44,
   32,  49,  43, 111, 102, 102, 115, 101, 116,  44,  32, 115, 116, 114, 105, 110,
  103,  46, 108, 101, 110,  40, 112,  97, 116,  41,  43, 111, 102, 102, 115, 101,
  116,  41,  32,  61,  61,  32, 112,  97, 116,  59,  10, 125,  10,  10,  47,  47,
   32,  67, 104, 101,  99, 107, 115,  32, 119, 104, 101, 116, 104, 101, 114,  32,
   97,  32, 115, 116, 114, 105, 110, 103,  32, 101, 110, 100, 115,  32, 119, 105,
  116, 104,  32,  97,  32, 103, 105, 118, 101, 110,  32, 115, 117,  98, 115, 116,
  114, 105, 110, 103,  10, 118,  97, 114,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  32, 115, 116, 114, 101, 119,  40, 115, 116, 114,  44,  32, 112,  97, 116,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,
   33,  32, 115, 116, 114,  32,  41,  32, 123,  32, 114, 101, 116, 117, 114, 110,
   32, 102,  97, 108, 115, 101,  59,  32, 125,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 114, 101, 116, 117, 114, 110,  32, 112,  97, 116,  61,  61,  39,  39,
   32, 124, 124,  32, 115, 116, 114, 105, 110, 103,  46, 115, 117,  98,  40, 115,
  116, 114,  44,  45, 115, 116, 114, 105, 110, 103,  46, 108, 101, 110,  40, 112,
   97, 116,  41,  41,  32,  61,  61,  32, 112,  97, 116,  59,  10, 125,  10,  10,
   47,  47,  32, 115, 116, 114, 105, 110, 103,  32, 116, 114, 105, 109,  49,  50,
   32, 102, 114, 111, 109,  32, 108, 117,  97,  32, 119, 105, 107, 105,  10, 118,
   97, 114,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32, 116, 114, 105, 109,
   40, 115, 116, 114,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 102, 114, 111, 109,  32,  61,  32, 115, 116, 114,  45,  62,
  109,  97, 116,  99, 104,  40,  34,  94,  37, 115,  42,  40,  41,  34,  41,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,
  102, 114, 111, 109,  32,  62,  32,  35, 115, 116, 114,  32,  38,  38,  32,  34,
   34,  32, 124, 124,  32, 115, 116, 114,  45,  62, 109,  97, 116,  99, 104,  40,
   34,  46,  42,  37,  83,  34,  44,  32, 102, 114, 111, 109,  41,  59,  10, 125,
   10,  10,  47,  47,  32, 114, 101, 116, 117, 114, 110, 115,  32, 116, 104, 101,
   32, 110, 117, 109,  98, 101, 114,  32, 111, 102,  32, 115, 116, 114, 105, 110,
  103,  32, 111,  99,  99, 117, 114, 114, 101, 110,  99, 101, 115,  10, 118,  97,
  114,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32, 102, 105, 110, 100, 110,
   40, 105, 110, 112, 117, 116,  44,  32, 119, 104,  97, 116,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  99, 111, 117, 110,
  116,  32,  61,  32,  48,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32, 111, 102, 102, 115, 101, 116,  32,  61,  32,  48,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  95,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101,  40,  32, 116, 114, 117,
  101,  32,  41,  32, 123,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  95,
   44,  32, 111, 102, 102, 115, 101, 116,  32,  61,  32, 115, 116, 114, 105, 110,
  103,  46, 102, 105, 110, 100,  40, 105, 110, 112, 117, 116,  44,  32, 119, 104,
   97, 116,  44,  32, 111, 102, 102, 115, 101, 116,  43,  49,  44,  32, 116, 114,
  117, 101,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,
   32,  33,  32, 111, 102, 102, 115, 101, 116,  32,  41,  32, 123,  32, 114, 101,
  116, 117, 114, 110,  32,  99, 111, 117, 110, 116,  59,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  43,  43,  99, 111, 117, 110, 116,  32,  32,  32,
   32,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10, 125,  10,  10,
   47,  47,  32,  67,  32, 108, 105, 116, 101, 114,  97, 108,  32, 115, 116, 114,
  105, 110, 103,  32,  99, 111, 110,  99,  97, 116, 101, 110,  97, 116, 105, 111,
  110,  10, 118,  97, 114,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32,  99,
  111, 110,  99,  97, 116,  83, 116, 114, 105, 110, 103,  76, 105, 116, 101, 114,
   97, 108,  40, 105, 110, 112, 117, 116,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32, 115,  99, 114, 101, 101, 110, 101, 114,  32,
  100, 111, 101, 115,  32, 114, 101, 109, 111, 118, 101,  32, 109, 117, 108, 116,
  105, 108, 105, 110, 101,  32, 100, 101, 102, 105, 110, 105, 116, 105, 111, 110,
   44,  32, 115, 111,  32, 106, 117, 115, 116,  32,  99, 104, 101,  99, 107,  32,
   34,  46,  42,  34,  37, 115,  42,  34,  46,  42,  34,  32, 112,  97, 116, 116,
  101, 114, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117,
  114, 110,  32, 105, 110, 112, 117, 116,  45,  62, 103, 115, 117,  98,  40,  34,
   92,  34,  40,  34,  46,  46,  83,  84,  82,  73,  78,  71,  95,  76,  73,  84,
   69,  82,  65,  76,  46,  46,  34,  41,  92,  34,  34,  46,  46,  79,  80,  84,
   83,  80,  65,  67,  69,  83,  46,  46,  34,  92,  34,  40,  34,  46,  46,  83,
   84,  82,  73,  78,  71,  95,  76,  73,  84,  69,  82,  65,  76,  46,  46,  34,
   41,  92,  34,  34,  44,  32,  34,  92,  34,  37,  49,  37,  50,  92,  34,  34,
   41,  59,  10, 125,  10,  10,  47,  47,  32,  99,  32, 115, 116, 121, 108, 101,
   32,  98, 111, 111, 108, 101,  97, 110,  32,  99, 104, 101,  99, 107,  32,  40,
  116, 104, 117, 115,  44,  32,  48,  32, 119, 105, 108, 108,  32,  98, 101,  32,
  102,  97, 108, 115, 101,  41,  10, 118,  97, 114,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  32,  67,  66, 111, 111, 108, 101,  97, 110,  40, 118,  97, 108,
  117, 101,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101,
  116, 117, 114, 110,  32, 118,  97, 108, 117, 101,  32,  38,  38,  32,  40, 118,
   97, 108, 117, 101,  32,  33,  61,  32,  48,  41,  59,  10, 125,  10,  10,  47,
   47,  32, 101, 118,  97, 108,  32, 119, 105, 116, 104,  32,  99,  32, 115, 116,
  121, 108, 101,  32, 110, 117, 109,  98, 101, 114,  32, 112,  97, 114, 115, 101,
   32,  40,  85,  76,  44,  32,  76,  76,  44,  32,  76,  41,  10, 118,  97, 114,
   32, 102, 117, 110,  99, 116, 105, 111, 110,  32,  67,  69, 118,  97, 108,  40,
  101, 120, 112, 114,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 111, 107,  44,  32, 114,  32,  61,  32, 112,  99,  97, 108,
  108,  40, 108, 111,  97, 100, 115, 116, 114, 105, 110, 103,  44,  32,  34, 114,
  101, 116, 117, 114, 110,  32,  34,  32,  46,  46,  32, 112,  97, 114, 115, 101,
   67,  73, 110, 116, 101, 103, 101, 114,  40, 101, 120, 112, 114,  41,  41,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 111, 107,  32,
   38,  38,  32, 114,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,
  114,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101,
  108, 115, 101,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114,  40, 114,  41,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  10, 125,  10,  10,  47,  47,  32,
   97,  32, 108, 105, 103, 104, 116, 119, 101, 105, 103, 104, 116,  32,  97, 110,
  100,  32, 102, 108, 101, 120, 105,  98, 108, 101,  32, 116, 111, 107, 101, 110,
  105, 122, 101, 114,  10, 118,  97, 114,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  32,  95, 116, 111, 107, 101, 110, 105, 122, 101, 114,  40, 115, 116, 114,
   44,  32, 115, 101, 116, 117, 112,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 100,
  101, 102, 115, 101, 116, 117, 112,  32,  61,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32,  69,  88,  65,  77,  80,  76,  69,  32, 112,
   97, 116, 116, 101, 114, 110, 115,  32, 104,  97, 118, 101,  32, 116, 111,  32,
   98, 101,  32, 112, 114, 101, 116, 101, 110, 100, 101, 100,  32, 119, 105, 116,
  104,  32,  34,  94,  34,  32, 102, 111, 114,  32, 116, 104, 101,  32, 116, 111,
  107, 101, 110, 105, 122, 101, 114,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   91,  34, 105, 100, 101, 110, 116, 105, 102, 105, 101, 114,  34,  93,  32,  61,
   32,  39,  94,  91,  95,  37,  97,  93,  91,  95,  37, 119,  93,  42,  39,  44,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  91,  34, 110, 117, 109,  98, 101,
  114,  34,  93,  32,  61,  32,  39,  94,  91,  37,  43,  37,  45,  93,  63,  37,
  100,  43,  91,  37,  46,  93,  63,  37, 100,  42,  91,  85,  76,  93,  42,  39,
   44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  91,  34, 105, 103, 110, 111,
  114, 101,  34,  93,  32,  61,  32,  39,  94,  37, 115,  43,  39,  44,  32,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  91,  34, 115, 116, 114, 105, 110, 103,
   34,  93,  32,  61,  32, 116, 114, 117, 101,  44,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  91,  34, 107, 101, 121, 119, 111, 114, 100, 115,  34,  93,  32,
   61,  32, 123,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32,  91,  34,  78,  65,  77,  69,  34,  93,
   32,  61,  32,  39,  94, 112,  97, 116, 116, 101, 114, 110,  39,  44,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,
   47,  32,  46,  46,  46,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  44,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,
   33,  32, 115, 101, 116, 117, 112,  32,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 101, 116, 117,
  112,  32,  61,  32, 100, 101, 102, 115, 101, 116, 117, 112,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  115, 101, 116, 117, 112,  46, 105, 100, 101, 110, 116, 105, 102, 105, 101, 114,
   32,  61,  32, 115, 101, 116, 117, 112,  46, 105, 100, 101, 110, 116, 105, 102,
  105, 101, 114,  32, 124, 124,  32, 100, 101, 102, 115, 101, 116, 117, 112,  46,
  105, 100, 101, 110, 116, 105, 102, 105, 101, 114,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 115, 101, 116, 117, 112,  46, 110, 117, 109,  98, 101, 114,
   32,  61,  32, 115, 101, 116, 117, 112,  46, 110, 117, 109,  98, 101, 114,  32,
  124, 124,  32, 100, 101, 102, 115, 101, 116, 117, 112,  46, 110, 117, 109,  98,
  101, 114,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 115, 101, 116, 117,
  112,  46, 105, 103, 110, 111, 114, 101,  32,  61,  32, 115, 101, 116, 117, 112,
   46, 105, 103, 110, 111, 114, 101,  32, 124, 124,  32, 100, 101, 102, 115, 101,
  116, 117, 112,  46, 105, 103, 110, 111, 114, 101,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  40,  32, 110, 117, 108, 108,  32,  61,  61,  32,
  115, 101, 116, 117, 112,  46, 115, 116, 114, 105, 110, 103,  32,  41,  32, 123,
   32, 115, 101, 116, 117, 112,  46, 115, 116, 114, 105, 110, 103,  32,  61,  32,
  116, 114, 117, 101,  59,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  115, 101, 116, 117, 112,  46, 107, 101, 121, 119, 111, 114, 100, 115,  32,  61,
   32, 115, 101, 116, 117, 112,  46, 107, 101, 121, 119, 111, 114, 100, 115,  32,
  124, 124,  32, 123, 125,  59,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 115, 116, 114, 108, 101, 110,  32,  61,  32,  35, 115, 116,
  114,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 105,
   32,  61,  32,  49,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32, 105,  49,  44,  32, 105,  50,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32, 107, 101, 121, 119, 111, 114, 100,  59,  10,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  32, 102, 105, 110, 100,  40, 112,  97, 116,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 105,  49,  44,  32, 105,  50,  32,  61,  32, 115, 116, 114,  45,  62, 102,
  105, 110, 100,  40, 112,  97, 116,  44, 105,  41,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117,
  114, 110,  32, 105,  49,  32,  33,  61,  32, 110, 117, 108, 108,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32,  99,
  117, 116,  40,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 115, 116,
  114,  45,  62, 115, 117,  98,  40, 105,  44,  32, 105,  50,  41,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32, 102, 105, 110, 100,  75, 101, 121, 119, 111, 114,
  100,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 115,
  101, 116, 117, 112,  46, 107, 101, 121, 119, 111, 114, 100, 115,  95, 111, 114,
  100, 101, 114,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 102, 105, 110, 100,  75, 101, 121, 119,
  111, 114, 100,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32,  40,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  40,
   32,  95,  44,  32, 110,  97, 109, 101,  32, 105, 110,  32, 105, 112,  97, 105,
  114, 115,  40, 115, 101, 116, 117, 112,  46, 107, 101, 121, 119, 111, 114, 100,
  115,  95, 111, 114, 100, 101, 114,  41,  32,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  97, 115, 115,
  101, 114, 116,  40, 115, 101, 116, 117, 112,  46, 107, 101, 121, 119, 111, 114,
  100, 115,  91, 110,  97, 109, 101,  93,  41,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 112,
   97, 116,  32,  61,  32, 115, 101, 116, 117, 112,  46, 107, 101, 121, 119, 111,
  114, 100, 115,  91, 110,  97, 109, 101,  93,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 114,
  101, 115, 117, 108, 116,  32,  61,  32, 102, 105, 110, 100,  40, 112,  97, 116,
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 102,  40,  32, 114, 101, 115, 117, 108, 116,  32,  41,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 107, 101, 121, 119, 111, 114,
  100,  32,  61,  32, 110,  97, 109, 101,  59,  32,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  59,  32,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 102, 105, 110, 100,  75, 101, 121, 119, 111, 114, 100,  32,  61,  32, 102,
  117, 110,  99, 116, 105, 111, 110,  32,  40,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 102, 111, 114,  40,  32, 110,  97, 109, 101,  44,  32,
  112,  97, 116,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 115, 101, 116,
  117, 112,  46, 107, 101, 121, 119, 111, 114, 100, 115,  41,  32,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 118,  97, 114,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32, 102, 105,
  110, 100,  40, 112,  97, 116,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 114, 101, 115,
  117, 108, 116,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  107, 101, 121, 119, 111, 114, 100,  32,  61,  32, 110,  97, 109, 101,  59,  32,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,
  116, 114, 117, 101,  59,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101,  40,  32,
  116, 114, 117, 101,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 105,  32,  62,
   32, 115, 116, 114, 108, 101, 110,  32,  41,  32, 123,  32, 114, 101, 116, 117,
  114, 110,  32,  39, 101, 111, 102,  39,  44,  32, 110, 117, 108, 108,  44,  32,
  115, 116, 114, 108, 101, 110,  44,  32, 115, 116, 114, 108, 101, 110,  59,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  40,  32, 102, 105, 110, 100,  75, 101, 121, 119, 111, 114,
  100,  40,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   99, 111, 114, 111, 117, 116, 105, 110, 101,  46, 121, 105, 101, 108, 100,  40,
  107, 101, 121, 119, 111, 114, 100,  44,  32,  99, 117, 116,  40,  41,  44,  32,
  105,  49,  44,  32, 105,  50,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32,
  105, 102,  40,  32, 102, 105, 110, 100,  40, 115, 101, 116, 117, 112,  46, 105,
  103, 110, 111, 114, 101,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  99, 111, 114, 111, 117, 116, 105, 110, 101,  46, 121, 105, 101,
  108, 100,  40,  34, 105, 103, 110, 111, 114, 101,  34,  44,  32,  99, 117, 116,
   40,  41,  44,  32, 105,  49,  44,  32, 105,  50,  41,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101,
  108, 115, 101,  32, 105, 102,  40,  32, 102, 105, 110, 100,  40, 115, 101, 116,
  117, 112,  46, 110, 117, 109,  98, 101, 114,  41,  32,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  99, 111, 114, 111, 117, 116, 105, 110, 101,
   46, 121, 105, 101, 108, 100,  40,  39, 110, 117, 109,  98, 101, 114,  39,  44,
   32, 116, 111, 110, 117, 109,  98, 101, 114,  40,  99, 117, 116,  40,  41,  41,
   44,  32, 105,  49,  44,  32, 105,  50,  41,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115,
  101,  32, 105, 102,  40,  32, 102, 105, 110, 100,  40, 115, 101, 116, 117, 112,
   46, 105, 100, 101, 110, 116, 105, 102, 105, 101, 114,  41,  32,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 114, 111, 117, 116, 105,
  110, 101,  46, 121, 105, 101, 108, 100,  40,  39, 105, 100, 101, 110, 116, 105,
  102, 105, 101, 114,  39,  44,  32,  99, 117, 116,  40,  41,  44,  32, 105,  49,
   44,  32, 105,  50,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 105, 102,
   40,  32, 115, 101, 116, 117, 112,  46, 115, 116, 114, 105, 110, 103,  32,  38,
   38,  32,  40, 102, 105, 110, 100,  40,  39,  94,  34,  91,  94,  34,  93,  42,
   34,  39,  41,  32, 124, 124,  32, 102, 105, 110, 100,  40,  34,  94,  39,  91,
   94,  39,  93,  42,  39,  34,  41,  41,  32,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32, 115, 116, 114, 105, 112,  32, 116, 104,
  101,  32, 113, 117, 111, 116, 101, 115,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  99, 111, 114, 111, 117, 116, 105, 110, 101,  46, 121, 105, 101, 108, 100,
   40,  39, 115, 116, 114, 105, 110, 103,  39,  44,  32,  99, 117, 116,  40,  41,
   45,  62, 115, 117,  98,  40,  50,  44,  45,  50,  41,  44,  32, 105,  49,  44,
   32, 105,  50,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  32,  47,
   47,  32,  97, 110, 121,  32, 111, 116, 104, 101, 114,  32, 117, 110, 107, 110,
  111, 119, 110,  32,  99, 104,  97, 114,  97,  99, 116, 101, 114,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 105,  49,  32,  61,  32, 105,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 105,  50,  32,  61,  32, 105,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  99, 111, 114, 111, 117, 116, 105, 110, 101,  46,
  121, 105, 101, 108, 100,  40,  39, 117, 110, 107, 110, 111, 119, 110,  39,  44,
   32,  99, 117, 116,  40,  41,  44,  32, 105,  49,  44,  32, 105,  50,  41,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 105,  32,  61,  32, 105,  50,  43,  49,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10, 125,  10, 118,  97, 114,  32, 102, 117, 110,
   99, 116, 105, 111, 110,  32, 116, 111, 107, 101, 110, 105, 122, 101, 114,  40,
  115, 116, 114,  44,  32, 115, 101, 116, 117, 112,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  99, 111, 114,
  111, 117, 116, 105, 110, 101,  46, 119, 114,  97, 112,  40, 102, 117, 110,  99,
  116, 105, 111, 110,  40,  41,  32, 123,  32,  95, 116, 111, 107, 101, 110, 105,
  122, 101, 114,  40, 115, 116, 114,  44,  32, 115, 101, 116, 117, 112,  41,  59,
   32, 125,  41,  59,  10, 125,  10,  10,  10,  47,  47,  32,  45,  45,  45,  45,
   45,  45,  45,  45,  45,  45,  45,  45,  10,  47,  47,  32,  80,  65,  82,  83,
   69,  82,  10,  47,  47,  32,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,
   45,  45,  10,  10, 118,  97, 114,  32,  80,  82,  69,  95,  84,  79,  75,  69,
   78,  73,  90,  69,  95,  67,  79,  77,  77,  69,  78,  84,  32,  61,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116, 114, 105, 110, 103,  32,
   61,  32, 102,  97, 108, 115, 101,  44,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 107, 101, 121, 119, 111, 114, 100, 115,  32,  61,  32, 123,  32,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  77,
   76,  67,  79,  77,  77,  69,  78,  84,  32,  61,  32,  34,  94,  47,  37,  42,
   46,  45,  37,  42,  47,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  83,  76,  67,  79,  77,  77,  69,  78,
   84,  32,  61,  32,  34,  94,  47,  47,  46,  45,  92, 110,  34,  44,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  83,
   84,  82,  73,  78,  71,  95,  76,  73,  84,  69,  82,  65,  76,  32,  61,  32,
   39,  94,  34,  91,  94,  34,  93,  42,  34,  39,  44,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  44,  10, 125,  59,  10,  47,  47,  32, 104, 105, 110,
  116,  58,  32,  76, 117,  97,  74,  73,  84,  32, 102, 102, 105,  32, 100, 111,
  101, 115,  32, 110, 111, 116,  32, 114, 101, 108, 121,  32, 111, 110,  32, 117,
  115,  32, 116, 111,  32, 114, 101, 109, 111, 118, 101,  32, 116, 104, 101,  32,
   99, 111, 109, 109, 101, 110, 116, 115,  44,  32,  98, 117, 116,  32, 109,  97,
  121,  98, 101,  32, 111, 116, 104, 101, 114,  32, 117, 115, 101,  99,  97, 115,
  101, 115,  10, 118,  97, 114,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32,
  114, 101, 109, 111, 118, 101,  67, 111, 109, 109, 101, 110, 116, 115,  40, 105,
  110, 112, 117, 116,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 111, 117, 116,  32,  61,  32, 123, 125,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 102, 111, 114,  40,  32, 107,  44,  32, 118,  44,
   32, 115, 116,  97, 114, 116,  44,  32, 101, 110, 100,  95,  32, 105, 110,  32,
  116, 111, 107, 101, 110, 105, 122, 101, 114,  40, 105, 110, 112, 117, 116,  44,
   32,  80,  82,  69,  95,  84,  79,  75,  69,  78,  73,  90,  69,  95,  67,  79,
   77,  77,  69,  78,  84,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 107,
   32,  61,  61,  32,  34,  77,  76,  67,  79,  77,  77,  69,  78,  84,  34,  32,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,
  110, 101, 119, 108, 105, 110, 101,  67, 111, 117, 110, 116,  32,  61,  32, 102,
  105, 110, 100, 110,  40, 105, 110, 112, 117, 116,  45,  62, 115, 117,  98,  40,
  115, 116,  97, 114, 116,  44,  32, 101, 110, 100,  95,  41,  44,  32,  34,  92,
  110,  34,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,
   32, 110, 101, 119, 108, 105, 110, 101, 115,  32,  61,  32, 115, 116, 114, 105,
  110, 103,  46, 114, 101, 112,  40,  34,  92, 110,  34,  44,  32, 110, 101, 119,
  108, 105, 110, 101,  67, 111, 117, 110, 116,  41,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,
   40, 111, 117, 116,  44,  32, 110, 101, 119, 108, 105, 110, 101, 115,  41,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  32, 101, 108, 115, 101,  32, 105, 102,  40,  32, 107,  32,  61,  61,
   32,  34,  83,  76,  67,  79,  77,  77,  69,  78,  84,  34,  32,  41,  32, 123,
   32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46,
  105, 110, 115, 101, 114, 116,  40, 111, 117, 116,  44,  32,  34,  92, 110,  34,
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,
   40, 111, 117, 116,  44,  32, 105, 110, 112, 117, 116,  45,  62, 115, 117,  98,
   40, 115, 116,  97, 114, 116,  44,  32, 101, 110, 100,  95,  41,  41,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116,  97,  98, 108, 101,
   46,  99, 111, 110,  99,  97, 116,  40, 111, 117, 116,  41,  59,  10, 125,  10,
   10,  47,  47,  32,  67,  32, 115, 116, 121, 108, 101,  32, 110, 117, 109,  98,
  101, 114,  32, 112,  97, 114, 115, 101,  32,  40,  85,  76,  44,  32,  76,  76,
   44,  32,  76,  41,  32,  97, 110, 100,  32,  40, 111,  99, 116, 101, 116,  44,
   32, 104, 101, 120,  44,  32,  98, 105, 110,  97, 114, 121,  41,  10, 118,  97,
  114,  32,  80,  82,  69,  95,  84,  79,  75,  69,  78,  73,  90,  69,  95,  73,
   78,  84,  69,  71,  69,  82,  32,  61,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 115, 116, 114, 105, 110, 103,  32,  61,  32, 102,  97, 108, 115,
  101,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32, 107, 101, 121, 119, 111,
  114, 100, 115,  95, 111, 114, 100, 101, 114,  32,  61,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  83,
   84,  82,  73,  78,  71,  95,  76,  73,  84,  69,  82,  65,  76,  34,  44,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   34,  67,  72,  65,  82,  95,  76,  73,  84,  69,  82,  65,  76,  34,  44,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   34,  72,  69,  88,  95,  76,  73,  84,  69,  82,  65,  76,  34,  44,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,
   66,  73,  78,  95,  76,  73,  84,  69,  82,  65,  76,  34,  44,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  79,
   67,  84,  95,  76,  73,  84,  69,  82,  65,  76,  34,  44,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  70,  80,
   78,  85,  77,  95,  76,  73,  84,  69,  82,  65,  76,  34,  44,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  78,
   85,  77,  66,  69,  82,  95,  76,  73,  84,  69,  82,  65,  76,  34,  44,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 107, 101, 121, 119, 111, 114, 100, 115,  32,  61,  32, 123,  32,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  83,  84,  82,  73,  78,  71,  95,  76,  73,  84,  69,  82,  65,  76,  32,
   61,  32,  39,  94,  34,  91,  94,  34,  93,  42,  34,  39,  44,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  67,  72,
   65,  82,  95,  76,  73,  84,  69,  82,  65,  76,  32,  61,  32,  34,  94,  76,
   39,  46,  42,  39,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  72,  69,  88,  95,  76,  73,  84,  69,  82,
   65,  76,  32,  61,  32,  39,  94,  91,  37,  43,  37,  45,  93,  63,  37, 115,
   42,  48, 120,  91,  97,  45, 102,  65,  45,  70,  37, 100,  93,  43,  91,  85,
   76,  93,  42,  39,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  66,  73,  78,  95,  76,  73,  84,  69,  82,  65,
   76,  32,  61,  32,  39,  94,  91,  37,  43,  37,  45,  93,  63,  37, 115,  42,
   48,  98,  37, 100,  43,  91,  85,  76,  93,  42,  39,  44,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  79,  67,  84,
   95,  76,  73,  84,  69,  82,  65,  76,  32,  61,  32,  39,  94,  91,  37,  43,
   37,  45,  93,  63,  37, 115,  42,  48,  37, 100,  43,  91,  85,  76,  93,  42,
   39,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  70,  80,  78,  85,  77,  95,  76,  73,  84,  69,  82,  65,  76,
   32,  61,  32,  39,  94,  91,  37,  43,  37,  45,  93,  63,  37, 115,  42,  37,
  100,  43,  91,  37,  46,  93,  63,  37, 100,  42, 101,  91,  37,  43,  37,  45,
   93,  37, 100,  42,  39,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  78,  85,  77,  66,  69,  82,  95,  76,  73,
   84,  69,  82,  65,  76,  32,  61,  32,  39,  94,  91,  37,  43,  37,  45,  93,
   63,  37, 115,  42,  37, 100,  43,  91,  37,  46,  93,  63,  37, 100,  42,  91,
   85,  76,  93,  43,  39,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   44,  10, 125,  59,  10, 118,  97, 114,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  32, 112,  97, 114, 115, 101,  67,  73, 110, 116, 101, 103, 101, 114,  40,
  105, 110, 112, 117, 116,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  47,  47,  32, 112, 114, 105, 110, 116,  40,  39, 112,  97, 114, 115, 101,
   67,  73, 110, 116, 101, 103, 101, 114,  58, 105, 110, 112, 117, 116,  58,  39,
   32,  46,  46,  32, 105, 110, 112, 117, 116,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 118,  97, 114,  32, 111, 117, 116,  32,  61,  32, 123, 125,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 117, 110,  97,
  114, 121,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  40,
   32, 107,  44,  32, 118,  44,  32, 115, 116,  97, 114, 116,  44,  32, 101, 110,
  100,  95,  32, 105, 110,  32, 116, 111, 107, 101, 110, 105, 122, 101, 114,  40,
  105, 110, 112, 117, 116,  44,  32,  80,  82,  69,  95,  84,  79,  75,  69,  78,
   73,  90,  69,  95,  73,  78,  84,  69,  71,  69,  82,  41,  32,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 112, 114, 105, 110,
  116,  40,  39, 112,  97, 114, 115, 101,  67,  73, 110, 116, 101, 103, 101, 114,
   58,  39,  32,  46,  46,  32, 107,  32,  46,  46,  32,  34, 124,  34,  32,  46,
   46,  32, 118,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 105, 102,  40,  32, 107,  32,  61,  61,  32,  34,  67,
   72,  65,  82,  95,  76,  73,  84,  69,  82,  65,  76,  34,  32,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105,
  110, 115, 101, 114, 116,  40, 111, 117, 116,  44,  32, 116, 111, 115, 116, 114,
  105, 110, 103,  40, 115, 116, 114, 105, 110, 103,  46,  98, 121, 116, 101,  40,
  108, 111,  97, 100, 115, 116, 114, 105, 110, 103,  40,  34, 114, 101, 116, 117,
  114, 110,  32,  92,  34,  34,  32,  46,  46,  32, 118,  45,  62, 103, 115, 117,
   98,  40,  34,  94,  76,  37,  39,  40,  46,  43,  41,  37,  39,  34,  44,  32,
   34,  37,  49,  34,  41,  32,  46,  46,  32,  34,  92,  34,  34,  41,  40,  41,
   41,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 105, 102,  40,  32,
  107,  32,  61,  61,  32,  34,  72,  69,  88,  95,  76,  73,  84,  69,  82,  65,
   76,  34,  32,  41,  32, 123,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  117, 110,  97, 114, 121,  44,  32, 118,  32,  61,  32, 118,  45,  62, 109,  97,
  116,  99, 104,  40,  39,  40,  91,  37,  43,  37,  45,  93,  63,  41,  48, 120,
   40,  91,  97,  45, 102,  65,  45,  70,  37, 100,  93,  43,  41,  91,  85,  76,
   93,  42,  39,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32, 110,  32,  61,  32, 116, 111, 110, 117, 109,  98, 101, 114,  40, 118,
   44,  32,  49,  54,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116,
   97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40, 111, 117, 116,  44,
   32, 117, 110,  97, 114, 121,  46,  46, 116, 111, 115, 116, 114, 105, 110, 103,
   40, 110,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 105, 102,  40,
   32, 107,  32,  61,  61,  32,  34,  78,  85,  77,  66,  69,  82,  95,  76,  73,
   84,  69,  82,  65,  76,  34,  32,  41,  32, 123,  32,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 118,  32,  61,  32, 118,  45,  62, 109,  97, 116,  99, 104,
   40,  39,  40,  91,  94,  85,  76,  93,  43,  41,  91,  85,  76,  93,  43,  39,
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,
   46, 105, 110, 115, 101, 114, 116,  40, 111, 117, 116,  44,  32, 118,  41,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  32, 101, 108, 115, 101,  32, 105, 102,  40,  32, 107,  32,  61,  61,
   32,  34,  66,  73,  78,  95,  76,  73,  84,  69,  82,  65,  76,  34,  32,  41,
   32, 123,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 117, 110,  97, 114,
  121,  44,  32, 118,  32,  61,  32, 118,  45,  62, 109,  97, 116,  99, 104,  40,
   39,  40,  91,  37,  43,  37,  45,  93,  63,  41,  48,  98,  40,  91,  48,  49,
   93,  43,  41,  91,  85,  76,  93,  42,  39,  41,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 118,  97, 114,  32, 110,  32,  61,  32, 116, 111, 110, 117,
  109,  98, 101, 114,  40, 118,  44,  32,  50,  41,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,
   40, 111, 117, 116,  44,  32, 117, 110,  97, 114, 121,  46,  46, 116, 111, 115,
  116, 114, 105, 110, 103,  40, 110,  41,  41,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115,
  101,  32, 105, 102,  40,  32, 107,  32,  61,  61,  32,  34,  79,  67,  84,  95,
   76,  73,  84,  69,  82,  65,  76,  34,  32,  41,  32, 123,  32,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 117, 110,  97, 114, 121,  44,  32, 118,  32,  61,
   32, 118,  45,  62, 109,  97, 116,  99, 104,  40,  39,  40,  91,  37,  43,  37,
   45,  93,  63,  41,  40,  48,  37, 100,  43,  41,  91,  85,  76,  93,  42,  39,
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 110,
   32,  61,  32, 116, 111, 110, 117, 109,  98, 101, 114,  40, 118,  44,  32,  56,
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,
   46, 105, 110, 115, 101, 114, 116,  40, 111, 117, 116,  44,  32, 117, 110,  97,
  114, 121,  46,  46, 116, 111, 115, 116, 114, 105, 110, 103,  40, 110,  41,  41,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40,
  111, 117, 116,  44,  32, 105, 110, 112, 117, 116,  45,  62, 115, 117,  98,  40,
  115, 116,  97, 114, 116,  44,  32, 101, 110, 100,  95,  41,  41,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 118,  97, 114,  32, 115, 116, 114,  32,  61,  32, 116,  97,  98,
  108, 101,  46,  99, 111, 110,  99,  97, 116,  40, 111, 117, 116,  41,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 112, 114, 105, 110, 116,
   40,  39, 112,  97, 114, 115, 101,  67,  73, 110, 116, 101, 103, 101, 114,  58,
  114, 101, 115, 117, 108, 116,  58,  39,  46,  46, 115, 116, 114,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 115, 116,
  114,  59,  10, 125,  10,  10,  47,  47,  32, 115,  99, 114, 101, 101, 110, 101,
  114,  58,  32, 114, 101, 118, 109, 111,  99, 101,  32,  99, 111, 109, 109, 101,
  110, 116, 115,  44,  32, 116, 114, 105, 109,  44,  32, 109, 108,  32,  99, 111,
  110,  99,  97, 116,  46,  46,  46,  10,  47,  47,  32, 105, 116,  32, 111, 110,
  108, 121,  32, 115, 112, 108, 105, 116, 115,  32, 116, 111,  32,  99, 112, 112,
   32, 105, 110, 112, 117, 116,  32, 108, 105, 110, 101, 115,  32,  97, 110, 100,
   32, 114, 101, 109, 111, 118, 101, 115,  32,  99, 111, 109, 109, 101, 110, 116,
  115,  46,  32, 105, 116,  32, 100, 111, 101, 115,  32, 110, 111, 116,  32, 116,
  111, 107, 101, 110, 105, 122, 101,  46,  32,  10, 118,  97, 114,  32, 102, 117,
  110,  99, 116, 105, 111, 110,  32, 115,  99, 114, 101, 101, 110, 101, 114,  40,
  105, 110, 112, 117, 116,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 118,  97, 114,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32,  95, 115,
   99, 114, 101, 101, 110, 101, 114,  40, 105, 110, 112, 117, 116,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 110, 112, 117, 116,  32,  61,  32, 114, 101, 109, 111, 118, 101,  67,
  111, 109, 109, 101, 110, 116, 115,  40, 105, 110, 112, 117, 116,  41,  59,  10,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  47,  47,  32,  99, 111, 110,  99,  97, 116,  32, 109, 117, 108, 105, 116,
   45, 108, 105, 110, 101,  32, 105, 110, 112, 117, 116,  46,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,
   32,  99, 111, 117, 110, 116,  32,  61,  32,  49,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108,
  101,  40,  32,  99, 111, 117, 110, 116,  32,  62,  32,  48,  32,  41,  32, 123,
   32, 105, 110, 112, 117, 116,  44,  32,  99, 111, 117, 110, 116,  32,  61,  32,
  115, 116, 114, 105, 110, 103,  46, 103, 115, 117,  98,  40, 105, 110, 112, 117,
  116,  44,  32,  34,  94,  40,  46,  45,  41,  92,  92,  92, 110,  40,  46,  45,
   41,  36,  34,  44,  32,  34,  37,  49,  32,  37,  50,  92, 110,  34,  41,  59,
   32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32, 116, 114, 105, 109,  32,  97, 110, 100,  32,
  106, 111, 105, 110,  32,  98, 108, 111,  99, 107, 115,  32, 110, 111, 116,  32,
  115, 116,  97, 114, 116, 105, 110, 103,  32, 119, 105, 116, 104,  32,  34,  35,
   34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32,  98, 117, 102, 102, 101, 114,  32,  61,  32, 123,
  125,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 102, 111, 114,  40,  32, 108, 105, 110, 101,  32, 105, 110,  32,
  103, 115, 112, 108, 105, 116,  40, 105, 110, 112, 117, 116,  44,  32,  78,  69,
   87,  76,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47, 112, 114, 105, 110, 116,  40,  39, 110, 101, 119, 108, 105, 110, 101,
   58,  39,  46,  46, 108, 105, 110, 101,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 108, 105, 110, 101,  32,  61,  32, 116, 114, 105, 109,  40, 108, 105,
  110, 101,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,
   32,  35, 108, 105, 110, 101,  32,  62,  32,  48,  32,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  40,  32, 108, 105, 110, 101,  45,  62,  98, 121, 116, 101,  40,  49,  41,
   32,  61,  61,  32,  67,  77,  68,  95,  66,  89,  84,  69,  32,  41,  32, 123,
   32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 105, 110, 101,  32,  61,
   32, 108, 105, 110, 101,  45,  62, 103, 115, 117,  98,  40,  34,  35,  37, 115,
   42,  40,  46,  42,  41,  34,  44,  32,  34,  35,  37,  49,  34,  41,  59,  32,
   32,  32,  47,  47,  32, 114, 101, 109, 111, 118, 101,  32, 111, 112, 116, 105,
  110,  97, 108,  32, 119, 104, 105, 116, 101, 115, 112,  97,  99, 101, 115,  32,
   97, 102, 116, 101, 114,  32,  34,  35,  34,  46,  32, 114, 101, 100, 117,  99,
  101,  32, 116, 114, 105, 109, 105, 110, 103,  32, 108,  97, 116, 101, 114,  46,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,  35,  98, 117,
  102, 102, 101, 114,  32,  62,  32,  48,  32,  41,  32, 123,  32,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111,
  114, 111, 117, 116, 105, 110, 101,  46, 121, 105, 101, 108, 100,  40, 116,  97,
   98, 108, 101,  46,  99, 111, 110,  99,  97, 116,  40,  98, 117, 102, 102, 101,
  114,  44,  32,  78,  69,  87,  76,  41,  41,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 117, 102, 102, 101,
  114,  32,  61,  32, 123, 125,  59,  32,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 114, 111, 117,
  116, 105, 110, 101,  46, 121, 105, 101, 108, 100,  40, 108, 105, 110, 101,  41,
   59,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  40,  32, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  46,  70,  65,  83,  84,  32,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116,  97,
   98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40,  98, 117, 102, 102, 101,
  114,  44,  32, 108, 105, 110, 101,  41,  59,  32,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 114, 111,
  117, 116, 105, 110, 101,  46, 121, 105, 101, 108, 100,  40, 108, 105, 110, 101,
   41,  59,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 105,
  102,  40,  32,  33,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111,
  114,  46,  70,  65,  83,  84,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 114, 111, 117,
  116, 105, 110, 101,  46, 121, 105, 101, 108, 100,  40, 108, 105, 110, 101,  41,
   59,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  40,  32,  35,  98, 117, 102, 102, 101, 114,  32,  62,  32,  48,  32,  41,
   32, 123,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 114, 111,
  117, 116, 105, 110, 101,  46, 121, 105, 101, 108, 100,  40, 116,  97,  98, 108,
  101,  46,  99, 111, 110,  99,  97, 116,  40,  98, 117, 102, 102, 101, 114,  44,
   32,  78,  69,  87,  76,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101,
  116, 117, 114, 110,  32,  99, 111, 114, 111, 117, 116, 105, 110, 101,  46, 119,
  114,  97, 112,  40, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41,  32, 123,
   32,  95, 115,  99, 114, 101, 101, 110, 101, 114,  40, 105, 110, 112, 117, 116,
   41,  59,  32, 125,  41,  59,  10, 125,  10,  10,  47,  47,  32,  97, 112, 112,
  108, 121,  32,  99, 117, 114, 114, 101, 110, 116, 108, 121,  32, 107, 110, 111,
  119, 110,  32, 109,  97,  99, 114, 111, 115,  32, 116, 111,  32, 105, 110, 112,
  117, 116,  32,  40,  97, 110, 100,  32, 114, 101, 116, 117, 114, 110, 115,  32,
  105, 116,  41,  10, 118,  97, 114,  32,  80,  82,  69,  95,  84,  79,  75,  69,
   78,  73,  90,  69,  95,  65,  80,  80,  76,  89,  95,  77,  65,  67,  82,  79,
   32,  61,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 107, 101, 121,
  119, 111, 114, 100, 115,  32,  61,  32, 123,  32,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  68,  69,  70,  73,  78,
   69,  68,  32,  61,  32,  34,  94, 100, 101, 102, 105, 110, 101, 100,  37, 115,
   42,  37,  40,  37, 115,  42,  34,  46,  46,  73,  68,  69,  78,  84,  73,  70,
   73,  69,  82,  46,  46,  34,  37, 115,  42,  37,  41,  34,  32,  32,  32,  32,
   32,  32,  32,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  44,  10,
  125,  59,  10, 118,  97, 114,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32,
   97, 112, 112, 108, 121,  40, 115, 116,  97, 116, 101,  44,  32, 105, 110, 112,
  117, 116,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 119, 104,
  105, 108, 101,  40,  32, 116, 114, 117, 101,  32,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32, 111, 117, 116,  32,  61,  32, 123, 125,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,
  102, 117, 110,  99, 116, 105, 111, 110, 115,  32,  61,  32, 123, 125,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 101, 120, 112,  97, 110, 100,  59,  10,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,
   40,  32, 107,  44,  32, 118,  44,  32, 115, 116,  97, 114, 116,  44,  32, 101,
  110, 100,  95,  32, 105, 110,  32, 116, 111, 107, 101, 110, 105, 122, 101, 114,
   40, 105, 110, 112, 117, 116,  44,  32,  80,  82,  69,  95,  84,  79,  75,  69,
   78,  73,  90,  69,  95,  65,  80,  80,  76,  89,  95,  77,  65,  67,  82,  79,
   41,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32, 112, 114, 105, 110, 116,  40,  39, 116, 111, 107, 101, 110, 105, 122, 101,
   58,  39,  46,  46, 116, 111, 115, 116, 114, 105, 110, 103,  40, 107,  41,  46,
   46,  34, 124,  34,  46,  46, 116, 111, 115, 116, 114, 105, 110, 103,  40, 118,
   41,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 107,
   32,  61,  61,  32,  34, 105, 100, 101, 110, 116, 105, 102, 105, 101, 114,  34,
   32,  41,  32, 123,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 114, 101, 112, 108,  32,  61,
   32, 118,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 118,  97, 114,  32, 109,  97,  99, 114, 111,  32,  61,  32,
  115, 116,  97, 116, 101,  46, 100, 101, 102, 105, 110, 101, 115,  91, 118,  93,
   59,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 102,  40,  32, 109,  97,  99, 114, 111,  32,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 116, 121, 112,
  101,  40, 109,  97,  99, 114, 111,  41,  32,  32,  32,  32,  32,  61,  61,  32,
   34,  98, 111, 111, 108, 101,  97, 110,  34,  32,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101,
  112, 108,  32,  61,  32,  34,  34,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 120, 112,  97, 110, 100,  32,
   61,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  32, 101, 108, 115, 101,  32, 105, 102,  40,  32, 116, 121, 112, 101,  40,
  109,  97,  99, 114, 111,  41,  32,  61,  61,  32,  34, 115, 116, 114, 105, 110,
  103,  34,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 114, 101, 112, 108,  32,  61,  32, 109,  97,
   99, 114, 111,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 101, 120, 112,  97, 110, 100,  32,  61,  32,  40, 114,
  101, 112, 108,  32,  33,  61,  32, 118,  41,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 105, 102,  40,  32, 116, 121,
  112, 101,  40, 109,  97,  99, 114, 111,  41,  32,  61,  61,  32,  34, 110, 117,
  109,  98, 101, 114,  34,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 112, 108,  32,  61,
   32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 109,  97,  99, 114, 111,  41,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 101, 120, 112,  97, 110, 100,  32,  61,  32,  40, 114, 101, 112, 108,
   32,  33,  61,  32, 118,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  32, 101, 108, 115, 101,  32, 105, 102,  40,  32, 116, 121, 112, 101,  40,
  109,  97,  99, 114, 111,  41,  32,  61,  61,  32,  34, 102, 117, 110,  99, 116,
  105, 111, 110,  34,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 100, 101,  99,
  108,  44,  99, 110, 116,  32,  61,  32, 105, 110, 112, 117, 116,  45,  62, 115,
  117,  98,  40, 115, 116,  97, 114, 116,  41,  45,  62, 103, 115, 117,  98,  40,
   34,  94,  91,  95,  37,  97,  93,  91,  95,  37, 119,  93,  42,  37, 115,  42,
   37,  98,  40,  41,  34,  44,  32,  34,  37,  49,  34,  41,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32, 112, 114, 105, 110, 116,  40,  39, 109,  97, 116,  99, 104, 105, 110, 103,
   58,  39,  46,  46, 105, 110, 112, 117, 116,  46,  46,  34, 124,  34,  46,  46,
  100, 101,  99, 108,  46,  46,  34, 124,  34,  46,  46,  99, 110, 116,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  40,  32,  99, 110, 116,  32,  62,  32,  48,  32,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 112, 108,  32,  61,  32, 109,
   97,  99, 114, 111,  40, 100, 101,  99, 108,  41,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32, 112, 114, 105, 110, 116,  40,  34, 100,  38,
  114,  58,  34,  46,  46, 100, 101,  99, 108,  46,  46,  34, 124,  34,  46,  46,
  114, 101, 112, 108,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 120,
  112,  97, 110, 100,  32,  61,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101, 114,
  116,  40, 111, 117, 116,  44,  32, 114, 101, 112, 108,  41,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101,
  114, 116,  40, 111, 117, 116,  44,  32, 105, 110, 112, 117, 116,  45,  62, 115,
  117,  98,  40, 101, 110, 100,  95,  32,  43,  32,  35, 100, 101,  99, 108,  41,
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 102,  40,  32, 105, 110, 112, 117, 116,  45,  62, 115, 117,
   98,  40, 115, 116,  97, 114, 116,  41,  45,  62, 102, 105, 110, 100,  40,  34,
   94,  91,  95,  37,  97,  93,  91,  95,  37, 119,  93,  42,  37, 115,  42,  37,
   40,  34,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 116, 104,  97, 116,  32,
  105, 115,  32, 112,  97, 114, 116,  32, 111, 102,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  97, 108,  32, 109,  97,  99, 114, 111,  32, 100, 101,  99, 108,
   97, 114,  97, 116, 105, 111, 110,  46,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 112, 114, 105, 110,
  116,  40, 118,  32,  46,  46,  39,  58,  32,  99,  97, 110, 110, 111, 116,  32,
  114, 101, 112, 108,  97,  99, 101,  58,  60,  39,  46,  46, 105, 110, 112, 117,
  116,  46,  46,  39,  62,  32, 114, 101,  97, 100,  32, 109, 111, 114, 101,  32,
  108, 105, 110, 101,  39,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 105, 110,
  112, 117, 116,  44, 116, 114, 117, 101,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 111, 110,
   32, 109,  97,  99, 114, 111,  32, 110,  97, 109, 101,  32, 105, 115,  32,  97,
  108, 115, 111,  32, 117, 115, 101, 100,  32,  97, 115,  32, 116, 104, 101,  32,
  115, 121, 109,  98, 111, 108,  32, 111, 102,  32, 115, 111, 109, 101,  32,  67,
   32, 100, 101,  99, 108,  97, 114,  97, 116, 105, 111, 110,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   40, 101,  46, 103,  46,  32,  47, 117, 115, 114,  47, 105, 110,  99, 108, 117,
  100, 101,  47, 115, 112,  97, 119, 110,  46, 104,  44,  32,  47, 117, 115, 114,
   47, 105, 110,  99, 108, 117, 100, 101,  47, 115, 121, 115,  47, 115, 101, 108,
  101,  99, 116,  46, 104,  32, 111, 110,  32,  99, 101, 110, 116, 111, 115,  32,
   54,  46,  52,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32, 110, 111,  32, 110, 101, 101, 100,  32,
  116, 111,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,  46,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112,
  114, 105, 110, 116,  40, 118,  32,  46,  46,  32,  39,  58,  32, 109,  97,  99,
  114, 111,  32, 110,  97, 109, 101,  32,  98, 117, 116,  32, 117, 115, 101, 100,
   32,  97, 115,  32,  67,  32, 100, 101,  99, 108,  97, 114,  97, 116, 105, 111,
  110,  32, 105, 110,  58,  39,  32,  46,  46,  32, 105, 110, 112, 117, 116,  41,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46,
  105, 110, 115, 101, 114, 116,  40, 111, 117, 116,  44,  32, 114, 101, 112, 108,
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115,
  101,  32, 105, 102,  40,  32, 107,  32,  61,  61,  32,  34,  68,  69,  70,  73,
   78,  69,  68,  34,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105,
  110, 115, 101, 114, 116,  40, 111, 117, 116,  44,  32, 105, 110, 112, 117, 116,
   45,  62, 115, 117,  98,  40, 115, 116,  97, 114, 116,  44,  32, 101, 110, 100,
   95,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101,
  108, 115, 101,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101,
  114, 116,  40, 111, 117, 116,  44,  32, 105, 110, 112, 117, 116,  45,  62, 115,
  117,  98,  40, 115, 116,  97, 114, 116,  44,  32, 101, 110, 100,  95,  41,  41,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 110,
  112, 117, 116,  32,  61,  32, 116,  97,  98, 108, 101,  46,  99, 111, 110,  99,
   97, 116,  40, 111, 117, 116,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,  33,  32, 101,
  120, 112,  97, 110, 100,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32,  67,  32, 108, 105,  98, 101, 114,  97, 108,  32, 115, 116, 114, 105, 110,
  103,  32,  99, 111, 110,  99,  97, 116, 101, 110,  97, 116, 105, 111, 110,  44,
   32, 112, 114, 111,  99, 101, 115, 115, 105, 110, 103,  32,  85,  44,  76,  44,
   85,  76,  44,  76,  76,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101,
  116, 117, 114, 110,  32, 112,  97, 114, 115, 101,  67,  73, 110, 116, 101, 103,
  101, 114,  40,  99, 111, 110,  99,  97, 116,  83, 116, 114, 105, 110, 103,  76,
  105, 116, 101, 114,  97, 108,  40, 105, 110, 112, 117, 116,  41,  41,  44, 102,
   97, 108, 115, 101,  59,  10, 125,  10,  10,  47,  47,  32, 112, 114, 111,  99,
  101, 115, 115, 101, 115,  32,  97, 110,  32, 105, 110, 112, 117, 116,  32, 108,
  105, 110, 101,  46,  32,  99,  97, 108, 108, 101, 100,  32, 102, 114, 111, 109,
   32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32, 100, 111,
   87, 111, 114, 107,  32, 108, 111, 111, 112,  10, 118,  97, 114,  32, 102, 117,
  110,  99, 116, 105, 111, 110,  32, 112, 114, 111,  99, 101, 115, 115,  76, 105,
  110, 101,  40, 115, 116,  97, 116, 101,  44,  32, 108, 105, 110, 101,  41,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,  33,  32,
  108, 105, 110, 101,  32, 124, 124,  32,  35, 108, 105, 110, 101,  32,  61,  61,
   32,  48,  32,  41,  32, 123,  32, 114, 101, 116, 117, 114, 110,  32, 108, 105,
  110, 101,  59,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32,  99, 109, 100,  32,  61,  32, 110, 117, 108, 108,  59,  32,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 108, 105, 110, 101,  45,
   62,  98, 121, 116, 101,  40,  49,  41,  32,  61,  61,  32,  67,  77,  68,  95,
   66,  89,  84,  69,  32,  41,  32, 123,  32,  99, 109, 100,  32,  61,  32, 108,
  105, 110, 101,  45,  62, 115, 117,  98,  40,  50,  41,  59,  32, 125,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 112, 114, 105, 110, 116,  40,
   34, 112, 114, 111,  99, 101, 115, 115,  58,  34,  46,  46, 108, 105, 110, 101,
   41,  45,  45,  46,  46,  34, 124,  34,  46,  46, 116, 111, 115, 116, 114, 105,
  110, 103,  40, 115, 116,  97, 116, 101,  58, 115, 107, 105, 112,  40,  41,  41,
   41,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  47,  42,  32,  73,  70,
   47,  84,  72,  69,  78,  47,  69,  76,  83,  69,  32,  83,  84,  82,  85,  67,
   84,  85,  82,  65,  76,  32,  66,  76,  79,  67,  75,  83,  32,  42,  47,  47,
   47,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,  99, 109,
  100,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 105, 102, 100, 101, 102,  32,
   32,  32,  61,  32,  99, 109, 100,  45,  62, 109,  97, 116,  99, 104,  40,  73,
   70,  68,  69,  70,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 105, 102, 101, 120, 112,
   32,  32,  32,  61,  32,  99, 109, 100,  45,  62, 109,  97, 116,  99, 104,  40,
   73,  70,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 118,  97, 114,  32, 105, 102, 110, 100, 101, 102,  32,
   32,  61,  32,  99, 109, 100,  45,  62, 109,  97, 116,  99, 104,  40,  73,  70,
   78,  68,  69,  70,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 101, 108, 105, 102,  32,
   32,  32,  32,  61,  32,  99, 109, 100,  45,  62, 109,  97, 116,  99, 104,  40,
   69,  76,  73,  70,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 101, 108, 115, 101, 105,
  102,  95,  32,  61,  32,  99, 109, 100,  45,  62, 109,  97, 116,  99, 104,  40,
   69,  76,  83,  69,  73,  70,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 101, 108, 115,
  101,  95,  32,  32,  32,  61,  32,  99, 109, 100,  45,  62, 109,  97, 116,  99,
  104,  40,  69,  76,  83,  69,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 101, 110, 100,
  105, 102,  32,  32,  32,  61,  32,  99, 109, 100,  45,  62, 109,  97, 116,  99,
  104,  40,  69,  78,  68,  73,  70,  41,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 115, 116,
  114, 117,  99, 116,  32,  32,  61,  32, 105, 102, 100, 101, 102,  32, 124, 124,
   32, 105, 102, 101, 120, 112,  32, 124, 124,  32, 105, 102, 110, 100, 101, 102,
   32, 124, 124,  32, 101, 108, 105, 102,  32, 124, 124,  32, 101, 108, 115, 101,
  105, 102,  95,  32, 124, 124,  32, 101, 108, 115, 101,  95,  32, 124, 124,  32,
  101, 110, 100, 105, 102,  59,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 115, 116, 114, 117,
   99, 116,  32,  41,  32, 123,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 115, 107, 105, 112,  32,  61,  32, 115, 116,  97, 116, 101,
   45,  62, 115, 107, 105, 112,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  40,  32, 105, 102, 100, 101, 102,  32,  32,  32,  41,  32,
  123,  32, 115, 116,  97, 116, 101,  45,  62, 111, 112, 101, 110,  66, 108, 111,
   99, 107,  40, 115, 116,  97, 116, 101,  45,  62, 100, 101, 102, 105, 110, 101,
  100,  40, 105, 102, 100, 101, 102,  41,  41,  59,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 105, 102,  32,
  115, 107, 105, 112, 112, 101, 100,  44,  32, 105, 116,  32, 109,  97, 121,  32,
  104,  97, 118, 101,  32, 117, 110, 100, 101, 102, 105, 110, 101, 100,  32, 101,
  120, 112, 114, 101, 115, 115, 105, 111, 110,  46,  32, 115, 111,  32, 110, 111,
  116,  32, 112,  97, 114, 115, 101,  32, 116, 104, 101, 109,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 105, 102,  40,  32, 105, 102, 101, 120, 112,  32,  32,
   32,  41,  32, 123,  32, 115, 116,  97, 116, 101,  45,  62, 111, 112, 101, 110,
   66, 108, 111,  99, 107,  40, 115, 107, 105, 112,  32,  38,  38,  32, 116, 114,
  117, 101,  32, 124, 124,  32,  67,  66, 111, 111, 108, 101,  97, 110,  40, 115,
  116,  97, 116, 101,  45,  62, 112,  97, 114, 115, 101,  69, 120, 112, 114,  40,
  105, 102, 101, 120, 112,  41,  41,  41,  59,  32,  32,  32,  32, 125,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 105, 102, 110, 100, 101,
  102,  32,  32,  41,  32, 123,  32, 115, 116,  97, 116, 101,  45,  62, 111, 112,
  101, 110,  66, 108, 111,  99, 107,  40,  33,  32, 115, 116,  97, 116, 101,  45,
   62, 100, 101, 102, 105, 110, 101, 100,  40, 105, 102, 110, 100, 101, 102,  41,
   41,  59,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,
   32, 101, 108, 105, 102,  32,  32,  32,  32,  41,  32, 123,  32, 115, 116,  97,
  116, 101,  45,  62, 101, 108, 115, 101,  66, 108, 111,  99, 107,  40,  40, 115,
  107, 105, 112,  32,  38,  38,  32, 115, 107, 105, 112,  32,  60,  32,  35, 115,
  116,  97, 116, 101,  46, 115, 116,  97,  99, 107,  41,  32,  38,  38,  32, 116,
  114, 117, 101,  32, 124, 124,  32,  67,  66, 111, 111, 108, 101,  97, 110,  40,
  115, 116,  97, 116, 101,  45,  62, 112,  97, 114, 115, 101,  69, 120, 112, 114,
   40, 101, 108, 105, 102,  41,  41,  41,  59,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 101, 108, 115, 101,
  105, 102,  95,  32,  41,  32, 123,  32, 115, 116,  97, 116, 101,  45,  62, 101,
  108, 115, 101,  66, 108, 111,  99, 107,  40,  40, 115, 107, 105, 112,  32,  38,
   38,  32, 115, 107, 105, 112,  32,  60,  32,  35, 115, 116,  97, 116, 101,  46,
  115, 116,  97,  99, 107,  41,  32,  38,  38,  32, 116, 114, 117, 101,  32, 124,
  124,  32,  67,  66, 111, 111, 108, 101,  97, 110,  40, 115, 116,  97, 116, 101,
   45,  62, 112,  97, 114, 115, 101,  69, 120, 112, 114,  40, 101, 108, 115, 101,
  105, 102,  95,  41,  41,  41,  59,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 102,  40,  32, 101, 108, 115, 101,  95,  32,  32,  32,  41,
   32, 123,  32, 115, 116,  97, 116, 101,  45,  62, 101, 108, 115, 101,  66, 108,
  111,  99, 107,  40, 116, 114, 117, 101,  41,  59,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 101, 110,
  100, 105, 102,  32,  32,  32,  41,  32, 123,  32, 115, 116,  97, 116, 101,  45,
   62,  99, 108, 111, 115, 101,  66, 108, 111,  99, 107,  40,  41,  59,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 114, 101, 116, 117, 114, 110,  59,  32,  47,  47,  32, 114, 101, 109, 111,
  118, 101,  32, 115, 116, 114, 117,  99, 116, 117, 114,  97, 108,  32, 100, 105,
  114, 101,  99, 116, 105, 118, 101, 115,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  10,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  47,
   42,  32,  83,  75,  73,  80,  80,  73,  78,  71,  32,  42,  47,  47,  47,  32,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 115, 116,  97,
  116, 101,  45,  62, 115, 107, 105, 112,  40,  41,  32,  41,  32, 123,  32,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32, 112, 114, 105, 110, 116,  40,  39, 115, 107, 105, 112,  58,  39,
   32,  46,  46,  32, 108, 105, 110, 101,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   59,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  10,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  47,  42,  32,  82,  69,  65,  68,  32,  78,
   69,  87,  32,  68,  73,  82,  69,  67,  84,  73,  86,  69,  83,  32,  42,  47,
   47,  47,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,  99,
  109, 100,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 104,  97, 110, 100, 108, 101,
   32,  35, 117, 110, 100, 101, 102,  32,  46,  46,  46,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,
  107, 101, 121,  32,  61,  32,  99, 109, 100,  45,  62, 109,  97, 116,  99, 104,
   40,  85,  78,  68,  69,  70,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 116, 121, 112,
  101,  40, 107, 101, 121,  41,  32,  61,  61,  32,  34, 115, 116, 114, 105, 110,
  103,  34,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115,
  116,  97, 116, 101,  45,  62, 117, 110, 100, 101, 102, 105, 110, 101,  40, 107,
  101, 121,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116,
  117, 114, 110,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 114, 101,  97, 100,  32,
   34,  35, 100, 101, 102, 105, 110, 101,  32,  62,  70, 111, 111,  66,  97, 114,
   46,  46,  46,  60,  34,  32, 100, 105, 114, 101,  99, 116, 105, 118, 101, 115,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  40,  32,  99, 109, 100,  45,  62, 109,  97, 116,  99, 104,  40,
   68,  69,  70,  73,  78,  69,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 118,  97, 114,  32, 100, 101, 102, 105, 110, 101,  32,  61,
   32, 116, 114, 105, 109,  40,  99, 109, 100,  45,  62, 115, 117,  98,  40,  68,
   69,  70,  73,  78,  69,  45,  62, 108, 101, 110,  40,  41,  43,  49,  41,  41,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 109,  97,
   99, 114, 111, 110,  97, 109, 101,  44,  32, 114, 101, 112, 108,  97,  99, 101,
  109, 101, 110, 116,  59,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,
   47,  32, 115, 105, 109, 112, 108, 101,  32,  34, 116, 114, 117, 101,  34,  32,
  100, 101, 102, 105, 110, 101, 115,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  109,  97,  99, 114, 111, 110,  97, 109, 101,  32,  61,  32, 100, 101, 102, 105,
  110, 101,  45,  62, 109,  97, 116,  99, 104,  40,  84,  82,  85,  69,  77,  65,
   67,  82,  79,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,
   40,  32, 109,  97,  99, 114, 111, 110,  97, 109, 101,  32,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  115, 116,  97, 116, 101,  45,  62, 100, 101, 102, 105, 110, 101,  40, 109,  97,
   99, 114, 111, 110,  97, 109, 101,  44,  32, 116, 114, 117, 101,  41,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,
   10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 114, 101, 112,
  108,  97,  99, 101,  32, 109,  97,  99, 114, 111,  32, 100, 101, 102, 105, 110,
  101, 115,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 109,  97,  99, 114, 111,
  110,  97, 109, 101,  44,  32, 114, 101, 112, 108,  97,  99, 101, 109, 101, 110,
  116,  32,  61,  32, 100, 101, 102, 105, 110, 101,  45,  62, 109,  97, 116,  99,
  104,  40,  82,  69,  80,  76,  77,  65,  67,  82,  79,  41,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 109,  97,  99, 114, 111, 110,
   97, 109, 101,  32,  38,  38,  32, 114, 101, 112, 108,  97,  99, 101, 109, 101,
  110, 116,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,  45,  62, 100, 101,
  102, 105, 110, 101,  40, 109,  97,  99, 114, 111, 110,  97, 109, 101,  44,  32,
  114, 101, 112, 108,  97,  99, 101, 109, 101, 110, 116,  41,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 114, 101,  97, 100,  32,
  102, 117, 110,  99, 116, 105, 111, 110,  97, 108,  32, 109,  97,  99, 114, 111,
  115,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 109,  97,  99, 114, 111, 110,
   97, 109, 101,  44,  32, 114, 101, 112, 108,  97,  99, 101, 109, 101, 110, 116,
   44,  32, 115, 111, 117, 114,  99, 101,  32,  61,  32, 115, 116,  97, 116, 101,
   45,  62, 112,  97, 114, 115, 101,  70, 117, 110,  99, 116, 105, 111, 110,  40,
  100, 101, 102, 105, 110, 101,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  40,  32, 109,  97,  99, 114, 111, 110,  97, 109, 101,  32,  38,
   38,  32, 114, 101, 112, 108,  97,  99, 101, 109, 101, 110, 116,  32,  41,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  47,  47,  32,  97, 100, 100,  32, 111, 114, 105, 103, 105, 110,  97,
  108,  32, 116, 101, 120, 116,  32, 102, 111, 114,  32, 100, 101, 102, 105, 110,
  105, 116, 105, 111, 110,  32, 116, 111,  32,  99, 104, 101,  99, 107,  32, 105,
  100, 101, 110, 116, 105, 102, 121,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,  45,  62, 100,
  101, 102, 105, 110, 101,  40, 109,  97,  99, 114, 111, 110,  97, 109, 101,  44,
   32, 114, 101, 112, 108,  97,  99, 101, 109, 101, 110, 116,  44,  32, 102,  97,
  108, 115, 101,  44,  32, 115, 111, 117, 114,  99, 101,  41,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  47,  47,  32, 104,  97, 110, 100, 108, 101,  32,  35, 105, 110,  99, 108,
  117, 100, 101,  32,  46,  46,  46,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 102, 105, 108, 101,
  110,  97, 109, 101,  32,  61,  32,  99, 109, 100,  45,  62, 109,  97, 116,  99,
  104,  40,  73,  78,  67,  76,  85,  68,  69,  41,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,
  102, 105, 108, 101, 110,  97, 109, 101,  32,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 115, 116,  97, 116,
  101,  45,  62, 105, 110,  99, 108, 117, 100, 101,  70, 105, 108, 101,  40, 102,
  105, 108, 101, 110,  97, 109, 101,  41,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 105, 108, 101,
  110,  97, 109, 101,  32,  61,  32,  99, 109, 100,  45,  62, 109,  97, 116,  99,
  104,  40,  76,  79,  67,  65,  76,  95,  73,  78,  67,  76,  85,  68,  69,  41,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  40,  32, 102, 105, 108, 101, 110,  97, 109, 101,  32,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114,
  110,  32, 115, 116,  97, 116, 101,  45,  62, 105, 110,  99, 108, 117, 100, 101,
   70, 105, 108, 101,  40, 102, 105, 108, 101, 110,  97, 109, 101,  44,  32, 102,
   97, 108, 115, 101,  44,  32, 116, 114, 117, 101,  41,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102,
  105, 108, 101, 110,  97, 109, 101,  32,  61,  32,  99, 109, 100,  45,  62, 109,
   97, 116,  99, 104,  40,  73,  78,  67,  76,  85,  68,  69,  95,  78,  69,  88,
   84,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  40,  32, 102, 105, 108, 101, 110,  97, 109, 101,
   32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47, 112, 114, 105, 110, 116,  40,  34, 105, 110,
   99, 108, 117, 100, 101,  95, 110, 101, 120, 116,  58,  34,  46,  46, 102, 105,
  108, 101, 110,  97, 109, 101,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  32, 115, 116,  97, 116, 101,  45,  62, 105, 110,
   99, 108, 117, 100, 101,  70, 105, 108, 101,  40, 102, 105, 108, 101, 110,  97,
  109, 101,  44,  32, 116, 114, 117, 101,  41,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32, 105, 103, 110, 111, 114, 101,  44,  32,  98, 101,  99,  97, 117, 115, 101,
   32, 119, 101,  32, 100, 111, 110, 116,  32, 104,  97, 118, 101,  32,  97, 110,
  121,  32, 112, 114,  97, 103, 109,  97,  32, 100, 105, 114, 101,  99, 116, 105,
  118, 101, 115,  32, 121, 101, 116,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,  99, 109, 100,  45,
   62, 109,  97, 116,  99, 104,  40,  80,  82,  65,  71,  77,  65,  41,  32,  41,
   32, 123,  32, 114, 101, 116, 117, 114, 110,  59,  32, 125,  10,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32, 104,  97, 110, 100, 108, 101,  32,  35, 101, 114, 114, 111, 114,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32, 101, 114, 114,  77, 115, 103,  32,  61,  32,  99, 109, 100,  45,
   62, 109,  97, 116,  99, 104,  40,  69,  82,  82,  79,  82,  41,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32, 101, 114, 114,  78, 111,  84, 120, 116,  32,  61,  32,  99, 109,
  100,  45,  62, 109,  97, 116,  99, 104,  40,  69,  82,  82,  79,  82,  95,  78,
   79,  84,  69,  88,  84,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 119,  97, 114, 110,
   77, 115, 103,  32,  61,  32,  99, 109, 100,  45,  62, 109,  97, 116,  99, 104,
   40,  87,  65,  82,  78,  73,  78,  71,  41,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 101,
  114, 114,  77, 115, 103,  32,  41,  32, 123,  32, 101, 114, 114, 111, 114,  40,
  101, 114, 114,  77, 115, 103,  41,  59,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 101,
  114, 114,  78, 111,  84, 120, 116,  32,  41,  32, 123,  32, 101, 114, 114, 111,
  114,  40,  34,  60,  69,  82,  82,  79,  82,  32,  77,  69,  83,  83,  65,  71,
   69,  32,  78,  79,  84,  32,  83,  69,  84,  62,  34,  41,  59,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  40,  32, 119,  97, 114, 110,  77, 115, 103,  32,  41,  32, 123,  32,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40, 119,
   97, 114, 110,  77, 115, 103,  41,  59,  32,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 114, 101, 116, 117, 114, 110,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   97,  98, 111, 114, 116,  32, 111, 110,  32, 117, 110, 107, 110, 111, 119, 110,
   32, 107, 101, 121, 119, 111, 114, 100, 115,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114,  40,
   34, 117, 110, 107, 110, 111, 119, 110,  32, 100, 105, 114, 101,  99, 116, 105,
  118, 101,  58,  32,  34,  46,  46, 108, 105, 110, 101,  41,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  40,  32, 115, 116,  97, 116, 101,  46, 105, 110,  99, 111, 109,
  112, 108, 101, 116, 101,  76, 105, 110, 101,  32,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
  112, 114, 105, 110, 116,  40,  39, 109, 101, 114, 103, 101,  32, 119, 105, 116,
  104,  32, 105, 110,  99, 111, 109, 112, 108, 101, 116, 101,  76, 105, 110, 101,
   58,  39,  46,  46, 115, 116,  97, 116, 101,  46, 105, 110,  99, 111, 109, 112,
  108, 101, 116, 101,  76, 105, 110, 101,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 105, 110, 101,  32,  61,
   32,  40, 115, 116,  97, 116, 101,  46, 105, 110,  99, 111, 109, 112, 108, 101,
  116, 101,  76, 105, 110, 101,  32,  46,  46,  32, 108, 105, 110, 101,  41,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 115, 116,  97, 116, 101,  46, 105, 110,  99, 111, 109, 112, 108, 101, 116,
  101,  76, 105, 110, 101,  32,  61,  32, 110, 117, 108, 108,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  10,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  47,  42,  32,  65,  80,  80,  76,  89,  32,  77,  65,  67,  82,  79,
   83,  32,  42,  47,  47,  47,  10,  32,  32,  32,  32,  32,  32,  32,  32,  47,
   47,  32, 112, 114, 105, 110, 116,  40, 108, 105, 110, 101,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  95, 108, 105, 110, 101,  44,
  109, 111, 114, 101,  32,  61,  32, 115, 116,  97, 116, 101,  45,  62,  97, 112,
  112, 108, 121,  40, 108, 105, 110, 101,  41,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  47,  47,  32, 112, 114, 105, 110, 116,  40,  39, 101, 110, 100,
  112, 114, 111,  99, 101, 115, 115,  58,  39,  46,  46,  95, 108, 105, 110, 101,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 109, 111,
  114, 101,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,  46, 105, 110,  99,
  111, 109, 112, 108, 101, 116, 101,  76, 105, 110, 101,  32,  61,  32, 108, 105,
  110, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  34,  34,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  32,  95, 108, 105, 110, 101,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 114, 101, 116, 117, 114, 110,  32, 108, 105, 110, 101,  59,  10, 125,  10,
   10, 118,  97, 114,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32, 100, 111,
   87, 111, 114, 107,  40, 115, 116,  97, 116, 101,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  32,  95, 100, 111,  87, 111, 114, 107,  40, 115, 116,  97, 116, 101,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  40,  32,  33,  32, 115, 116,  97, 116, 101,  45,
   62, 100, 101, 102, 105, 110, 101, 100,  40,  70,  73,  76,  69,  41,  32,  41,
   32, 123,  32, 115, 116,  97, 116, 101,  45,  62, 100, 101, 102, 105, 110, 101,
   40,  70,  73,  76,  69,  44,  32,  34,  60,  85,  83,  69,  82,  95,  67,  72,
   85,  78,  75,  62,  34,  44,  32, 116, 114, 117, 101,  41,  59,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 111, 108, 100,  73, 110, 100, 101, 110, 116,  32,  61,  32,
  115, 116,  97, 116, 101,  45,  62, 103, 101, 116,  73, 110, 100, 101, 110, 116,
   40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 119, 104, 105, 108, 101,  40,  32, 116, 114, 117, 101,  32,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,
  105, 110, 112, 117, 116,  32,  61,  32, 115, 116,  97, 116, 101,  45,  62, 103,
  101, 116,  76, 105, 110, 101,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  40,  32,  33,  32, 105, 110, 112, 117, 116,  32,  41,  32,
  123,  32,  98, 114, 101,  97, 107,  59,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 118,  97, 114,  32, 111, 117, 116, 112, 117, 116,  32,  61,  32,
  112, 114, 111,  99, 101, 115, 115,  76, 105, 110, 101,  40, 115, 116,  97, 116,
  101,  44,  32, 105, 110, 112, 117, 116,  41,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 102,  40,  32,  33,  32, 112, 114, 101, 112, 114, 111,  99,
  101, 115, 115, 111, 114,  46,  70,  65,  83,  84,  32,  38,  38,  32,  33,  32,
  111, 117, 116, 112, 117, 116,  32,  41,  32, 123,  32, 111, 117, 116, 112, 117,
  116,  32,  61,  32,  34,  34,  59,  32, 125,  32,  47,  47,  32, 111, 117, 116,
  112, 117, 116,  32, 101, 109, 112, 116, 121,  32, 115, 107, 105, 112, 112, 101,
  100,  32, 108, 105, 110, 101, 115,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  40,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,
   46,  68,  69,  66,  85,  71,  32,  41,  32, 123,  32, 111, 117, 116, 112, 117,
  116,  32,  61,  32, 111, 117, 116, 112, 117, 116,  46,  46,  34,  32,  45,  45,
   32,  34,  46,  46, 105, 110, 112, 117, 116,  59,  32, 125,  32,  47,  47,  32,
  105, 110, 112, 117, 116,  32,  97, 115,  32,  99, 111, 109, 109, 101, 110, 116,
   32, 119, 104, 101, 110,  32,  68,  69,  66,  85,  71,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  40,  32, 111, 117, 116, 112, 117, 116,  32,  41,
   32, 123,  32,  99, 111, 114, 111, 117, 116, 105, 110, 101,  46, 121, 105, 101,
  108, 100,  40, 111, 117, 116, 112, 117, 116,  41,  59,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  40,  32,  40, 111, 108, 100,  73, 110, 100, 101, 110, 116,  32,  33,
   61,  32, 115, 116,  97, 116, 101,  45,  62, 103, 101, 116,  73, 110, 100, 101,
  110, 116,  40,  41,  41,  32,  41,  32, 123,  32, 101, 114, 114, 111, 114,  40,
   34, 105, 110, 100, 101, 110, 116,  97, 116, 105, 111, 110,  32, 108, 101, 118,
  101, 108,  32, 109, 117, 115, 116,  32,  98, 101,  32,  98,  97, 108,  97, 110,
   99, 101, 100,  32, 119, 105, 116, 104, 105, 110,  32,  97,  32, 102, 105, 108,
  101,  46,  32, 119,  97, 115,  58,  34,  46,  46, 111, 108, 100,  73, 110, 100,
  101, 110, 116,  46,  46,  34,  32, 105, 115,  58,  34,  46,  46, 115, 116,  97,
  116, 101,  45,  62, 103, 101, 116,  73, 110, 100, 101, 110, 116,  40,  41,  41,
   59,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  99, 111, 114,
  111, 117, 116, 105, 110, 101,  46, 119, 114,  97, 112,  40, 102, 117, 110,  99,
  116, 105, 111, 110,  40,  41,  32, 123,  32,  95, 100, 111,  87, 111, 114, 107,
   40, 115, 116,  97, 116, 101,  41,  59,  32, 125,  41,  59,  10, 125,  10,  10,
  118,  97, 114,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32, 105, 110,  99,
  108, 117, 100, 101,  70, 105, 108, 101,  40, 115, 116,  97, 116, 101,  44,  32,
  102, 105, 108, 101, 110,  97, 109, 101,  44,  32, 110, 101, 120, 116,  44,  32,
   95, 108, 111,  99,  97, 108,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32, 114, 101, 115, 117, 108, 116,  44,  32, 114, 101,
  115, 117, 108, 116,  95, 115, 116,  97, 116, 101,  32,  61,  32, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  46,  99, 111, 109, 112, 105, 108,
  101,  70, 105, 108, 101,  40, 102, 105, 108, 101, 110,  97, 109, 101,  44,  32,
  115, 116,  97, 116, 101,  46, 100, 101, 102, 105, 110, 101, 115,  44,  32, 115,
  116,  97, 116, 101,  46, 109,  97,  99, 114, 111,  95, 115, 111, 117, 114,  99,
  101, 115,  44,  32, 110, 101, 120, 116,  44,  32,  95, 108, 111,  99,  97, 108,
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 110, 111,
  119,  44,  32, 119, 101,  32, 116,  97, 107, 101,  32, 116, 104, 101,  32, 100,
  101, 102, 105, 110, 101,  32, 116,  97,  98, 108, 101,  32, 111, 102,  32, 116,
  104, 101,  32, 115, 117,  98,  32, 102, 105, 108, 101,  32, 102, 111, 114,  32,
  102, 117, 114, 116, 104, 101, 114,  32, 112, 114, 111,  99, 101, 115, 115, 105,
  110, 103,  10,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,
   46, 100, 101, 102, 105, 110, 101, 115,  32,  61,  32, 114, 101, 115, 117, 108,
  116,  95, 115, 116,  97, 116, 101,  46, 100, 101, 102, 105, 110, 101, 115,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  97, 110, 100,  32,
  114, 101, 116, 117, 114, 110,  32, 116, 104, 101,  32,  99, 111, 109, 112, 105,
  108, 101, 100,  32, 114, 101, 115, 117, 108, 116,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 114, 101, 115, 117, 108, 116,
   59,  10, 125,  10,  10,  47,  47,  32, 115, 101, 116, 115,  32,  97,  32, 103,
  108, 111,  98,  97, 108,  32, 100, 101, 102, 105, 110, 101,  10, 118,  97, 114,
   32, 102, 117, 110,  99, 116, 105, 111, 110,  32, 100, 101, 102, 105, 110, 101,
   40, 115, 116,  97, 116, 101,  44,  32, 107, 101, 121,  44,  32, 118,  97, 108,
  117, 101,  44,  32, 111, 118, 101, 114, 114, 105, 100, 101,  44,  32, 109,  97,
   99, 114, 111,  95, 115, 111, 117, 114,  99, 101,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  47,  47, 112, 114, 105, 110, 116,  40,  34, 100,
  101, 102, 105, 110, 101,  58,  34,  46,  46, 107, 101, 121,  46,  46,  34,  32,
  116, 121, 112, 101,  58,  34,  46,  46, 116, 111, 115, 116, 114, 105, 110, 103,
   40, 118,  97, 108, 117, 101,  41,  46,  46,  34,  32, 118,  97, 108, 117, 101,
   58,  34,  46,  46, 116, 111, 115, 116, 114, 105, 110, 103,  40, 112, 118,  97,
  108,  41,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,
  118,  97, 108, 117, 101,  32,  38,  38,  32,  33,  32, 111, 118, 101, 114, 114,
  105, 100, 101,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 116, 121, 112, 101,
   40, 118,  97, 108, 117, 101,  41,  32,  61,  61,  32,  39, 102, 117, 110,  99,
  116, 105, 111, 110,  39,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  97, 115, 115, 101, 114, 116,  40, 109,  97,  99, 114, 111,  95, 115,
  111, 117, 114,  99, 101,  44,  32,  34, 109,  97,  99, 114, 111,  32, 115, 111,
  117, 114,  99, 101,  32, 115, 104, 111, 117, 108, 100,  32, 115, 112, 101,  99,
  105, 102, 121,  32, 116, 111,  32,  99, 104, 101,  99, 107,  32, 105, 100, 101,
  110, 116, 105, 116, 121,  34,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 118,  97, 114,  32, 112, 118,  97, 108,  32,  61,  32, 115, 116,  97, 116,
  101,  46, 109,  97,  99, 114, 111,  95, 115, 111, 117, 114,  99, 101, 115,  91,
  107, 101, 121,  93,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,
   40,  32, 112, 118,  97, 108,  32,  38,  38,  32,  40, 112, 118,  97, 108,  32,
   33,  61,  32, 109,  97,  99, 114, 111,  95, 115, 111, 117, 114,  99, 101,  41,
   32,  41,  32, 123,  32, 101, 114, 114, 111, 114,  40,  34,  97, 108, 114, 101,
   97, 100, 121,  32, 100, 101, 102, 105, 110, 101, 100,  58,  32,  34,  46,  46,
  107, 101, 121,  41,  59,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  115, 116,  97, 116, 101,  46, 109,  97,  99, 114, 111,  95, 115, 111, 117, 114,
   99, 101, 115,  91, 107, 101, 121,  93,  32,  61,  32, 109,  97,  99, 114, 111,
   95, 115, 111, 117, 114,  99, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 112, 118,
   97, 108,  32,  61,  32, 115, 116,  97, 116, 101,  46, 100, 101, 102, 105, 110,
  101, 115,  91, 107, 101, 121,  93,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  40,  32, 112, 118,  97, 108,  32,  38,  38,  32,  40, 112, 118,
   97, 108,  32,  33,  61,  32, 118,  97, 108, 117, 101,  41,  32,  41,  32, 123,
   32, 101, 114, 114, 111, 114,  40,  34,  97, 108, 114, 101,  97, 100, 121,  32,
  100, 101, 102, 105, 110, 101, 100,  58,  32,  34,  46,  46, 107, 101, 121,  41,
   59,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,  46, 100, 101,
  102, 105, 110, 101, 115,  91, 107, 101, 121,  93,  32,  61,  32, 115, 116,  97,
  116, 101,  45,  62, 112, 114, 101, 112,  97, 114, 101,  77,  97,  99, 114, 111,
   40, 118,  97, 108, 117, 101,  41,  59,  10, 125,  10,  10,  47,  47,  32, 112,
   97, 114, 115, 101, 115,  32,  67,  80,  80,  32, 101, 120, 114, 101, 115, 115,
  105, 111, 110, 115,  10,  47,  47,  32, 105,  46, 101,  46,  58,  32,  35, 105,
  102,  32,  33, 100, 101, 102, 105, 110, 101, 100,  40,  95,  85,  78,  73,  67,
   79,  68,  69,  41,  32,  38,  38,  32,  33, 100, 101, 102, 105, 110, 101, 100,
   40,  85,  78,  73,  67,  79,  68,  69,  41,  10,  47,  47,  10,  47,  47,  66,
   78,  70,  58,  10,  47,  47,  32,  32,  69,  88,  80,  82,  32,  32,  32,  32,
   32,  45,  62,  32,  40,  66,  82,  65,  67,  75,  69,  84,  95,  79,  80,  69,
   78,  41,  40,  69,  88,  80,  82,  41,  40,  66,  82,  65,  67,  75,  69,  84,
   95,  67,  76,  79,  83,  69,  41,  10,  47,  47,  32,  32,  69,  88,  80,  82,
   32,  32,  32,  32,  32,  45,  62,  32,  40,  69,  88,  80,  82,  41,  40,  79,
   82,  41,  40,  69,  88,  80,  82,  41,  10,  47,  47,  32,  32,  69,  88,  80,
   82,  32,  32,  32,  32,  32,  45,  62,  32,  40,  69,  88,  80,  82,  41,  40,
   65,  78,  68,  41,  40,  69,  88,  80,  82,  41,  10,  47,  47,  32,  32,  69,
   88,  80,  82,  32,  32,  32,  32,  32,  45,  62,  32,  40,  78,  79,  84,  41,
   40,  69,  88,  80,  82,  41,  10,  47,  47,  32,  32,  69,  88,  80,  82,  32,
   32,  32,  32,  32,  45,  62,  32,  40,  70,  85,  78,  67,  84,  73,  79,  78,
   41,  10,  47,  47,  32,  32,  70,  85,  78,  67,  84,  73,  79,  78,  32,  45,
   62,  32,  40,  73,  68,  69,  78,  84,  73,  70,  73,  69,  82,  41,  40,  66,
   82,  65,  67,  75,  69,  84,  95,  79,  80,  69,  78,  41,  40,  65,  82,  71,
   83,  41,  40,  66,  82,  65,  67,  75,  69,  84,  95,  67,  76,  79,  83,  69,
   41,  10,  47,  47,  32,  32,  65,  82,  71,  83,  32,  32,  32,  32,  32,  45,
   62,  32,  40,  40,  73,  68,  69,  78,  84,  73,  70,  73,  69,  82,  41,  91,
   40,  67,  79,  77,  77,  65,  41,  40,  73,  68,  69,  78,  84,  73,  70,  73,
   69,  82,  41,  93,  41,  63,  10,  47,  47,  76,  69,  65,  86,  69,  83,  58,
   10,  47,  47,  32,  32,  73,  71,  78,  79,  82,  69,  32,  45,  62,  32,  34,
   32,  92, 116,  34,  10,  47,  47,  32,  32,  66,  82,  65,  67,  75,  69,  84,
   95,  79,  80,  69,  78,  32,  32,  45,  62,  32,  34,  40,  34,  10,  47,  47,
   32,  32,  66,  82,  65,  67,  75,  69,  84,  95,  67,  76,  79,  83,  69,  32,
   45,  62,  32,  34,  41,  34,  10,  47,  47,  32,  32,  79,  82,  32,  45,  62,
   32,  34, 124, 124,  34,  10,  47,  47,  32,  32,  65,  78,  68,  32,  45,  62,
   32,  34,  38,  38,  34,  10,  47,  47,  32,  32,  78,  79,  84,  32,  45,  62,
   32,  34,  33,  34,  10,  47,  47,  32,  32,  73,  68,  69,  78,  84,  73,  70,
   73,  69,  82,  32,  45,  62,  32,  34,  91,  48,  45,  57,  97,  45, 122,  65,
   45,  90,  95,  93,  34,  10,  47,  47,  10,  10, 118,  97, 114,  32,  80,  82,
   69,  95,  84,  79,  75,  69,  78,  73,  90,  69,  95,  77,  65,  67,  82,  79,
   32,  61,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116, 114,
  105, 110, 103,  32,  61,  32, 116, 114, 117, 101,  44,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 107, 101, 121, 119, 111, 114, 100, 115,  95, 111, 114, 100,
  101, 114,  32,  61,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  34,  67,  79,  78,  67,  65,  84,  34,  44,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  34,  83,  80,  65,  67,  69,  34,  44,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32, 107, 101, 121,
  119, 111, 114, 100, 115,  32,  61,  32, 123,  32,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  67,  79,  78,  67,  65,
   84,  32,  61,  32,  34,  94,  37, 115,  42,  35,  35,  37, 115,  42,  34,  44,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  83,  80,  65,  67,  69,  32,  61,  32,  34,  94,  37, 115,  34,  44,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  44,  10, 125,  59,  10, 118,  97,
  114,  32,  80,  82,  69,  95,  84,  79,  75,  69,  78,  73,  90,  69,  95,  77,
   65,  67,  82,  79,  95,  65,  82,  71,  83,  32,  61,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 115, 116, 114, 105, 110, 103,  32,  61,  32, 116,
  114, 117, 101,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32, 107, 101, 121,
  119, 111, 114, 100, 115,  95, 111, 114, 100, 101, 114,  32,  61,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   34,  83,  84,  82,  73,  78,  71,  95,  76,  73,  84,  69,  82,  65,  76,  34,
   44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  34,  80,  65,  82,  69,  78,  84,  72,  69,  83,  69,  34,  44,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   34,  70,  85,  78,  67,  84,  73,  79,  78,  65,  76,  34,  44,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  65,
   82,  71,  83,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  34,  83,  73,  78,  71,  76,  69,  95,  67,  72,
   65,  82,  65,  67,  84,  69,  82,  95,  65,  82,  71,  83,  34,  44,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,
   67,  79,  77,  77,  65,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32, 107, 101, 121, 119, 111,
  114, 100, 115,  32,  61,  32, 123,  32,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  80,  65,  82,  69,  78,  84,  72,
   69,  83,  69,  32,  61,  32,  34,  94,  37, 115,  42,  37,  98,  40,  41,  34,
   44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  70,  85,  78,  67,  84,  73,  79,  78,  65,  76,  32,  61,  32,  34,
   94,  34,  46,  46,  32,  73,  68,  69,  78,  84,  73,  70,  73,  69,  82,  32,
   46,  46,  32,  34,  37, 115,  42,  37,  98,  40,  41,  34,  44,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  83,  84,
   82,  73,  78,  71,  95,  76,  73,  84,  69,  82,  65,  76,  32,  61,  32,  39,
   94,  34,  91,  94,  34,  93,  42,  34,  39,  44,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  65,  82,  71,  83,  32,
   61,  32,  34,  94,  91,  94,  44,  37, 115,  93,  91,  94,  44,  93,  42,  91,
   94,  44,  37, 115,  93,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  83,  73,  78,  71,  76,  69,  95,  67,
   72,  65,  82,  65,  67,  84,  69,  82,  95,  65,  82,  71,  83,  32,  61,  32,
   34,  94,  91,  94,  44,  37, 115,  93,  34,  44,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  67,  79,  77,  77,  65,
   32,  61,  32,  34,  94,  44,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  44,  10, 125,  59,  10, 118,  97, 114,  32,  80,  82,  69,  95,  84,
   79,  75,  69,  78,  73,  90,  69,  95,  69,  88,  80,  82,  32,  61,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116, 114, 105, 110, 103,  32,
   61,  32, 102,  97, 108, 115, 101,  44,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 107, 101, 121, 119, 111, 114, 100, 115,  95, 111, 114, 100, 101, 114,  32,
   61,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  34,  68,  69,  70,  73,  78,  69,  68,  34,  44,  32,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   34,  70,  85,  78,  67,  84,  73,  79,  78,  65,  76,  95,  77,  65,  67,  82,
   79,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  34,  66,  82,  79,  80,  69,  78,  34,  44,  32,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,
   66,  82,  67,  76,  79,  83,  69,  34,  44,  32,  10,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  84,  69,  78,
   65,  82,  89,  95,  83,  84,  65,  82,  84,  34,  44,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  84,  69,  78,
   65,  82,  89,  95,  77,  73,  68,  68,  76,  69,  34,  44,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   98, 105, 110,  97, 114, 121,  32, 111, 112, 101, 114,  97, 116, 111, 114, 115,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  34,  69,  81,  85,  65,  76,  34,  44,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  78,  79,  84,  95,  69,
   81,  85,  65,  76,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  34,  65,  78,  68,  34,  44,  32,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,
   79,  82,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  34,  66,  65,  78,  68,  34,  44,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  66,  79,
   82,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  34,  66,  88,  79,  82,  34,  44,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  80,  76,  85,
   83,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  34,  77,  73,  78,  85,  83,  34,  44,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  77,  85,
   76,  84,  73,  80,  76,  89,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  68,  73,  86,  34,  44,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   34,  77,  79,  68,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  34,  76,  84,  69,  34,  44,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  77,
   84,  69,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  34,  76,  83,  72,  73,  70,  84,  34,  44,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,
   82,  83,  72,  73,  70,  84,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  76,  84,  34,  44,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,
   77,  84,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32, 117, 110,  97, 114, 121,  32, 111, 112,
  101, 114,  97, 116, 111, 114,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  34,  78,  79,  84,  34,  44,  32,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,
   66,  78,  79,  84,  34,  44,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 108, 105, 116, 101, 114,
   97, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  34,  83,  84,  82,  73,  78,  71,  95,  76,  73,  84,  69,  82,
   65,  76,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  34,  67,  72,  65,  82,  95,  76,  73,  84,  69,  82,
   65,  76,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  34,  72,  69,  88,  95,  76,  73,  84,  69,  82,  65,
   76,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  34,  70,  80,  78,  85,  77,  95,  76,  73,  84,  69,  82,
   65,  76,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  34,  78,  85,  77,  66,  69,  82,  95,  76,  73,  84,
   69,  82,  65,  76,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   44,  10,  32,  32,  32,  32,  32,  32,  32,  32, 107, 101, 121, 119, 111, 114,
  100, 115,  32,  61,  32, 123,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  68,  69,  70,  73,  78,  69,  68,  32,
   61,  32,  39,  94, 100, 101, 102, 105, 110, 101, 100,  39,  44,  32,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  70,
   85,  78,  67,  84,  73,  79,  78,  65,  76,  95,  77,  65,  67,  82,  79,  32,
   61,  32,  39,  94,  39,  32,  46,  46,  32,  73,  68,  69,  78,  84,  73,  70,
   73,  69,  82,  32,  46,  46,  32,  34,  37, 115,  42,  37,  98,  40,  41,  34,
   44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  66,  82,  79,  80,  69,  78,  32,  61,  32,  39,  94,  91,  40,  93,
   39,  44,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  66,  82,  67,  76,  79,  83,  69,  32,  61,  32,  39,  94,
   91,  41,  93,  39,  44,  32,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  84,  69,  78,  65,  82,  89,  95,  83,
   84,  65,  82,  84,  32,  61,  32,  39,  94,  37,  63,  39,  44,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  84,  69,
   78,  65,  82,  89,  95,  77,  73,  68,  68,  76,  69,  32,  61,  32,  39,  94,
   37,  58,  39,  44,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  69,  81,  85,  65,  76,  32,  61,  32,  39,  94,
   61,  61,  39,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  78,  79,  84,  95,  69,  81,  85,  65,  76,  32,  61,
   32,  39,  94,  33,  61,  39,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  65,  78,  68,  32,  61,  32,  39,  94,
   38,  38,  39,  44,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  79,  82,  32,  61,  32,  39,  94, 124, 124,  39,
   44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  66,  65,  78,  68,  32,  61,  32,  39,  94,  38,  39,  44,  32,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   66,  79,  82,  32,  61,  32,  39,  94, 124,  39,  44,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  66,  88,  79,  82,
   32,  61,  32,  39,  94,  37,  94,  39,  44,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  80,  76,  85,  83,  32,  61,
   32,  39,  94,  37,  43,  39,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  77,  73,  78,  85,  83,  32,  61,  32,
   39,  94,  37,  45,  39,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  77,  85,  76,  84,  73,  80,  76,  89,  32,
   61,  32,  39,  94,  37,  42,  39,  44,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  68,  73,  86,  32,  61,  32,  39,
   94,  37,  47,  39,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  77,  79,  68,  32,  61,  32,  39,  94,  37,  37,
   39,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  76,  84,  69,  32,  61,  32,  39,  94,  60,  61,  39,  44,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   77,  84,  69,  32,  61,  32,  39,  94,  62,  61,  39,  44,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  76,  83,  72,
   73,  70,  84,  32,  61,  32,  39,  94,  60,  60,  39,  44,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  82,  83,  72,
   73,  70,  84,  32,  61,  32,  39,  94,  62,  62,  39,  44,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  76,  84,  32,
   61,  32,  39,  94,  60,  39,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  77,  84,  32,  61,  32,  39,  94,  62,
   39,  44,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  78,  79,  84,  32,  61,  32,  39,  94,  33,  39,  44,  32,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  66,  78,  79,  84,  32,  61,  32,  39,  94, 126,  39,  44,  10,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  83,
   84,  82,  73,  78,  71,  95,  76,  73,  84,  69,  82,  65,  76,  32,  61,  32,
   39,  94,  76,  63,  34,  91,  94,  34,  93,  42,  34,  39,  44,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  67,  72,
   65,  82,  95,  76,  73,  84,  69,  82,  65,  76,  32,  61,  32,  34,  94,  76,
   63,  39,  46,  42,  39,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  72,  69,  88,  95,  76,  73,  84,  69,
   82,  65,  76,  32,  61,  32,  39,  94,  91,  37,  43,  37,  45,  93,  63,  48,
   63, 120,  91,  97,  45, 102,  65,  45,  70,  37, 100,  93,  43,  91,  85,  76,
   93,  42,  39,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  70,  80,  78,  85,  77,  95,  76,  73,  84,  69,  82,
   65,  76,  32,  61,  32,  39,  94,  91,  37,  43,  37,  45,  93,  63,  37, 100,
   43,  91,  37,  46,  93,  63,  37, 100,  42, 101,  91,  37,  43,  37,  45,  93,
   37, 100,  42,  39,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  78,  85,  77,  66,  69,  82,  95,  76,  73,  84,
   69,  82,  65,  76,  32,  61,  32,  39,  94,  91,  37,  43,  37,  45,  93,  63,
   48,  63,  98,  63,  37, 100,  43,  91,  37,  46,  93,  63,  37, 100,  42,  91,
   85,  76,  93,  42,  39,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   44,  10, 125,  59,  10,  10, 118,  97, 114,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  32, 112,  97, 114, 115, 101,  68, 101, 102, 105, 110, 101, 100,  40,
  115, 116,  97, 116, 101,  44,  32, 105, 110, 112, 117, 116,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 114, 101, 115, 117,
  108, 116,  32,  61,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 118,  97, 114,  32,  98, 114, 111, 112, 101, 110,  32,  61,
   32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32,  98, 114,  99, 108, 111, 115, 101,  32,  61,  32, 102,  97,
  108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,
   32, 105, 100, 101, 110, 116,  32,  61,  32, 110, 117, 108, 108,  59,  10,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  40,  32, 107, 101, 121,
   44,  32, 118,  97, 108, 117, 101,  32, 105, 110,  32, 105, 110, 112, 117, 116,
   32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 105, 102,  40,  32, 107, 101, 121,  32,  61,  61,  32,
   34,  66,  82,  79,  80,  69,  78,  34,  32,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  98, 114, 111, 112, 101, 110,  32,  61,  32, 116, 114,
  117, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 107, 101, 121,  32,  61,  61,
   32,  34, 105, 100, 101, 110, 116, 105, 102, 105, 101, 114,  34,  32,  41,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 100, 101, 110, 116,
   32,  61,  32, 118,  97, 108, 117, 101,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 102,  40,  32,  33,  32,  98, 114, 111, 112, 101, 110,  32,
   41,  32, 123,  32,  98, 114, 101,  97, 107,  59,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  40,  32, 107, 101, 121,  32,  61,  61,  32,  34,  66,  82,  67,  76,  79,
   83,  69,  34,  32,  38,  38,  32, 105, 100, 101, 110, 116,  32,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114,  99, 108, 111, 115, 101,
   32,  61,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
  119, 105, 104, 116,  32,  97, 110, 100,  32, 119,  47, 111,  32,  98, 114,  97,
   99, 107, 101, 116, 115,  32,  97, 108, 108, 111, 119, 101, 100,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 105, 100, 101, 110, 116,  32,
   38,  38,  32,  40,  40,  98, 114, 111, 112, 101, 110,  32,  38,  38,  32,  98,
  114,  99, 108, 111, 115, 101,  41,  32, 124, 124,  32,  40,  33,  32,  98, 114,
  111, 112, 101, 110,  32,  38,  38,  32,  33,  32,  98, 114,  99, 108, 111, 115,
  101,  41,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 115,
  116,  97, 116, 101,  45,  62, 100, 101, 102, 105, 110, 101, 100,  40, 105, 100,
  101, 110, 116,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114,  40,  34,
  101, 120, 112, 114, 101, 115, 115, 105, 111, 110,  32, 112,  97, 114, 115, 101,
   32, 101, 114, 114, 111, 114,  58,  32, 100, 101, 102, 105, 110, 101, 100,  40,
  105, 100, 101, 110, 116,  41,  34,  41,  59,  10, 125,  10,  10,  10,  47,  42,
   10, 111, 114, 100, 101, 114,  32,  58,  32, 115, 109,  97, 108, 108, 101, 114,
   32, 105, 115,  32, 104, 105, 103, 104, 101, 114,  32, 112, 114, 105, 111, 114,
  105, 116, 121,  10,  49,  32,  32,  32,  32,  32,  32,  32,  40,  41,  32,  32,
   32,  91,  93,  32,  32,  32,  45,  62,  32,  32,  32,  46,  32,  32,  10,  50,
   32,  32,  32,  32,  32,  32,  32,  32,  33,  32,  32,  32, 126,  32,  32,  32,
   45,  32,  32,  32,  43,  32,  32,  32,  42,  32,  32,  32,  38,  32,  32,  32,
  115, 105, 122, 101, 111, 102,  32,  32,  32, 116, 121, 112, 101,  32,  99,  97,
  115, 116,  32,  32,  32,  43,  43,  32,  32,  32,  45,  45,  32,  32,  10,  51,
   32,  32,  32,  32,  32,  32,  32,  42,  32,  32,  32,  47,  32,  32,  32,  37,
   10,  52,  32,  32,  32,  32,  32,  32,  32,  43,  32,  32,  32,  45,  10,  53,
   32,  32,  32,  32,  32,  32,  32,  60,  60,  32,  32,  32,  62,  62,  10,  54,
   32,  32,  32,  32,  32,  32,  32,  60,  32,  32,  32,  60,  61,  32,  32,  32,
   62,  32,  32,  32,  62,  61,  10,  55,  32,  32,  32,  32,  32,  32,  32,  61,
   61,  32,  32,  32,  33,  61,  10,  56,  32,  32,  32,  32,  32,  32,  32,  38,
   10,  57,  32,  32,  32,  32,  32,  32,  32,  94,  10,  49,  48,  32,  32,  32,
   32,  32,  32, 124,  10,  49,  49,  32,  32,  32,  32,  32,  32,  38,  38,  10,
   49,  50,  32,  32,  32,  32,  32,  32, 124, 124,  10,  49,  51,  32,  32,  32,
   32,  32,  32,  32,  63,  58,  32,  32,  32,  61,  32,  32,  32,  43,  61,  32,
   32,  32,  45,  61,  32,  32,  32,  42,  61,  32,  32,  32,  47,  61,  32,  32,
   32,  37,  61,  32,  32,  32,  38,  61,  32,  32,  32, 124,  61,  32,  32,  32,
   94,  61,  32,  32,  32,  60,  60,  61,  32,  32,  32,  62,  62,  61,  10,  49,
   52,  32,  32,  32,  32,  32,  32,  44,  10,  42,  47,  10, 118,  97, 114,  32,
   99, 111, 109,  98, 105, 110,  97, 116, 105, 111, 110,  95, 111, 114, 100, 101,
  114,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32,  40, 111, 112,
   44,  32, 117, 110,  97, 114, 121,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 102,  40,  32, 117, 110,  97, 114, 121,  32,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  40,  32, 111, 112,  32,  61,  61,  32,  39,  45,  39,  32, 124,
  124,  32, 111, 112,  32,  61,  61,  32,  39,  33,  39,  32, 124, 124,  32, 111,
  112,  32,  61,  61,  32,  39, 126,  39,  32,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  50,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   32, 101, 108, 115, 101,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   97, 115, 115, 101, 114, 116,  40, 102,  97, 108, 115, 101,  44,  32,  39, 117,
  110, 115, 117, 112, 112, 111, 114, 116, 101, 100,  32, 117, 110,  97, 114, 121,
   32, 111, 112, 101, 114,  97, 116, 111, 114,  58,  39,  32,  46,  46,  32, 111,
  112,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32,
  101, 108, 115, 101,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 111, 112,  32,  61,  61,
   32,  39,  42,  39,  32, 124, 124,  32, 111, 112,  32,  61,  61,  32,  39,  47,
   39,  32, 124, 124,  32, 111, 112,  32,  61,  61,  32,  39,  37,  39,  32,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114,
  110,  32,  51,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 105, 102,  40,  32,
  111, 112,  32,  61,  61,  32,  39,  43,  39,  32, 124, 124,  32, 111, 112,  32,
   61,  61,  32,  39,  45,  39,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  52,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101,
  108, 115, 101,  32, 105, 102,  40,  32, 111, 112,  32,  61,  61,  32,  39,  62,
   62,  39,  32, 124, 124,  32, 111, 112,  32,  61,  61,  32,  39,  60,  60,  39,
   32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116,
  117, 114, 110,  32,  53,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 105, 102,
   40,  32, 111, 112,  32,  61,  61,  32,  39,  60,  39,  32, 124, 124,  32, 111,
  112,  32,  61,  61,  32,  39,  62,  39,  32, 124, 124,  32, 111, 112,  32,  61,
   61,  32,  39,  60,  61,  39,  32, 124, 124,  32, 111, 112,  32,  61,  61,  32,
   39,  62,  61,  39,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 114, 101, 116, 117, 114, 110,  32,  54,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115,
  101,  32, 105, 102,  40,  32, 111, 112,  32,  61,  61,  32,  39,  61,  61,  39,
   32, 124, 124,  32, 111, 112,  32,  61,  61,  32,  39,  33,  61,  39,  32,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114,
  110,  32,  55,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 105, 102,  40,  32,
  111, 112,  32,  61,  61,  32,  39,  38,  39,  32,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  56,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  32, 101, 108, 115, 101,  32, 105, 102,  40,  32, 111, 112,  32,  61,  61,
   32,  39,  94,  39,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 114, 101, 116, 117, 114, 110,  32,  57,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115,
  101,  32, 105, 102,  40,  32, 111, 112,  32,  61,  61,  32,  39, 124,  39,  32,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117,
  114, 110,  32,  49,  48,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 105, 102,
   40,  32, 111, 112,  32,  61,  61,  32,  39,  38,  38,  39,  32,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,
   49,  49,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 105, 102,  40,  32, 111,
  112,  32,  61,  61,  32,  39, 124, 124,  39,  32,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  49,  50,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  32, 101, 108, 115, 101,  32, 105, 102,  40,  32, 111, 112,  32,  61,
   61,  32,  39,  63,  39,  32, 124, 124,  32, 111, 112,  32,  61,  61,  32,  39,
   58,  39,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32,  49,  51,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  97, 115, 115, 101, 114,
  116,  40, 102,  97, 108, 115, 101,  44,  32,  39, 117, 110, 115, 117, 112, 112,
  111, 114, 116, 101, 100,  32, 111, 112, 101, 114,  97, 116, 111, 114,  58,  39,
   32,  46,  46,  32, 111, 112,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  10, 125,  59,  10,  10, 118,  97, 114,  32, 101, 118,  97,
  108, 117,  97, 116, 101,  59,  10, 101, 118,  97, 108, 117,  97, 116, 101,  32,
   61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32,  40, 110, 111, 100, 101,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,
   33,  32, 110, 111, 100, 101,  46, 111, 112,  32,  41,  32, 123,  32,  47,  47,
   32, 108, 101,  97, 102,  32, 110, 111, 100, 101,  32, 111, 114,  32, 108, 101,
   97, 102,  32, 110, 111, 100, 101,  32, 119, 105, 116, 104,  32, 117, 110,  97,
  114, 121,  32, 111, 112, 101, 114,  97, 116, 111, 114, 115,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,
   32, 118,  32,  61,  32, 110, 111, 100, 101,  46, 118,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,
   32, 110, 111, 100, 101,  46, 117, 111, 112, 115,  32,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  40,  32,  95,  44,  32, 117,
  111, 112,  32, 105, 110,  32, 105, 112,  97, 105, 114, 115,  40, 110, 111, 100,
  101,  46, 117, 111, 112, 115,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 112,
  114, 105, 110, 116,  40,  39,  97, 112, 112, 108, 121,  32, 117, 111, 112,  58,
   39,  46,  46, 117, 111, 112,  46,  46,  34, 124,  34,  46,  46, 116, 111, 115,
  116, 114, 105, 110, 103,  40, 118,  41,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 117, 111,
  112,  32,  61,  61,  32,  39,  45,  39,  32,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 118,  32,  61,  32,  45, 118,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101,
  108, 115, 101,  32, 105, 102,  40,  32, 117, 111, 112,  32,  61,  61,  32,  39,
   33,  39,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   32,  61,  32,  40,  33,  32, 118,  41,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,
   32, 105, 102,  40,  32, 117, 111, 112,  32,  61,  61,  32,  39, 126,  39,  32,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  32,  61,  32,
   98, 105, 116,  46,  98, 110, 111, 116,  40, 118,  41,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101,
  108, 115, 101,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  97, 115,
  115, 101, 114, 116,  40, 102,  97, 108, 115, 101,  44,  32,  39, 105, 110, 118,
   97, 108, 105, 100,  32, 117, 111, 112,  58,  39,  32,  46,  46,  32, 116, 111,
  115, 116, 114, 105, 110, 103,  40, 117, 111, 112,  41,  41,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 112,
  114, 105, 110, 116,  40,  39,  97, 102, 116, 101, 114,  32,  97, 112, 112, 108,
  121,  58,  39,  46,  46, 116, 111, 115, 116, 114, 105, 110, 103,  40, 118,  41,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 114, 101, 116, 117, 114, 110,  32, 118,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32, 112, 114, 105, 110, 116,  40, 110, 111, 100, 101,  46, 111, 112,  46,  46,
   39,  58,  39,  46,  46, 116, 111, 115, 116, 114, 105, 110, 103,  40, 110, 111,
  100, 101,  46, 108,  46, 118,  32, 111, 114,  32, 110, 111, 100, 101,  46, 108,
   46, 111, 112,  41,  46,  46,  34,  40,  34,  46,  46, 116, 121, 112, 101,  40,
  110, 111, 100, 101,  46, 108,  46, 118,  41,  46,  46,  34,  41, 124,  34,  46,
   46, 116, 111, 115, 116, 114, 105, 110, 103,  40, 110, 111, 100, 101,  46, 114,
   46, 118,  32, 111, 114,  32, 110, 111, 100, 101,  46, 114,  46, 111, 112,  41,
   46,  46,  34,  40,  34,  46,  46, 116, 121, 112, 101,  40, 110, 111, 100, 101,
   46, 114,  46, 118,  41,  46,  46,  34,  41,  34,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  40,  32, 110, 111, 100, 101,  46, 111, 112,  32,
   61,  61,  32,  39,  43,  39,  32,  41,  32, 123,  32,  47,  47,  32,  98, 105,
  110,  97, 114, 121,  32, 111, 112, 101, 114,  97, 116, 111, 114, 115,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32,  40, 101, 118,  97, 108, 117,  97, 116, 101,  40,
  110, 111, 100, 101,  46, 108,  41,  32,  43,  32, 101, 118,  97, 108, 117,  97,
  116, 101,  40, 110, 111, 100, 101,  46, 114,  41,  41,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 105, 102,  40,  32,
  110, 111, 100, 101,  46, 111, 112,  32,  61,  61,  32,  39,  45,  39,  32,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  40, 101, 118,  97, 108, 117,
   97, 116, 101,  40, 110, 111, 100, 101,  46, 108,  41,  32,  45,  32, 101, 118,
   97, 108, 117,  97, 116, 101,  40, 110, 111, 100, 101,  46, 114,  41,  41,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32,
  105, 102,  40,  32, 110, 111, 100, 101,  46, 111, 112,  32,  61,  61,  32,  39,
   42,  39,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  40, 101,
  118,  97, 108, 117,  97, 116, 101,  40, 110, 111, 100, 101,  46, 108,  41,  32,
   42,  32, 101, 118,  97, 108, 117,  97, 116, 101,  40, 110, 111, 100, 101,  46,
  114,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101,
  108, 115, 101,  32, 105, 102,  40,  32, 110, 111, 100, 101,  46, 111, 112,  32,
   61,  61,  32,  39,  47,  39,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114,
  110,  32,  40, 101, 118,  97, 108, 117,  97, 116, 101,  40, 110, 111, 100, 101,
   46, 108,  41,  32,  47,  32, 101, 118,  97, 108, 117,  97, 116, 101,  40, 110,
  111, 100, 101,  46, 114,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  32, 101, 108, 115, 101,  32, 105, 102,  40,  32, 110, 111, 100, 101,
   46, 111, 112,  32,  61,  61,  32,  39,  37,  39,  32,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32,  40, 101, 118,  97, 108, 117,  97, 116, 101,  40,
  110, 111, 100, 101,  46, 108,  41,  32,  37,  32, 101, 118,  97, 108, 117,  97,
  116, 101,  40, 110, 111, 100, 101,  46, 114,  41,  41,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 105, 102,  40,  32,
  110, 111, 100, 101,  46, 111, 112,  32,  61,  61,  32,  39,  61,  61,  39,  32,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  40, 101, 118,  97, 108,
  117,  97, 116, 101,  40, 110, 111, 100, 101,  46, 108,  41,  32,  61,  61,  32,
  101, 118,  97, 108, 117,  97, 116, 101,  40, 110, 111, 100, 101,  46, 114,  41,
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115,
  101,  32, 105, 102,  40,  32, 110, 111, 100, 101,  46, 111, 112,  32,  61,  61,
   32,  39,  33,  61,  39,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32,  40, 101, 118,  97, 108, 117,  97, 116, 101,  40, 110, 111, 100, 101,  46,
  108,  41,  32,  33,  61,  32, 101, 118,  97, 108, 117,  97, 116, 101,  40, 110,
  111, 100, 101,  46, 114,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  32, 101, 108, 115, 101,  32, 105, 102,  40,  32, 110, 111, 100, 101,
   46, 111, 112,  32,  61,  61,  32,  39,  60,  60,  39,  32,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  32,  98, 105, 116,  46, 108, 115, 104, 105, 102,
  116,  40, 101, 118,  97, 108, 117,  97, 116, 101,  40, 110, 111, 100, 101,  46,
  108,  41,  44,  32, 101, 118,  97, 108, 117,  97, 116, 101,  40, 110, 111, 100,
  101,  46, 114,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   32, 101, 108, 115, 101,  32, 105, 102,  40,  32, 110, 111, 100, 101,  46, 111,
  112,  32,  61,  61,  32,  39,  62,  62,  39,  32,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101,
  116, 117, 114, 110,  32,  98, 105, 116,  46, 114, 115, 104, 105, 102, 116,  40,
  101, 118,  97, 108, 117,  97, 116, 101,  40, 110, 111, 100, 101,  46, 108,  41,
   44,  32, 101, 118,  97, 108, 117,  97, 116, 101,  40, 110, 111, 100, 101,  46,
  114,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101,
  108, 115, 101,  32, 105, 102,  40,  32, 110, 111, 100, 101,  46, 111, 112,  32,
   61,  61,  32,  39,  38,  38,  39,  32,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117,
  114, 110,  32,  40,  67,  66, 111, 111, 108, 101,  97, 110,  40, 101, 118,  97,
  108, 117,  97, 116, 101,  40, 110, 111, 100, 101,  46, 108,  41,  41,  32,  38,
   38,  32,  67,  66, 111, 111, 108, 101,  97, 110,  40, 101, 118,  97, 108, 117,
   97, 116, 101,  40, 110, 111, 100, 101,  46, 114,  41,  41,  41,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 105, 102,
   40,  32, 110, 111, 100, 101,  46, 111, 112,  32,  61,  61,  32,  39, 124, 124,
   39,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  40,  67,  66,
  111, 111, 108, 101,  97, 110,  40, 101, 118,  97, 108, 117,  97, 116, 101,  40,
  110, 111, 100, 101,  46, 108,  41,  41,  32, 124, 124,  32,  67,  66, 111, 111,
  108, 101,  97, 110,  40, 101, 118,  97, 108, 117,  97, 116, 101,  40, 110, 111,
  100, 101,  46, 114,  41,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  32, 101, 108, 115, 101,  32, 105, 102,  40,  32, 110, 111, 100, 101,
   46, 111, 112,  32,  61,  61,  32,  39,  38,  39,  32,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32,  98, 105, 116,  46,  98,  97, 110, 100,  40, 101,
  118,  97, 108, 117,  97, 116, 101,  40, 110, 111, 100, 101,  46, 108,  41,  44,
   32, 101, 118,  97, 108, 117,  97, 116, 101,  40, 110, 111, 100, 101,  46, 114,
   41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108,
  115, 101,  32, 105, 102,  40,  32, 110, 111, 100, 101,  46, 111, 112,  32,  61,
   61,  32,  39, 124,  39,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32,  98, 105, 116,  46,  98, 111, 114,  40, 101, 118,  97, 108, 117,  97, 116,
  101,  40, 110, 111, 100, 101,  46, 108,  41,  44,  32, 101, 118,  97, 108, 117,
   97, 116, 101,  40, 110, 111, 100, 101,  46, 114,  41,  41,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 105, 102,  40,
   32, 110, 111, 100, 101,  46, 111, 112,  32,  61,  61,  32,  39,  94,  39,  32,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  98, 105, 116,  46,  98,
  120, 111, 114,  40, 101, 118,  97, 108, 117,  97, 116, 101,  40, 110, 111, 100,
  101,  46, 108,  41,  44,  32, 101, 118,  97, 108, 117,  97, 116, 101,  40, 110,
  111, 100, 101,  46, 114,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  32, 101, 108, 115, 101,  32, 105, 102,  40,  32, 110, 111, 100, 101,
   46, 111, 112,  32,  61,  61,  32,  39,  60,  61,  39,  32,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  32,  40, 101, 118,  97, 108, 117,  97, 116, 101,
   40, 110, 111, 100, 101,  46, 108,  41,  32,  60,  61,  32, 101, 118,  97, 108,
  117,  97, 116, 101,  40, 110, 111, 100, 101,  46, 114,  41,  41,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 105, 102,
   40,  32, 110, 111, 100, 101,  46, 111, 112,  32,  61,  61,  32,  39,  62,  61,
   39,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  40, 101, 118,
   97, 108, 117,  97, 116, 101,  40, 110, 111, 100, 101,  46, 108,  41,  32,  62,
   61,  32, 101, 118,  97, 108, 117,  97, 116, 101,  40, 110, 111, 100, 101,  46,
  114,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101,
  108, 115, 101,  32, 105, 102,  40,  32, 110, 111, 100, 101,  46, 111, 112,  32,
   61,  61,  32,  39,  60,  39,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114,
  110,  32,  40, 101, 118,  97, 108, 117,  97, 116, 101,  40, 110, 111, 100, 101,
   46, 108,  41,  32,  60,  32, 101, 118,  97, 108, 117,  97, 116, 101,  40, 110,
  111, 100, 101,  46, 114,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  32, 101, 108, 115, 101,  32, 105, 102,  40,  32, 110, 111, 100, 101,
   46, 111, 112,  32,  61,  61,  32,  39,  62,  39,  32,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32,  40, 101, 118,  97, 108, 117,  97, 116, 101,  40,
  110, 111, 100, 101,  46, 108,  41,  32,  62,  32, 101, 118,  97, 108, 117,  97,
  116, 101,  40, 110, 111, 100, 101,  46, 114,  41,  41,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  97, 115,
  115, 101, 114, 116,  40, 102,  97, 108, 115, 101,  44,  32,  39, 105, 110, 118,
   97, 108, 105, 100,  32, 111, 112,  58,  39,  32,  46,  46,  32, 116, 111, 115,
  116, 114, 105, 110, 103,  40, 110, 111, 100, 101,  46, 111, 112,  41,  41,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10, 125,  59,  10,  10, 118,
   97, 114,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32, 115, 101, 116,  86,
   97, 108, 117, 101,  40, 110, 111, 100, 101,  44,  32, 118,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 112, 114, 105, 110, 116,
   40,  39, 115, 101, 116,  86,  97, 108, 117, 101,  58,  39,  32,  46,  46,  32,
  116, 111, 115, 116, 114, 105, 110, 103,  40, 118,  41,  46,  46,  34, 124,  34,
   46,  46, 116, 111, 115, 116, 114, 105, 110, 103,  40, 110, 111, 100, 101,  46,
  117, 111, 112, 115,  41,  41,  45,  45,  32,  46,  46,  32,  34,  92, 116,  34,
   32,  46,  46,  32, 100, 101,  98, 117, 103,  46, 116, 114,  97,  99, 101,  98,
   97,  99, 107,  40,  41,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  40,  32,  33,  32, 110, 111, 100, 101,  46, 111, 112,  32,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  97, 115, 115, 101, 114, 116,  40,  33,  32, 110, 111, 100, 101,  46, 118,
   44,  32, 100, 101,  98, 117, 103,  46, 116, 114,  97,  99, 101,  98,  97,  99,
  107,  40,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 110, 111, 100, 101,  46, 118,  32,  61,  32, 118,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  97, 115, 115, 101, 114, 116,  40, 110, 111, 100, 101,  46, 108,
   32,  38,  38,  32,  40,  33,  32, 110, 111, 100, 101,  46, 114,  41,  41,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 110, 111, 100, 101,  46, 114,  32,  61,  32, 123, 118,  32,  61,  32, 118,
   44,  32, 117, 111, 112, 115,  32,  61,  32, 110, 111, 100, 101,  46, 117, 111,
  112, 115, 125,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10, 125,
   10,  10, 118,  97, 114,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32, 115,
  101, 116,  85, 110,  97, 114, 121,  79, 112,  40, 110, 111, 100, 101,  44,  32,
  117, 111, 112,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  47,
   47,  32, 112, 114, 105, 110, 116,  40,  39, 115, 101, 116,  85, 110,  97, 114,
  121,  79, 112,  58,  39,  32,  46,  46,  32, 116, 111, 115, 116, 114, 105, 110,
  103,  40, 117, 111, 112,  41,  41,  45,  45,  32,  46,  46,  32,  34,  92, 116,
   34,  32,  46,  46,  32, 100, 101,  98, 117, 103,  46, 116, 114,  97,  99, 101,
   98,  97,  99, 107,  40,  41,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  40,  32,  33,  32, 110, 111, 100, 101,  46, 117, 111, 112, 115,  32,
   41,  32, 123,  32, 110, 111, 100, 101,  46, 117, 111, 112, 115,  32,  61,  32,
  123, 125,  59,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 116,  97,
   98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40, 110, 111, 100, 101,  46,
  117, 111, 112, 115,  44,  32,  49,  44,  32, 117, 111, 112,  41,  59,  10, 125,
   10,  10, 118,  97, 114,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32, 112,
   97, 114, 115, 101,  69, 120, 112, 114,  40, 115, 116,  97, 116, 101,  44,  32,
  105, 110, 112, 117, 116,  41,  32, 123,  32,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32, 110, 111, 100, 101,  32,  61,  32, 123, 125,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 114, 111, 111,
  116,  32,  61,  32, 110, 111, 100, 101,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  47,  47,  32, 102, 105, 114, 115, 116,  32,  99,  97, 108, 108,  32,
  103, 101, 116, 115,  32, 115, 116, 114, 105, 110, 103,  32, 105, 110, 112, 117,
  116,  46,  32, 114, 101, 115, 116,  32, 117, 115, 101, 115,  32, 116, 111, 107,
  101, 110, 105, 122, 101, 114,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  40,  32, 116, 121, 112, 101,  40, 105, 110, 112, 117, 116,  41,  32,  61,
   61,  32,  34, 115, 116, 114, 105, 110, 103,  34,  32,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,
   47,  32, 112, 114, 105, 110, 116,  40,  39, 112,  97, 114, 115, 101,  58,  39,
   32,  46,  46,  32, 105, 110, 112, 117, 116,  41,  32,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 110, 112, 117,
  116,  32,  61,  32, 116, 111, 107, 101, 110, 105, 122, 101, 114,  40, 105, 110,
  112, 117, 116,  44,  32,  80,  82,  69,  95,  84,  79,  75,  69,  78,  73,  90,
   69,  95,  69,  88,  80,  82,  41,  59,  32,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,
   40,  32, 116, 121, 112, 101,  44,  32, 118,  97, 108, 117, 101,  32, 105, 110,
   32, 105, 110, 112, 117, 116,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 112, 114,
  105, 110, 116,  40,  34, 116, 121, 112, 101,  58,  34,  46,  46, 116, 121, 112,
  101,  46,  46,  34,  32, 118,  97, 108, 117, 101,  58,  34,  46,  46, 118,  97,
  108, 117, 101,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32, 117, 110,  97, 114, 121,  32, 111, 112,
  101, 114,  97, 116, 111, 114,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 116, 121, 112, 101,  32,
   61,  61,  32,  34,  78,  79,  84,  34,  32, 124, 124,  32,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 116, 121, 112, 101,  32,  61,  61,  32,  34,  66,  78,
   79,  84,  34,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  115, 101, 116,  85, 110,  97, 114, 121,  79, 112,  40, 110, 111, 100, 101,  44,
   32, 118,  97, 108, 117, 101,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 116,
  121, 112, 101,  32,  61,  61,  32,  34,  66,  82,  79,  80,  69,  78,  34,  32,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 101, 116,  86,
   97, 108, 117, 101,  40, 110, 111, 100, 101,  44,  32, 115, 116,  97, 116, 101,
   45,  62, 112,  97, 114, 115, 101,  69, 120, 112, 114,  40, 105, 110, 112, 117,
  116,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 116, 121, 112, 101,  32,
   61,  61,  32,  34,  66,  82,  67,  76,  79,  83,  69,  34,  32,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47, 112, 114, 105, 110, 116,
   40,  39,  66,  82,  67,  76,  79,  83,  69,  58,  39,  32,  46,  46,  32, 116,
  111, 115, 116, 114, 105, 110, 103,  40, 114, 101, 115, 117, 108, 116,  41,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  40,  32, 116, 121, 112, 101,  32,  61,  61,  32,  34,  83,
   84,  82,  73,  78,  71,  95,  76,  73,  84,  69,  82,  65,  76,  34,  32,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 101, 116,  86,  97,
  108, 117, 101,  40, 110, 111, 100, 101,  44,  32, 118,  97, 108, 117, 101,  45,
   62, 115, 117,  98,  40, 118,  97, 108, 117, 101,  91,  49,  93,  32,  61,  61,
   32,  39,  76,  39,  32,  38,  38,  32,  51,  32, 124, 124,  32,  50,  44,  45,
   50,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 116, 121, 112, 101,  32,
   61,  61,  32,  34,  78,  85,  77,  66,  69,  82,  95,  76,  73,  84,  69,  82,
   65,  76,  34,  32, 124, 124,  32, 116, 121, 112, 101,  32,  61,  61,  32,  34,
   72,  69,  88,  95,  76,  73,  84,  69,  82,  65,  76,  34,  32, 124, 124,  32,
  116, 121, 112, 101,  32,  61,  61,  32,  34,  70,  80,  78,  85,  77,  95,  76,
   73,  84,  69,  82,  65,  76,  34,  32, 124, 124,  32, 116, 121, 112, 101,  32,
   61,  61,  32,  34,  67,  72,  65,  82,  95,  76,  73,  84,  69,  82,  65,  76,
   34,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 101,
  116,  86,  97, 108, 117, 101,  40, 110, 111, 100, 101,  44,  32, 116, 111, 110,
  117, 109,  98, 101, 114,  40, 112,  97, 114, 115, 101,  67,  73, 110, 116, 101,
  103, 101, 114,  40, 118,  97, 108, 117, 101,  41,  41,  41,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32, 116, 101, 110,  97, 114, 121,  32, 111, 112, 101, 114,  97, 116,
  111, 114,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  47,  47,  32, 116, 101, 110,  97, 114, 121,  32, 104,  97, 115,
   32, 108, 111, 119, 101, 115, 116,  32, 112, 114, 105, 111, 114, 105, 116, 121,
   44,  32, 115, 111,  32,  97, 110, 121,  32, 111, 116, 104, 101, 114,  32, 111,
  112, 101, 114,  97, 116, 105, 111, 110,  32,  99,  97, 110,  32,  98, 101,  32,
   99,  97, 108,  99, 117, 108,  97, 116, 101,  32, 110, 111, 119,  46,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  40,  32, 116, 121, 112, 101,  32,  61,  61,  32,  34,  84,  69,  78,  65,
   82,  89,  95,  83,  84,  65,  82,  84,  34,  32,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 108,  32,  61,  32, 115, 116,
   97, 116, 101,  45,  62, 112,  97, 114, 115, 101,  69, 120, 112, 114,  40, 105,
  110, 112, 117, 116,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32, 114,  32,  61,  32, 115, 116,  97, 116, 101,  45,  62, 112,  97,
  114, 115, 101,  69, 120, 112, 114,  40, 105, 110, 112, 117, 116,  41,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 101, 118,  97, 108,
  117,  97, 116, 101,  40, 114, 111, 111, 116,  41,  32,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32, 108,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  32, 101, 108, 115, 101,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32, 114,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  40,  32, 116, 121, 112, 101,  32,  61,  61,  32,  34,  84,  69,  78,
   65,  82,  89,  95,  77,  73,  68,  68,  76,  69,  34,  32,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  47,  47,  32,  98, 105, 110,  97, 114, 121,  32, 111, 112, 101, 114,  97,
  116, 111, 114,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  40,  32, 116, 121, 112, 101,  32,  61,  61,  32,
   34,  69,  81,  85,  65,  76,  34,  32, 124, 124,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 116, 121, 112, 101,  32,  61,  61,  32,  34,  78,  79,  84,  95,
   69,  81,  85,  65,  76,  34,  32, 124, 124,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 116, 121, 112, 101,  32,  61,  61,  32,  34,  65,  78,  68,  34,  32,
  124, 124,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116, 121, 112, 101,  32,
   61,  61,  32,  34,  79,  82,  34,  32, 124, 124,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 116, 121, 112, 101,  32,  61,  61,  32,  34,  66,  65,  78,  68,
   34,  32, 124, 124,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116, 121, 112,
  101,  32,  61,  61,  32,  34,  66,  79,  82,  34,  32, 124, 124,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 116, 121, 112, 101,  32,  61,  61,  32,  34,  66,
   88,  79,  82,  34,  32, 124, 124,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  116, 121, 112, 101,  32,  61,  61,  32,  34,  80,  76,  85,  83,  34,  32, 124,
  124,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116, 121, 112, 101,  32,  61,
   61,  32,  34,  77,  73,  78,  85,  83,  34,  32, 124, 124,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 116, 121, 112, 101,  32,  61,  61,  32,  34,  77,  85,
   76,  84,  73,  80,  76,  89,  34,  32, 124, 124,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 116, 121, 112, 101,  32,  61,  61,  32,  34,  68,  73,  86,  34,
   32, 124, 124,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116, 121, 112, 101,
   32,  61,  61,  32,  34,  77,  79,  68,  34,  32, 124, 124,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 116, 121, 112, 101,  32,  61,  61,  32,  34,  76,  84,
   69,  34,  32, 124, 124,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116, 121,
  112, 101,  32,  61,  61,  32,  34,  77,  84,  69,  34,  32, 124, 124,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 116, 121, 112, 101,  32,  61,  61,  32,  34,
   76,  83,  72,  73,  70,  84,  34,  32, 124, 124,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 116, 121, 112, 101,  32,  61,  61,  32,  34,  82,  83,  72,  73,
   70,  84,  34,  32, 124, 124,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116,
  121, 112, 101,  32,  61,  61,  32,  34,  76,  84,  34,  32, 124, 124,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 116, 121, 112, 101,  32,  61,  61,  32,  34,
   77,  84,  34,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  40,  32, 110, 111, 100, 101,  46, 111, 112,  32,  41,  32, 123,  32,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  40,  32,  33,  32, 110, 111, 100, 101,  46, 114,  32,  41,  32,
  123,  32,  47,  47,  32, 100, 117, 114, 105, 110, 103,  32, 112,  97, 114, 115,
  101,  32, 114, 105, 103, 104, 116,  32, 111, 112, 101, 114,  97, 110, 100,  32,
   58,  32, 117, 111, 112,  49,  32, 117, 111, 112,  50,  32,  46,  46,  46,  32,
  117, 111, 112,  78,  32, 111, 112, 101, 114,  97, 110, 100,  49,  32, 111, 112,
   49,  32, 117, 111, 112,  40,  78,  43,  49,  41,  32, 117, 111, 112,  40,  78,
   43,  50,  41,  32,  46,  46,  46,  32,  91, 117, 111, 112,  40,  78,  43,  75,
   41,  93,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  97, 115, 115, 101, 114,
  116,  40, 116, 121, 112, 101,  32,  61,  61,  32,  34,  77,  73,  78,  85,  83,
   34,  44,  32,  32,  34, 101, 114, 114, 111, 114,  58,  32, 111, 112, 101, 114,
   97, 116, 111, 114, 115,  32,  99, 111, 109, 101,  32,  99, 111, 110, 115, 101,
  113, 117, 101, 110, 116, 108, 121,  58,  32,  34,  32,  46,  46,  32, 116, 111,
  115, 116, 114, 105, 110, 103,  40, 110, 111, 100, 101,  46, 111, 112,  41,  32,
   46,  46,  32,  34,  32,  97, 110, 100,  32,  34,  32,  46,  46,  32, 116, 111,
  115, 116, 114, 105, 110, 103,  40, 118,  97, 108, 117, 101,  41,  41,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 117, 110,  97, 114, 121,
   32, 111, 112, 101, 114,  97, 116, 101, 114,  32,  97, 102, 116, 101, 114,  32,
   98, 105, 110,  97, 114, 121,  32, 111, 112, 101, 114,  97, 116, 111, 114,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 115, 101, 116,  85, 110,  97, 114, 121,
   79, 112,  40, 110, 111, 100, 101,  44,  32, 118,  97, 108, 117, 101,  41,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  32, 101, 108, 115, 101,  32, 123,  32,  47,  47,  32, 117, 111, 112,
   49,  32, 117, 111, 112,  50,  32,  46,  46,  46,  32, 117, 111, 112,  78,  32,
  111, 112, 101, 114,  97, 110, 100,  49,  32, 111, 112,  49,  32, 117, 111, 112,
   40,  78,  43,  49,  41,  32, 117, 111, 112,  40,  78,  43,  50,  41,  32,  46,
   46,  46,  32, 117, 111, 112,  40,  78,  43,  77,  41,  32, 111, 112, 101, 114,
   97, 110, 100,  50,  32,  91, 111, 112,  50,  93,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  47,  47,  32, 112, 114, 105, 110, 116,  40,  34, 111, 112, 101,
  114,  97, 116, 111, 114,  32, 112, 114, 111,  99, 101, 115, 115, 105, 110, 103,
   58,  34,  32,  46,  46,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 110,
  111, 100, 101,  46, 111, 112,  41,  32,  46,  46,  32,  34, 124,  34,  32,  46,
   46,  32, 118,  97, 108, 117, 101,  32,  46,  46,  32,  34, 124,  34,  32,  46,
   46,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 110, 111, 100, 101,  46,
  108,  41,  32,  46,  46,  32,  34, 124,  34,  32,  46,  46,  32, 116, 111, 115,
  116, 114, 105, 110, 103,  40, 110, 111, 100, 101,  46, 114,  41,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 116, 109, 112,  32,  61,
   32, 110, 111, 100, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 119,
  104, 105, 108, 101,  40,  32, 116, 109, 112,  32,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32, 112, 114, 105, 110, 116,  40,  39,  99, 111, 109, 112,  97, 114, 101,  32,
   39,  32,  46,  46,  32, 118,  97, 108, 117, 101,  46,  46,  39,  32,  97, 110,
  100,  32,  39,  32,  46,  46,  32, 116, 109, 112,  46, 111, 112,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  40,  32,  99, 111, 109,  98, 105, 110,  97, 116, 105, 111, 110,  95, 111,
  114, 100, 101, 114,  40, 116, 109, 112,  46, 111, 112,  41,  32,  62,  32,  99,
  111, 109,  98, 105, 110,  97, 116, 105, 111, 110,  95, 111, 114, 100, 101, 114,
   40, 118,  97, 108, 117, 101,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32, 112, 114, 105, 110, 116,  40, 118,  97, 108,
  117, 101,  46,  46,  39,  32, 105, 115,  32, 115, 116, 114, 111, 110, 103, 101,
  114,  32, 116, 104,  97, 110,  32,  39,  32,  46,  46,  32, 116, 109, 112,  46,
  111, 112,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97,
  107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 116, 109, 112,  32,  61,  32, 116, 109, 112,  46, 112,
   97, 114, 101, 110, 116,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 116, 109, 112,
   32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 110, 111, 100, 101,  32,  61,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 111, 112,  32,  61,  32, 118,  97, 108, 117, 101,
   44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108,  32,  61,  32, 116, 109,
  112,  46, 114,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112,  97, 114,
  101, 110, 116,  32,  61,  32, 116, 109, 112,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116, 109, 112,
   46, 114,  46, 112,  97, 114, 101, 110, 116,  32,  61,  32, 110, 111, 100, 101,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 116, 109, 112,  46, 114,  32,  61,  32, 110, 111, 100, 101,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 110, 111, 100, 101,  32,  61,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 111, 112,  32,  61,  32, 118,  97, 108, 117, 101,  44,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 108,  32,  61,  32, 114, 111, 111, 116,  44,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 114, 111, 111, 116,  46, 112,  97, 114, 101, 110, 116,  32,  61,
   32, 110, 111, 100, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 114, 111, 111, 116,  32,  61,  32, 110, 111,
  100, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 105,
  102,  40,  32, 110, 111, 100, 101,  46, 118,  32,  33,  61,  32, 110, 117, 108,
  108,  32,  41,  32, 123,  32,  47,  47,  32, 117, 111, 112,  49,  32, 117, 111,
  112,  50,  32,  46,  46,  46,  32, 117, 111, 112,  78,  32, 111, 112, 101, 114,
   97, 110, 100,  49,  32,  91, 111, 112,  93,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 100, 101,
  118, 105, 100, 101, 100,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 110, 111, 100, 101,  46,
  117, 111, 112, 115,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 102, 111, 114,  40,  32,  95,  44,  32, 117, 111, 112,  32, 105, 110,  32,
  105, 112,  97, 105, 114, 115,  40, 110, 111, 100, 101,  46, 117, 111, 112, 115,
   41,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 105, 102,  40,  32,  99, 111, 109,  98, 105, 110,
   97, 116, 105, 111, 110,  95, 111, 114, 100, 101, 114,  40, 117, 111, 112,  44,
   32, 116, 114, 117, 101,  41,  32,  62,  32,  99, 111, 109,  98, 105, 110,  97,
  116, 105, 111, 110,  95, 111, 114, 100, 101, 114,  40, 118,  97, 108, 117, 101,
   41,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32, 116, 104, 101, 114, 101,  32, 105, 115,  32,  97,  32,  98, 105, 110,  97,
  114, 121,  32, 111, 112, 101, 114,  97, 116, 111, 114,  32, 119, 104, 105,  99,
  104,  32, 104,  97, 115,  32, 115, 116, 114, 111, 110, 103, 101, 114,  32, 116,
  104,  97, 110,  32,  97, 110, 121,  32, 111, 102,  32, 116, 104, 101,  32, 117,
  110,  97, 114, 121,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 100, 101, 118,
  105, 100, 101, 100,  32,  61,  32, 117, 111, 112,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 100, 101,
  118, 105, 100, 101, 100,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  97, 115, 115, 101, 114, 116,  40, 102,  97, 108, 115, 101,  44,  32,
   34,  84,  79,  68,  79,  58,  32,  99,  97, 110,  32, 119, 101,  32, 100, 111,
   32, 115, 111, 109, 101, 116, 104, 105, 110, 103,  32,  97,  98, 111, 117, 116,
   32, 116, 104, 105, 115,  32,  99,  97, 115, 101,  63,  63,  58,  34,  46,  46,
  118,  97, 108, 117, 101,  46,  46,  34,  32, 105, 115,  32, 115, 116, 114, 111,
  110, 103, 101, 114,  32, 116, 104,  97, 110,  32,  34,  46,  46, 100, 101, 118,
  105, 100, 101, 100,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 110, 111, 100, 101,  46, 108,  32,  61,
   32, 123,  32, 118,  32,  61,  32, 110, 111, 100, 101,  46, 118,  44,  32, 117,
  111, 112, 115,  32,  61,  32, 110, 111, 100, 101,  46, 117, 111, 112, 115,  32,
  125,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 111, 100, 101,  46,
  118,  32,  61,  32, 110, 117, 108, 108,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 110, 111, 100, 101,  46, 117, 111, 112, 115,  32,  61,  32, 110, 117,
  108, 108,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 111, 100, 101,
   46, 111, 112,  32,  61,  32, 118,  97, 108, 117, 101,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  32,
   47,  47,  32, 117, 110,  97, 114, 121,  32, 111, 112, 101, 114,  97, 116, 111,
  114,  32,  58,  32, 117, 111, 112,  49,  32, 117, 111, 112,  50,  32,  46,  46,
   46,  32,  91, 117, 111, 112,  78,  93,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  97, 115, 115, 101, 114, 116,  40,
  116, 121, 112, 101,  32,  61,  61,  32,  34,  77,  73,  78,  85,  83,  34,  44,
   32,  34, 101, 114, 114, 111, 114,  58,  32, 105, 110, 118,  97, 108, 105, 100,
   32, 117, 110,  97, 114, 121,  32, 111, 112, 101, 114,  97, 116, 111, 114,  58,
   34,  32,  46,  46,  32, 118,  97, 108, 117, 101,  41,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 101, 116,
   85, 110,  97, 114, 121,  79, 112,  40, 110, 111, 100, 101,  44,  32, 118,  97,
  108, 117, 101,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  40,  32, 116, 121, 112, 101,  32,  61,  61,  32,  34,  68,
   69,  70,  73,  78,  69,  68,  34,  32,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 115, 101, 116,  86,  97, 108, 117, 101,  40, 110, 111, 100,
  101,  44,  32, 112,  97, 114, 115, 101,  68, 101, 102, 105, 110, 101, 100,  40,
  115, 116,  97, 116, 101,  44,  32, 105, 110, 112, 117, 116,  41,  41,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  32, 101, 108, 115, 101,  32, 105, 102,  40,  32, 116, 121, 112, 101,  32,
   61,  61,  32,  34, 105, 100, 101, 110, 116, 105, 102, 105, 101, 114,  34,  32,
  124, 124,  32, 116, 121, 112, 101,  32,  61,  61,  32,  34,  70,  85,  78,  67,
   84,  73,  79,  78,  65,  76,  95,  77,  65,  67,  82,  79,  34,  32,  41,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 112, 114, 105,
  110, 116,  40,  39, 105, 100, 101, 110, 116,  58,  39,  32,  46,  46,  32, 118,
   97, 108, 117, 101,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32, 101, 118,  97, 108,  32,  61,  32, 115, 116,  97, 116, 101,  45,  62,
   97, 112, 112, 108, 121,  40, 118,  97, 108, 117, 101,  41,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  47,  47,  32, 112, 114, 105, 110, 116,  40,  39,
   97, 112, 112, 108, 121,  32, 114, 101, 115, 117, 108, 116,  32,  39,  32,  46,
   46,  32, 101, 118,  97, 108,  32,  46,  46,  32,  34, 124,  34,  32,  46,  46,
   32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 117, 110, 112, 114, 111,  99,
  101, 115, 115, 101, 100,  41,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  40,  32, 101, 118,  97, 108,  32,  33,  61,  32, 118,  97, 108, 117,
  101,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 101, 118,  97, 108,  32,  61,  32, 115, 116,  97,
  116, 101,  45,  62, 112,  97, 114, 115, 101,  69, 120, 112, 114,  40, 101, 118,
   97, 108,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32, 112, 114, 105, 110, 116,  40,  39, 114,
  101,  45, 101, 118,  97, 108, 117,  97, 116, 101,  32, 101, 120, 112, 114,  32,
   39,  32,  46,  46,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 101, 118,
   97, 108,  41,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 115, 101, 116,  86,  97, 108, 117, 101,  40, 110, 111,
  100, 101,  44,  32, 101, 118,  97, 108,  41,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 117,
  110, 100, 101, 102, 105, 110, 101, 100,  32, 109,  97,  99, 114, 111,  32, 115,
  121, 109,  98, 111, 108,  32, 105, 115,  32,  97, 108, 119,  97, 121, 115,  32,
  116, 114, 101,  97, 116, 101, 100,  32,  97, 115,  32,  48,  46,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32, 104, 116, 116, 112,  58,  47,  47, 103,  99,  99,  46, 103, 110, 117,  46,
  111, 114, 103,  47, 111, 110, 108, 105, 110, 101, 100, 111,  99, 115,  47,  99,
  112, 112,  47,  73, 102,  46, 104, 116, 109, 108,  35,  73, 102,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 101,
  116,  86,  97, 108, 117, 101,  40, 110, 111, 100, 101,  44,  32,  48,  41,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 114,  32,  61,  32, 101, 118,  97, 108, 117,  97, 116, 101,
   40, 114, 111, 111, 116,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32, 112, 114, 105, 110, 116,  40,  39, 101, 118,  97, 108, 117,  97,
  116, 101,  58,  39,  32,  46,  46,  32, 116, 111, 115, 116, 114, 105, 110, 103,
   40, 114,  41,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116,
  117, 114, 110,  32, 114,  59,  10, 125,  10,  10,  47,  47,  32,  97, 112, 112,
  108, 121,  32, 115, 116, 114, 105, 110, 103,  32, 111, 112, 115,  32,  34,  35,
   35,  34,  10, 118,  97, 114,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32,
  112, 114, 101, 112,  97, 114, 101,  77,  97,  99, 114, 111,  40, 115, 116,  97,
  116, 101,  44,  32, 105, 110, 112, 117, 116,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 105, 102,  40,  32, 116, 121, 112, 101,  40, 105, 110,
  112, 117, 116,  41,  32,  33,  61,  32,  34, 115, 116, 114, 105, 110, 103,  34,
   32,  41,  32, 123,  32, 114, 101, 116, 117, 114, 110,  32, 105, 110, 112, 117,
  116,  59,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 100, 111,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32, 111, 117, 116,  32,  61,  32, 123, 125,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32,  99, 111, 110,  99,  97, 116,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  40,
   32, 107,  44,  32, 118,  44,  32, 115, 116,  97, 114, 116,  44,  32, 101, 110,
  100,  95,  32, 105, 110,  32, 116, 111, 107, 101, 110, 105, 122, 101, 114,  40,
  105, 110, 112, 117, 116,  44,  32,  80,  82,  69,  95,  84,  79,  75,  69,  78,
   73,  90,  69,  95,  77,  65,  67,  82,  79,  41,  32,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 107,  32,  61,  61,  32,
   34,  67,  79,  78,  67,  65,  84,  34,  32,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
  114, 101, 109, 111, 118, 101,  32,  99, 111, 110,  99,  97, 116,  32, 111, 112,
   32,  34,  35,  35,  34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  99, 111, 110,  99,  97, 116,  32,  61,  32, 116,
  114, 117, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101,
  108, 115, 101,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101,
  114, 116,  40, 111, 117, 116,  44,  32, 105, 110, 112, 117, 116,  45,  62, 115,
  117,  98,  40, 115, 116,  97, 114, 116,  44,  32, 101, 110, 100,  95,  41,  41,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 110,
  112, 117, 116,  32,  61,  32, 116,  97,  98, 108, 101,  46,  99, 111, 110,  99,
   97, 116,  40, 111, 117, 116,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  32, 119, 104, 105, 108, 101,  40,  33,  40,  32,  33,  32,  99, 111,
  110,  99,  97, 116,  41,  32,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 114, 101, 116, 117, 114, 110,  32, 105, 110, 112, 117, 116,  59,  10, 125,
   10,  10,  47,  47,  32, 109,  97,  99, 114, 111,  32,  97, 114, 103, 115,  32,
  114, 101, 112, 108,  97,  99, 101, 109, 101, 110, 116,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  32, 115, 108, 111, 119, 101, 114,  32,  98, 117, 116,  32,
  109, 111, 114, 101,  32, 116, 111, 114, 101, 108,  97, 110, 116,  32, 102, 111,
  114,  32, 112,  97, 116, 104, 111, 108, 111, 103, 105,  99,  97, 108,  32,  99,
   97, 115, 101,  32,  10, 118,  97, 114,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  32, 114, 101, 112, 108,  97,  99, 101,  65, 114, 103, 115,  40,  97, 114,
  103, 115, 115, 116, 114,  44,  32, 114, 101, 112, 108,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  97, 114, 103, 115,  32,
   61,  32, 123, 125,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  97, 114,
  103, 115, 115, 116, 114,  32,  61,  32,  97, 114, 103, 115, 115, 116, 114,  45,
   62, 115, 117,  98,  40,  50,  44,  45,  50,  41,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32, 112, 114, 105, 110, 116,  40,  39,  97, 114,
  103, 115, 115, 116, 114,  58,  39,  46,  46,  97, 114, 103, 115, 115, 116, 114,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  99, 111,
  109, 109,  97,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,
   40,  32, 107,  44,  32, 118,  44,  32, 115, 116,  97, 114, 116,  44,  32, 101,
  110, 100,  95,  32, 105, 110,  32, 116, 111, 107, 101, 110, 105, 122, 101, 114,
   40,  97, 114, 103, 115, 115, 116, 114,  44,  32,  80,  82,  69,  95,  84,  79,
   75,  69,  78,  73,  90,  69,  95,  77,  65,  67,  82,  79,  95,  65,  82,  71,
   83,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 112, 114, 105, 110, 116,  40,
   34, 114, 101, 112, 108,  97,  99, 101,  65, 114, 103, 115,  58,  34,  32,  46,
   46,  32, 107,  32,  46,  46,  32,  34, 124,  34,  32,  46,  46,  32, 118,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  40,  32, 107,  32,  61,  61,  32,  34,  65,  82,  71,  83,  34,
   32, 124, 124,  32, 107,  32,  61,  61,  32,  34,  80,  65,  82,  69,  78,  84,
   72,  69,  83,  69,  34,  32, 124, 124,  32, 107,  32,  61,  61,  32,  34,  83,
   84,  82,  73,  78,  71,  95,  76,  73,  84,  69,  82,  65,  76,  34,  32, 124,
  124,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 107,  32,  61,  61,  32,
   34,  70,  85,  78,  67,  84,  73,  79,  78,  65,  76,  34,  32, 124, 124,  32,
  107,  32,  61,  61,  32,  34,  83,  73,  78,  71,  76,  69,  95,  67,  72,  65,
   82,  65,  67,  84,  69,  82,  95,  65,  82,  71,  83,  34,  32,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105,
  110, 115, 101, 114, 116,  40,  97, 114, 103, 115,  44,  32, 118,  41,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 109, 109,  97,  32,  61,  32,
  102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 105, 102,
   40,  32, 107,  32,  61,  61,  32,  34,  67,  79,  77,  77,  65,  34,  32,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,  99,
  111, 109, 109,  97,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  99, 111, 110, 116,
  105, 110, 117, 101, 100,  32,  99, 111, 109, 109,  97,  32, 109, 101,  97, 110,
  115,  32, 101, 109, 112, 116, 121,  32, 112,  97, 114,  97, 109, 101, 116, 101,
  114,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40,  97,
  114, 103, 115,  44,  32,  34,  34,  41,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 109, 109,
   97,  32,  61,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32, 118,  32,  61,  32, 114, 101, 112, 108,  45,  62, 103, 115, 117,  98,
   40,  34,  37,  36,  40,  37, 100,  43,  41,  34,  44,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  32,  40, 109,  41,  32, 123,  32, 114, 101, 116, 117, 114,
  110,  32,  97, 114, 103, 115,  91, 116, 111, 110, 117, 109,  98, 101, 114,  40,
  109,  41,  93,  32, 124, 124,  32,  34,  34,  59,  32, 125,  41,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 112, 114, 105, 110, 116,  40,
   34, 114, 101, 112, 108,  97,  99, 101,  65, 114, 103, 115,  58,  34,  32,  46,
   46,  32, 114, 101, 112, 108,  32,  46,  46,  32,  34, 124,  34,  32,  46,  46,
   32, 116, 111, 115, 116, 114, 105, 110, 103,  40,  35,  97, 114, 103, 115,  41,
   32,  46,  46,  32,  34, 124,  34,  32,  46,  46,  32, 118,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 118,  59,  10,
  125,  10,  10,  47,  47,  32, 105,  46, 101,  46,  58,  32,  34,  77,  65,  88,
   40, 120,  44,  32, 121,  41,  32,  40,  40,  40, 120,  41,  32,  62,  32,  40,
  121,  41,  41,  32,  63,  32,  40, 120,  41,  32,  58,  32,  40, 121,  41,  41,
   34,  10, 118,  97, 114,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32, 112,
   97, 114, 115, 101,  70, 117, 110,  99, 116, 105, 111, 110,  40, 115, 116,  97,
  116, 101,  44,  32, 105, 110, 112, 117, 116,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 105, 102,  40,  32,  33,  32, 105, 110, 112, 117, 116,
   32,  41,  32, 123,  32, 114, 101, 116, 117, 114, 110,  59,  32, 125,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  99, 111, 110,  99,  97,
  116,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 110,
   97, 109, 101,  44,  32,  97, 114, 103, 115, 115, 116, 114,  44,  32, 114, 101,
  112, 108,  32,  61,  32, 105, 110, 112, 117, 116,  45,  62, 109,  97, 116,  99,
  104,  40,  70,  85,  78,  67,  77,  65,  67,  82,  79,  41,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 105, 102,  40,  32,  33,  32, 110,  97, 109, 101,
   32, 124, 124,  32,  33,  32,  97, 114, 103, 115, 115, 116, 114,  32, 124, 124,
   32,  33,  32, 114, 101, 112, 108,  32,  41,  32, 123,  32, 114, 101, 116, 117,
  114, 110,  59,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  47,
   47,  32, 114, 101, 110,  97, 109, 101,  32,  97, 114, 103, 115,  32, 116, 111,
   32,  36,  49,  44,  36,  50,  46,  46,  46,  32, 102, 111, 114,  32, 108,  97,
  116, 101, 114,  32, 103, 115, 117,  98,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 118,  97, 114,  32, 110, 111,  97, 114, 103, 115,  32,  61,  32,  48,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  40,  32,  97, 114,
  103, 110,  97, 109, 101,  32, 105, 110,  32,  97, 114, 103, 115, 115, 116, 114,
   45,  62, 103, 109,  97, 116,  99, 104,  40,  73,  68,  69,  78,  84,  73,  70,
   73,  69,  82,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 111,  97, 114, 103, 115,  32,
   61,  32, 110, 111,  97, 114, 103, 115,  32,  43,  32,  49,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32,  97, 118, 111, 105, 100,  32, 109,  97, 116,  99, 104, 105, 110, 103,  32,
  115, 117,  98, 115, 116, 114, 105, 110, 103,  32, 111, 102,  32,  97, 110, 111,
  116, 104, 101, 114,  32, 105, 100, 101, 110, 116, 105, 102, 105, 101, 114,  32,
   40, 101, 103,  46,  32,  97, 116, 116, 114, 105,  98,  32, 109,  97, 116,  99,
  104, 101, 115,  32,  97, 116, 116, 114, 105,  98, 117, 116, 101,  32,  97, 110,
  100,  32, 114, 101, 112, 108,  97,  99, 101,  32, 105, 116,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101,
  112, 108,  32,  61,  32, 114, 101, 112, 108,  45,  62, 103, 115, 117,  98,  40,
   34,  40,  35,  42,  41,  40,  37, 115,  42,  41,  40,  34,  46,  46,  97, 114,
  103, 110,  97, 109, 101,  46,  46,  34,  41,  40,  91,  95,  37, 119,  93,  63,
   41,  34,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32,  40, 115,  49,
   44,  32, 115,  50,  44,  32, 115,  51,  44,  32, 115,  52,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,  35, 115,  52,  32,
   60,  61,  32,  48,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,
   40,  35, 115,  49,  32,  61,  61,  32,  49,  41,  32,  38,  38,  32,  40,  34,
   92,  34,  36,  34,  46,  46, 110, 111,  97, 114, 103, 115,  46,  46,  34,  92,
   34,  34,  41,  32, 124, 124,  32,  40, 115,  49,  46,  46, 115,  50,  46,  46,
   34,  36,  34,  46,  46, 110, 111,  97, 114, 103, 115,  41,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32, 115,  49,  46,  46, 115,  50,  46,  46, 115,  51,
   46,  46, 115,  52,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  47,  47,  32, 114, 101, 109, 111, 118, 101,  32,
   99, 111, 110,  99,  97, 116,  32,  40,  97, 102, 116, 101, 114,  32, 114, 101,
  112, 108,  97,  99, 101,  32, 109,  97, 116,  99, 104, 105, 110, 103,  32,  97,
  114, 103, 117, 109, 101, 110, 116,  32, 110,  97, 109, 101,  32, 116, 111,  32,
   36,  49,  44,  32,  36,  50,  44,  32,  46,  46,  46,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 114, 101, 112, 108,  32,  61,  32, 114, 101, 112, 108,
   45,  62, 103, 115, 117,  98,  40,  34,  37, 115,  42,  35,  35,  37, 115,  42,
   34,  44,  32,  34,  34,  41,  59,  10,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  47,  47,  32,  98, 117, 105, 108, 100,  32, 109,  97,  99, 114, 111,  32,
  102, 117, 110,  99, 105, 111, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 102, 117, 110,  99,  32,  61,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40, 105, 110, 112, 117, 116,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116,
  117, 114, 110,  32, 105, 110, 112, 117, 116,  45,  62, 103, 115, 117,  98,  40,
  110,  97, 109, 101,  46,  46,  34,  37, 115,  42,  40,  37,  98,  40,  41,  41,
   34,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32,  40, 109,  97, 116,
   99, 104,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101,
  116, 117, 114, 110,  32, 114, 101, 112, 108,  97,  99, 101,  65, 114, 103, 115,
   40, 109,  97, 116,  99, 104,  44,  32, 114, 101, 112, 108,  41,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  59,  10,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 110,  97,
  109, 101,  44,  32, 102, 117, 110,  99,  44,  32, 114, 101, 112, 108,  59,  10,
  125,  10,  10,  10,  47,  47,  32,  45,  45,  45,  45,  45,  45,  45,  45,  45,
   45,  45,  45,  10,  47,  47,  32,  80,  82,  69,  32,  73,  78,  84,  69,  82,
   70,  65,  67,  69,  10,  47,  47,  32,  45,  45,  45,  45,  45,  45,  45,  45,
   45,  45,  45,  45,  10,  10,  47,  47,  45,  32, 105, 110, 105, 116, 105,  97,
  108, 105, 101, 115,  32,  97,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115,
  115, 111, 114,  32, 115, 116,  97, 116, 101,  46,  32, 110, 111, 116,  32, 110,
  101, 101, 100, 101, 100,  32, 109,  97, 110, 117,  97, 108, 108, 121,  46,  32,
  104,  97, 110, 100, 121,  32, 102, 111, 114,  32, 116, 101, 115, 116, 105, 110,
  103,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 112, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 111, 114,  46, 105, 110, 105, 116,  40, 105, 110, 112,
  117, 116,  44,  32, 112, 114, 101, 100, 101, 102, 105, 110, 101, 115,  44,  32,
  109,  97,  99, 114, 111,  95, 115, 111, 117, 114,  99, 101, 115,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  99, 114, 101,  97,
  116, 101,  32, 115,  97, 116, 101,  32, 118,  97, 114,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 118,  97, 114,  32, 115, 116,  97, 116, 101,  32,  32,  32,
   32,  32,  61,  32, 123, 125,  59,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32, 105, 110, 105, 116,  32, 116, 104, 101,
   32, 115, 116,  97, 116, 101,  32, 111,  98, 106, 101,  99, 116,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,  46, 100, 101, 102, 105,
  110, 101, 115,  32,  32,  32,  61,  32, 123, 125,  59,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 116, 104, 101,  32,
  116,  97,  98, 108, 101,  32, 111, 102,  32, 107, 110, 111, 119, 110,  32, 100,
  101, 102, 105, 110, 101, 115,  32,  97, 110, 100,  32, 114, 101, 112, 108,  97,
   99, 101, 109, 101, 110, 116, 115,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  115, 116,  97, 116, 101,  46, 115,  99, 114, 101, 101, 110, 101, 114,  32,  32,
   61,  32, 115,  99, 114, 101, 101, 110, 101, 114,  40, 105, 110, 112, 117, 116,
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,
   46, 108, 105, 110, 101, 110, 111,  32,  32,  32,  32,  61,  32,  48,  59,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32, 116, 104, 101,  32,  99, 117, 114, 114, 101, 110, 116,  32, 108, 105, 110,
  101,  32, 110, 117, 109,  98, 101, 114,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 115, 116,  97, 116, 101,  46, 115, 116,  97,  99, 107,  32,  32,  32,  32,
   32,  61,  32, 123, 125,  59,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32, 115, 116, 111, 114, 101, 115,  32, 119, 101,
  116, 104, 101, 114,  32, 116, 104, 101,  32,  99, 117, 114, 114, 101, 110, 116,
   32, 115, 116,  97,  99, 107,  32, 108, 101, 118, 101, 108,  32, 105, 115,  32,
  116, 111,  32,  98, 101,  32, 105, 110,  99, 108, 117, 100, 101, 100,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,  46, 111, 110,  99,
  101,  32,  32,  32,  32,  32,  32,  61,  32, 123, 125,  59,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 115, 116,  97,
   99, 107,  32, 108, 101, 118, 101, 108,  32, 119,  97, 115,  32, 111, 110,  99,
  101,  32, 116, 114, 117, 101,  32,  40, 102, 105, 114, 115, 116,  32, 105, 102,
   32, 116, 104,  97, 116,  32, 101, 118,  97, 108, 115,  32, 116, 111,  32, 116,
  114, 117, 101,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116,  97,
  116, 101,  46, 109,  97,  99, 114, 111,  95, 115, 111, 117, 114,  99, 101, 115,
   32,  61,  32, 109,  97,  99, 114, 111,  95, 115, 111, 117, 114,  99, 101, 115,
   32, 124, 124,  32, 123, 125,  59,  32,  47,  47,  32, 111, 114, 105, 103, 105,
  110,  97, 108,  32, 114, 101, 112, 108,  97,  99, 101, 109, 101, 110, 116,  32,
  116, 101, 120, 116,  32, 102, 111, 114,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  97, 108,  32, 109,  97,  99, 114, 111,  32,  10,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32, 102, 117, 110,  99, 115,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 115, 116,  97, 116, 101,  46, 100, 101, 102, 105, 110,
  101,  32,  61,  32, 100, 101, 102, 105, 110, 101,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 115, 116,  97, 116, 101,  46, 117, 110, 100, 101, 102, 105,
  110, 101,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 115, 116,
   97, 116, 101,  44,  32, 107, 101, 121,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116,
  101,  45,  62, 100, 101, 102, 105, 110, 101,  40, 107, 101, 121,  44,  32, 110,
  117, 108, 108,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,  46, 109,  97,  99, 114,
  111,  95, 115, 111, 117, 114,  99, 101, 115,  91, 107, 101, 121,  93,  32,  61,
   32, 110, 117, 108, 108,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,  46,
  100, 101, 102, 105, 110, 101, 100,  32,  61,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  40, 115, 116,  97, 116, 101,  44,  32, 107, 101, 121,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 114, 101, 116, 117, 114, 110,  32, 115, 116,  97, 116, 101,  46, 100, 101,
  102, 105, 110, 101, 115,  91, 107, 101, 121,  93,  32,  33,  61,  32, 110, 117,
  108, 108,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,  46,  97, 112, 112,
  108, 121,  32,  61,  32,  97, 112, 112, 108, 121,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 115, 116,  97, 116, 101,  46, 105, 110,  99, 108, 117, 100,
  101,  70, 105, 108, 101,  32,  61,  32, 105, 110,  99, 108, 117, 100, 101,  70,
  105, 108, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116,  97,
  116, 101,  46, 100, 111,  87, 111, 114, 107,  32,  61,  32, 100, 111,  87, 111,
  114, 107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116,
  101,  46, 103, 101, 116,  73, 110, 100, 101, 110, 116,  32,  61,  32, 102, 117,
  110,  99, 116, 105, 111, 110,  40, 115, 116,  97, 116, 101,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  32,  35, 115, 116,  97, 116, 101,  46, 115, 116,
   97,  99, 107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,  46, 111, 112,
  101, 110,  66, 108, 111,  99, 107,  32,  61,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  40, 115, 116,  97, 116, 101,  44,  32,  98, 111, 111, 108,  41,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 115, 116,  97, 116, 101,  46, 115, 116,  97,  99, 107,  91,  35, 115,
  116,  97, 116, 101,  46, 115, 116,  97,  99, 107,  43,  49,  93,  32,  61,  32,
   98, 111, 111, 108,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,  46, 111, 110,  99, 101,
   32,  91,  35, 115, 116,  97, 116, 101,  46, 111, 110,  99, 101,  43,  49,  93,
   32,  32,  61,  32,  98, 111, 111, 108,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,  45,
   62, 100, 101, 102, 105, 110, 101,  40,  80,  82,  69,  95,  73,  78,  68,  69,
   78,  84,  44,  32, 115, 116,  97, 116, 101,  45,  62, 103, 101, 116,  73, 110,
  100, 101, 110, 116,  40,  41,  44,  32, 116, 114, 117, 101,  41,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 115, 116,  97, 116, 101,  46, 101, 108, 115, 101,  66, 108, 111,  99,
  107,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 115, 116,  97,
  116, 101,  44,  32,  98, 111, 111, 108,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,
  115, 116,  97, 116, 101,  46, 111, 110,  99, 101,  91,  35, 115, 116,  97, 116,
  101,  46, 111, 110,  99, 101,  93,  32,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 115, 116,  97, 116, 101,  46, 115, 116,  97,  99, 107,  91,
   35, 115, 116,  97, 116, 101,  46, 115, 116,  97,  99, 107,  93,  32,  61,  32,
  102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,  46, 115, 116,
   97,  99, 107,  91,  35, 115, 116,  97, 116, 101,  46, 115, 116,  97,  99, 107,
   93,  32,  61,  32,  98, 111, 111, 108,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  40,  32,  98, 111, 111, 108,  32,  41,  32, 123,  32, 115,
  116,  97, 116, 101,  46, 111, 110,  99, 101,  91,  35, 115, 116,  97, 116, 101,
   46, 111, 110,  99, 101,  93,  32,  61,  32, 116, 114, 117, 101,  59,  32, 125,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,  46,  99, 108, 111, 115,
  101,  66, 108, 111,  99, 107,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  40, 115, 116,  97, 116, 101,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,
   46, 115, 116,  97,  99, 107,  91,  35, 115, 116,  97, 116, 101,  46, 115, 116,
   97,  99, 107,  93,  32,  61,  32, 110, 117, 108, 108,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116,  97,
  116, 101,  46, 111, 110,  99, 101,  32,  91,  35, 115, 116,  97, 116, 101,  46,
  111, 110,  99, 101,  93,  32,  32,  61,  32, 110, 117, 108, 108,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115,
  116,  97, 116, 101,  45,  62, 100, 101, 102, 105, 110, 101,  40,  80,  82,  69,
   95,  73,  78,  68,  69,  78,  84,  44,  32, 115, 116,  97, 116, 101,  45,  62,
  103, 101, 116,  73, 110, 100, 101, 110, 116,  40,  41,  44,  32, 116, 114, 117,
  101,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  40,  32, 115, 116,  97, 116, 101,  45,  62, 103,
  101, 116,  73, 110, 100, 101, 110, 116,  40,  41,  32,  60,  32,  48,  32,  41,
   32, 123,  32, 101, 114, 114, 111, 114,  40,  34,  85, 110, 111, 112, 101, 110,
  101, 100,  32,  98, 108, 111,  99, 107,  32, 100, 101, 116, 101,  99, 116, 101,
  100,  46,  32,  73, 110, 100, 101, 110, 116,  97, 105, 111, 110,  32, 112, 114,
  111,  98, 108, 101, 109,  46,  34,  41,  59,  32, 125,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 115,
  116,  97, 116, 101,  46, 115, 107, 105, 112,  32,  61,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  40, 115, 116,  97, 116, 101,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111,
  114,  40,  32, 105,  32,  61,  32,  49,  44,  32,  35, 115, 116,  97, 116, 101,
   46, 115, 116,  97,  99, 107,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 102,  40,  32,  33,  32, 115, 116,  97, 116, 101,  46, 115,
  116,  97,  99, 107,  91, 105,  93,  32,  41,  32, 123,  32, 114, 101, 116, 117,
  114, 110,  32, 105,  59,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,
   46, 103, 101, 116,  76, 105, 110, 101,  32,  61,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40, 115, 116,  97, 116, 101,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116,  97,
  116, 101,  46, 108, 105, 110, 101, 110, 111,  32,  61,  32, 115, 116,  97, 116,
  101,  46, 108, 105, 110, 101, 110, 111,  32,  43,  32,  49,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116,
   97, 116, 101,  45,  62, 100, 101, 102, 105, 110, 101,  40,  76,  73,  78,  69,
   44,  32, 115, 116,  97, 116, 101,  46, 108, 105, 110, 101, 110, 111,  44,  32,
  116, 114, 117, 101,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 115, 116,
   97, 116, 101,  46, 115,  99, 114, 101, 101, 110, 101, 114,  40,  41,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 115, 116,  97, 116, 101,  46, 112, 114, 101, 112,  97, 114, 101,
   77,  97,  99, 114, 111,  32,  61,  32, 112, 114, 101, 112,  97, 114, 101,  77,
   97,  99, 114, 111,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116,
   97, 116, 101,  46, 112,  97, 114, 115, 101,  69, 120, 112, 114,  32,  61,  32,
  112,  97, 114, 115, 101,  69, 120, 112, 114,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 115, 116,  97, 116, 101,  46, 112,  97, 114, 115, 101,  70, 117,
  110,  99, 116, 105, 111, 110,  32,  61,  32, 112,  97, 114, 115, 101,  70, 117,
  110,  99, 116, 105, 111, 110,  59,  10,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  47,  47,  32, 112, 114, 101, 100, 101, 102, 105, 110, 101, 115,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,  45,  62, 100, 101,
  102, 105, 110, 101,  40,  68,  65,  84,  69,  44,  32, 111, 115,  46, 100,  97,
  116, 101,  40,  34,  37,  66,  32,  37, 100,  32,  37,  89,  34,  41,  44,  32,
  116, 114, 117, 101,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 115,
  116,  97, 116, 101,  45,  62, 100, 101, 102, 105, 110, 101,  40,  84,  73,  77,
   69,  44,  32, 111, 115,  46, 100,  97, 116, 101,  40,  34,  37,  72,  58,  37,
   77,  58,  37,  83,  34,  41,  44,  32, 116, 114, 117, 101,  41,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,  45,  62, 100, 101,
  102, 105, 110, 101,  40,  76,  73,  78,  69,  44,  32, 115, 116,  97, 116, 101,
   46, 108, 105, 110, 101, 110, 111,  44,  32, 116, 114, 117, 101,  41,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101,  45,  62, 100,
  101, 102, 105, 110, 101,  40,  80,  82,  69,  95,  73,  78,  68,  69,  78,  84,
   44,  32, 115, 116,  97, 116, 101,  45,  62, 103, 101, 116,  73, 110, 100, 101,
  110, 116,  40,  41,  44,  32, 116, 114, 117, 101,  41,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 112, 114, 101, 100, 101, 102, 105, 110, 101, 115,  32,
   61,  32, 112, 114, 101, 100, 101, 102, 105, 110, 101, 115,  32, 124, 124,  32,
  123, 125,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  40,
   32, 107,  44, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 112, 114,
  101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46,  69,  78,  86,  41,  32,
   41,  32, 123,  32, 115, 116,  97, 116, 101,  45,  62, 100, 101, 102, 105, 110,
  101,  40, 107,  44,  32, 118,  44,  32, 116, 114, 117, 101,  41,  59,  32, 125,
   32,  32,  32,  32,  47,  47,  32, 115, 116,  97, 116, 105,  99,  32, 111, 110,
  101, 115,  10,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  40,  32,
  107,  44, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 112, 114, 101,
  100, 101, 102, 105, 110, 101, 115,  41,  32,  41,  32, 123,  32,  32,  32,  32,
   32,  32,  32, 115, 116,  97, 116, 101,  45,  62, 100, 101, 102, 105, 110, 101,
   40, 107,  44,  32, 118,  44,  32, 116, 114, 117, 101,  41,  59,  32, 125,  10,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  46,  80,  82,  69,  95,  84,  69,
   83,  84,  32,  41,  32, 123,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115,
  115, 111, 114,  46,  83,  84,  65,  84,  69,  32,  61,  32, 115, 116,  97, 116,
  101,  59,  32, 125,  32,  47,  47,  32,  97,  99, 116, 105, 118,  97, 116, 101,
   32, 115, 116,  97, 116, 105,  99,  32, 115, 116,  97, 116, 101,  32, 100, 101,
   98, 117, 103, 103, 105, 110, 103,  10,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 114, 101, 116, 117, 114, 110,  32, 115, 116,  97, 116, 101,  59,  10, 125,
   10,  10,  47,  47,  45,  32, 116, 104, 101,  32, 112, 114, 101, 112, 114, 111,
   99, 101, 115, 115, 111, 114, 115,  32, 109,  97, 105, 110,  32, 102, 117, 110,
   99, 116, 105, 111, 110,  46,  10,  47,  47,  32, 114, 101, 116, 117, 114, 110,
  115,  32, 116, 104, 101,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,
  101, 100,  32, 111, 117, 116, 112, 117, 116,  32,  97, 115,  32,  97,  32, 115,
  116, 114, 105, 110, 103,  46,  10,  47,  47,  32,  64, 112,  97, 114,  97, 109,
   32,  99, 111, 100, 101,  32, 100,  97, 116,  97,  32,  97, 115,  32, 115, 116,
  114, 105, 110, 103,  10,  47,  47,  32,  64, 112,  97, 114,  97, 109,  32, 112,
  114, 101, 100, 101, 102, 105, 110, 101, 115,  32,  79,  80,  84,  73,  79,  78,
   65,  76,  32,  97,  32, 116,  97,  98, 108, 101,  32, 111, 102,  32, 112, 114,
  101, 100, 101, 102, 105, 110, 101, 100,  32, 118,  97, 114, 105,  97,  98, 108,
  101, 115,  10,  47,  47,  32,  64, 117, 115,  97, 103, 101,  32, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  46,  99, 111, 109, 112, 105, 108,
  101,  40,  34,  35, 100, 101, 102, 105, 110, 101,  32,  98,  97, 114,  32,  48,
  120,  49,  51,  51,  55,  92, 110, 115, 116,  97, 116, 105,  99,  32,  99, 111,
  110, 115, 116,  32, 105, 110, 116,  32, 102, 111, 111,  32,  61,  32,  98,  97,
  114,  59,  34,  41,  10,  47,  47,  32,  64, 117, 115,  97, 103, 101,  32, 112,
  114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46,  99, 111, 109, 112,
  105, 108, 101,  40,  34,  35, 100, 101, 102, 105, 110, 101,  32,  98,  97, 114,
   32,  48, 120,  49,  51,  51,  55,  92, 110, 115, 116,  97, 116, 105,  99,  32,
   99, 111, 110, 115, 116,  32, 105, 110, 116,  32, 102, 111, 111,  32,  61,  32,
   98,  97, 114,  59,  34,  44,  32, 123,  91,  34,  98,  97, 114,  34,  93,  32,
   61,  32,  34,  48, 120,  49,  51,  51,  56,  34, 125,  41,  10, 102, 117, 110,
   99, 116, 105, 111, 110,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,
  111, 114,  46,  99, 111, 109, 112, 105, 108, 101,  40,  99, 111, 100, 101,  44,
   32, 112, 114, 101, 100, 101, 102, 105, 110, 101, 115,  44,  32, 109,  97,  99,
  114, 111,  95, 115, 111, 117, 114,  99, 101, 115,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 115, 116,  97, 116, 101,  32,
   61,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46, 105,
  110, 105, 116,  40,  99, 111, 100, 101,  44,  32, 112, 114, 101, 100, 101, 102,
  105, 110, 101, 115,  44,  32, 109,  97,  99, 114, 111,  95, 115, 111, 117, 114,
   99, 101, 115,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32,  98, 117, 102,  32,  61,  32, 123, 125,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 102, 111, 114,  40,  32, 111, 117, 116, 112, 117, 116,  32,
  105, 110,  32, 115, 116,  97, 116, 101,  45,  62, 100, 111,  87, 111, 114, 107,
   40,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105, 110, 115,
  101, 114, 116,  40,  98, 117, 102,  44,  32, 111, 117, 116, 112, 117, 116,  41,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 118,  97, 114,  32, 111, 117, 116, 112, 117, 116,  32,  61,
   32, 116,  97,  98, 108, 101,  46,  99, 111, 110,  99,  97, 116,  40,  98, 117,
  102,  44,  32,  78,  69,  87,  76,  41,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  40,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,
  111, 114,  46,  68,  69,  66,  85,  71,  32,  41,  32, 123,  32, 112, 114, 105,
  110, 116,  40, 111, 117, 116, 112, 117, 116,  41,  59,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 111, 117, 116,
  112, 117, 116,  44,  32, 115, 116,  97, 116, 101,  59,  10, 125,  10,  10,  47,
   47,  45,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 101, 115,  32,
   97,  32, 102, 105, 108, 101,  10,  47,  47,  32,  64, 112,  97, 114,  97, 109,
   32, 102, 105, 108, 101, 110,  97, 109, 101,  32, 116, 104, 101,  32, 102, 105,
  108, 101,  32, 116, 111,  32, 114, 101,  97, 100,  10,  47,  47,  32,  64, 112,
   97, 114,  97, 109,  32, 112, 114, 101, 100, 101, 102, 105, 110, 101, 115,  32,
   79,  80,  84,  73,  79,  78,  65,  76,  32,  97,  32, 116,  97,  98, 108, 101,
   32, 111, 102,  32, 112, 114, 101, 100, 101, 102, 105, 110, 101, 100,  32, 118,
   97, 114, 105,  97,  98, 108, 101, 115,  10,  47,  47,  32,  64, 117, 115,  97,
  103, 101,  32, 111, 117, 116,  44,  32, 115, 116,  97, 116, 101,  32,  61,  32,
  112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46,  99, 111, 109,
  112, 105, 108, 101,  70, 105, 108, 101,  40,  34,  46,  46,  47, 111, 100,  98,
  103,  47, 112, 108, 117, 103, 105, 110,  46, 104,  34,  44,  32, 123,  91,  34,
   77,  65,  88,  95,  80,  65,  72,  34,  93,  61,  50,  54,  48,  44,  32,  91,
   34,  85,  78,  73,  67,  79,  68,  69,  34,  93,  61, 116, 114, 117, 101, 125,
   41,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 112, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 111, 114,  46,  99, 111, 109, 112, 105, 108, 101,  70,
  105, 108, 101,  40, 102, 105, 108, 101, 110,  97, 109, 101,  44,  32, 112, 114,
  101, 100, 101, 102, 105, 110, 101, 115,  44,  32, 109,  97,  99, 114, 111,  95,
  115, 111, 117, 114,  99, 101, 115,  44,  32, 110, 101, 120, 116,  44,  32,  95,
  108, 111,  99,  97, 108,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  40,  32,  33,  32, 102, 105, 108, 101, 110,  97, 109, 101,  32,
   41,  32, 123,  32, 101, 114, 114, 111, 114,  40,  34, 112, 114, 111,  99, 101,
  115, 115,  70, 105, 108, 101,  40,  41,  32,  97, 114, 103,  49,  32, 104,  97,
  115,  32, 116, 111,  32,  98, 101,  32,  97,  32, 115, 116, 114, 105, 110, 103,
   34,  41,  59,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32, 102, 105, 108, 101,  32,  61,  32, 105, 111,  46, 111, 112, 101, 110,
   40, 102, 105, 108, 101, 110,  97, 109, 101,  44,  32,  39, 114,  39,  41,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,  33,  32, 102,
  105, 108, 101,  32,  41,  32, 123,  32, 101, 114, 114, 111, 114,  40,  34, 102,
  105, 108, 101,  32, 110, 111, 116,  32, 102, 111, 117, 110, 100,  58,  32,  34,
   46,  46, 102, 105, 108, 101, 110,  97, 109, 101,  41,  59,  32, 125,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  99, 111, 100, 101,  32,
   61,  32, 102, 105, 108, 101,  45,  62, 114, 101,  97, 100,  40,  39,  42,  97,
   39,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 101, 100,
  101, 102, 105, 110, 101, 115,  32,  61,  32, 112, 114, 101, 100, 101, 102, 105,
  110, 101, 115,  32, 124, 124,  32, 123, 125,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 112, 114, 101, 100, 101, 102, 105, 110, 101, 115,  91,  70,  73,
   76,  69,  93,  32,  61,  32, 102, 105, 108, 101, 110,  97, 109, 101,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112,
  114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46,  99, 111, 109, 112,
  105, 108, 101,  40,  99, 111, 100, 101,  44,  32, 112, 114, 101, 100, 101, 102,
  105, 110, 101, 115,  44,  32, 109,  97,  99, 114, 111,  95, 115, 111, 117, 114,
   99, 101, 115,  41,  59,  10, 125,  10,  10,  10,  47,  47,  32,  45,  45,  45,
   45,  45,  45,  45,  45,  45,  45,  45,  45,  10,  47,  47,  32,  83,  65,  84,
   73,  67,  32,  85,  78,  73,  84,  32,  84,  69,  83,  84,  83,  10,  47,  47,
   32,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  10, 102, 117,
  110,  99, 116, 105, 111, 110,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115,
  115, 111, 114,  46, 116, 101, 115, 116,  40, 115, 117, 112, 112, 114, 101, 115,
  115,  77, 115, 103,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 116, 101, 115, 116,  76,  97,  98, 101, 108,  67, 111, 117,
  110, 116,  32,  61,  32,  48,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32, 103, 101, 116,
   84, 101, 115, 116,  76,  97,  98, 101, 108,  40,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  43,  43,
  116, 101, 115, 116,  76,  97,  98, 101, 108,  67, 111, 117, 110, 116,  32,  32,
   32,  32,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  34,  32, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  95,  97, 115, 115, 101, 114, 116,
   95,  34,  46,  46, 116, 101, 115, 116,  76,  97,  98, 101, 108,  67, 111, 117,
  110, 116,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 116, 104, 105, 115,  32, 117,
  103, 108, 121,  32, 103, 108, 111,  98,  97, 108,  32, 105, 115,  32, 114, 101,
  113, 117, 105, 114, 101, 100,  32, 115, 111,  32, 111, 117, 114,  32, 116, 101,
  115, 116,  99, 111, 100, 101,  32,  99,  97, 110,  32, 102, 105, 110, 100,  32,
  105, 116,  10,  32,  32,  32,  32,  32,  32,  32,  32,  95,  71,  46, 112, 114,
  101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  95, 116, 101, 115, 116,  32,
   61,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  97, 115, 115, 101, 114, 116,  84, 114, 117, 101,  67,  97,
  108, 108, 115,  32,  61,  32,  48,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  97, 115, 115, 101, 114, 116,  84,
  114, 117, 101,  67, 111, 117, 110, 116,  32,  61,  32,  48,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  97, 115,
  115, 101, 114, 116,  84, 114, 117, 101,  32,  61,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  95, 116, 101, 115,
  116,  46,  97, 115, 115, 101, 114, 116,  84, 114, 117, 101,  67, 111, 117, 110,
  116,  32,  61,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,
   95, 116, 101, 115, 116,  46,  97, 115, 115, 101, 114, 116,  84, 114, 117, 101,
   67, 111, 117, 110, 116,  32,  43,  32,  49,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  59,  10,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 118,  97, 114,  32, 116, 101, 115, 116, 112, 114, 101, 112, 114, 111,  99,
  101, 115, 115, 111, 114,  32,  61,  32,  91,  61,  91,  93,  61,  93,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  46,  70,  65,  83,  84,  32,  61,  32, 102,  97, 108, 115,
  101,  59,  32,  32,  32,  32,  32,  32,  47,  47,  32, 101, 110,  97,  98, 108,
  101,  32, 102, 117, 108, 108,  32, 118,  97, 108, 105, 100,  32, 111, 117, 116,
  112, 117, 116,  32, 102, 111, 114,  32, 116, 101, 115, 116, 105, 110, 103,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  46,  83,  69,  76,  70,  95,  84,  69,  83,  84,  32,  61,
   32, 116, 114, 117, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32, 116, 101, 115, 116, 108, 117,  97,  32,  61,  32, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  46,  99, 111, 109, 112, 105, 108,
  101,  40, 116, 101, 115, 116, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,
  111, 114,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  46,  83,  69,  76,  70,  95,  84,
   69,  83,  84,  32,  61,  32, 110, 117, 108, 108,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110,
  116,  40, 116, 101, 115, 116, 108, 117,  97,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  97, 115, 115, 101, 114, 116,  40, 108, 111,  97, 100, 115, 116,
  114, 105, 110, 103,  40, 116, 101, 115, 116, 108, 117,  97,  44,  32,  34, 116,
  101, 115, 116, 108, 117,  97,  34,  41,  41,  40,  41,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111,
  114,  95, 116, 101, 115, 116,  46,  97, 115, 115, 101, 114, 116,  84, 114, 117,
  101,  67,  97, 108, 108, 115,  32,  61,  32, 102, 105, 110, 100, 110,  40, 116,
  101, 115, 116, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  44,
   32,  34, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  95, 116,
  101, 115, 116,  46,  97, 115, 115, 101, 114, 116,  84, 114, 117, 101,  40,  41,
   34,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  97, 115, 115, 101,
  114, 116,  40, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  95,
  116, 101, 115, 116,  46,  97, 115, 115, 101, 114, 116,  84, 114, 117, 101,  67,
  111, 117, 110, 116,  32,  61,  61,  32, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  95, 116, 101, 115, 116,  46,  97, 115, 115, 101, 114, 116,
   84, 114, 117, 101,  67,  97, 108, 108, 115,  44,  32,  34,  97, 115, 115, 101,
  114, 116,  84, 114, 117, 101,  32,  99,  97, 108, 108, 115,  58,  34,  46,  46,
  112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  95, 116, 101, 115,
  116,  46,  97, 115, 115, 101, 114, 116,  84, 114, 117, 101,  67,  97, 108, 108,
  115,  46,  46,  34,  32,  99, 111, 117, 110, 116,  58,  34,  46,  46, 112, 114,
  101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  95, 116, 101, 115, 116,  46,
   97, 115, 115, 101, 114, 116,  84, 114, 117, 101,  67, 111, 117, 110, 116,  41,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  95,  71,  46, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  95, 116, 101, 115, 116,  32,  61,
   32, 110, 117, 108, 108,  59,  32,  32,  32,  32,  47,  47,  32, 100, 101, 108,
  101, 116, 101,  32, 117, 103, 108, 121,  32, 103, 108, 111,  98,  97, 108,  32,
  104,  97,  99, 107,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,
   32,  33,  32, 115, 117, 112, 112, 114, 101, 115, 115,  77, 115, 103,  32,  41,
   32, 123,  32, 112, 114, 105, 110, 116,  40,  34,  84, 101, 115, 116,  32, 114,
  117, 110,  32, 115, 117, 115,  99, 101, 115, 115, 117, 108, 108, 121,  34,  41,
   59,  32, 125,  10, 125,  10, 105, 102,  40,  32, 112, 114, 101, 112, 114, 111,
   99, 101, 115, 115, 111, 114,  46,  80,  82,  69,  95,  84,  69,  83,  84,  32,
   41,  32, 123,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,
   46, 116, 101, 115, 116,  40, 116, 114, 117, 101,  41,  59,  32, 125,  10,  10,
   10,  47,  47,  32,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,
   10,  47,  47,  32,  82,  69,  71,  73,  83,  84,  69,  82,  32,  80,  82,  69,
   10,  47,  47,  32,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,
   10,  10,  47,  47,  45,  32, 100, 105, 115,  97,  98, 108, 101,  32, 112, 114,
  101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32, 112, 114, 111,  99, 101,
  115, 115, 105, 110, 103,  32, 102, 111, 114,  32, 102, 102, 105,  44,  32, 108,
  111,  97, 100, 115, 116, 114, 105, 110, 103,  32,  97, 110, 100,  32, 115, 117,
   99, 104,  10, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46,
  100, 105, 115,  97,  98, 108, 101,  32,  61,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  40,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  40,  32,  47,  42, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111,
  114,  46,  80,  82,  69,  95,  76,  85,  65,  42,  47,  32, 116, 114, 117, 101,
   32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32,  97,  99, 116, 105, 118,  97, 116, 101,
   32,  80,  82,  69,  95,  76,  85,  65,  32,  97,  99, 116, 117,  97, 108, 108,
  121,  32, 100, 111, 101, 115,  32,  97, 110, 121, 116, 104, 105, 110, 103,  32,
  117, 115, 101, 102, 117, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  95,  71,  46, 108, 111,  97,
  100, 115, 116, 114, 105, 110, 103,  32,  61,  32,  95,  71,  46, 108, 111,  97,
  100, 115, 116, 114, 105, 110, 103,  95, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  95,  98,  97,  99, 107, 117, 112,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  40,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46,
   80,  82,  69,  95,  70,  70,  73,  32,  38,  38,  32, 112,  99,  97, 108, 108,
   40, 114, 101, 113, 117, 105, 114, 101,  44,  32,  34, 102, 102, 105,  34,  41,
   32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 102, 102, 105,  32,  61,  32, 114, 101, 113, 117, 105,
  114, 101,  40,  34, 102, 102, 105,  34,  41,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 102,
  102, 105,  46, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  95,
   99, 100, 101, 102,  95,  98,  97,  99, 107, 117, 112,  32,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 102, 102, 105,  46,  99, 100, 101, 102,
   32,  61,  32, 102, 102, 105,  46, 112, 114, 101, 112, 114, 111,  99, 101, 115,
  115, 111, 114,  95,  99, 100, 101, 102,  95,  98,  97,  99, 107, 117, 112,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 102, 105,  46, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  95,  99, 100, 101, 102,  95,  98,
   97,  99, 107, 117, 112,  32,  61,  32, 110, 117, 108, 108,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  10, 125,  59,  10,  10,  47,  47,
   45,  32,  40, 114, 101,  41, 101, 110,  97,  98, 108, 101,  32, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  32, 112, 114, 111,  99, 101, 115,
  115, 105, 110, 103,  32, 102, 111, 114,  32, 102, 102, 105,  44,  32, 108, 111,
   97, 100, 115, 116, 114, 105, 110, 103,  32,  97, 110, 100,  32, 115, 117,  99,
  104,  10, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46, 101,
  110,  97,  98, 108, 101,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,
   40,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   85, 115, 101,  32,  80,  82,  69,  32, 116, 111,  32, 112, 114, 111,  99, 101,
  115, 115,  32,  76, 117,  97,  32,  99, 111, 100, 101,  32,  40, 108, 111,  97,
  100,  44,  32, 108, 111,  97, 100, 102, 105, 108, 101,  44,  32, 108, 111,  97,
  100, 115, 116, 114, 105, 110, 103,  46,  46,  46,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  40,  32,  47,  42, 112, 114, 101, 112, 114, 111,
   99, 101, 115, 115, 111, 114,  46,  80,  82,  69,  95,  76,  85,  65,  42,  47,
   32, 116, 114, 117, 101,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  84,  79,  68,
   79,  58,  32, 109,  97, 107, 101,  32, 105, 116,  32, 112, 114, 111, 112, 101,
  114, 108, 121,  32, 119, 111, 114, 107,  32, 111, 110,  32,  97, 108, 108,  32,
  102, 117, 110,  99, 116, 105, 111, 110, 115,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  95,  71,  46, 108, 111,  97,
  100, 115, 116, 114, 105, 110, 103,  95, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  95,  98,  97,  99, 107, 117, 112,  32,  61,  32,  95,  71,
   46, 108, 111,  97, 100, 115, 116, 114, 105, 110, 103,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  95,  71,  46,
  108, 111,  97, 100, 115, 116, 114, 105, 110, 103,  32,  61,  32, 102, 117, 110,
   99, 116, 105, 111, 110,  40, 115, 116, 114,  44,  32,  99, 104, 117, 110, 107,
   41,  32, 123,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116,
  117, 114, 110,  32, 108, 111,  97, 100, 115, 116, 114, 105, 110, 103,  95, 112,
  114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  95,  98,  97,  99, 107,
  117, 112,  40, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46,
   99, 111, 109, 112, 105, 108, 101,  40, 115, 116, 114,  41,  44,  32,  99, 104,
  117, 110, 107,  41,  59,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  85,
  115, 101,  32,  80,  82,  69,  32,  97, 115,  32,  76, 117,  97,  74,  73,  84,
   32,  80, 114, 101,  80, 114, 111,  99, 101, 115, 115, 111, 114,  32, 105, 102,
   32, 117, 115, 101, 100,  32, 105, 110, 115, 105, 100, 101,  32,  76, 117,  97,
   74,  73,  84,  46,  32, 105,  46, 101,  46,  32,  72, 111, 111, 107,  32, 102,
  102, 105,  46,  99, 100, 101, 102,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  40,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,
   46,  80,  82,  69,  95,  70,  70,  73,  32,  38,  38,  32, 112,  99,  97, 108,
  108,  40, 114, 101, 113, 117, 105, 114, 101,  44,  32,  34, 102, 102, 105,  34,
   41,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 102, 102, 105,  32,  61,  32, 114, 101, 113, 117,
  105, 114, 101,  40,  34, 102, 102, 105,  34,  41,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,
   33,  32, 102, 102, 105,  46, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,
  111, 114,  95,  99, 100, 101, 102,  95,  98,  97,  99, 107, 117, 112,  32,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,  33,
   32, 102, 102, 105,  46, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111,
  114,  95, 100, 101, 102, 115,  32,  41,  32, 123,  32, 102, 102, 105,  46, 112,
  114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  95, 100, 101, 102, 115,
   32,  61,  32, 123, 125,  59,  32, 125,  32,  47,  47,  32, 100, 101, 102, 115,
   32,  97, 114, 101,  32, 115, 116, 111, 114, 101, 100,  32,  97, 110, 100,  32,
  114, 101, 117, 115, 101, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102,
  102, 105,  46, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32,
   61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 110, 112, 117, 116,
   41,  32, 123,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 118,  97, 114,  32, 111, 117, 116, 112, 117, 116,  44,
   32, 115, 116,  97, 116, 101,  32,  61,  32, 112, 114, 101, 112, 114, 111,  99,
  101, 115, 115, 111, 114,  46,  99, 111, 109, 112, 105, 108, 101,  40, 105, 110,
  112, 117, 116,  44,  32, 102, 102, 105,  46, 112, 114, 101, 112, 114, 111,  99,
  101, 115, 115, 111, 114,  95, 100, 101, 102, 115,  44,  32, 102, 102, 105,  46,
  112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  95, 109,  97,  99,
  114, 111,  95, 115, 111, 117, 114,  99, 101, 115,  41,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 102, 105,
   46, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  95, 100, 101,
  102, 115,  32,  61,  32, 115, 116,  97, 116, 101,  46, 100, 101, 102, 105, 110,
  101, 115,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 102, 102, 105,  46, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  95, 109,  97,  99, 114, 111,  95, 115, 111, 117, 114,  99,
  101, 115,  32,  61,  32, 115, 116,  97, 116, 101,  46, 109,  97,  99, 114, 111,
   95, 115, 111, 117, 114,  99, 101, 115,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32, 111, 117, 116, 112, 117, 116,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 102, 105,  46,
  112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  95,  99, 100, 101,
  102,  95,  98,  97,  99, 107, 117, 112,  32,  61,  32, 102, 102, 105,  46,  99,
  100, 101, 102,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 102, 105,
   46,  99, 100, 101, 102,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,
   40, 105, 110, 112, 117, 116,  41,  32, 123,  32,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 116,
  114, 117, 101,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  32, 102, 102, 105,  46, 112, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 111, 114,  95,  99, 100, 101, 102,  95,  98,  97,  99,
  107, 117, 112,  40, 102, 102, 105,  46, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  40, 105, 110, 112, 117, 116,  41,  41,  59,  32,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   32, 101, 108, 115, 101,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 102, 110,  44,  99, 110, 116,  32,  61,  32, 105, 110, 112,
  117, 116,  45,  62, 103, 115, 117,  98,  40,  39,  35, 105, 110,  99, 108, 117,
  100, 101,  32,  91,  34,  60,  93,  46,  45,  40,  91,  94,  47,  93,  43,  37,
   46, 104,  41,  91,  34,  62,  93,  39,  44,  32,  39,  37,  49,  39,  41,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 110, 112, 117, 116,  32,  61,
   32, 102, 102, 105,  46, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111,
  114,  40, 105, 110, 112, 117, 116,  41,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  40,  32,  99, 110, 116,  32,  62,  32,  48,  32,  41,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32, 102,  32,  61,  32, 105, 111,  46, 111, 112, 101,
  110,  40,  34,  46,  47, 116, 109, 112,  47,  34,  46,  46, 102, 110,  44,  32,
   39, 119,  39,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 102,  32,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 102,  45,  62, 119, 114, 105, 116, 101,
   40, 105, 110, 112, 117, 116,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 102,  45,  62,  99, 108, 111, 115, 101,  40,  41,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101,
  108, 115, 101,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  97, 115,
  115, 101, 114, 116,  40, 102, 110,  45,  62, 102, 105, 110, 100,  40,  39,  47,
   39,  41,  44,  32,  39,  99,  97, 110, 110, 111, 116,  32, 111, 112, 101, 110,
   58,  32,  46,  47, 116, 109, 112,  47,  39,  46,  46, 102, 110,  41,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102, 102, 105,  46, 112,
  114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  95,  99, 100, 101, 102,
   95,  98,  97,  99, 107, 117, 112,  40, 105, 110, 112, 117, 116,  41,  59,  32,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  10, 125,  59,  10,  10, 112, 114,
  101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46, 101, 110,  97,  98, 108,
  101,  40,  41,  59,  10,  10,  47,  42,  32, 105, 110, 116, 101, 114, 102,  97,
   99, 101,  32,  42,  47,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 112,
  114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  58,  58,  73, 110, 116,
  101, 114, 102,  97,  99, 101,  40,  46,  46,  46,  41, 123,  10,  32,  32,  32,
   32,  97, 114, 103, 115,  32,  61,  32, 123,  46,  46,  46, 125,  59,  10,  10,
   32,  32,  32,  32,  47,  47,  32,  70, 105, 114, 115, 116,  32,  97, 114, 103,
   32, 115, 104, 111, 117, 108, 100,  32,  98, 101,  32,  97,  32, 102, 105, 108,
  101, 110,  97, 109, 101,  10,  32,  32,  32,  32, 102, 105, 108, 101, 110,  97,
  109, 101,  32,  61,  32,  97, 114, 103, 115,  91,  49,  93,  59,  10,  10,  32,
   32,  32,  32,  47,  47,  32,  83, 101,  99, 111, 110, 100,  32,  97, 114, 103,
   32, 119, 105, 108, 108,  32,  98, 101,  32, 102, 108,  97, 103, 115,  10,  32,
   32,  32,  32, 111, 117, 116, 102, 105, 108, 101,  32,  61,  32,  34,  34,  59,
   10,  10,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 114, 101, 109, 111,
  118, 101,  40,  97, 114, 103, 115,  44,  32,  49,  41,  59,  10,  32,  32,  32,
   32, 102, 108,  97, 103, 115,  32,  61,  32, 123, 125,  59,  10,  10,  32,  32,
   32,  32, 102, 111, 114,  32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,
   97, 105, 114, 115,  40,  97, 114, 103, 115,  41,  41, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 105, 102,  32,  40, 118,  32,  61,  61,  32,  34,  45,
  100,  34,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46,  68,  69,
   66,  85,  71,  32,  61,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 125, 101, 108, 115, 101,  32, 105, 102,  32,  40, 118,  32,
   61,  61,  32,  34,  45, 116,  34,  41, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,
  111, 114,  46,  80,  82,  69,  95,  84,  69,  83,  84,  32,  61,  32, 116, 114,
  117, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125, 101, 108, 115,
  101,  32, 105, 102,  32,  40, 118,  32,  61,  61,  32,  34,  45, 102,  34,  41,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114,
  101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46,  70,  65,  83,  84,  32,
   61,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  125, 101, 108, 115, 101,  32, 105, 102,  32,  40, 118,  32,  61,  61,  32,  34,
   45, 111,  34,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 111, 117, 116, 102, 105, 108, 101,  32,  61,  32,  97, 114, 103, 115,
   91, 105,  43,  49,  93,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,
  101, 108, 115, 101,  32, 105, 102,  32,  40, 118,  32,  61,  61,  32,  34,  45,
   68,  34,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 114, 101, 115, 116,  32,  61,  32, 118,  45,  62, 115, 117,  98,  40,  51,
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 107,
  101, 121,  32,  61,  32, 114, 101, 115, 116,  45,  62, 115, 117,  98,  40,  49,
   44,  32, 114, 101, 115, 116,  45,  62, 102, 105, 110, 100,  40,  34,  61,  34,
   41,  45,  49,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 108, 117, 101,  32,  61,  32, 114, 101, 115, 116,  45,  62,
  115, 117,  98,  40, 114, 101, 115, 116,  45,  62, 102, 105, 110, 100,  40,  34,
   61,  34,  41,  43,  49,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 102, 108,  97, 103, 115,  91, 107, 101, 121,  93,  32,  61,
   32, 118,  97, 108, 117, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  125, 101, 108, 115, 101,  32, 105, 102,  32,  40, 118,  32,  61,  61,  32,  34,
   45, 104,  34,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 112, 114, 105, 110, 116,  40,  34,  85, 115,  97, 103, 101,  58,  32,
   99, 111,  98,  97, 108, 116, 112, 114, 101,  32,  91, 102, 108,  97, 103, 115,
   93,  32,  60, 102, 105, 108, 101, 110,  97, 109, 101,  62,  34,  41,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110,
  116,  40,  34,  70, 108,  97, 103, 115,  58,  34,  41,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,  34,
   32,  32,  45, 100,  58,  32,  69, 110,  97,  98, 108, 101,  32, 100, 101,  98,
  117, 103,  32, 111, 117, 116, 112, 117, 116,  34,  41,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,  34,
   32,  32,  45, 116,  58,  32,  82, 117, 110,  32, 117, 110, 105, 116,  32, 116,
  101, 115, 116, 115,  34,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 112, 114, 105, 110, 116,  40,  34,  32,  32,  45, 102,  58,
   32,  69, 110,  97,  98, 108, 101,  32, 102,  97, 115, 116,  32, 109, 111, 100,
  101,  34,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 112, 114, 105, 110, 116,  40,  34,  32,  32,  45, 111,  58,  32,  79, 117,
  116, 112, 117, 116,  32, 116, 111,  32, 102, 105, 108, 101,  34,  41,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110,
  116,  40,  34,  32,  32,  45, 104,  58,  32,  83, 104, 111, 119,  32, 116, 104,
  105, 115,  32, 104, 101, 108, 112,  34,  41,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  32,
   32,  32,  32,  10,  32,  32,  32,  32,  47,  42,  32, 114, 117, 110,  32,  42,
   47,  10,  32,  32,  32,  32,  99, 111, 109, 112, 105, 108, 101, 100,  32,  61,
   32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46,  99, 111,
  109, 112, 105, 108, 101,  70, 105, 108, 101,  40, 102, 105, 108, 101, 110,  97,
  109, 101,  44,  32, 102, 108,  97, 103, 115,  41,  59,  10,  10,  32,  32,  32,
   32, 105, 102,  32,  40, 111, 117, 116, 102, 105, 108, 101,  32,  61,  61,  32,
   34,  34,  32, 124, 124,  32,  33, 111, 117, 116, 102, 105, 108, 101,  41, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114,  40,  34,
   78, 111,  32, 102, 105, 108, 101,  32, 116, 111,  32, 111, 117, 116, 112, 117,
  116,  32, 116, 111,  34,  41,  59,  10,  32,  32,  32,  32, 125, 101, 108, 115,
  101, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 102, 105, 108, 101,  32,
   61,  32, 105, 111,  46, 111, 112, 101, 110,  40, 111, 117, 116, 102, 105, 108,
  101,  44,  32,  34, 119,  34,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 102, 105, 108, 101,  45,  62, 119, 114, 105, 116, 101,  40,  99, 111, 109,
  112, 105, 108, 101, 100,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  102, 105, 108, 101,  45,  62,  99, 108, 111, 115, 101,  40,  41,  59,  10,  32,
   32,  32,  32, 125,  10, 125,  10,  10, 114, 101, 116, 117, 114, 110,  32, 112,
  114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  59,   0
};

#define AOT_LUAOPEN_NAME luaopen_preprocess
#define EXTERNAL LUALIB_API
#include "aot_footer.c"
