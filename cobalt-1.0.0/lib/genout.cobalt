// Cobalt library for generating HTML based on code analysis
// @AsynchronousAI
// @cobaltlang
// 2023-08-10

// INIT \\
var isJit = jit != nil
var dump = isJit ? require("jit.dump") : nil
// GENERATOR \\
var Generator
{
   var original = [=[<head>
   <style>
      body {
         background-color: rgb(15,15,15);
         color: rgb(220,220,220);
         font-family: "Sofia", sans-serif;
      }
   </style>
   </head>

   <h1 id="-filename-">{filename}</h1>
   <blockquote>
   <p style="color:#808080">Autogenerated by cobalt</p>
   </blockquote>
   <h2 id="stats">stats</h2>
   <ul>
   <li>{totalspeed} seconds for execution</li>
   <li><span style="color: yellow;">{lintissues}</span> linter issues</li>
   <li><span style="color: red;">{compileissue}</span> runtime issues</li>
   <li>{plat} target</li>
   <li>{type}</li>
   </ul>
   <hr>
   <h2 id="issues">issues</h2>
   <p>{issues}</p>
   <h2 id="source">source</h2>
   <pre><code class="lang-js"><span class="hljs-built_in">{source}</span>
   </code></pre>
   <h2 id="-filename-">./{filename}</h2>
   <pre><code class="lang-js"><span class="hljs-built_in">{output}</span>
   </code></pre>
   <h1 id="trace-1">trace 1</h1>
   <blockquote>
   <p>{traceinfo}</p>
   </blockquote>
   <table>
   <thead>
   <tr>
   <th>Bytecode</th>
   <th>IR</th>
   <th>mcode</th>
   </tr>
   </thead>
   <tbody>
   <tr>
   <td><code>{bytecode}</code></td>
   <td><code>{ir}</code></td>
   <td><code>{mcode}</code></td>
   </tr>
   </tbody>
   </table>
   <h1 id="bytecode">bytecode</h1>
   <pre><code class="lang-js">{interpreterbytecode}
   </code></pre>
   <h2 id="requires">requires</h2>
   <p>{requires}</p>
   <h2 id="variables">variables</h2>
   <p>{variables}</p>
   ]=]

   var isInterpreted = false

   function isin(x, y){
      // X is a string, same with Y. Returns true if Y is in X
      //return x->find(y) != nil
      return x == y
   }
   function generateHTML(args: table){
      var HTML = original
      // Remove JITSTART-JITEND if isInterpreted is false, otherwise remove INTERPRETERSTART-INTERPRETEREND
      var lines = {}
      var off = false
      for (line in original->gmatch("[^\n]+")) {
         //if (isJit ? isin(line,  "<!--INTERPRETERSTART -->") : isin(line, "<!--JITSTART -->")){
         //   off = true
         //} else if (off){
            // Dont add
         //} else if (isJit ? isin(line, "<!--INTERPRETEREND -->") : isin(line, "<!--JITEND -->")){
         //  off = false
            // Dont add
         //} else {
            table.insert(lines, line)
            // add
         //}
      }

      // Join lines
      var newHTML = ""
      for (i, v in pairs(lines)){
         newHTML = newHTML.. v.."\n"
      }
      HTML = newHTML

      // Replace all items in the table
      for (i, v in pairs(args)){
         var str = "{"..i.."}"

         HTML = HTML->gsub(str, v)
      }

      return HTML
   }

   function generateSpeedBlame(blame: table, str: string){
      // Split by lines
      var lines = {}
      for (line in str->gmatch("[^\n]+")) {
         table.insert(lines, line)
      }

      // Add a blame to start of each line
      for (i, v in pairs(lines)){
         var sstr = string.format("<span style=\"color: rgb(%s);\">|</span>", tostring(blame[i][1])..", "..tostring(blame[i][2])..", "..tostring(blame[i][3]))
         lines[i] = sstr..v
      }

      // Connect the lines and return it
      var newstr = ""
      for (i, v in pairs(lines)){
         newstr = newstr.. v.."\n"
      }
      return newstr
   }
   function htmlize(array: table){
      // Converts inputted `array` to a HTML list
      var str = "<ul>\n"
      for (i, v in pairs(array)){
         str = str.."<li>"..v.."</li>\n"
      }
      str = str.."</ul>"
      return str
   }
   Generator = {
      "htmlize": htmlize,
      "generateHTML": generateHTML,
      "generateSpeedBlame": generateSpeedBlame,
   }
}

// DATA COLLECTOR \\
var DataCollector
{
   // DUAL \\
   function getDevice(){
      return os.getenv("PROCESSOR_ARCHITECTURE") || os.getenv("USERPROFILE") || os.getenv("PROCESSOR_IDENTIFIER") || os.getenv("PROCESSOR_LEVEL") || os.getenv("PROCESSOR_REVISION") || os.getenv("NUMBER_OF_PROCESSORS") || os.getenv("OS") || os.getenv("COMPUTERNAME") || os.getenv("USERDOMAIN") || os.getenv("USERNAME") || os.getenv("USERDNSDOMAIN") || os.getenv("USERDOMAIN_ROAMINGPROFILE") || os.getenv("USERPROFILE") || os.getenv("HOMEDRIVE") || os.getenv("HOMEPATH") || os.getenv("HOMESHARE") || os.getenv("LOGONSERVER") || os.getenv("SESSIONNAME") || "Not found"
   }
   if (isJit){
      // JIT \\
      function dumpfun(outfile){
         outfile = os.getenv("LUAJIT_DUMPFILE")
         dump.start()

         // Collect the data of outfile and then clear it
         var data = outfile->read("*a")
         outfile->close()
         outfile->open("w")
         outfile->write("")
         outfile->close()


         return data
      }
   }else{
      // INTERPRETER \\

   }

   // ASSIGN \\
   DataCollector = {
      "getDevice": getDevice,
      "dump": dumpfun,
   }
}
// TEST \\

print(Generator.generateHTML({
   "filename": "test.cobalt",
   "totalspeed": "0.00000",
   "issues": htmlize(["Issue1", "Issue2", "Issue3"]),
   "compileissue": "0",
   "plat": DataCollector.getDevice(),
   "type": isJit ? "JIT" : "Interpreter",
   "traceinfo": "test.cobalt:1:1",
   "bytecode": isJit ? DataCollector.dump() : "JIT NOT ENABLED",
   "ir": isJit ? "0x0000000000000000" : "JIT NOT ENABLED",
   "mcode": isJit ? "0x0000000000000000" : "JIT NOT ENABLED",
   "interpreterbytecode": isJit ? "JIT ENABLED" : "0x0000000000000000",
   "requires": "0",
   "variables": "0",
   "source": generateSpeedBlame([ [255,0,0] ], "print(\"Hello World\")"),
   "lintissues": "0",
}))