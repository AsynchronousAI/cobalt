var table = require ('ext.table');

// classes

var function newmember(class, ...) {
	var obj = setmetatable({}, class);
	if( obj.init ) { return obj, obj->init(...); }
	return obj;
}

var classmeta = {
	__call = function(this, ...) {
// [[ normally:
		return this->new(...);
//]]
/* if you want to keep track of all instances
		local results = table.pack(self:new(...))
		local obj = results[1]
		self.instances[obj] = true
		return results:table.unpack()
--*/
	},
};

// usage: class:isa(obj)
//  so it's not really a member method, since the object doesn't come first, but this way we can use it as Class:isa(obj) and not worry about nils or local closures
var function isa(cl, obj) {
	assert(cl, "isa: argument 1 is nil, should be the class object");	// isa(nil, anything) errors, because it should always have a class in the 1st arg
	if( type(obj) != 'table' ) { return false; }	// class:isa(not a table) will return false
	if( ! obj.isaSet ) { return false; }	// not an object generated by class(), so it doesn't have a set of all classes that it "is-a"
	return obj.isaSet[cl] || false;	// returns true if the 'isaSet' of the object's metatable (its class) holds the calling class
}

var function class(...) {
	var cl = table(...);
	cl.class = cl;

	cl.super = ...;	// .super only stores the first.  the rest can be accessed by iterating .isaSet's keys

	// I was thinking of calling this '.superSet', but it is used for 'isa' which is true for its own class, so this is 'isaSet'
	cl.isaSet = {[cl] = true};
	for( i=1,select('#', ...) ) {
		var parent = select(i, ...);
		if( parent != null ) {
			cl.isaSet[parent] = true;
			if( parent.isaSet ) {
				for( grandparent,_ in pairs(parent.isaSet) ) {
					cl.isaSet[grandparent] = true;
				}
			}
		}
	}

	// store 'descendantSet' as well that gets appended when we call class() on this obj?
	for( ancestor,_ in pairs(cl.isaSet) ) {
		ancestor.descendantSet = ancestor.descendantSet || {};
		ancestor.descendantSet[cl] = true;
	}

	cl.__index = cl;
	cl.new = newmember;
	cl.isa = isa;	// usage: Class:isa(obj)
	cl.subclass = class;     // such that cl:subclass() or cl:subclass{...} will return a subclass of 'cl'

/* if you want to keep track of all instances
	cl.instances = setmetatable({}, {__mode = 'k'})
--*/

	setmetatable(cl, classmeta);
	return cl;
}

return class;
