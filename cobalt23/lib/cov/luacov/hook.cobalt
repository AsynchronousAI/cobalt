//----------------------
// Hook module, creates debug hook used by LuaCov.
// @class module
// @name luacov.hook
var hook = {};

//--------------------------------------------------------------
var dir_sep = package.config->sub(1, 1);
if( ! dir_sep->find("[/\\]") ) {
   dir_sep = "/";
}

//- Creates a new debug hook.
// @param runner runner module.
// @return debug hook function that uses runner fields and functions
// and sets `runner.data`.
function hook.new(runner) {
   var ignored_files = {};
   var steps_after_save = 0;

   return function(_, line_nr, level) {
      // Do not use string metamethods within the debug hook:
      // they may be absent if it's called from a sandboxed environment
      // or because of carelessly implemented monkey-patching.
      level = level || 2;
      if( ! runner.initialized ) {
         return;
      }

      // Get name of processed file.
      var name = debug.getinfo(level, "S").source;
      var prefixed_name = string.match(name, "^@(.*)");
      if( prefixed_name ) {
         name = prefixed_name->gsub("^%.[/\\]", "")->gsub("[/\\]", dir_sep);
      } else if( ! runner.configuration.codefromstrings ) {
         // Ignore Lua code loaded from raw strings by default.
         return;
      }

      var data = runner.data;
      var file = data[name];

      if( ! file ) {
         // New or ignored file.
         if( ignored_files[name] ) {
            return;
         } else if( runner.file_included(name) ) {
            file = {max = 0, max_hits = 0};
            data[name] = file;
         } else {
            ignored_files[name] = true;
            return;
         }
      }

      if( line_nr > file.max ) {
         file.max = line_nr;
      }

      var hits = (file[line_nr] || 0) + 1;
      file[line_nr] = hits;

      if( hits > file.max_hits ) {
         file.max_hits = hits;
      }

      if( runner.tick ) {
         ++steps_after_save    ;

         if( steps_after_save == runner.configuration.savestepsize ) {
            steps_after_save = 0;

            if( ! runner.paused ) {
               runner.save_stats();
            }
         }
      }
   };
}

return hook;
