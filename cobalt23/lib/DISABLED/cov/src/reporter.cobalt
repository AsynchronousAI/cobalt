//----------------------
// Report module, will transform statistics file into a report.
// @class module
// @name luacov.reporter
var reporter = {};

var LineScanner = require("cov.src.linescanner");
var luacov = require("cov.src.runner");
var util = require("cov.src.util");
var lfs_ok, lfs = pcall(require, "lfs");

//--------------------------------------------------------------
var dir_sep = package.config->sub(1, 1);
if( ! dir_sep->find("[/\\]") ) {
   dir_sep = "/";
}


//- returns all files inside dir
//- @param dir directory to be listed
//- @treturn table with filenames and attributes
var function dirtree(dir) {
   assert(dir && dir != "", "Please pass directory parameter");
   if( dir->sub(-1)->match("[/\\]") ) {
       dir=string.sub(dir, 1, -2);
   }

   dir = dir->gsub("[/\\]", dir_sep);

   var function yieldtree(directory) {
       for( entry in lfs.dir(directory) ) {
           if( entry != "." && entry != ".." ) {
               entry=directory..dir_sep..entry;
               var attr=lfs.attributes(entry);
               coroutine.yield(entry,attr);
               if( attr.mode == "directory" ) {
                   yieldtree(entry);
               }
           }
       }
   }

   return coroutine.wrap(function() { yieldtree(dir); });
}

//--------------------------------------------------------------
//- checks if string 'filename' has pattern 'pattern'
//- @param filename
//- @param pattern
//- @return boolean
var function fileMatches(filename, pattern) {
   return string.find(filename, pattern);
}

//--------------------------------------------------------------
//- Basic reporter class stub.
// Implements 'new', 'run' and 'close' methods required by `report`.
// Provides some helper methods and stubs to be overridden by child classes.
// @usage
// local MyReporter = setmetatable({}, ReporterBase)
// MyReporter.__index = MyReporter
// function MyReporter:on_hit_line(...)
//    self:write(("File %s: hit line %s %d times"):format(...))
// end
// @type ReporterBase
var ReporterBase = {}; {
ReporterBase.__index = ReporterBase;

function ReporterBase::new(conf) {
   var stats = require("cov.src.stats");
   var data = stats.load(conf.statsfile);

   if( ! data ) {
      return null, "Could not load stats file " .. conf.statsfile .. ".";
   }

   var files = {};
   var filtered_data = {};
   var max_hits = 0;

   // Several original paths can map to one real path,
   // their stats should be merged in this case.
   for( filename, file_stats in pairs(data) ) {
      if( luacov.file_included(filename) ) {
         filename = luacov.real_name(filename);

         if( filtered_data[filename] ) {
            luacov.update_stats(filtered_data[filename], file_stats);
         } else {
            table.insert(files, filename);
            filtered_data[filename] = file_stats;
         }

         max_hits = math.max(max_hits, filtered_data[filename].max_hits);
      }
   }

   // including files without tests
   // only .lua files
   if( conf.includeuntestedfiles ) {
      if( ! lfs_ok ) {
         print("The option includeuntestedfiles requires the lfs module (from luafilesystem) to be installed.");
         os.exit(1);
      }

      var function add_empty_file_coverage_data(file_path) {

         // Leading "./" must be trimmed from the file paths because the paths of tested
         // files do not have a leading "./" either
         if( (file_path->match("^%.[/\\]")) ) {
            file_path = file_path->sub(3);
         }

         if( luacov.file_included(file_path) ) {
            var file_stats = {
               max = 0,
               max_hits = 0
            };

            var filename = luacov.real_name(file_path);

            if( ! filtered_data[filename] ) {
               table.insert(files, filename);
               filtered_data[filename] = file_stats;
            }
         }

      }

      var function add_empty_dir_coverage_data(directory_path) {

         for( filename, attr in dirtree(directory_path) ) {
            if( attr.mode == "file" && fileMatches(filename, '.%.lua$') ) {
               add_empty_file_coverage_data(filename);
            }
         }

      }

      if( (conf.includeuntestedfiles == true) ) {
        add_empty_dir_coverage_data("." .. dir_sep);

      } else if( (type(conf.includeuntestedfiles) == "table" && conf.includeuntestedfiles[1]) ) {
         for( _, include_path in ipairs(conf.includeuntestedfiles) ) {
            if( (fileMatches(include_path, '.%.lua$')) ) {
               add_empty_file_coverage_data(include_path);
            } else {
               add_empty_dir_coverage_data(include_path);
            }
         }
      }

   }

   table.sort(files);

   var out, err = io.open(conf.reportfile, "w");
   if( ! out ) { return null, err; }

   var o = setmetatable({
      _out  = out,
      _cfg  = conf,
      _data = filtered_data,
      _files = files,
      _mhit = max_hits,
   }, this);

   return o;
}

//- Returns configuration table.
// @see luacov.defaults
function ReporterBase::config() {
   return this._cfg;
}

//- Returns maximum number of hits per line in all coverage data.
function ReporterBase::max_hits() {
   return this._mhit;
}

//- Writes strings to report file.
// @param ... strings.
function ReporterBase::write(...) {
   return this._out->write(...);
}

function ReporterBase::close() {
   this._out->close();
   this._private = null;
}

//- Returns array of filenames to be reported.
function ReporterBase::files() {
   return this._files;
}

//- Returns coverage data for a file.
// @param filename name of the file.
// @see luacov.stats.load
function ReporterBase::stats(filename) {
   return this._data[filename];
}

// Stub methods follow.
// luacheck: push no unused args

//- Stub method called before reporting.
function ReporterBase::on_start() {
}

//- Stub method called before processing a file.
// @param filename name of the file.
function ReporterBase::on_new_file(filename) {
}

//- Stub method called if a file couldn't be processed due to an error.
// @param filename name of the file.
// @param error_type "open", "read" or "load".
// @param message error message.
function ReporterBase::on_file_error(filename, error_type, message) {
}

//- Stub method called for each empty source line
// and other lines that can't be hit.
// @param filename name of the file.
// @param lineno line number.
// @param line the line itself as a string.
function ReporterBase::on_empty_line(filename, lineno, line) {
}

//- Stub method called for each missed source line.
// @param filename name of the file.
// @param lineno line number.
// @param line the line itself as a string.
function ReporterBase::on_mis_line(filename, lineno, line) {
}

//- Stub method called for each hit source line.
// @param filename name of the file.
// @param lineno line number.
// @param line the line itself as a string.
// @param hits number of times the line was hit. Should be positive.
function ReporterBase::on_hit_line(filename, lineno, line, hits) {
}

//- Stub method called after a file has been processed.
// @param filename name of the file.
// @param hits total number of hit lines in the file.
// @param miss total number of missed lines in the file.
function ReporterBase::on_end_file(filename, hits, miss) {
}

//- Stub method called after reporting.
function ReporterBase::on_end() {
}

// luacheck: pop

var cluacov_ok = pcall(require, "cluacov.version");
var deepactivelines;

if( cluacov_ok ) {
   deepactivelines = require("cluacov.deepactivelines");
}

function ReporterBase::_run_file(filename) {
   var file, open_err = io.open(filename);

   if( ! file ) {
      this->on_file_error(filename, "open", util.unprefix(open_err, filename .. ": "));
      return;
   }

   var active_lines;

   if( cluacov_ok ) {
      var src, read_err = file->read("*a");

      if( ! src ) {
         this->on_file_error(filename, "read", read_err);
         return;
      }

      src = src->gsub("^#![^\n]*", "");
      var func, load_err = util.load_string(src, null, "@file");

      if( ! func ) {
         this->on_file_error(filename, "load", "line " .. util.unprefix(load_err, "file:"));
         return;
      }

      active_lines = deepactivelines.get(func);
      file->seek("set");
   }

   this->on_new_file(filename);
   var file_hits, file_miss = 0, 0;
   var filedata = this->stats(filename);

   var line_nr = 1;
   var scanner = LineScanner->new();

   while( true ) {
      var line = file->read("*l");
      if( ! line ) { break; }

      var always_excluded, excluded_when_not_hit = scanner->consume(line);
      var hits = filedata[line_nr] || 0;
      var included = ! always_excluded && (! excluded_when_not_hit || hits != 0);

      if( cluacov_ok ) {
         included = included && active_lines[line_nr];
      }

      if( included ) {
         if( hits == 0 ) {
            this->on_mis_line(filename, line_nr, line);
            ++file_miss    ;
         } else {
            this->on_hit_line(filename, line_nr, line, hits);
            ++file_hits    ;
         }
      } else {
         this->on_empty_line(filename, line_nr, line);
      }

      ++line_nr    ;
   }

   file->close();
   this->on_end_file(filename, file_hits, file_miss);
}

function ReporterBase::run() {
   this->on_start();

   for( _, filename in ipairs(this->files()) ) {
      this->_run_file(filename);
   }

   this->on_end();
}

}
//- @section end
//--------------------------------------------------------------

//--------------------------------------------------------------
var DefaultReporter = setmetatable({}, ReporterBase); {
DefaultReporter.__index = DefaultReporter;

function DefaultReporter::on_start() {
   var most_hits = this->max_hits();
   var most_hits_length = #("%d")->format(most_hits);

   this._summary      = {};
   this._empty_format = (" ")->rep(most_hits_length + 1);
   this._zero_format  = ("*")->rep(most_hits_length).."0";
   this._count_format = ("%% %dd")->format(most_hits_length+1);
   this._printed_first_header = false;
}

function DefaultReporter::on_new_file(filename) {
   this->write(("=")->rep(78), "\n");
   this->write(filename, "\n");
   this->write(("=")->rep(78), "\n");
}

function DefaultReporter::on_file_error(filename, error_type, message) { //luacheck: no self
   io.stderr->write(("Couldn't %s %s: %s\n")->format(error_type, filename, message));
}

function DefaultReporter::on_empty_line(_, _, line) {
   if( line == "" ) {
      this->write("\n");
   } else {
      this->write(this._empty_format, " ", line, "\n");
   }
}

function DefaultReporter::on_mis_line(_, _, line) {
   this->write(this._zero_format, " ", line, "\n");
}

function DefaultReporter::on_hit_line(_, _, line, hits) {
   this->write(this._count_format->format(hits), " ", line, "\n");
}

function DefaultReporter::on_end_file(filename, hits, miss) {
   this._summary[filename] = { hits = hits, miss = miss };
   this->write("\n");
}

var function coverage_to_string(hits, missed) {
   var total = hits + missed;

   if( total == 0 ) {
      total = 1;
   }

   return ("%.2f%%")->format(hits/total*100.0);
}

function DefaultReporter::on_end() {
   this->write(("=")->rep(78), "\n");
   this->write("Summary\n");
   this->write(("=")->rep(78), "\n");
   this->write("\n");

   var lines = {{"File", "Hits", "Missed", "Coverage"}};
   var total_hits, total_missed = 0, 0;

   for( _, filename in ipairs(this->files()) ) {
      var summary = this._summary[filename];

      if( summary ) {
         var hits, missed = summary.hits, summary.miss;

         table.insert(lines, {
            filename,
            tostring(summary.hits),
            tostring(summary.miss),
            coverage_to_string(hits, missed)
         });

         total_hits +=   hits;
         total_missed +=   missed;
      }
   }

   table.insert(lines, {
      "Total",
      tostring(total_hits),
      tostring(total_missed),
      coverage_to_string(total_hits, total_missed)
   });

   var max_column_lengths = {};

   for( _, line in ipairs(lines) ) {
      for( column_nr, column in ipairs(line) ) {
         max_column_lengths[column_nr] = math.max(max_column_lengths[column_nr] || -1, #column);
      }
   }

   var table_width = #max_column_lengths - 1;

   for( _, column_length in ipairs(max_column_lengths) ) {
      table_width +=   column_length;
   }


   for( line_nr, line in ipairs(lines) ) {
      if( line_nr == #lines || line_nr == 2 ) {
         this->write(("-")->rep(table_width), "\n");
      }

      for( column_nr, column in ipairs(line) ) {
         this->write(column);

         if( column_nr == #line ) {
            this->write("\n");
         } else {
            this->write((" ")->rep(max_column_lengths[column_nr] - #column + 1));
         }
      }
   }
}

}
//--------------------------------------------------------------

//- Runs the report generator.
// To load a config, use `luacov.runner.load_config` first.
// @param[opt] reporter_class custom reporter class. Will be
// instantiated using 'new' method with configuration
// (see `luacov.defaults`) as the argument. It should
// return nil + error if something went wrong.
// After acquiring a reporter object its 'run' and 'close'
// methods will be called.
// The easiest way to implement a custom reporter class is to
// extend `ReporterBase`.
function reporter.report(reporter_class) {
   var configuration = luacov.load_config();

   reporter_class = reporter_class || DefaultReporter;

   var rep, err = reporter_class->new(configuration);

   if( ! rep ) {
      print(err);
      print("Run your Lua program with -lluacov and then rerun luacov.");
      os.exit(1);
   }

   rep->run();

   rep->close();

   if( configuration.deletestats ) {
      os.remove(configuration.statsfile);
   }
}

reporter.ReporterBase    = ReporterBase;

reporter.DefaultReporter = DefaultReporter;

return reporter;
