/* ============================================================================== //
// This file is apart of the Cobalt Programming Language. Cobalt is under the MIT //
// License. Read `cobalt.h` for license information.                              //
// ============================================================================== */

#include "../aot_header.c" // changed by developer

// source = @init.cobalt
// main function
static
CallInfo *magic_implementation_00(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
    case 132: goto label_132;
    case 133: goto label_133;
    case 134: goto label_134;
    case 135: goto label_135;
    case 136: goto label_136;
    case 137: goto label_137;
    case 138: goto label_138;
    case 139: goto label_139;
    case 140: goto label_140;
    case 141: goto label_141;
    case 142: goto label_142;
    case 143: goto label_143;
  }

  // 0	[1]	VARARGPREP	0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000051);
    ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));
    if (l_unlikely(trap)) {  /* previous "Protect" updated trap */
      luaD_hookcall(L, ci);
      L->oldpc = 1;  /* next opcode will be seen as a "new" line */
    }
    updatebase(ci);  /* function has new base after adjustment */
  }

  // 1	[12]	GETTABUP 	0 0 1	; _ENV "file"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0100000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[12]	SETTABUP 	0 0 0	; _ENV "filesystem"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0000000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 3	[13]	GETTABUP 	0 0 3	; _ENV "import"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0300000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[13]	LOADK    	1 4	; "ext.file"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00020083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[13]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[13]	SETTABUP 	0 2 0	; _ENV "filex"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0002000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 7	[15]	CLOSURE  	0 0	; 0x7fbced0044c0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0000004f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 8	[15]	SETTABUP 	0 5 0	; _ENV "macros"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0005000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 9	[41]	CLOSURE  	0 1	; 0x7fbced004550
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0000804f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 10	[17]	SETTABUP 	0 6 0	; _ENV "switch"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0006000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 11	[70]	NEWTABLE 	0 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000013);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 12	[70]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 13	[70]	SETTABUP 	0 7 0	; _ENV "dead"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0007000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 14	[86]	CLOSURE  	0 2	; 0x7fbced004f50
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0001004f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 15	[73]	SETTABUP 	0 8 0	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x0008000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 16	[119]	CLOSURE  	0 3	; 0x7fbced0051a0
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0001804f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 17	[88]	SETTABUP 	0 9 0	; _ENV "tabletostring"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0009000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 18	[132]	CLOSURE  	0 4	; 0x7fbced006030
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0002004f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 19	[120]	SETTABUP 	0 10 0	; _ENV "loadenv"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000a000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 20	[135]	NEWTABLE 	0 6 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00060013);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 21	[135]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 22	[139]	CLOSURE  	1 5	; 0x7fbced0062d0
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000280cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 23	[139]	SETFIELD 	0 12 1	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x010c0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 24	[142]	CLOSURE  	1 6	; 0x7fbced006420
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x000300cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 25	[142]	SETFIELD 	0 13 1	; "pos"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x010d0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 26	[145]	CLOSURE  	1 7	; 0x7fbced0065b0
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x000380cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 27	[145]	SETFIELD 	0 14 1	; "neg"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x010e0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 28	[148]	CLOSURE  	1 8	; 0x7fbced0067c0
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x000400cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 29	[148]	SETFIELD 	0 15 1	; "posint"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x010f0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 30	[151]	CLOSURE  	1 9	; 0x7fbced004e50
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x000480cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 31	[151]	SETFIELD 	0 16 1	; "negint"
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x01100012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 32	[155]	CLOSURE  	1 10	; 0x7fbced006bd0
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x000500cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 33	[155]	SETFIELD 	0 17 1	; "pointer"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x01110012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 34	[163]	CLOSURE  	1 11	; 0x7fbced006f20
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x000580cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 35	[163]	SETFIELD 	0 18 1	; "array"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x01120012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 36	[171]	CLOSURE  	1 12	; 0x7fbced007070
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x000600cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 37	[171]	SETFIELD 	0 19 1	; "matrix"
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x01130012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 38	[175]	CLOSURE  	1 13	; 0x7fbced007240
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x000680cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 39	[175]	SETFIELD 	0 20 1	; "Vector3"
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x01140012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 40	[179]	CLOSURE  	1 14	; 0x7fbced007450
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x000700cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 41	[179]	SETFIELD 	0 21 1	; "Vector2"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x01150012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 42	[183]	CLOSURE  	1 15	; 0x7fbced007660
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x000780cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 43	[183]	SETFIELD 	0 22 1	; "Color"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x01160012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 44	[187]	CLOSURE  	1 16	; 0x7fbced0079e0
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x000800cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 45	[187]	SETFIELD 	0 23 1	; "Transform"
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x01170012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 46	[191]	CLOSURE  	1 17	; 0x7fbced007bb0
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x000880cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 47	[191]	SETFIELD 	0 24 1	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x01180012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 48	[195]	CLOSURE  	1 18	; 0x7fbced007d00
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x000900cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 49	[195]	SETFIELD 	0 25 1	; "boolean"
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x01190012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 50	[199]	CLOSURE  	1 19	; 0x7fbced007e90
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x000980cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 51	[199]	SETFIELD 	0 26 1	; "table"
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x011a0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 52	[203]	CLOSURE  	1 20	; 0x7fbced008020
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x000a00cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 53	[203]	SETFIELD 	0 27 1	; "function"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x011b0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 54	[207]	CLOSURE  	1 21	; 0x7fbced0081b0
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x000a80cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 55	[207]	SETFIELD 	0 28 1	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x011c0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 56	[211]	CLOSURE  	1 22	; 0x7fbced008340
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x000b00cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 57	[211]	SETFIELD 	0 29 1	; "thread"
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x011d0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 58	[215]	CLOSURE  	1 23	; 0x7fbced0084d0
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x000b80cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 59	[215]	SETFIELD 	0 30 1	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x011e0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 60	[219]	CLOSURE  	1 24	; 0x7fbced008660
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x000c00cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 61	[219]	SETFIELD 	0 31 1	; "char"
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x011f0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 62	[224]	CLOSURE  	1 25	; 0x7fbced006910
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x000c80cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 63	[224]	SETFIELD 	0 32 1	; "msg"
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x01200012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 64	[229]	CLOSURE  	1 26	; 0x7fbced0087f0
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x000d00cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 65	[229]	SETFIELD 	0 33 1	; "complex"
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x01210012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 66	[234]	CLOSURE  	1 27	; 0x7fbced008c10
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x000d80cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 67	[234]	SETFIELD 	0 34 1	; "directory"
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x01220012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 68	[239]	CLOSURE  	1 28	; 0x7fbced008ce0
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x000e00cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 69	[239]	SETFIELD 	0 35 1	; "lock"
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x01230012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 70	[243]	CLOSURE  	1 29	; 0x7fbced008e70
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x000e80cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 71	[243]	SETFIELD 	0 36 1	; "protected"
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x01240012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 72	[248]	CLOSURE  	1 30	; 0x7fbced009000
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x000f00cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 73	[248]	SETFIELD 	0 37 1	; "_LUABOX"
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x01250012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 74	[252]	CLOSURE  	1 31	; 0x7fbced009190
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x000f80cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 75	[252]	SETFIELD 	0 38 1	; "any"
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x01260012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 76	[256]	CLOSURE  	1 32	; 0x7fbced0078e0
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x001000cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 77	[256]	SETFIELD 	0 39 1	; "thread"
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x01270012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 78	[260]	CLOSURE  	1 33	; 0x7fbced009520
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x001080cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 79	[260]	SETFIELD 	0 40 1	; "int"
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x01280012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 80	[264]	CLOSURE  	1 34	; 0x7fbced0096b0
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x001100cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 81	[264]	SETFIELD 	0 41 1	; "float"
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x01290012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 82	[268]	CLOSURE  	1 35	; 0x7fbced009840
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x001180cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 83	[268]	SETFIELD 	0 42 1	; "double"
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x012a0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 84	[269]	SETTABUP 	0 11 0	; _ENV "types"
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x000b000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 85	[270]	NEWTABLE 	0 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x00000013);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 86	[270]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 87	[270]	SETTABUP 	0 43 0	; _ENV "alltypes"
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x002b000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 88	[272]	GETTABUP 	0 0 44	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x2c00000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 89	[272]	GETTABUP 	1 0 11	; _ENV "types"
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x0b00008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 90	[272]	CALL     	0 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x05020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 91	[272]	TFORPREP 	0 5	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x0002804b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_97;
  }

  // 92	[273]	GETTABUP 	6 0 45	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x2d00030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 93	[273]	GETFIELD 	6 6 46	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x2e06030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 94	[273]	GETTABUP 	7 0 43	; _ENV "alltypes"
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x2b00038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 95	[273]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 96	[273]	CALL     	6 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x01030344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 97	[272]	TFORCALL 	0 2
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x0200004c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 98	[272]	TFORLOOP 	0 7	; to 93
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x0003804d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_92; /* jump back */
    }
  }

  // 99	[274]	CLOSE    	0
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x00000036);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 100	[289]	CLOSURE  	0 36	; 0x7fbced009a50
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x0012004f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 101	[277]	SETTABUP 	0 47 0	; _ENV "deffind"
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x002f000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 102	[304]	CLOSURE  	0 37	; 0x7fbced009f00
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x0012804f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 103	[290]	SETTABUP 	0 48 0	; _ENV "assign"
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x0030000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 104	[316]	CLOSURE  	0 38	; 0x7fbced00a2e0
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x0013004f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 105	[305]	SETTABUP 	0 49 0	; _ENV "findfunctions"
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x0031000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 106	[330]	CLOSURE  	0 39	; 0x7fbced00a580
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x0013804f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 107	[317]	SETTABUP 	0 50 0	; _ENV "allassign"
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x0032000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 108	[342]	CLOSURE  	0 40	; 0x7fbced00a990
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x0014004f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 109	[331]	SETTABUP 	0 51 0	; _ENV "findall"
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x0033000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 110	[368]	CLOSURE  	0 41	; 0x7fbced00aca0
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x0014804f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 111	[343]	SETTABUP 	0 52 0	; _ENV "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x0034000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 112	[390]	CLOSURE  	0 42	; 0x7fbced00b0b0
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x0015004f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 113	[369]	SETTABUP 	0 53 0	; _ENV "clean"
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x0035000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 114	[393]	GETTABUP 	0 0 55	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x3700000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 115	[393]	SETTABUP 	0 54 0	; _ENV "typeof"
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x0036000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 116	[415]	CLOSURE  	0 43	; 0x7fbced00ba00
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x0015804f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 117	[394]	SETTABUP 	0 56 0	; _ENV "check"
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x0038000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 118	[457]	CLOSURE  	0 44	; 0x7fbced00c0c0
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x0016004f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 119	[418]	SETTABUP 	0 57 0	; _ENV "typecheck"
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x0039000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 120	[464]	CLOSURE  	0 45	; 0x7fbced0054c0
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x0016804f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 121	[458]	SETTABUP 	0 58 0	; _ENV "all"
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x003a000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 122	[466]	NEWTABLE 	0 3 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x00030013);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 123	[466]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 124	[467]	GETTABUP 	1 0 58	; _ENV "all"
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x3a00008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 125	[467]	SETFIELD 	0 58 1	; "all"
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x013a0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 126	[468]	GETTABUP 	1 0 57	; _ENV "typecheck"
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x3900008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 127	[468]	SETFIELD 	0 60 1	; "check"
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x013c0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 128	[469]	GETTABUP 	1 0 61	; _ENV "clean"
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x3d00008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 129	[469]	SETFIELD 	0 61 1	; "clean"
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x013d0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 130	[470]	GETTABUP 	1 0 52	; _ENV "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_132
  label_130: {
    aot_vmfetch(0x3400008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 131	[470]	SETFIELD 	0 52 1	; "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_133
  label_131: {
    aot_vmfetch(0x01340012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 132	[471]	SETTABUP 	0 59 0	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 133)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_134
  label_132: {
    aot_vmfetch(0x003b000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 133	[511]	CLOSURE  	0 46	; 0x7fbced008b10
  #undef  AOT_PC
  #define AOT_PC (code + 134)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_135
  label_133: {
    aot_vmfetch(0x0017004f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 134	[496]	SETTABUP 	0 62 0	; _ENV "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 135)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_136
  label_134: {
    aot_vmfetch(0x003e000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 135	[524]	CLOSURE  	0 47	; 0x7fbced00cf30
  #undef  AOT_PC
  #define AOT_PC (code + 136)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_137
  label_135: {
    aot_vmfetch(0x0017804f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 136	[513]	SETTABUP 	0 63 0	; _ENV "find"
  #undef  AOT_PC
  #define AOT_PC (code + 137)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_138
  label_136: {
    aot_vmfetch(0x003f000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 137	[618]	CLOSURE  	0 48	; 0x7fbced00d160
  #undef  AOT_PC
  #define AOT_PC (code + 138)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_139
  label_137: {
    aot_vmfetch(0x0018004f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 138	[618]	SETTABUP 	0 64 0	; _ENV "ext"
  #undef  AOT_PC
  #define AOT_PC (code + 139)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_140
  label_138: {
    aot_vmfetch(0x0040000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 139	[1225]	CLOSURE  	0 49	; 0x7fbced00da40
  #undef  AOT_PC
  #define AOT_PC (code + 140)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_141
  label_139: {
    aot_vmfetch(0x0018804f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 140	[662]	SETTABUP 	0 65 0	; _ENV "process"
  #undef  AOT_PC
  #define AOT_PC (code + 141)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_142
  label_140: {
    aot_vmfetch(0x0041000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 141	[1228]	GETTABUP 	0 0 66	; _ENV "process"
  #undef  AOT_PC
  #define AOT_PC (code + 142)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_143
  label_141: {
    aot_vmfetch(0x4200000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 142	[1228]	RETURN   	0 2 1	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 143)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_142: {
    aot_vmfetch(0x01028046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 143	[1228]	RETURN   	0 1 1	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 144)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_143: {
    aot_vmfetch(0x01018046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 15 - 15
static
CallInfo *magic_implementation_01(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
  }

  // 0	[15]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_00: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 17 - 41
static
CallInfo *magic_implementation_02(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
  }

  // 0	[18]	GETTABUP 	2 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[18]	MOVE     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00010180);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[18]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[18]	EQK      	2 1 1	; "table"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0001813c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[18]	JMP      	3	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_08;
  }

  // 5	[19]	GETTABUP 	2 0 2	; _ENV "error"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[19]	LOADK    	3 3	; "Switch expects a table as the second argument"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[19]	CALL     	2 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x01020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[22]	GETTABLE 	2 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0001010c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 9	[22]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_25
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 10	[22]	JMP      	14	; to 26
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x800006b8);
    updatetrap(ci);
    goto label_25;
  }

  // 11	[23]	GETTABUP 	2 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[23]	GETTABLE 	3 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0001018c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 13	[23]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[23]	EQK      	2 4 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_21
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0004013c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 15	[23]	JMP      	5	; to 22
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_21;
  }

  // 16	[24]	GETTABUP 	2 0 5	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0500010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[24]	GETTABLE 	3 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0001018c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 18	[24]	CALL     	2 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x01020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[25]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_25
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 20	[26]	JMP      	4	; to 26
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_25;
  }

  // 21	[27]	GETTABLE 	2 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0001010c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 22	[27]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 23	[27]	CALL     	2 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x01020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[28]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 25	[31]	GETFIELD 	2 1 6	; "default"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x0601010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 26	[31]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 27	[31]	JMP      	14	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x800006b8);
    updatetrap(ci);
    goto label_42;
  }

  // 28	[32]	GETTABUP 	2 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 29	[32]	GETFIELD 	3 1 6	; "default"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0601018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 30	[32]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 31	[32]	EQK      	2 4 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_38
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x0004013c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 32	[32]	JMP      	5	; to 39
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_38;
  }

  // 33	[33]	GETTABUP 	2 0 5	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x0500010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 34	[33]	GETFIELD 	3 1 6	; "default"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x0601018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 35	[33]	CALL     	2 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x01020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 36	[34]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 37	[35]	JMP      	4	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_42;
  }

  // 38	[36]	GETFIELD 	2 1 6	; "default"
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x0601010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 39	[36]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 40	[36]	CALL     	2 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x01020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 41	[37]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 42	[40]	GETTABUP 	2 0 7	; _ENV "warn"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0700010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[40]	LOADK    	3 8	; "Switch cannot find a case for "
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x00040183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 44	[40]	GETTABUP 	4 0 9	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x0900020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 45	[40]	MOVE     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x00000280);
    setobjs2s(L, ra, RB(i));
  }

  // 46	[40]	CALL     	4 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x02020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 47	[40]	LOADK    	5 10	; " and no default case was provided"
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00050283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 48	[40]	CONCAT   	3 3
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x000301b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 49	[40]	CALL     	2 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_49: {
    aot_vmfetch(0x01020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 50	[41]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_50: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 73 - 86
static
CallInfo *magic_implementation_03(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
  }

  // 0	[74]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[74]	LOADK    	4 1	; "\027[1;31mTypechecker error:\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[74]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[75]	TEST     	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 4	[75]	JMP      	6	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_11;
  }

  // 5	[76]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[76]	LOADK    	4 2	; "\027[1;31m"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[76]	MOVE     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000280);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[76]	LOADK    	6 3	; "\027[0m\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00018303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[76]	CONCAT   	4 3
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00030235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 10	[76]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 11	[78]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[78]	LOADK    	4 4	; "\027[1;31mSnippet:\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00020203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[78]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[79]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 15	[79]	GETTABUP 	4 0 5	; _ENV "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x0500020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 16	[79]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[79]	CALL     	4 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[79]	CALL     	3 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x010001c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[80]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_30
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 20	[80]	JMP      	9	; to 31
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_30;
  }

  // 21	[81]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 22	[81]	LOADK    	4 6	; "\n\027[1;31mTypechecker provided note:\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00030203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 23	[81]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[82]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 25	[82]	LOADK    	4 7	; "\n\027[1;31m"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00038203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 26	[82]	MOVE     	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00020280);
    setobjs2s(L, ra, RB(i));
  }

  // 27	[82]	LOADK    	6 8	; "\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00040303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 28	[82]	CONCAT   	4 3
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00030235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 29	[82]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 30	[84]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 31	[84]	LOADK    	4 9	; "\n\027[1;31mStopping Typechecker.\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x00048203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 32	[84]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 33	[85]	GETTABUP 	3 0 10	; _ENV "os"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x0a00018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 34	[85]	GETFIELD 	3 3 11	; "exit"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x0b03018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 35	[85]	CALL     	3 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_35: {
    aot_vmfetch(0x010101c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 36	[86]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_36: {
    aot_vmfetch(0x000101c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 88 - 119
static
CallInfo *magic_implementation_04(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
  }

  // 0	[90]	LOADK    	1 0	; "{"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[91]	GETTABUP 	2 0 1	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[91]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[91]	CALL     	2 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x05020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[91]	TFORPREP 	2 62	; to 68
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x001f014b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_67;
  }

  // 5	[92]	TEST     	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000083c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 6	[92]	JMP      	1	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_08;
  }

  // 7	[93]	LOADK    	7 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00010383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 8	[95]	GETTABUP 	8 0 3	; _ENV "loadstring"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0300040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 9	[95]	LOADK    	9 4	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00020483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 10	[95]	TESTSET  	10 7 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00078543);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 11	[95]	JMP      	1	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_13;
  }

  // 12	[95]	LOADK    	10 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00010503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[95]	CONCAT   	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000204b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 14	[95]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 15	[95]	TESTSET  	7 8 1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_25
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000883c3);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 16	[95]	JMP      	8	; to 26
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_25;
  }

  // 17	[95]	GETTABUP 	8 0 5	; _ENV "loadenv"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0500040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 18	[95]	LOADK    	9 4	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00020483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 19	[95]	TESTSET  	10 7 1
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00078543);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 20	[95]	JMP      	1	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_22;
  }

  // 21	[95]	LOADK    	10 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00010503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 22	[95]	CONCAT   	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000204b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 23	[95]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[95]	MOVE     	7 8
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00080380);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[96]	GETTABUP 	8 0 6	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x0600040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 26	[98]	CLOSURE  	9 0	; 0x7fbced005710
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x000004cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 27	[107]	CLOSURE  	10 1	; 0x7fbced0057a0
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0000854f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 28	[96]	CALL     	8 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x01030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 29	[109]	GETTABUP 	8 0 7	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0700040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 30	[109]	MOVE     	9 7
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00070480);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[109]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[109]	EQK      	8 8 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x0008043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 33	[109]	JMP      	8	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_42;
  }

  // 34	[110]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 35	[110]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 36	[110]	LOADK    	10 9	; " = \""
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00048503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 37	[110]	MOVE     	11 7
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00070580);
    setobjs2s(L, ra, RB(i));
  }

  // 38	[110]	LOADK    	12 10	; "\","
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00050603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 39	[110]	CONCAT   	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00050435);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 40	[110]	MOVE     	1 8
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_66
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00080080);
    setobjs2s(L, ra, RB(i));
  }

  // 41	[111]	JMP      	24	; to 67
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x80000bb8);
    updatetrap(ci);
    goto label_66;
  }

  // 42	[111]	GETTABUP 	8 0 7	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0700040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[111]	MOVE     	9 7
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x00070480);
    setobjs2s(L, ra, RB(i));
  }

  // 44	[111]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 45	[111]	EQK      	8 11 0	; "table"
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_57
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000b043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 46	[111]	JMP      	10	; to 58
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_57;
  }

  // 47	[112]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 48	[112]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 49	[112]	LOADK    	10 12	; " = "
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00060503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 50	[112]	GETTABUP 	11 0 13	; _ENV "tabletostring"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0d00058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 51	[112]	MOVE     	12 7
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00070600);
    setobjs2s(L, ra, RB(i));
  }

  // 52	[112]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 53	[112]	LOADK    	12 14	; ", "
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00070603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 54	[112]	CONCAT   	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x00050435);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 55	[112]	MOVE     	1 8
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_66
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x00080080);
    setobjs2s(L, ra, RB(i));
  }

  // 56	[113]	JMP      	9	; to 67
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_66;
  }

  // 57	[114]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 58	[114]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 59	[114]	LOADK    	10 12	; " = "
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x00060503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 60	[114]	TESTSET  	11 7 1
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_63
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x000785c3);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 61	[114]	JMP      	1	; to 64
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_63;
  }

  // 62	[114]	LOADK    	11 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x00010583);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 63	[114]	LOADK    	12 15	; ","
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x00078603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 64	[114]	CONCAT   	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x00050435);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 65	[114]	MOVE     	1 8
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x00080080);
    setobjs2s(L, ra, RB(i));
  }

  // 66	[116]	CLOSE    	6
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x00000336);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 67	[91]	TFORCALL 	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x0200014c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 68	[91]	TFORLOOP 	2 64	; to 6
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x0020014d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_05; /* jump back */
    }
  }

  // 69	[116]	CLOSE    	2
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x00000136);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 70	[117]	MOVE     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x00010100);
    setobjs2s(L, ra, RB(i));
  }

  // 71	[117]	LOADK    	3 16	; "}"
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x00080183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 72	[117]	CONCAT   	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x00020135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 73	[117]	MOVE     	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x00020080);
    setobjs2s(L, ra, RB(i));
  }

  // 74	[118]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_74: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 75	[119]	RETURN   	2 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_75: {
    aot_vmfetch(0x00018146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 96 - 98
static
CallInfo *magic_implementation_05(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[97]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[97]	CALL     	0 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x02010044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 2	[97]	SETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x0000000a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 3	[98]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 99 - 107
static
CallInfo *magic_implementation_06(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
  }

  // 0	[100]	GETTABUP 	0 1 0	; _ENV "loadenv"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0001000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[100]	LOADK    	1 1	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[100]	GETUPVAL 	2 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[100]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 4	[100]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[100]	LOADK    	2 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[100]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 7	[100]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[100]	SETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0000000a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 9	[101]	GETTABUP 	0 1 3	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0301000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 10	[103]	CLOSURE  	1 0	; 0x7fbced0058f0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000000cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 11	[106]	CLOSURE  	2 1	; 0x7fbced0059c0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0000814f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 12	[101]	CALL     	0 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x01030044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 13	[107]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 101 - 103
static
CallInfo *magic_implementation_07(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[102]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[102]	CALL     	0 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x02010044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 2	[102]	SETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x0000000a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 3	[103]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 104 - 106
static
CallInfo *magic_implementation_08(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
  }

  // 0	[105]	GETTABUP 	1 0 0	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[105]	LOADK    	2 1	; "Error checking value: "
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[105]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[105]	CONCAT   	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00020135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 4	[105]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_04: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[106]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_05: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 120 - 132
static
CallInfo *magic_implementation_09(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
  }

  // 0	[122]	GETTABUP 	2 0 1	; _ENV "tabletostring"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[122]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[122]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[122]	SETTABUP 	0 0 2	; _ENV "envstr"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0200000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 4	[124]	LOADK    	2 2	; "    env = "
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[124]	GETTABUP 	3 0 0	; _ENV "envstr"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[129]	LOADK    	4 3	; "    for (i, v in pairs(env)) {\n      _G[i] = v\n    }\n\n  "
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[129]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[129]	CONCAT   	2 4
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00040135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 9	[129]	MOVE     	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00020080);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[131]	GETTABUP 	2 0 4	; _ENV "loadstring"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 11	[131]	GETTABUP 	3 0 5	; _ENV "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0500018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[131]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[131]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[131]	TAILCALL 	2 0 0	; -1 in
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000145);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 15	[131]	RETURN   	2 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x00000146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 16	[132]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_16: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 136 - 139
static
CallInfo *magic_implementation_10(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[138]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[138]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[138]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[138]	EQK      	1 1 1	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[138]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[138]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[138]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[138]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[139]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 140 - 142
static
CallInfo *magic_implementation_11(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
  }

  // 0	[141]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[141]	GETFIELD 	1 1 1	; "abs"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[141]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[141]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[141]	EQ       	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_07
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000080b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 5	[141]	JMP      	1	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_07;
  }

  // 6	[141]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 7	[141]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 8	[141]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 9	[142]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 143 - 145
static
CallInfo *magic_implementation_12(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
  }

  // 0	[144]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[144]	GETFIELD 	1 1 1	; "abs"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[144]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[144]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[144]	EQ       	1 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_07
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000000b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 5	[144]	JMP      	1	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_07;
  }

  // 6	[144]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 7	[144]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 8	[144]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 9	[145]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 146 - 148
static
CallInfo *magic_implementation_13(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
  }

  // 0	[147]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[147]	GETFIELD 	1 1 1	; "abs"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[147]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[147]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[147]	EQ       	1 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000000b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 5	[147]	JMP      	6	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_12;
  }

  // 6	[147]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[147]	GETFIELD 	1 1 2	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0201008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[147]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[147]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[147]	EQ       	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000080b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 11	[147]	JMP      	1	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_13;
  }

  // 12	[147]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 13	[147]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 14	[147]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 15	[148]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 149 - 151
static
CallInfo *magic_implementation_14(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
  }

  // 0	[150]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[150]	GETFIELD 	1 1 1	; "abs"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[150]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[150]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[150]	EQ       	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000080b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 5	[150]	JMP      	6	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_12;
  }

  // 6	[150]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[150]	GETFIELD 	1 1 2	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0201008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[150]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[150]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[150]	EQ       	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000080b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 11	[150]	JMP      	1	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_13;
  }

  // 12	[150]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 13	[150]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 14	[150]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 15	[151]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 152 - 155
static
CallInfo *magic_implementation_15(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
  }

  // 0	[154]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[154]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[154]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[154]	EQK      	1 1 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_21
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[154]	JMP      	16	; to 22
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800007b8);
    updatetrap(ci);
    goto label_21;
  }

  // 5	[154]	GETTABUP 	1 0 1	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0100008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[154]	GETFIELD 	1 1 2	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0201008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[154]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[154]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 9	[154]	LOADI    	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x80000201);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 10	[154]	CALL     	1 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x020400c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 11	[154]	EQK      	1 3 1	; "&"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000380bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 12	[154]	JMP      	9	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_22;
  }

  // 13	[154]	GETTABUP 	1 0 1	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0100008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 14	[154]	GETFIELD 	1 1 2	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0201008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[154]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[154]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 17	[154]	LOADI    	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x80008201);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 18	[154]	CALL     	1 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x020400c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[154]	EQK      	1 4 1	; "0x"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000480bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 20	[154]	JMP      	1	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_22;
  }

  // 21	[154]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 22	[154]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 23	[154]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_23: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 24	[155]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_24: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 156 - 163
static
CallInfo *magic_implementation_16(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
  }

  // 0	[158]	GETTABUP 	1 0 0	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[158]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[158]	CALL     	1 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x050200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[158]	TFORPREP 	1 7	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000380cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_11;
  }

  // 4	[159]	GETTABUP 	7 0 1	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 5	[159]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 6	[159]	CALL     	7 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x020203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[159]	EQK      	7 2 1	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000283bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 8	[159]	JMP      	2	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_11;
  }

  // 9	[160]	LOADFALSE	7
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000385);
    setbfvalue(s2v(ra));
  }

  // 10	[160]	RETURN   	7 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000283c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 11	[158]	TFORCALL 	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020000cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 12	[158]	TFORLOOP 	1 9	; to 5
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000480cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_04; /* jump back */
    }
  }

  // 13	[162]	CLOSE    	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000000b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 14	[163]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 164 - 171
static
CallInfo *magic_implementation_17(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
  }

  // 0	[166]	GETTABUP 	1 0 0	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[166]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[166]	CALL     	1 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x050200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[166]	TFORPREP 	1 7	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000380cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_11;
  }

  // 4	[167]	GETTABUP 	7 0 1	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 5	[167]	MOVE     	8 6
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00060400);
    setobjs2s(L, ra, RB(i));
  }

  // 6	[167]	CALL     	7 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x020203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[167]	EQK      	7 2 1	; "table"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000283bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 8	[167]	JMP      	2	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_11;
  }

  // 9	[168]	LOADFALSE	7
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000385);
    setbfvalue(s2v(ra));
  }

  // 10	[168]	RETURN   	7 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000283c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 11	[166]	TFORCALL 	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020000cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 12	[166]	TFORLOOP 	1 9	; to 5
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000480cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_04; /* jump back */
    }
  }

  // 13	[170]	CLOSE    	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000000b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 14	[171]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 172 - 175
static
CallInfo *magic_implementation_18(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
  }

  // 0	[174]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[174]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[174]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[174]	EQK      	1 1 0	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[174]	JMP      	8	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_13;
  }

  // 5	[174]	GETTABUP 	1 0 2	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[174]	GETFIELD 	1 1 3	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[174]	GETTABUP 	2 0 4	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[174]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[174]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[174]	LOADK    	3 5	; "^vec3: "
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00028183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[174]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_15
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[174]	JMP      	2	; to 16
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_15;
  }

  // 13	[174]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 14	[174]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 15	[174]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 16	[175]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_16: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 176 - 179
static
CallInfo *magic_implementation_19(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
  }

  // 0	[178]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[178]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[178]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[178]	EQK      	1 1 0	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[178]	JMP      	8	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_13;
  }

  // 5	[178]	GETTABUP 	1 0 2	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[178]	GETFIELD 	1 1 3	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[178]	GETTABUP 	2 0 4	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[178]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[178]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[178]	LOADK    	3 5	; "^vec2: "
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00028183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[178]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_15
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[178]	JMP      	2	; to 16
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_15;
  }

  // 13	[178]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 14	[178]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 15	[178]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 16	[179]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_16: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 180 - 183
static
CallInfo *magic_implementation_20(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
  }

  // 0	[182]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[182]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[182]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[182]	EQK      	1 1 0	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[182]	JMP      	8	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_13;
  }

  // 5	[182]	GETTABUP 	1 0 2	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[182]	GETFIELD 	1 1 3	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[182]	GETTABUP 	2 0 4	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[182]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[182]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[182]	LOADK    	3 5	; "^color: "
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00028183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[182]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_15
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[182]	JMP      	2	; to 16
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_15;
  }

  // 13	[182]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 14	[182]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 15	[182]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 16	[183]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_16: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 184 - 187
static
CallInfo *magic_implementation_21(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
  }

  // 0	[186]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[186]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[186]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[186]	EQK      	1 1 0	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[186]	JMP      	8	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_13;
  }

  // 5	[186]	GETTABUP 	1 0 2	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[186]	GETFIELD 	1 1 3	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[186]	GETTABUP 	2 0 4	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[186]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[186]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[186]	LOADK    	3 5	; "^transform: "
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00028183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[186]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_15
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[186]	JMP      	2	; to 16
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_15;
  }

  // 13	[186]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 14	[186]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 15	[186]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 16	[187]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_16: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 188 - 191
static
CallInfo *magic_implementation_22(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[190]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[190]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[190]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[190]	EQK      	1 1 1	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[190]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[190]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[190]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[190]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[191]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 192 - 195
static
CallInfo *magic_implementation_23(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[194]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[194]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[194]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[194]	EQK      	1 1 1	; "boolean"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[194]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[194]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[194]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[194]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[195]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 196 - 199
static
CallInfo *magic_implementation_24(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[198]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[198]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[198]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[198]	EQK      	1 1 1	; "table"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[198]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[198]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[198]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[198]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[199]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 200 - 203
static
CallInfo *magic_implementation_25(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[202]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[202]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[202]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[202]	EQK      	1 1 1	; "function"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[202]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[202]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[202]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[202]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[203]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 204 - 207
static
CallInfo *magic_implementation_26(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[206]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[206]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[206]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[206]	EQK      	1 1 1	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[206]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[206]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[206]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[206]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[207]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 208 - 211
static
CallInfo *magic_implementation_27(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[210]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[210]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[210]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[210]	EQK      	1 1 1	; "thread"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[210]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[210]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[210]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[210]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[211]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 212 - 215
static
CallInfo *magic_implementation_28(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[214]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[214]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[214]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[214]	EQK      	1 1 1	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[214]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[214]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[214]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[214]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[215]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 216 - 219
static
CallInfo *magic_implementation_29(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
  }

  // 0	[218]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[218]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[218]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[218]	EQK      	1 1 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[218]	JMP      	3	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_08;
  }

  // 5	[218]	LEN      	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000000b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 6	[218]	EQI      	1 1 1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_09
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x008080bd);
    int cond;
    int im = GETARG_sB(i);
    if (ttisinteger(s2v(ra)))
      cond = (ivalue(s2v(ra)) == im);
    else if (ttisfloat(s2v(ra)))
      cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));
    else
      cond = 0;  /* other types cannot be equal to a number */
    docondjump();
  }

  // 7	[218]	JMP      	1	; to 10
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_09;
  }

  // 8	[218]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 9	[218]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 10	[218]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_10: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 11	[219]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 220 - 224
static
CallInfo *magic_implementation_30(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
  }

  // 0	[223]	GETTABUP 	1 0 0	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[223]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[223]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[223]	GETTABUP 	2 0 1	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[223]	GETFIELD 	2 2 2	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0202010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[223]	LOADK    	3 3	; "^message: "
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[223]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[223]	EQ       	1 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000280b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 8	[223]	JMP      	1	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_10;
  }

  // 9	[223]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 10	[223]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 11	[223]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 12	[224]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 225 - 229
static
CallInfo *magic_implementation_31(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
  }

  // 0	[227]	GETTABUP 	1 0 2	; _ENV "pcall"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[227]	CLOSURE  	2 0	; 0x7fbced008900
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0000014f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 2	[227]	CALL     	1 2 3	; 1 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x030200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[227]	SETTABUP 	0 1 2	; _ENV "e"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0201000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 4	[227]	SETTABUP 	0 0 1	; _ENV "s"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 5	[228]	GETTABUP 	1 0 0	; _ENV "s"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[228]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 7	[229]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 227 - 227
static
CallInfo *magic_implementation_32(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
  }

  // 0	[227]	GETTABUP 	0 0 0	; item "__name"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[227]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 2	[227]	JMP      	3	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_06;
  }

  // 3	[227]	GETTABUP 	0 1 1	; _ENV "error"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0101000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[227]	LOADK    	1 2	; "Force error"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[227]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_05: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[227]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 230 - 234
static
CallInfo *magic_implementation_33(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
  }

  // 0	[233]	GETTABUP 	1 0 0	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[233]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[233]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[233]	GETTABUP 	2 0 1	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[233]	GETFIELD 	2 2 2	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0202010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[233]	LOADK    	3 3	; "^directory: "
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[233]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[233]	EQ       	1 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000280b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 8	[233]	JMP      	1	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_10;
  }

  // 9	[233]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 10	[233]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 11	[233]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 12	[234]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 235 - 239
static
CallInfo *magic_implementation_34(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
  }

  // 0	[238]	GETTABUP 	1 0 0	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[238]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[238]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[238]	GETTABUP 	2 0 1	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[238]	GETFIELD 	2 2 2	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0202010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[238]	LOADK    	3 3	; "^lock: "
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[238]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[238]	EQ       	1 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000280b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 8	[238]	JMP      	1	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_10;
  }

  // 9	[238]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 10	[238]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 11	[238]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 12	[239]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 240 - 243
static
CallInfo *magic_implementation_35(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
  }

  // 0	[242]	GETTABUP 	1 0 0	; _ENV "getmetatable"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[242]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[242]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[242]	GETFIELD 	1 1 1	; "__metatable"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[242]	EQK      	1 2 0	; null
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_07
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000200bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 5	[242]	JMP      	1	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_07;
  }

  // 6	[242]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 7	[242]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 8	[242]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 9	[243]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 244 - 248
static
CallInfo *magic_implementation_36(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
  }

  // 0	[247]	GETTABUP 	1 0 0	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[247]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[247]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[247]	GETTABUP 	2 0 1	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[247]	GETFIELD 	2 2 2	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0202010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[247]	LOADK    	3 3	; "^LUABOX: "
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[247]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[247]	EQ       	1 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000280b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 8	[247]	JMP      	1	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_10;
  }

  // 9	[247]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 10	[247]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 11	[247]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 12	[248]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 249 - 252
static
CallInfo *magic_implementation_37(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
  }

  // 0	[251]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 1	[251]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_01: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 2	[252]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 253 - 256
static
CallInfo *magic_implementation_38(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[255]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[255]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[255]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[255]	EQK      	1 1 1	; "thread"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[255]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[255]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[255]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[255]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[256]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 257 - 260
static
CallInfo *magic_implementation_39(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
  }

  // 0	[259]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[259]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[259]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[259]	EQK      	1 1 0	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[259]	JMP      	6	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_11;
  }

  // 5	[259]	GETTABUP 	1 0 2	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[259]	GETFIELD 	1 1 3	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[259]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[259]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[259]	EQ       	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000080b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 10	[259]	JMP      	1	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_12;
  }

  // 11	[259]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 12	[259]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 13	[259]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 14	[260]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 261 - 264
static
CallInfo *magic_implementation_40(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
  }

  // 0	[263]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[263]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[263]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[263]	EQK      	1 1 0	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[263]	JMP      	6	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_11;
  }

  // 5	[263]	GETTABUP 	1 0 2	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[263]	GETFIELD 	1 1 3	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[263]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[263]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[263]	EQ       	1 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000000b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 10	[263]	JMP      	1	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_12;
  }

  // 11	[263]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 12	[263]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 13	[263]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 14	[264]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 265 - 268
static
CallInfo *magic_implementation_41(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
  }

  // 0	[267]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[267]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[267]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[267]	EQK      	1 1 0	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[267]	JMP      	6	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_11;
  }

  // 5	[267]	GETTABUP 	1 0 2	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[267]	GETFIELD 	1 1 3	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[267]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[267]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[267]	EQ       	1 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000000b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 10	[267]	JMP      	1	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_12;
  }

  // 11	[267]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 12	[267]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 13	[267]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 14	[268]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 277 - 289
static
CallInfo *magic_implementation_42(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
  }

  // 0	[279]	LOADK    	1 0	; "^%s*var%s+([^%s]+)%s*:%s*([^%s]+)%s*=%s*([^%s]+)%s*$"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[280]	LOADK    	1 1	; "^%s*var%s+([^%s]+)%s*:%s*([^%s]+)%s*=%s*(.-)%s*$"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[281]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 3	[281]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 4	[282]	SELF     	3 0 2k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[282]	LOADK    	5 3	; "[^\r\n]+"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00018283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[282]	CALL     	3 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x050301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[282]	TFORPREP 	3 20	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000a01cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_28;
  }

  // 8	[283]	SELF     	8 7 4k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x04078414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 9	[283]	MOVE     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00010500);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[283]	CALL     	8 3 4	; 2 in 3 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x04030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 11	[284]	TEST     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_28
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000442);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 12	[284]	JMP      	15	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x80000738);
    updatetrap(ci);
    goto label_28;
  }

  // 13	[284]	TEST     	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_28
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000004c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 14	[284]	JMP      	13	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_28;
  }

  // 15	[284]	TEST     	10 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_28
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000542);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 16	[284]	JMP      	11	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x80000538);
    updatetrap(ci);
    goto label_28;
  }

  // 17	[285]	GETTABUP 	11 0 5	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0500058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 18	[285]	GETFIELD 	11 11 6	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x060b058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[285]	MOVE     	12 2
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00020600);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[285]	NEWTABLE 	13 0 4	; 4
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x04000693);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 21	[285]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 22	[285]	MOVE     	14 8
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00080700);
    setobjs2s(L, ra, RB(i));
  }

  // 23	[285]	MOVE     	15 9
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00090780);
    setobjs2s(L, ra, RB(i));
  }

  // 24	[285]	MOVE     	16 10
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x000a0800);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[285]	MOVE     	17 7
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00070880);
    setobjs2s(L, ra, RB(i));
  }

  // 26	[285]	SETLIST  	13 4 0
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x000406ce);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 27	[285]	CALL     	11 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x010305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 28	[282]	TFORCALL 	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x010001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 29	[282]	TFORLOOP 	3 22	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x000b01cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_08; /* jump back */
    }
  }

  // 30	[287]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 31	[288]	RETURN   	2 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_31: {
    aot_vmfetch(0x00028146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 32	[289]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_32: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 290 - 304
static
CallInfo *magic_implementation_43(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
  }

  // 0	[292]	LOADK    	1 0	; "%s*([^%s]+)%s*:%s*([^%s]+)%s*=%s*([^%s]+)%s*"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[293]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 2	[293]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 3	[294]	SELF     	3 0 1k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x01008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[294]	LOADK    	5 2	; "[^\r\n]+"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[294]	CALL     	3 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x050301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[294]	TFORPREP 	3 26	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000d01cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_33;
  }

  // 7	[295]	SELF     	8 7 3k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x03078414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[295]	MOVE     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010500);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[295]	CALL     	8 3 4	; 2 in 3 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x04030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[296]	TEST     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_33
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000442);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 11	[296]	JMP      	21	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000a38);
    updatetrap(ci);
    goto label_33;
  }

  // 12	[296]	TEST     	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_33
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000004c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 13	[296]	JMP      	19	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x80000938);
    updatetrap(ci);
    goto label_33;
  }

  // 14	[296]	TEST     	10 0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_33
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000542);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 15	[296]	JMP      	17	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000838);
    updatetrap(ci);
    goto label_33;
  }

  // 16	[298]	GETTABUP 	11 0 4	; _ENV "deffind"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0400058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[298]	MOVE     	12 7
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00070600);
    setobjs2s(L, ra, RB(i));
  }

  // 18	[298]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[298]	GETI     	11 11 1
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x010b058d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 20	[298]	TEST     	11 1
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_33
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x000085c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 21	[298]	JMP      	11	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x80000538);
    updatetrap(ci);
    goto label_33;
  }

  // 22	[299]	GETTABUP 	11 0 5	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0500058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 23	[299]	GETFIELD 	11 11 6	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x060b058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 24	[299]	MOVE     	12 2
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00020600);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[299]	NEWTABLE 	13 0 4	; 4
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x04000693);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 26	[299]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 27	[299]	MOVE     	14 8
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00080700);
    setobjs2s(L, ra, RB(i));
  }

  // 28	[299]	MOVE     	15 9
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00090780);
    setobjs2s(L, ra, RB(i));
  }

  // 29	[299]	MOVE     	16 10
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x000a0800);
    setobjs2s(L, ra, RB(i));
  }

  // 30	[299]	MOVE     	17 7
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00070880);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[299]	SETLIST  	13 4 0
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000406ce);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 32	[299]	CALL     	11 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x010305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 33	[294]	TFORCALL 	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x010001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 34	[294]	TFORLOOP 	3 28	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x000e01cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_07; /* jump back */
    }
  }

  // 35	[302]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 36	[303]	RETURN   	2 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_36: {
    aot_vmfetch(0x00028146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 37	[304]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_37: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 305 - 316
static
CallInfo *magic_implementation_44(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
  }

  // 0	[307]	LOADK    	1 0	; "^%s*function%s+([^%s]+)%s*%(([^%s]*)%)%s*$"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[308]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 2	[308]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 3	[309]	SELF     	3 0 1k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x01008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[309]	LOADK    	5 2	; "[^\r\n]+"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[309]	CALL     	3 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x050301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[309]	TFORPREP 	3 17	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000881cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_24;
  }

  // 7	[310]	SELF     	8 7 3k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x03078414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[310]	MOVE     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010500);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[310]	CALL     	8 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x03030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[311]	TEST     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000442);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 11	[311]	JMP      	12	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_24;
  }

  // 12	[311]	TEST     	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000004c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 13	[311]	JMP      	10	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_24;
  }

  // 14	[312]	GETTABUP 	10 0 4	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0400050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 15	[312]	GETFIELD 	10 10 5	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x050a050e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 16	[312]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[312]	NEWTABLE 	12 0 3	; 3
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x03000613);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 18	[312]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 19	[312]	MOVE     	13 8
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00080680);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[312]	MOVE     	14 9
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00090700);
    setobjs2s(L, ra, RB(i));
  }

  // 21	[312]	MOVE     	15 7
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00070780);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[312]	SETLIST  	12 3 0
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0003064e);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 23	[312]	CALL     	10 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x01030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[309]	TFORCALL 	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x010001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 25	[309]	TFORLOOP 	3 19	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x000981cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_07; /* jump back */
    }
  }

  // 26	[314]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 27	[315]	RETURN   	2 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_27: {
    aot_vmfetch(0x00028146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 28	[316]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_28: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 317 - 330
static
CallInfo *magic_implementation_45(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
  }

  // 0	[319]	LOADK    	1 0	; "%s*([^%s]+)%s*=%s*([^%s]+)%s*"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[320]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 2	[320]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 3	[321]	SELF     	3 0 1k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x01008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[321]	LOADK    	5 2	; "[^\r\n]+"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[321]	CALL     	3 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x050301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[321]	TFORPREP 	3 29	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000e81cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_36;
  }

  // 7	[322]	SELF     	8 7 3k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x03078414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[322]	MOVE     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010500);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[322]	CALL     	8 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x03030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[323]	TEST     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_36
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000442);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 11	[323]	JMP      	24	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000bb8);
    updatetrap(ci);
    goto label_36;
  }

  // 12	[323]	TEST     	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_36
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000004c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 13	[323]	JMP      	22	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x80000ab8);
    updatetrap(ci);
    goto label_36;
  }

  // 14	[324]	GETTABUP 	10 0 4	; _ENV "deffind"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0400050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 15	[324]	MOVE     	11 7
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00070580);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[324]	CALL     	10 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x02020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 17	[324]	GETI     	10 10 1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x010a050d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 18	[324]	TEST     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_36
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00008542);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 19	[324]	JMP      	16	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x800007b8);
    updatetrap(ci);
    goto label_36;
  }

  // 20	[324]	GETTABUP 	10 0 5	; _ENV "assign"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0500050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 21	[324]	MOVE     	11 7
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00070580);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[324]	CALL     	10 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x02020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 23	[324]	GETI     	10 10 1
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x010a050d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 24	[324]	TEST     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_36
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00008542);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 25	[324]	JMP      	10	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_36;
  }

  // 26	[325]	GETTABUP 	10 0 6	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x0600050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 27	[325]	GETFIELD 	10 10 7	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x070a050e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 28	[325]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 29	[325]	NEWTABLE 	12 0 3	; 3
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x03000613);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 30	[325]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 31	[325]	MOVE     	13 8
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x00080680);
    setobjs2s(L, ra, RB(i));
  }

  // 32	[325]	MOVE     	14 9
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x00090700);
    setobjs2s(L, ra, RB(i));
  }

  // 33	[325]	MOVE     	15 7
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x00070780);
    setobjs2s(L, ra, RB(i));
  }

  // 34	[325]	SETLIST  	12 3 0
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x0003064e);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 35	[325]	CALL     	10 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x01030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 36	[321]	TFORCALL 	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x010001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 37	[321]	TFORLOOP 	3 31	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x000f81cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_07; /* jump back */
    }
  }

  // 38	[328]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 39	[329]	RETURN   	2 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_39: {
    aot_vmfetch(0x00028146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 40	[330]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_40: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 331 - 342
static
CallInfo *magic_implementation_46(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
  }

  // 0	[333]	LOADK    	1 0	; "%s*=%s*"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[334]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 2	[334]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 3	[335]	SELF     	3 0 1k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x01008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[335]	LOADK    	5 2	; "[^\r\n]+"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[335]	CALL     	3 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x050301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[335]	TFORPREP 	3 17	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000881cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_24;
  }

  // 7	[336]	SELF     	8 7 3k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x03078414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[336]	MOVE     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010500);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[336]	CALL     	8 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x03030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[337]	TEST     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000442);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 11	[337]	JMP      	12	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_24;
  }

  // 12	[337]	TEST     	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000004c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 13	[337]	JMP      	10	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_24;
  }

  // 14	[338]	GETTABUP 	10 0 4	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0400050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 15	[338]	GETFIELD 	10 10 5	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x050a050e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 16	[338]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[338]	NEWTABLE 	12 0 3	; 3
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x03000613);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 18	[338]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 19	[338]	MOVE     	13 8
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00080680);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[338]	MOVE     	14 9
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00090700);
    setobjs2s(L, ra, RB(i));
  }

  // 21	[338]	MOVE     	15 7
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00070780);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[338]	SETLIST  	12 3 0
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0003064e);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 23	[338]	CALL     	10 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x01030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[335]	TFORCALL 	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x010001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 25	[335]	TFORLOOP 	3 19	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x000981cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_07; /* jump back */
    }
  }

  // 26	[340]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 27	[341]	RETURN   	2 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_27: {
    aot_vmfetch(0x00028146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 28	[342]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_28: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 343 - 368
static
CallInfo *magic_implementation_47(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
  }

  // 0	[344]	GETTABUP 	1 0 0	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[344]	GETTABUP 	2 0 1	; _ENV "dead"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[344]	CALL     	1 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x050200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[344]	TFORPREP 	1 48	; to 53
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x001800cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_52;
  }

  // 4	[345]	LOADK    	7 2	; "'DEADVALUESTRTYPECHECK-"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[345]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 6	[345]	LOADK    	9 3	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[345]	CONCAT   	7 3
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000303b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 8	[350]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 9	[351]	LOADK    	9 4	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00020483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 10	[352]	LOADI    	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80000501);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 11	[352]	LEN      	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000005b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 12	[352]	LOADI    	12 1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x80000601);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 13	[352]	FORPREP  	10 37	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0012854a);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_52; /* skip the loop */
  }

  // 14	[353]	SELF     	14 0 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x05008714);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[353]	MOVE     	16 13
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000d0800);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[353]	MOVE     	17 13
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x000d0880);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[353]	CALL     	14 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x02040744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[354]	SELF     	15 7 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x05078794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[354]	MOVE     	17 8
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00080880);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[354]	MOVE     	18 8
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00080900);
    setobjs2s(L, ra, RB(i));
  }

  // 21	[354]	CALL     	15 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x020407c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 22	[354]	EQ       	14 15 0
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_49
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000f0739);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 23	[354]	JMP      	25	; to 50
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x80000c38);
    updatetrap(ci);
    goto label_49;
  }

  // 24	[355]	MOVE     	15 8
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00080780);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[355]	ADDI     	8 8 1
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80080415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 26	[355]	MMBINI   	8 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x0680042f);
    Instruction pi = 0x80080415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 27	[356]	MOVE     	15 9
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00090780);
    setobjs2s(L, ra, RB(i));
  }

  // 28	[356]	MOVE     	16 14
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x000e0800);
    setobjs2s(L, ra, RB(i));
  }

  // 29	[356]	CONCAT   	15 2
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x000207b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 30	[356]	MOVE     	9 15
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x000f0480);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[357]	EQ       	9 7 0
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000704b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 32	[357]	JMP      	18	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x800008b8);
    updatetrap(ci);
    goto label_51;
  }

  // 33	[358]	SELF     	15 0 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x05008794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 34	[358]	LOADI    	17 1
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x80000881);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 35	[358]	LEN      	18 7
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x00070934);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 36	[358]	SUB      	18 13 18
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x120d0923);
    op_arith(L, l_subi, luai_numsub);
  }

  // 37	[358]	MMBIN    	13 18 7	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x071206ae);
    Instruction pi = 0x120d0923; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 38	[358]	CALL     	15 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x020407c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 39	[358]	MOVE     	16 6
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00060800);
    setobjs2s(L, ra, RB(i));
  }

  // 40	[358]	SELF     	17 0 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x05008894);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 41	[358]	ADDI     	19 13 1
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x800d0995);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 42	[358]	MMBINI   	13 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x068006af);
    Instruction pi = 0x800d0995;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 43	[358]	LEN      	20 0
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x00000a34);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 44	[358]	CALL     	17 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x020408c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 45	[358]	CONCAT   	15 3
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000307b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 46	[358]	MOVE     	0 15
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_52
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x000f0000);
    setobjs2s(L, ra, RB(i));
  }

  // 47	[359]	JMP      	4	; to 53
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_52;
  }

  // 48	[361]	JMP      	2	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_51;
  }

  // 49	[362]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 50	[363]	LOADK    	9 4	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x00020483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 51	[352]	FORLOOP  	10 38	; to 15
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00130549);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_14; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_14; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 52	[344]	TFORCALL 	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x020000cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 53	[344]	TFORLOOP 	1 50	; to 5
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x001900cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_04; /* jump back */
    }
  }

  // 54	[366]	CLOSE    	1
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x000000b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 55	[367]	RETURN   	0 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_55: {
    aot_vmfetch(0x00028046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 56	[368]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_56: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 369 - 390
static
CallInfo *magic_implementation_48(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
  }

  // 0	[372]	NEWTABLE 	1 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000093);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 1	[372]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 2	[373]	LOADI    	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x7fff8101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 3	[374]	SETTABUP 	0 0 0	; _ENV "ogstr"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0000000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 4	[375]	GETFIELD 	3 0 1	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[375]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 6	[375]	JMP      	3	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_10;
  }

  // 7	[375]	GETTABUP 	3 0 2	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0200018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[375]	LOADK    	4 3	; "string.gsub is not a found function, Are you sure you provided a string?"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00018203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[375]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[376]	SELF     	3 0 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x01008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[376]	LOADK    	5 4	; "'[^']-'"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00020283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 12	[380]	CLOSURE  	6 0	; 0x7fbced00b330
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0000034f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 13	[376]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[380]	SELF     	3 3 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x01038194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[380]	LOADK    	5 5	; "\"[^\"]-\""
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00028283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 16	[384]	CLOSURE  	6 1	; 0x7fbced00b4a0
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0000834f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 17	[376]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[384]	SELF     	3 3 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x01038194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[384]	LOADK    	5 6	; "%[%[.-%]%]"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00030283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 20	[388]	CLOSURE  	6 2	; 0x7fbced00b6b0
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0001034f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 21	[376]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 22	[388]	MOVE     	0 3
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00030000);
    setobjs2s(L, ra, RB(i));
  }

  // 23	[389]	SELF     	3 0 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x01008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 24	[389]	LOADK    	5 7	; "//.-\n"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00038283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 25	[389]	LOADK    	6 8	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00040303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 26	[389]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 27	[389]	SELF     	3 3 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x01038194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 28	[389]	LOADK    	5 9	; "/%*.-%*/"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00048283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 29	[389]	LOADK    	6 8	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00040303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 30	[389]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 31	[389]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 32	[389]	RETURN   	3 3 0	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_32: {
    aot_vmfetch(0x000381c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 33	[390]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_33: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 376 - 380
static
CallInfo *magic_implementation_49(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
  }

  // 0	[377]	GETUPVAL 	1 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[377]	GETUPVAL 	3 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 2	[377]	ADDI     	3 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80030195);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 3	[377]	MMBINI   	3 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x068001af);
    Instruction pi = 0x80030195;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 4	[377]	SETUPVAL 	3 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0000018a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 5	[378]	GETUPVAL 	2 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[378]	GETUPVAL 	1 1	; dead
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[378]	SETTABLE 	1 2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00020090);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 8	[379]	LOADK    	1 0	; "'DEADVALUESTRTYPECHECK-"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[379]	GETUPVAL 	2 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 10	[379]	LOADK    	3 1	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00008183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[379]	CONCAT   	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000300b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 12	[379]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 13	[380]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 380 - 384
static
CallInfo *magic_implementation_50(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
  }

  // 0	[381]	GETUPVAL 	1 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[381]	GETUPVAL 	3 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 2	[381]	ADDI     	3 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80030195);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 3	[381]	MMBINI   	3 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x068001af);
    Instruction pi = 0x80030195;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 4	[381]	SETUPVAL 	3 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0000018a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 5	[382]	GETUPVAL 	2 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[382]	GETUPVAL 	1 1	; dead
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[382]	SETTABLE 	1 2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00020090);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 8	[383]	LOADK    	1 0	; "'DEADVALUESTRTYPECHECK-"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[383]	GETUPVAL 	2 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 10	[383]	LOADK    	3 1	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00008183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[383]	CONCAT   	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000300b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 12	[383]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 13	[384]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 384 - 388
static
CallInfo *magic_implementation_51(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
  }

  // 0	[385]	GETUPVAL 	1 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[385]	GETUPVAL 	3 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 2	[385]	ADDI     	3 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80030195);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 3	[385]	MMBINI   	3 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x068001af);
    Instruction pi = 0x80030195;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 4	[385]	SETUPVAL 	3 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0000018a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 5	[386]	GETUPVAL 	2 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[386]	GETUPVAL 	1 1	; dead
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[386]	SETTABLE 	1 2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00020090);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 8	[387]	LOADK    	1 0	; "'DEADVALUESTRTYPECHECK-"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[387]	GETUPVAL 	2 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 10	[387]	LOADK    	3 1	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00008183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[387]	CONCAT   	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000300b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 12	[387]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 13	[388]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 394 - 415
static
CallInfo *magic_implementation_52(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
  }

  // 0	[395]	GETTABUP 	5 0 1	; _ENV "loadenv"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0100028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[395]	MOVE     	6 3
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00030300);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[395]	LOADK    	7 2	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 3	[395]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 4	[395]	CONCAT   	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000203b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 5	[395]	CALL     	5 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x030302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[395]	SETTABUP 	0 0 6	; _ENV "err"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0600000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 7	[395]	MOVE     	1 5
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00050080);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[396]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_16
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 9	[396]	JMP      	6	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_16;
  }

  // 10	[397]	GETTABUP 	5 0 3	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0300028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 11	[397]	LOADK    	6 4	; "Check error: "
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00020303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 12	[397]	GETTABUP 	7 0 0	; _ENV "err"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0000038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[397]	CONCAT   	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00020335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 14	[397]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 15	[397]	CALL     	5 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x010302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[399]	GETTABUP 	5 0 5	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0500028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[401]	CLOSURE  	6 0	; 0x7fbced00bc10
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0000034f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 18	[404]	CLOSURE  	7 1	; 0x7fbced00bca0
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x000083cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 19	[399]	CALL     	5 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x010302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[405]	GETTABUP 	5 0 6	; _ENV "types"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0600028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 21	[405]	GETTABLE 	5 5 0
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0005028c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 22	[405]	TEST     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_60
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000002c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 23	[405]	JMP      	36	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x800011b8);
    updatetrap(ci);
    goto label_60;
  }

  // 24	[406]	GETTABUP 	5 0 6	; _ENV "types"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0600028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 25	[406]	GETTABLE 	5 5 0
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x0005028c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 26	[406]	MOVE     	6 1
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00010300);
    setobjs2s(L, ra, RB(i));
  }

  // 27	[406]	CALL     	5 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x020202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 28	[406]	TEST     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_33
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x000002c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 29	[406]	JMP      	3	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_33;
  }

  // 30	[407]	LOADTRUE 	5
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00000287);
    setbtvalue(s2v(ra));
  }

  // 31	[407]	RETURN   	5 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_72
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000282c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 32	[408]	JMP      	39	; to 73
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x80001338);
    updatetrap(ci);
    goto label_72;
  }

  // 33	[409]	GETTABUP 	5 0 7	; _ENV "typeof"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x0700028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 34	[409]	MOVE     	6 1
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00010300);
    setobjs2s(L, ra, RB(i));
  }

  // 35	[409]	CALL     	5 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x020202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 36	[409]	EQK      	5 8 0	; "function"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_40
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x000802bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 37	[409]	JMP      	2	; to 41
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_40;
  }

  // 38	[409]	LOADTRUE 	5
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00000287);
    setbtvalue(s2v(ra));
  }

  // 39	[409]	RETURN   	5 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x000282c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 40	[410]	GETTABUP 	5 0 3	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x0300028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 41	[410]	GETTABUP 	6 0 9	; _ENV "core"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x0900030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 42	[410]	GETFIELD 	6 6 10	; "error"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0a06030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 43	[410]	GETFIELD 	6 6 11	; "strerror"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0b06030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 44	[410]	LOADI    	7 111
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x80370381);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 45	[410]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 46	[410]	SELF     	6 6 12k	; "format"
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x0c068314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 47	[410]	MOVE     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00000400);
    setobjs2s(L, ra, RB(i));
  }

  // 48	[410]	GETTABUP 	9 0 13	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x0d00048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 49	[410]	GETTABUP 	10 0 7	; _ENV "typeof"
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x0700050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 50	[410]	MOVE     	11 1
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x00010580);
    setobjs2s(L, ra, RB(i));
  }

  // 51	[410]	CALL     	10 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 52	[410]	CALL     	9 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x020004c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 53	[410]	LOADK    	10 14	; " (and it's descendents)"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00070503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 54	[410]	CONCAT   	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x000204b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 55	[410]	MOVE     	10 2
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x00020500);
    setobjs2s(L, ra, RB(i));
  }

  // 56	[410]	CALL     	6 5 2	; 4 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x02050344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 57	[410]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 58	[410]	CALL     	5 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_72
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x010302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 59	[412]	JMP      	12	; to 73
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_72;
  }

  // 60	[413]	GETTABUP 	5 0 3	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x0300028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 61	[413]	GETTABUP 	6 0 9	; _ENV "core"
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x0900030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 62	[413]	GETFIELD 	6 6 10	; "error"
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x0a06030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 63	[413]	GETFIELD 	6 6 11	; "strerror"
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x0b06030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 64	[413]	LOADI    	7 112
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x80378381);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 65	[413]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 66	[413]	SELF     	6 6 12k	; "format"
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x0c068314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 67	[413]	MOVE     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x00000400);
    setobjs2s(L, ra, RB(i));
  }

  // 68	[413]	CALL     	6 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x02030344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 69	[413]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 70	[413]	LOADK    	8 15	; "Use `cobaltpre -types` to see all types"
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x00078403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 71	[413]	CALL     	5 4 1	; 3 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_71: {
    aot_vmfetch(0x010402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 72	[415]	RETURN   	5 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_72: {
    aot_vmfetch(0x000182c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 399 - 401
static
CallInfo *magic_implementation_53(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[400]	GETUPVAL 	0 0	; value
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[400]	CALL     	0 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x02010044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 2	[400]	SETUPVAL 	0 0	; value
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x0000000a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 3	[401]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 401 - 404
static
CallInfo *magic_implementation_54(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
  }

  // 0	[403]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 1	[403]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_01: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 2	[404]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 418 - 457
static
CallInfo *magic_implementation_55(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
    case 132: goto label_132;
    case 133: goto label_133;
  }

  // 0	[419]	GETTABUP 	1 0 2	; _ENV "clean"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[419]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[419]	CALL     	1 2 3	; 1 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x030200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[419]	SETTABUP 	0 1 2	; _ENV "newdead"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0201000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 4	[419]	SETTABUP 	0 0 1	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 5	[420]	GETTABUP 	1 0 1	; _ENV "newdead"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0100008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[420]	SETTABUP 	0 3 1	; _ENV "dead"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0103000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 7	[421]	GETTABUP 	1 0 4	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0400008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[421]	GETTABUP 	2 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 9	[421]	SELF     	2 2 5k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x05028114);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 10	[421]	LOADK    	4 6	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00030203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[421]	CALL     	2 3 0	; 2 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00030144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[421]	CALL     	1 0 5	; all in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x050000c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 13	[421]	TFORPREP 	1 114	; to 129
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x003900cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_128;
  }

  // 14	[422]	GETTABUP 	7 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0000038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 15	[422]	SELF     	7 7 5k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x05078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 16	[422]	LOADK    	9 6	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00030483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 17	[422]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[422]	GETTABLE 	7 7 5
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0507038c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[422]	TEST     	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000083c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 20	[422]	JMP      	1	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_22;
  }

  // 21	[422]	LOADK    	7 7	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00038383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 22	[422]	SETTABUP 	0 0 7	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0700000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 23	[423]	GETTABUP 	7 0 8	; _ENV "deffind"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x0800038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 24	[423]	GETTABUP 	8 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0000040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 25	[423]	CALL     	7 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x020203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 26	[424]	GETTABUP 	8 0 9	; _ENV "assign"
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x0900040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 27	[424]	GETTABUP 	9 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0000048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 28	[424]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 29	[425]	GETTABUP 	9 0 10	; _ENV "allassign"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0a00048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 30	[425]	GETTABUP 	10 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x0000050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 31	[425]	CALL     	9 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x020204c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[426]	GETTABUP 	10 0 11	; _ENV "findfunctions"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x0b00050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 33	[426]	GETTABUP 	11 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x0000058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 34	[426]	CALL     	10 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x02020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 35	[427]	GETTABUP 	11 0 12	; _ENV "findall"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x0c00058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 36	[427]	GETTABUP 	12 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x0000060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 37	[427]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 38	[429]	NEWTABLE 	12 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00000613);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 39	[429]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 40	[430]	NEWTABLE 	13 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00000693);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 41	[430]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 42	[431]	GETTABUP 	14 0 4	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0400070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[431]	MOVE     	15 7
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x00070780);
    setobjs2s(L, ra, RB(i));
  }

  // 44	[431]	CALL     	14 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x05020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 45	[431]	TFORPREP 	14 31	; to 78
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000f874b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_77;
  }

  // 46	[432]	GETTABUP 	20 0 13	; _ENV "check"
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x0d000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 47	[432]	GETI     	21 19 2
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x02130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 48	[432]	GETI     	22 19 3
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x03130b0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 49	[432]	GETI     	23 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x01130b8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 50	[432]	MOVE     	24 13
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x000d0c00);
    setobjs2s(L, ra, RB(i));
  }

  // 51	[432]	GETI     	25 19 4
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x04130c8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 52	[432]	CALL     	20 6 1	; 5 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x01060a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 53	[433]	GETTABUP 	20 0 16	; _ENV "loadenv"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x10000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 54	[433]	MOVE     	21 13
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x000d0a80);
    setobjs2s(L, ra, RB(i));
  }

  // 55	[433]	LOADK    	22 17	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x00088b03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 56	[433]	GETI     	23 19 3
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x03130b8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 57	[433]	CONCAT   	22 2
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00020b35);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 58	[433]	CALL     	20 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x03030a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 59	[433]	SETTABUP 	0 15 21	; _ENV "err"
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x150f000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 60	[433]	SETTABUP 	0 14 20	; _ENV "value"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x140e000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 61	[434]	GETTABUP 	20 0 14	; _ENV "value"
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x0e000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 62	[434]	TEST     	20 1
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_69
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x00008a42);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 63	[434]	JMP      	5	; to 70
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_69;
  }

  // 64	[435]	GETTABUP 	20 0 18	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x12000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 65	[435]	LOADK    	21 19	; "Check error: "
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x00098a83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 66	[435]	GETTABUP 	22 0 15	; _ENV "err"
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x0f000b0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 67	[435]	CONCAT   	21 2
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x00020ab5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 68	[435]	CALL     	20 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x01020a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 69	[437]	GETI     	20 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x01130a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 70	[437]	GETI     	21 19 2
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x02130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 71	[437]	SETTABLE 	12 20 21
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x15140610);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 72	[438]	GETTABUP 	20 0 20	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x14000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 73	[440]	CLOSURE  	21 0	; 0x7fbced00c5e0
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x00000acf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 74	[440]	CLOSURE  	22 1	; 0x7fbced005430
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x00008b4f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 75	[438]	CALL     	20 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x01030a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 76	[442]	CLOSE    	18
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x00000936);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 77	[431]	TFORCALL 	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x0200074c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 78	[431]	TFORLOOP 	14 33	; to 47
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x0010874d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_46; /* jump back */
    }
  }

  // 79	[442]	CLOSE    	14
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x00000736);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 80	[443]	GETTABUP 	14 0 4	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x0400070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 81	[443]	MOVE     	15 9
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x00090780);
    setobjs2s(L, ra, RB(i));
  }

  // 82	[443]	CALL     	14 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x05020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 83	[443]	TFORPREP 	14 20	; to 105
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x000a074b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_104;
  }

  // 84	[444]	GETI     	20 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x01130a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 85	[444]	GETTABLE 	20 12 20
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x140c0a0c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 86	[444]	TEST     	20 0
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_97
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x00000a42);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 87	[444]	JMP      	9	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_97;
  }

  // 88	[445]	GETTABUP 	20 0 13	; _ENV "check"
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x0d000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 89	[445]	GETI     	21 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x01130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 90	[445]	GETTABLE 	21 12 21
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x150c0a8c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 91	[445]	GETI     	22 19 2
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x02130b0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 92	[445]	GETI     	23 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x01130b8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 93	[445]	MOVE     	24 13
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x000d0c00);
    setobjs2s(L, ra, RB(i));
  }

  // 94	[445]	GETI     	25 19 3
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x03130c8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 95	[445]	CALL     	20 6 1	; 5 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_104
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x01060a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 96	[446]	JMP      	7	; to 105
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_104;
  }

  // 97	[446]	GETI     	20 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x01130a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 98	[446]	GETTABLE 	20 13 20
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x140d0a0c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 99	[446]	TEST     	20 1
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_104
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x00008a42);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 100	[446]	JMP      	3	; to 105
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_104;
  }

  // 101	[447]	GETI     	20 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x01130a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 102	[447]	GETI     	21 19 2
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x02130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 103	[447]	SETTABLE 	13 20 21
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x15140690);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 104	[443]	TFORCALL 	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x0200074c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 105	[443]	TFORLOOP 	14 22	; to 85
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x000b074d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_84; /* jump back */
    }
  }

  // 106	[449]	CLOSE    	14
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x00000736);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 107	[450]	GETTABUP 	14 0 4	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x0400070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 108	[450]	MOVE     	15 8
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x00080780);
    setobjs2s(L, ra, RB(i));
  }

  // 109	[450]	CALL     	14 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x05020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 110	[450]	TFORPREP 	14 13	; to 125
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x0006874b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_124;
  }

  // 111	[451]	GETTABUP 	20 0 13	; _ENV "check"
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x0d000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 112	[451]	GETI     	21 19 2
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x02130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 113	[451]	GETI     	22 19 3
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x03130b0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 114	[451]	GETI     	23 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x01130b8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 115	[451]	MOVE     	24 13
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x000d0c00);
    setobjs2s(L, ra, RB(i));
  }

  // 116	[451]	GETI     	25 19 4
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x04130c8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 117	[451]	CALL     	20 6 1	; 5 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x01060a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 118	[452]	GETI     	20 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x01130a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 119	[452]	GETI     	21 19 3
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x03130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 120	[452]	SETTABLE 	13 20 21
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x15140690);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 121	[453]	GETI     	20 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x01130a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 122	[453]	GETI     	21 19 2
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x02130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 123	[453]	SETTABLE 	12 20 21
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x15140610);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 124	[450]	TFORCALL 	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x0200074c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 125	[450]	TFORLOOP 	14 15	; to 112
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x0007874d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_111; /* jump back */
    }
  }

  // 126	[454]	CLOSE    	14
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x00000736);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 127	[455]	CLOSE    	7
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x000003b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 128	[421]	TFORCALL 	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x020000cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 129	[421]	TFORLOOP 	1 116	; to 15
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x003a00cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_14; /* jump back */
    }
  }

  // 130	[455]	CLOSE    	1
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_132
  label_130: {
    aot_vmfetch(0x000000b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 131	[456]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_133
  label_131: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 132	[456]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 133)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_132: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 133	[457]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 134)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_133: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 438 - 440
static
CallInfo *magic_implementation_56(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
  }

  // 0	[439]	GETUPVAL 	0 1	; def
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00010009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[439]	GETI     	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0100008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[439]	GETUPVAL 	0 0	; knownValues
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[439]	GETTABUP 	2 2 0	; _ENV "value"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0002010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[439]	CALL     	2 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02010144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[439]	SETTABLE 	0 1 2
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_05: {
    aot_vmfetch(0x02010010);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 6	[440]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 440 - 440
static
CallInfo *magic_implementation_57(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
  }

  // 0	[440]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_00: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 458 - 464
static
CallInfo *magic_implementation_58(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
  }

  // 0	[460]	GETTABUP 	0 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[460]	LOADK    	1 1	; "All valid checkable types:"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[460]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[461]	GETTABUP 	0 0 2	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0200000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[461]	GETTABUP 	1 0 3	; _ENV "alltypes"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0300008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 5	[461]	CALL     	0 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x05020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[461]	TFORPREP 	0 5	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0002804b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_12;
  }

  // 7	[462]	GETTABUP 	6 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0000030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[462]	LOADK    	7 4	; "  "
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00020383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[462]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[462]	CONCAT   	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000203b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 11	[462]	CALL     	6 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x01020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[461]	TFORCALL 	0 2
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0200004c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 13	[461]	TFORLOOP 	0 7	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0003804d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_07; /* jump back */
    }
  }

  // 14	[463]	CLOSE    	0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x00000036);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 15	[464]	RETURN   	0 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x00018046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 496 - 511
static
CallInfo *magic_implementation_59(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
  }

  // 0	[498]	LOADK    	3 0	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[499]	LEN      	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00010234);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 2	[500]	LOADI    	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000281);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 3	[501]	LEN      	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000334);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 4	[501]	LE       	5 6 0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_32
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000602bb);
    op_order(L, l_lei, LEnum, lessequalothers);
  }

  // 5	[501]	JMP      	26	; to 33
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000cb8);
    updatetrap(ci);
    goto label_32;
  }

  // 6	[502]	SELF     	6 0 1k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x01008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[502]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[502]	ADD      	9 5 4
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x040504a2);
    op_arith(L, l_addi, luai_numadd);
  }

  // 9	[502]	MMBIN    	5 4 6	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x060402ae);
    Instruction pi = 0x040504a2; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 10	[502]	ADDI     	9 9 -1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x7e090495);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 11	[502]	MMBINI   	9 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x078004af);
    Instruction pi = 0x7e090495;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 12	[502]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 13	[502]	EQ       	6 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00010339);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 14	[502]	JMP      	7	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_22;
  }

  // 15	[503]	MOVE     	6 3
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00030300);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[503]	MOVE     	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00020380);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[503]	CONCAT   	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00020335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 18	[503]	MOVE     	3 6
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00060180);
    setobjs2s(L, ra, RB(i));
  }

  // 19	[504]	ADD      	5 5 4
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x040502a2);
    op_arith(L, l_addi, luai_numadd);
  }

  // 20	[504]	MMBIN    	5 4 6	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_03
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x060402ae);
    Instruction pi = 0x040502a2; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 21	[505]	JMP      	-19	; to 4
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x7ffff638);
    updatetrap(ci);
    goto label_03;
  }

  // 22	[506]	MOVE     	6 3
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00030300);
    setobjs2s(L, ra, RB(i));
  }

  // 23	[506]	SELF     	7 0 1k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x01008394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 24	[506]	MOVE     	9 5
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00050480);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[506]	MOVE     	10 5
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00050500);
    setobjs2s(L, ra, RB(i));
  }

  // 26	[506]	CALL     	7 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x020403c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 27	[506]	CONCAT   	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00020335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 28	[506]	MOVE     	3 6
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00060180);
    setobjs2s(L, ra, RB(i));
  }

  // 29	[507]	ADDI     	5 5 1
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x80050295);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 30	[507]	MMBINI   	5 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_03
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x068002af);
    Instruction pi = 0x80050295;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 31	[509]	JMP      	-29	; to 4
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x7ffff138);
    updatetrap(ci);
    goto label_03;
  }

  // 32	[510]	RETURN1  	3
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_32: {
    aot_vmfetch(0x000201c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 33	[511]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_33: {
    aot_vmfetch(0x00010347);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 513 - 524
static
CallInfo *magic_implementation_60(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
  }

  // 0	[514]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_03
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 1	[514]	JMP      	1	; to 4
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_03;
  }

  // 2	[514]	LOADI    	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 3	[515]	LEN      	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000101b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 4	[516]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 5	[517]	LEN      	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000002b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 6	[517]	LE       	4 5 0
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_26
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0005023b);
    op_order(L, l_lei, LEnum, lessequalothers);
  }

  // 7	[517]	JMP      	18	; to 27
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x800008b8);
    updatetrap(ci);
    goto label_26;
  }

  // 8	[518]	SELF     	5 0 0k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 9	[518]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[518]	ADD      	8 4 3
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x03040422);
    op_arith(L, l_addi, luai_numadd);
  }

  // 11	[518]	MMBIN    	4 3 6	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0603022e);
    Instruction pi = 0x03040422; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 12	[518]	ADDI     	8 8 -1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x7e080415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 13	[518]	MMBINI   	8 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0780042f);
    Instruction pi = 0x7e080415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 14	[518]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 15	[518]	EQ       	5 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000102b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 16	[518]	JMP      	6	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_23;
  }

  // 17	[519]	MOVE     	5 4
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00040280);
    setobjs2s(L, ra, RB(i));
  }

  // 18	[519]	ADD      	6 4 3
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x03040322);
    op_arith(L, l_addi, luai_numadd);
  }

  // 19	[519]	MMBIN    	4 3 6	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0603022e);
    Instruction pi = 0x03040322; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 20	[519]	ADDI     	6 6 -1
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x7e060315);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 21	[519]	MMBINI   	6 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0780032f);
    Instruction pi = 0x7e060315;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 22	[519]	RETURN   	5 3 0	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000302c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 23	[521]	ADDI     	4 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x80040215);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 24	[521]	MMBINI   	4 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_05
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0680022f);
    Instruction pi = 0x80040215;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 25	[522]	JMP      	-21	; to 6
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x7ffff538);
    updatetrap(ci);
    goto label_05;
  }

  // 26	[523]	LOADNIL  	5 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00000288);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 27	[523]	RETURN1  	5
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_27: {
    aot_vmfetch(0x000202c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 28	[524]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_28: {
    aot_vmfetch(0x000102c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 526 - 618
static
CallInfo *magic_implementation_61(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
    case 132: goto label_132;
    case 133: goto label_133;
    case 134: goto label_134;
    case 135: goto label_135;
    case 136: goto label_136;
    case 137: goto label_137;
    case 138: goto label_138;
    case 139: goto label_139;
    case 140: goto label_140;
    case 141: goto label_141;
    case 142: goto label_142;
    case 143: goto label_143;
    case 144: goto label_144;
    case 145: goto label_145;
    case 146: goto label_146;
    case 147: goto label_147;
    case 148: goto label_148;
    case 149: goto label_149;
    case 150: goto label_150;
    case 151: goto label_151;
    case 152: goto label_152;
    case 153: goto label_153;
    case 154: goto label_154;
    case 155: goto label_155;
    case 156: goto label_156;
    case 157: goto label_157;
    case 158: goto label_158;
    case 159: goto label_159;
    case 160: goto label_160;
    case 161: goto label_161;
    case 162: goto label_162;
    case 163: goto label_163;
    case 164: goto label_164;
    case 165: goto label_165;
    case 166: goto label_166;
    case 167: goto label_167;
    case 168: goto label_168;
    case 169: goto label_169;
    case 170: goto label_170;
    case 171: goto label_171;
    case 172: goto label_172;
    case 173: goto label_173;
    case 174: goto label_174;
    case 175: goto label_175;
    case 176: goto label_176;
    case 177: goto label_177;
    case 178: goto label_178;
    case 179: goto label_179;
    case 180: goto label_180;
    case 181: goto label_181;
    case 182: goto label_182;
    case 183: goto label_183;
    case 184: goto label_184;
    case 185: goto label_185;
    case 186: goto label_186;
    case 187: goto label_187;
    case 188: goto label_188;
    case 189: goto label_189;
    case 190: goto label_190;
    case 191: goto label_191;
    case 192: goto label_192;
    case 193: goto label_193;
    case 194: goto label_194;
    case 195: goto label_195;
    case 196: goto label_196;
    case 197: goto label_197;
    case 198: goto label_198;
    case 199: goto label_199;
    case 200: goto label_200;
    case 201: goto label_201;
    case 202: goto label_202;
    case 203: goto label_203;
    case 204: goto label_204;
    case 205: goto label_205;
    case 206: goto label_206;
    case 207: goto label_207;
    case 208: goto label_208;
    case 209: goto label_209;
    case 210: goto label_210;
    case 211: goto label_211;
    case 212: goto label_212;
    case 213: goto label_213;
    case 214: goto label_214;
    case 215: goto label_215;
    case 216: goto label_216;
    case 217: goto label_217;
    case 218: goto label_218;
    case 219: goto label_219;
    case 220: goto label_220;
    case 221: goto label_221;
    case 222: goto label_222;
    case 223: goto label_223;
    case 224: goto label_224;
    case 225: goto label_225;
    case 226: goto label_226;
    case 227: goto label_227;
    case 228: goto label_228;
    case 229: goto label_229;
    case 230: goto label_230;
    case 231: goto label_231;
    case 232: goto label_232;
    case 233: goto label_233;
    case 234: goto label_234;
    case 235: goto label_235;
    case 236: goto label_236;
    case 237: goto label_237;
    case 238: goto label_238;
    case 239: goto label_239;
    case 240: goto label_240;
    case 241: goto label_241;
    case 242: goto label_242;
    case 243: goto label_243;
    case 244: goto label_244;
    case 245: goto label_245;
    case 246: goto label_246;
    case 247: goto label_247;
    case 248: goto label_248;
    case 249: goto label_249;
    case 250: goto label_250;
    case 251: goto label_251;
    case 252: goto label_252;
  }

  // 0	[527]	GETTABUP 	1 0 2	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[527]	GETFIELD 	1 1 3	; "clean"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[527]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[527]	CALL     	1 2 3	; 1 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x030200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[527]	SETTABUP 	0 1 2	; _ENV "dead"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0201000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 5	[527]	SETTABUP 	0 0 1	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0100000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 6	[529]	GETTABUP 	1 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[529]	SELF     	1 1 5k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x05018094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[529]	LOADK    	3 6	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00030183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[529]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[529]	SETTABUP 	0 4 1	; _ENV "lines"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0104000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 11	[532]	GETTABUP 	1 0 7	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0700008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[532]	GETTABUP 	2 0 4	; _ENV "lines"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[532]	CALL     	1 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x050200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[532]	TFORPREP 	1 228	; to 244
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x007200cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_243;
  }

  // 15	[533]	GETTABUP 	7 0 2	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x0200038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 16	[533]	GETFIELD 	7 7 9	; "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0907038e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 17	[533]	MOVE     	8 6
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00060400);
    setobjs2s(L, ra, RB(i));
  }

  // 18	[533]	GETTABUP 	9 0 1	; _ENV "dead"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0100048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 19	[533]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[533]	SETTABUP 	0 8 7	; _ENV "vclean"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0708000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 21	[535]	LOADK    	7 10	; "var%s+([^%s]+)%s+<pre>%s*=%s*(.-)%s*$"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00050383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 22	[536]	GETTABUP 	8 0 8	; _ENV "vclean"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0800040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 23	[536]	SELF     	8 8 11k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x0b088414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 24	[536]	MOVE     	10 7
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00070500);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[536]	CALL     	8 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x05030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 26	[536]	TFORPREP 	8 70	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x0023044b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_97;
  }

  // 27	[537]	SETTABUP 	0 12 13k	; _ENV "newval" ""
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0d0c800f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 28	[538]	GETTABUP 	14 0 14	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x0e00070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 29	[540]	CLOSURE  	15 0	; 0x7fbced00d610
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x000007cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 30	[542]	CLOSURE  	16 1	; 0x7fbced00d740
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x0000884f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 31	[538]	CALL     	14 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x01030744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[545]	GETTABUP 	14 0 15	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x0f00070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 33	[545]	GETTABUP 	15 0 16	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x1000078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 34	[545]	CALL     	14 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x02020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 35	[545]	EQK      	14 17 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x0011073c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 36	[545]	JMP      	5	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_42;
  }

  // 37	[545]	LOADK    	14 18	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00090703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 38	[545]	GETTABUP 	15 0 16	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x1000078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 39	[545]	LOADK    	16 18	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00090803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 40	[545]	CONCAT   	14 3
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00030735);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 41	[545]	SETTABUP 	0 16 14	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x0e10000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 42	[546]	GETTABUP 	14 0 15	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0f00070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[546]	GETTABUP 	15 0 16	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x1000078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 44	[546]	CALL     	14 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x02020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 45	[546]	EQK      	14 19 0	; "table"
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x0013073c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 46	[546]	JMP      	4	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_51;
  }

  // 47	[546]	GETTABUP 	14 0 20	; _ENV "tabletostring"
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x1400070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 48	[546]	GETTABUP 	15 0 16	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x1000078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 49	[546]	CALL     	14 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x02020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 50	[546]	SETTABUP 	0 16 14	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0e10000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 51	[547]	GETTABUP 	14 0 15	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x0f00070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 52	[547]	GETTABUP 	15 0 16	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x1000078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 53	[547]	CALL     	14 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x02020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 54	[547]	EQK      	14 21 0	; "function"
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_61
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x0015073c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 55	[547]	JMP      	5	; to 62
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_61;
  }

  // 56	[547]	GETTABUP 	14 0 22	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x1600070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 57	[547]	LOADK    	15 23	; "Functions are not supported in <pre> values"
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x000b8783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 58	[547]	MOVE     	16 6
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00060800);
    setobjs2s(L, ra, RB(i));
  }

  // 59	[547]	CALL     	14 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x02030744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 60	[547]	SETTABUP 	0 16 14	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x0e10000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 61	[548]	GETTABUP 	14 0 15	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x0f00070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 62	[548]	GETTABUP 	15 0 16	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x1000078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 63	[548]	CALL     	14 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x02020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 64	[548]	EQK      	14 24 0	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_71
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x0018073c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 65	[548]	JMP      	5	; to 72
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_71;
  }

  // 66	[548]	GETTABUP 	14 0 22	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x1600070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 67	[548]	LOADK    	15 25	; "Userdata is not supported in <pre> values"
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x000c8783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 68	[548]	MOVE     	16 6
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x00060800);
    setobjs2s(L, ra, RB(i));
  }

  // 69	[548]	CALL     	14 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x02030744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 70	[548]	SETTABUP 	0 16 14	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x0e10000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 71	[549]	GETTABUP 	14 0 15	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x0f00070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 72	[549]	GETTABUP 	15 0 16	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x1000078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 73	[549]	CALL     	14 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x02020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 74	[549]	EQK      	14 26 0	; "thread"
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_81
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x001a073c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 75	[549]	JMP      	5	; to 82
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_81;
  }

  // 76	[549]	GETTABUP 	14 0 22	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x1600070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 77	[549]	LOADK    	15 27	; "Threads are not supported in <pre> values"
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x000d8783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 78	[549]	MOVE     	16 6
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x00060800);
    setobjs2s(L, ra, RB(i));
  }

  // 79	[549]	CALL     	14 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x02030744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 80	[549]	SETTABUP 	0 16 14	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x0e10000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 81	[550]	GETTABUP 	14 0 15	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x0f00070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 82	[550]	GETTABUP 	15 0 16	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x1000078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 83	[550]	CALL     	14 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x02020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 84	[550]	EQK      	14 28 0	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_87
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x001c073c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 85	[550]	JMP      	1	; to 88
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_87;
  }

  // 86	[550]	SETTABUP 	0 16 28k	; _ENV "newval" "null"
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x1c10800f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 87	[554]	SELF     	14 6 29k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x1d068714);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 88	[554]	LOADK    	16 10	; "var%s+([^%s]+)%s+<pre>%s*=%s*(.-)%s*$"
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x00050803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 89	[554]	LOADK    	17 30	; "var "
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x000f0883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 90	[554]	MOVE     	18 12
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x000c0900);
    setobjs2s(L, ra, RB(i));
  }

  // 91	[554]	LOADK    	19 31	; " = "
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x000f8983);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 92	[554]	GETTABUP 	20 0 16	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x10000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 93	[554]	CONCAT   	17 4
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x000408b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 94	[554]	CALL     	14 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x02040744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 95	[554]	MOVE     	6 14
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x000e0300);
    setobjs2s(L, ra, RB(i));
  }

  // 96	[555]	CLOSE    	12
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x00000636);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 97	[536]	TFORCALL 	8 2
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x0200044c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 98	[536]	TFORLOOP 	8 72	; to 28
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x0024044d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_27; /* jump back */
    }
  }

  // 99	[555]	CLOSE    	8
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x00000436);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 100	[557]	GETTABUP 	8 0 8	; _ENV "vclean"
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x0800040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 101	[557]	SELF     	8 8 11k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x0b088414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 102	[557]	LOADK    	10 32	; "@[a-zA-Z0-9_]+"
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x00100503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 103	[557]	CALL     	8 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x05030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 104	[557]	TFORPREP 	8 10	; to 116
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x0005044b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_115;
  }

  // 105	[558]	SELF     	13 6 29k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x1d068694);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 106	[558]	MOVE     	15 12
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x000c0780);
    setobjs2s(L, ra, RB(i));
  }

  // 107	[558]	LOADK    	16 33	; "ipairs("
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x00108803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 108	[558]	SELF     	17 12 34k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x220c8894);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 109	[558]	LOADI    	19 2
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x80008981);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 110	[558]	CALL     	17 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x020308c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 111	[558]	LOADK    	18 35	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x00118903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 112	[558]	CONCAT   	16 3
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x00030835);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 113	[558]	CALL     	13 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x020406c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 114	[558]	MOVE     	6 13
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x000d0300);
    setobjs2s(L, ra, RB(i));
  }

  // 115	[557]	TFORCALL 	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x0100044c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 116	[557]	TFORLOOP 	8 12	; to 106
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x0006044d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_105; /* jump back */
    }
  }

  // 117	[559]	CLOSE    	8
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x00000436);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 118	[560]	GETTABUP 	8 0 8	; _ENV "vclean"
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x0800040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 119	[560]	SELF     	8 8 11k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x0b088414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 120	[560]	LOADK    	10 36	; "$[a-zA-Z0-9_]+"
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x00120503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 121	[560]	CALL     	8 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x05030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 122	[560]	TFORPREP 	8 10	; to 134
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x0005044b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_133;
  }

  // 123	[561]	SELF     	13 6 29k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x1d068694);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 124	[561]	MOVE     	15 12
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x000c0780);
    setobjs2s(L, ra, RB(i));
  }

  // 125	[561]	LOADK    	16 37	; "pairs("
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x00128803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 126	[561]	SELF     	17 12 34k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x220c8894);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 127	[561]	LOADI    	19 2
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x80008981);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 128	[561]	CALL     	17 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x020308c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 129	[561]	LOADK    	18 35	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x00118903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 130	[561]	CONCAT   	16 3
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_132
  label_130: {
    aot_vmfetch(0x00030835);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 131	[561]	CALL     	13 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_133
  label_131: {
    aot_vmfetch(0x020406c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 132	[561]	MOVE     	6 13
  #undef  AOT_PC
  #define AOT_PC (code + 133)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_134
  label_132: {
    aot_vmfetch(0x000d0300);
    setobjs2s(L, ra, RB(i));
  }

  // 133	[560]	TFORCALL 	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 134)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_135
  label_133: {
    aot_vmfetch(0x0100044c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 134	[560]	TFORLOOP 	8 12	; to 124
  #undef  AOT_PC
  #define AOT_PC (code + 135)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_136
  label_134: {
    aot_vmfetch(0x0006044d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_123; /* jump back */
    }
  }

  // 135	[562]	CLOSE    	8
  #undef  AOT_PC
  #define AOT_PC (code + 136)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_137
  label_135: {
    aot_vmfetch(0x00000436);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 136	[565]	SELF     	8 6 11k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 137)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_138
  label_136: {
    aot_vmfetch(0x0b068414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 137	[565]	LOADK    	10 38	; "[a-zA-Z0-9_]+~[^%s]+"
  #undef  AOT_PC
  #define AOT_PC (code + 138)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_139
  label_137: {
    aot_vmfetch(0x00130503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 138	[565]	CALL     	8 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 139)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_140
  label_138: {
    aot_vmfetch(0x05030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 139	[565]	TFORPREP 	8 28	; to 169
  #undef  AOT_PC
  #define AOT_PC (code + 140)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_141
  label_139: {
    aot_vmfetch(0x000e044b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_168;
  }

  // 140	[572]	SELF     	13 12 34k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 141)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_142
  label_140: {
    aot_vmfetch(0x220c8694);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 141	[572]	LOADI    	15 1
  #undef  AOT_PC
  #define AOT_PC (code + 142)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_143
  label_141: {
    aot_vmfetch(0x80000781);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 142	[572]	SELF     	16 12 40k	; "find"
  #undef  AOT_PC
  #define AOT_PC (code + 143)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_144
  label_142: {
    aot_vmfetch(0x280c8814);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 143	[572]	LOADK    	18 41	; "~"
  #undef  AOT_PC
  #define AOT_PC (code + 144)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_145
  label_143: {
    aot_vmfetch(0x00148903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 144	[572]	CALL     	16 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 145)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_146
  label_144: {
    aot_vmfetch(0x02030844);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 145	[572]	ADDI     	16 16 -1
  #undef  AOT_PC
  #define AOT_PC (code + 146)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_147
  label_145: {
    aot_vmfetch(0x7e100815);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 146	[572]	MMBINI   	16 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 147)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_148
  label_146: {
    aot_vmfetch(0x0780082f);
    Instruction pi = 0x7e100815;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 147	[572]	CALL     	13 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 148)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_149
  label_147: {
    aot_vmfetch(0x020406c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 148	[572]	SETTABUP 	0 39 13	; _ENV "arg1"
  #undef  AOT_PC
  #define AOT_PC (code + 149)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_150
  label_148: {
    aot_vmfetch(0x0d27000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 149	[573]	SELF     	13 12 34k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 150)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_151
  label_149: {
    aot_vmfetch(0x220c8694);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 150	[573]	SELF     	15 12 40k	; "find"
  #undef  AOT_PC
  #define AOT_PC (code + 151)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_152
  label_150: {
    aot_vmfetch(0x280c8794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 151	[573]	LOADK    	17 41	; "~"
  #undef  AOT_PC
  #define AOT_PC (code + 152)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_153
  label_151: {
    aot_vmfetch(0x00148883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 152	[573]	CALL     	15 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 153)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_154
  label_152: {
    aot_vmfetch(0x020307c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 153	[573]	ADDI     	15 15 1
  #undef  AOT_PC
  #define AOT_PC (code + 154)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_155
  label_153: {
    aot_vmfetch(0x800f0795);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 154	[573]	MMBINI   	15 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 155)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_156
  label_154: {
    aot_vmfetch(0x068007af);
    Instruction pi = 0x800f0795;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 155	[573]	CALL     	13 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 156)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_157
  label_155: {
    aot_vmfetch(0x020306c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 156	[573]	SETTABUP 	0 42 13	; _ENV "arg2"
  #undef  AOT_PC
  #define AOT_PC (code + 157)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_158
  label_156: {
    aot_vmfetch(0x0d2a000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 157	[574]	GETTABUP 	13 0 29	; _ENV "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 158)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_159
  label_157: {
    aot_vmfetch(0x1d00068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 158	[574]	MOVE     	14 6
  #undef  AOT_PC
  #define AOT_PC (code + 159)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_160
  label_158: {
    aot_vmfetch(0x00060700);
    setobjs2s(L, ra, RB(i));
  }

  // 159	[574]	MOVE     	15 12
  #undef  AOT_PC
  #define AOT_PC (code + 160)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_161
  label_159: {
    aot_vmfetch(0x000c0780);
    setobjs2s(L, ra, RB(i));
  }

  // 160	[574]	LOADK    	16 43	; "_.global(\""
  #undef  AOT_PC
  #define AOT_PC (code + 161)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_162
  label_160: {
    aot_vmfetch(0x00158803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 161	[574]	GETTABUP 	17 0 39	; _ENV "arg1"
  #undef  AOT_PC
  #define AOT_PC (code + 162)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_163
  label_161: {
    aot_vmfetch(0x2700088b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 162	[574]	LOADK    	18 44	; "\", "
  #undef  AOT_PC
  #define AOT_PC (code + 163)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_164
  label_162: {
    aot_vmfetch(0x00160903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 163	[574]	GETTABUP 	19 0 42	; _ENV "arg2"
  #undef  AOT_PC
  #define AOT_PC (code + 164)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_165
  label_163: {
    aot_vmfetch(0x2a00098b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 164	[574]	LOADK    	20 35	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 165)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_166
  label_164: {
    aot_vmfetch(0x00118a03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 165	[574]	CONCAT   	16 5
  #undef  AOT_PC
  #define AOT_PC (code + 166)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_167
  label_165: {
    aot_vmfetch(0x00050835);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 166	[574]	CALL     	13 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 167)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_168
  label_166: {
    aot_vmfetch(0x020406c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 167	[574]	MOVE     	6 13
  #undef  AOT_PC
  #define AOT_PC (code + 168)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_169
  label_167: {
    aot_vmfetch(0x000d0300);
    setobjs2s(L, ra, RB(i));
  }

  // 168	[565]	TFORCALL 	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 169)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_170
  label_168: {
    aot_vmfetch(0x0100044c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 169	[565]	TFORLOOP 	8 30	; to 141
  #undef  AOT_PC
  #define AOT_PC (code + 170)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_171
  label_169: {
    aot_vmfetch(0x000f044d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_140; /* jump back */
    }
  }

  // 170	[575]	CLOSE    	8
  #undef  AOT_PC
  #define AOT_PC (code + 171)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_172
  label_170: {
    aot_vmfetch(0x00000436);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 171	[588]	SELF     	8 6 11k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 172)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_173
  label_171: {
    aot_vmfetch(0x0b068414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 172	[588]	LOADK    	10 45	; "f'(.-)'"
  #undef  AOT_PC
  #define AOT_PC (code + 173)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_174
  label_172: {
    aot_vmfetch(0x00168503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 173	[588]	CALL     	8 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 174)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_175
  label_173: {
    aot_vmfetch(0x05030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 174	[588]	TFORPREP 	8 33	; to 209
  #undef  AOT_PC
  #define AOT_PC (code + 175)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_176
  label_174: {
    aot_vmfetch(0x0010844b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_208;
  }

  // 175	[590]	GETTABUP 	13 0 2	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 176)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_177
  label_175: {
    aot_vmfetch(0x0200068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 176	[590]	GETFIELD 	13 13 9	; "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 177)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_178
  label_176: {
    aot_vmfetch(0x090d068e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 177	[590]	SELF     	14 6 29k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 178)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_179
  label_177: {
    aot_vmfetch(0x1d068714);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 178	[590]	LOADK    	16 45	; "f'(.-)'"
  #undef  AOT_PC
  #define AOT_PC (code + 179)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_180
  label_178: {
    aot_vmfetch(0x00168803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 179	[590]	LOADK    	17 46	; "string.format('"
  #undef  AOT_PC
  #define AOT_PC (code + 180)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_181
  label_179: {
    aot_vmfetch(0x00170883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 180	[590]	MOVE     	18 12
  #undef  AOT_PC
  #define AOT_PC (code + 181)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_182
  label_180: {
    aot_vmfetch(0x000c0900);
    setobjs2s(L, ra, RB(i));
  }

  // 181	[590]	LOADK    	19 47	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 182)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_183
  label_181: {
    aot_vmfetch(0x00178983);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 182	[590]	CONCAT   	17 3
  #undef  AOT_PC
  #define AOT_PC (code + 183)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_184
  label_182: {
    aot_vmfetch(0x000308b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 183	[590]	CALL     	14 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 184)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_185
  label_183: {
    aot_vmfetch(0x02040744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 184	[590]	GETTABUP 	15 0 1	; _ENV "dead"
  #undef  AOT_PC
  #define AOT_PC (code + 185)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_186
  label_184: {
    aot_vmfetch(0x0100078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 185	[590]	CALL     	13 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 186)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_187
  label_185: {
    aot_vmfetch(0x020306c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 186	[590]	MOVE     	6 13
  #undef  AOT_PC
  #define AOT_PC (code + 187)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_188
  label_186: {
    aot_vmfetch(0x000d0300);
    setobjs2s(L, ra, RB(i));
  }

  // 187	[592]	SELF     	13 6 11k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 188)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_189
  label_187: {
    aot_vmfetch(0x0b068694);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 188	[592]	LOADK    	15 48	; "{(.-)}"
  #undef  AOT_PC
  #define AOT_PC (code + 189)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_190
  label_188: {
    aot_vmfetch(0x00180783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 189	[592]	CALL     	13 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 190)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_191
  label_189: {
    aot_vmfetch(0x050306c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 190	[592]	TFORPREP 	13 10	; to 202
  #undef  AOT_PC
  #define AOT_PC (code + 191)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_192
  label_190: {
    aot_vmfetch(0x000506cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_201;
  }

  // 191	[594]	MOVE     	18 6
  #undef  AOT_PC
  #define AOT_PC (code + 192)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_193
  label_191: {
    aot_vmfetch(0x00060900);
    setobjs2s(L, ra, RB(i));
  }

  // 192	[594]	LOADK    	19 49	; ", "
  #undef  AOT_PC
  #define AOT_PC (code + 193)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_194
  label_192: {
    aot_vmfetch(0x00188983);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 193	[594]	MOVE     	20 17
  #undef  AOT_PC
  #define AOT_PC (code + 194)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_195
  label_193: {
    aot_vmfetch(0x00110a00);
    setobjs2s(L, ra, RB(i));
  }

  // 194	[594]	CONCAT   	18 3
  #undef  AOT_PC
  #define AOT_PC (code + 195)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_196
  label_194: {
    aot_vmfetch(0x00030935);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 195	[594]	MOVE     	6 18
  #undef  AOT_PC
  #define AOT_PC (code + 196)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_197
  label_195: {
    aot_vmfetch(0x00120300);
    setobjs2s(L, ra, RB(i));
  }

  // 196	[596]	SELF     	18 6 29k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 197)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_198
  label_196: {
    aot_vmfetch(0x1d068914);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 197	[596]	LOADK    	20 48	; "{(.-)}"
  #undef  AOT_PC
  #define AOT_PC (code + 198)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_199
  label_197: {
    aot_vmfetch(0x00180a03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 198	[596]	LOADK    	21 50	; "%%s"
  #undef  AOT_PC
  #define AOT_PC (code + 199)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_200
  label_198: {
    aot_vmfetch(0x00190a83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 199	[596]	CALL     	18 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 200)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_201
  label_199: {
    aot_vmfetch(0x02040944);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 200	[596]	MOVE     	6 18
  #undef  AOT_PC
  #define AOT_PC (code + 201)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_202
  label_200: {
    aot_vmfetch(0x00120300);
    setobjs2s(L, ra, RB(i));
  }

  // 201	[592]	TFORCALL 	13 1
  #undef  AOT_PC
  #define AOT_PC (code + 202)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_203
  label_201: {
    aot_vmfetch(0x010006cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 202	[592]	TFORLOOP 	13 12	; to 192
  #undef  AOT_PC
  #define AOT_PC (code + 203)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_204
  label_202: {
    aot_vmfetch(0x000606cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_191; /* jump back */
    }
  }

  // 203	[597]	CLOSE    	13
  #undef  AOT_PC
  #define AOT_PC (code + 204)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_205
  label_203: {
    aot_vmfetch(0x000006b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 204	[600]	MOVE     	13 6
  #undef  AOT_PC
  #define AOT_PC (code + 205)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_206
  label_204: {
    aot_vmfetch(0x00060680);
    setobjs2s(L, ra, RB(i));
  }

  // 205	[600]	LOADK    	14 35	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 206)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_207
  label_205: {
    aot_vmfetch(0x00118703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 206	[600]	CONCAT   	13 2
  #undef  AOT_PC
  #define AOT_PC (code + 207)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_208
  label_206: {
    aot_vmfetch(0x000206b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 207	[600]	MOVE     	6 13
  #undef  AOT_PC
  #define AOT_PC (code + 208)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_209
  label_207: {
    aot_vmfetch(0x000d0300);
    setobjs2s(L, ra, RB(i));
  }

  // 208	[588]	TFORCALL 	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 209)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_210
  label_208: {
    aot_vmfetch(0x0100044c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 209	[588]	TFORLOOP 	8 35	; to 176
  #undef  AOT_PC
  #define AOT_PC (code + 210)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_211
  label_209: {
    aot_vmfetch(0x0011844d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_175; /* jump back */
    }
  }

  // 210	[601]	CLOSE    	8
  #undef  AOT_PC
  #define AOT_PC (code + 211)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_212
  label_210: {
    aot_vmfetch(0x00000436);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 211	[603]	SELF     	8 6 11k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 212)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_213
  label_211: {
    aot_vmfetch(0x0b068414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 212	[603]	LOADK    	10 51	; "f[[(.*)]]"
  #undef  AOT_PC
  #define AOT_PC (code + 213)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_214
  label_212: {
    aot_vmfetch(0x00198503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 213	[603]	CALL     	8 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 214)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_215
  label_213: {
    aot_vmfetch(0x05030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 214	[603]	TFORPREP 	8 18	; to 234
  #undef  AOT_PC
  #define AOT_PC (code + 215)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_216
  label_214: {
    aot_vmfetch(0x0009044b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_233;
  }

  // 215	[604]	GETTABUP 	13 0 52	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 216)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_217
  label_215: {
    aot_vmfetch(0x3400068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 216	[604]	LOADK    	14 53	; "\027[1;31mPreprocessor error:\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 217)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_218
  label_216: {
    aot_vmfetch(0x001a8703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 217	[604]	CALL     	13 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 218)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_219
  label_217: {
    aot_vmfetch(0x010206c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 218	[605]	GETTABUP 	13 0 52	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 219)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_220
  label_218: {
    aot_vmfetch(0x3400068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 219	[605]	LOADK    	14 54	; "\027[1;31mError with the 'f[[' preprocessor command.\027[0m\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 220)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_221
  label_219: {
    aot_vmfetch(0x001b0703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 220	[605]	CALL     	13 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 221)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_222
  label_220: {
    aot_vmfetch(0x010206c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 221	[606]	GETTABUP 	13 0 55	; _ENV "errorin"
  #undef  AOT_PC
  #define AOT_PC (code + 222)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_223
  label_221: {
    aot_vmfetch(0x3700068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 222	[606]	TEST     	13 0
  #undef  AOT_PC
  #define AOT_PC (code + 223)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_227
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_224
  label_222: {
    aot_vmfetch(0x000006c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 223	[606]	JMP      	3	; to 228
  #undef  AOT_PC
  #define AOT_PC (code + 224)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_225
  label_223: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_227;
  }

  // 224	[607]	GETTABUP 	13 0 52	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 225)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_226
  label_224: {
    aot_vmfetch(0x3400068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 225	[607]	LOADK    	14 56	; "\027[1;31mMultiline formatted strings are not supported.\027[0m\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 226)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_227
  label_225: {
    aot_vmfetch(0x001c0703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 226	[607]	CALL     	13 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 227)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_228
  label_226: {
    aot_vmfetch(0x010206c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 227	[609]	GETTABUP 	13 0 52	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 228)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_229
  label_227: {
    aot_vmfetch(0x3400068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 228	[609]	LOADK    	14 57	; "\027[1;31mStopping preprocessor.\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 229)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_230
  label_228: {
    aot_vmfetch(0x001c8703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 229	[609]	CALL     	13 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 230)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_231
  label_229: {
    aot_vmfetch(0x010206c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 230	[610]	GETTABUP 	13 0 58	; _ENV "os"
  #undef  AOT_PC
  #define AOT_PC (code + 231)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_232
  label_230: {
    aot_vmfetch(0x3a00068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 231	[610]	GETFIELD 	13 13 59	; "exit"
  #undef  AOT_PC
  #define AOT_PC (code + 232)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_233
  label_231: {
    aot_vmfetch(0x3b0d068e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 232	[610]	CALL     	13 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 233)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_234
  label_232: {
    aot_vmfetch(0x010106c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 233	[603]	TFORCALL 	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 234)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_235
  label_233: {
    aot_vmfetch(0x0100044c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 234	[603]	TFORLOOP 	8 20	; to 216
  #undef  AOT_PC
  #define AOT_PC (code + 235)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_236
  label_234: {
    aot_vmfetch(0x000a044d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_215; /* jump back */
    }
  }

  // 235	[611]	CLOSE    	8
  #undef  AOT_PC
  #define AOT_PC (code + 236)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_237
  label_235: {
    aot_vmfetch(0x00000436);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 236	[613]	GETTABUP 	8 0 4	; _ENV "lines"
  #undef  AOT_PC
  #define AOT_PC (code + 237)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_238
  label_236: {
    aot_vmfetch(0x0400040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 237	[613]	GETTABUP 	9 0 2	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 238)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_239
  label_237: {
    aot_vmfetch(0x0200048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 238	[613]	GETFIELD 	9 9 9	; "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 239)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_240
  label_238: {
    aot_vmfetch(0x0909048e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 239	[613]	MOVE     	10 6
  #undef  AOT_PC
  #define AOT_PC (code + 240)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_241
  label_239: {
    aot_vmfetch(0x00060500);
    setobjs2s(L, ra, RB(i));
  }

  // 240	[613]	CALL     	9 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 241)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_242
  label_240: {
    aot_vmfetch(0x020204c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 241	[613]	SETTABLE 	8 5 9
  #undef  AOT_PC
  #define AOT_PC (code + 242)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_243
  label_241: {
    aot_vmfetch(0x09050410);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 242	[614]	CLOSE    	5
  #undef  AOT_PC
  #define AOT_PC (code + 243)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_244
  label_242: {
    aot_vmfetch(0x000002b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 243	[532]	TFORCALL 	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 244)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_245
  label_243: {
    aot_vmfetch(0x020000cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 244	[532]	TFORLOOP 	1 230	; to 16
  #undef  AOT_PC
  #define AOT_PC (code + 245)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_246
  label_244: {
    aot_vmfetch(0x007300cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_15; /* jump back */
    }
  }

  // 245	[614]	CLOSE    	1
  #undef  AOT_PC
  #define AOT_PC (code + 246)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_247
  label_245: {
    aot_vmfetch(0x000000b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 246	[617]	GETTABUP 	1 0 19	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 247)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_248
  label_246: {
    aot_vmfetch(0x1300008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 247	[617]	GETFIELD 	1 1 60	; "concat"
  #undef  AOT_PC
  #define AOT_PC (code + 248)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_249
  label_247: {
    aot_vmfetch(0x3c01008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 248	[617]	GETTABUP 	2 0 4	; _ENV "lines"
  #undef  AOT_PC
  #define AOT_PC (code + 249)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_250
  label_248: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 249	[617]	LOADK    	3 6	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 250)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_251
  label_249: {
    aot_vmfetch(0x00030183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 250	[617]	TAILCALL 	1 3 0	; 2 in
  #undef  AOT_PC
  #define AOT_PC (code + 251)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_252
  label_250: {
    aot_vmfetch(0x000380c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 251	[617]	RETURN   	1 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 252)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_251: {
    aot_vmfetch(0x000080c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 252	[618]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 253)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_252: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 538 - 540
static
CallInfo *magic_implementation_62(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
  }

  // 0	[539]	GETTABUP 	0 0 1	; _ENV "loadstring"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0100000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[539]	LOADK    	1 2	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00010083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[539]	GETUPVAL 	2 1	; match2
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[539]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 4	[539]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[539]	CALL     	0 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02010044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[539]	SETTABUP 	0 0 0	; _ENV "newval"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x0000000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 7	[540]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 540 - 542
static
CallInfo *magic_implementation_63(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
  }

  // 0	[541]	GETTABUP 	1 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[541]	LOADK    	2 1	; "Error rendering <pre> value: "
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[541]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[541]	CONCAT   	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00020135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 4	[541]	GETUPVAL 	3 1	; v
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 5	[541]	CALL     	1 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_05: {
    aot_vmfetch(0x010300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[542]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 662 - 1225
static
CallInfo *magic_implementation_64(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
    case 132: goto label_132;
    case 133: goto label_133;
    case 134: goto label_134;
    case 135: goto label_135;
    case 136: goto label_136;
    case 137: goto label_137;
    case 138: goto label_138;
    case 139: goto label_139;
    case 140: goto label_140;
    case 141: goto label_141;
    case 142: goto label_142;
    case 143: goto label_143;
    case 144: goto label_144;
    case 145: goto label_145;
    case 146: goto label_146;
    case 147: goto label_147;
    case 148: goto label_148;
    case 149: goto label_149;
    case 150: goto label_150;
    case 151: goto label_151;
    case 152: goto label_152;
    case 153: goto label_153;
    case 154: goto label_154;
    case 155: goto label_155;
    case 156: goto label_156;
    case 157: goto label_157;
    case 158: goto label_158;
    case 159: goto label_159;
    case 160: goto label_160;
    case 161: goto label_161;
    case 162: goto label_162;
    case 163: goto label_163;
    case 164: goto label_164;
    case 165: goto label_165;
    case 166: goto label_166;
    case 167: goto label_167;
    case 168: goto label_168;
    case 169: goto label_169;
    case 170: goto label_170;
    case 171: goto label_171;
    case 172: goto label_172;
    case 173: goto label_173;
    case 174: goto label_174;
    case 175: goto label_175;
    case 176: goto label_176;
    case 177: goto label_177;
    case 178: goto label_178;
    case 179: goto label_179;
    case 180: goto label_180;
    case 181: goto label_181;
    case 182: goto label_182;
    case 183: goto label_183;
    case 184: goto label_184;
    case 185: goto label_185;
    case 186: goto label_186;
    case 187: goto label_187;
    case 188: goto label_188;
    case 189: goto label_189;
    case 190: goto label_190;
    case 191: goto label_191;
    case 192: goto label_192;
    case 193: goto label_193;
    case 194: goto label_194;
    case 195: goto label_195;
    case 196: goto label_196;
    case 197: goto label_197;
    case 198: goto label_198;
    case 199: goto label_199;
    case 200: goto label_200;
    case 201: goto label_201;
    case 202: goto label_202;
    case 203: goto label_203;
    case 204: goto label_204;
    case 205: goto label_205;
    case 206: goto label_206;
    case 207: goto label_207;
    case 208: goto label_208;
    case 209: goto label_209;
    case 210: goto label_210;
    case 211: goto label_211;
    case 212: goto label_212;
    case 213: goto label_213;
    case 214: goto label_214;
    case 215: goto label_215;
    case 216: goto label_216;
    case 217: goto label_217;
    case 218: goto label_218;
    case 219: goto label_219;
    case 220: goto label_220;
    case 221: goto label_221;
    case 222: goto label_222;
    case 223: goto label_223;
    case 224: goto label_224;
    case 225: goto label_225;
    case 226: goto label_226;
    case 227: goto label_227;
    case 228: goto label_228;
    case 229: goto label_229;
    case 230: goto label_230;
    case 231: goto label_231;
    case 232: goto label_232;
    case 233: goto label_233;
    case 234: goto label_234;
    case 235: goto label_235;
    case 236: goto label_236;
    case 237: goto label_237;
    case 238: goto label_238;
    case 239: goto label_239;
    case 240: goto label_240;
    case 241: goto label_241;
    case 242: goto label_242;
    case 243: goto label_243;
    case 244: goto label_244;
    case 245: goto label_245;
    case 246: goto label_246;
    case 247: goto label_247;
    case 248: goto label_248;
    case 249: goto label_249;
    case 250: goto label_250;
    case 251: goto label_251;
    case 252: goto label_252;
    case 253: goto label_253;
    case 254: goto label_254;
    case 255: goto label_255;
    case 256: goto label_256;
    case 257: goto label_257;
    case 258: goto label_258;
    case 259: goto label_259;
    case 260: goto label_260;
    case 261: goto label_261;
    case 262: goto label_262;
    case 263: goto label_263;
    case 264: goto label_264;
    case 265: goto label_265;
    case 266: goto label_266;
    case 267: goto label_267;
    case 268: goto label_268;
    case 269: goto label_269;
    case 270: goto label_270;
    case 271: goto label_271;
    case 272: goto label_272;
    case 273: goto label_273;
    case 274: goto label_274;
    case 275: goto label_275;
    case 276: goto label_276;
    case 277: goto label_277;
    case 278: goto label_278;
    case 279: goto label_279;
    case 280: goto label_280;
    case 281: goto label_281;
    case 282: goto label_282;
    case 283: goto label_283;
    case 284: goto label_284;
    case 285: goto label_285;
    case 286: goto label_286;
    case 287: goto label_287;
    case 288: goto label_288;
    case 289: goto label_289;
    case 290: goto label_290;
    case 291: goto label_291;
    case 292: goto label_292;
    case 293: goto label_293;
    case 294: goto label_294;
    case 295: goto label_295;
    case 296: goto label_296;
    case 297: goto label_297;
    case 298: goto label_298;
    case 299: goto label_299;
    case 300: goto label_300;
    case 301: goto label_301;
    case 302: goto label_302;
    case 303: goto label_303;
    case 304: goto label_304;
    case 305: goto label_305;
    case 306: goto label_306;
    case 307: goto label_307;
    case 308: goto label_308;
    case 309: goto label_309;
    case 310: goto label_310;
    case 311: goto label_311;
    case 312: goto label_312;
    case 313: goto label_313;
    case 314: goto label_314;
    case 315: goto label_315;
    case 316: goto label_316;
    case 317: goto label_317;
    case 318: goto label_318;
    case 319: goto label_319;
    case 320: goto label_320;
    case 321: goto label_321;
    case 322: goto label_322;
    case 323: goto label_323;
    case 324: goto label_324;
    case 325: goto label_325;
    case 326: goto label_326;
    case 327: goto label_327;
    case 328: goto label_328;
    case 329: goto label_329;
    case 330: goto label_330;
    case 331: goto label_331;
    case 332: goto label_332;
    case 333: goto label_333;
    case 334: goto label_334;
    case 335: goto label_335;
    case 336: goto label_336;
    case 337: goto label_337;
    case 338: goto label_338;
    case 339: goto label_339;
    case 340: goto label_340;
    case 341: goto label_341;
    case 342: goto label_342;
    case 343: goto label_343;
    case 344: goto label_344;
    case 345: goto label_345;
    case 346: goto label_346;
    case 347: goto label_347;
    case 348: goto label_348;
    case 349: goto label_349;
    case 350: goto label_350;
  }

  // 0	[662]	VARARGPREP	4
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000251);
    ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));
    if (l_unlikely(trap)) {  /* previous "Protect" updated trap */
      luaD_hookcall(L, ci);
      L->oldpc = 1;  /* next opcode will be seen as a "new" line */
    }
    updatebase(ci);  /* function has new base after adjustment */
  }

  // 1	[666]	EQK      	3 0 1	; "-types"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_07
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x000081bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 2	[666]	JMP      	4	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_07;
  }

  // 3	[666]	EQK      	0 0 0	; "-types"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0000003c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[666]	JMP      	6	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_11;
  }

  // 5	[666]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 6	[666]	JMP      	4	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_11;
  }

  // 7	[667]	GETTABUP 	4 0 1	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0100020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[667]	GETFIELD 	4 4 2	; "all"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0204020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 9	[667]	CALL     	4 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x01010244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[668]	RETURN   	4 1 5	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x05018246);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 11	[669]	NEWTABLE 	4 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000213);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 12	[669]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 13	[669]	VARARG   	5 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000002d0);
    int n = GETARG_C(i) - 1;  /* required results */
    Protect(luaT_getvarargs(L, ci, ra, n));
  }

  // 14	[669]	SETLIST  	4 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0000024e);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 15	[669]	NEWTABLE 	5 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000293);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 16	[669]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 17	[669]	EQ       	4 5 0
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00050239);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 18	[669]	JMP      	3	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_22;
  }

  // 19	[670]	GETTABUP 	4 0 3	; _ENV "error"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0300020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 20	[670]	LOADK    	5 4	; "No arguments or invalid flags provided."
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00020283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 21	[670]	CALL     	4 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x01020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 22	[674]	GETTABUP 	4 0 5	; _ENV "macros"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0500020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 23	[674]	CALL     	4 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x01010244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[677]	LOADNIL  	4 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00000208);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 25	[678]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_29
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 26	[678]	JMP      	2	; to 30
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_29;
  }

  // 27	[678]	MOVE     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_30
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00000280);
    setobjs2s(L, ra, RB(i));
  }

  // 28	[678]	JMP      	1	; to 31
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_30;
  }

  // 29	[678]	LOADNIL  	5 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00000288);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 30	[679]	EQK      	1 6 0	; "file"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_60
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x000600bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 31	[679]	JMP      	28	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x80000db8);
    updatetrap(ci);
    goto label_60;
  }

  // 32	[680]	GETTABUP 	6 0 7	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x0700030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 33	[680]	GETFIELD 	6 6 8	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x0806030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 34	[680]	MOVE     	7 0
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00000380);
    setobjs2s(L, ra, RB(i));
  }

  // 35	[680]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 36	[681]	TEST     	6 1
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_45
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00008342);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 37	[681]	JMP      	7	; to 46
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_45;
  }

  // 38	[682]	GETTABUP 	7 0 3	; _ENV "error"
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x0300038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 39	[682]	GETTABUP 	8 0 9	; _ENV "core"
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x0900040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 40	[682]	GETFIELD 	8 8 3	; "error"
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x0308040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 41	[682]	GETFIELD 	8 8 10	; "strerror"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x0a08040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 42	[682]	LOADI    	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x80008481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 43	[682]	CALL     	8 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x00020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 44	[682]	CALL     	7 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x010003c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 45	[684]	SELF     	7 6 11k	; "read"
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x0b068394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 46	[684]	LOADK    	9 12	; "*all"
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x00060483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 47	[684]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 48	[684]	MOVE     	4 7
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x00070200);
    setobjs2s(L, ra, RB(i));
  }

  // 49	[685]	SELF     	7 6 13k	; "close"
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x0d068394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 50	[685]	CALL     	7 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x010203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 51	[686]	TEST     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_60
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00008242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 52	[686]	JMP      	7	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_60;
  }

  // 53	[687]	GETTABUP 	7 0 3	; _ENV "error"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x0300038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 54	[687]	GETTABUP 	8 0 9	; _ENV "core"
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x0900040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 55	[687]	GETFIELD 	8 8 3	; "error"
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x0308040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 56	[687]	GETFIELD 	8 8 10	; "strerror"
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x0a08040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 57	[687]	LOADI    	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x80008481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 58	[687]	CALL     	8 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 59	[687]	CALL     	7 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x010003c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 60	[692]	TEST     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_63
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x00008242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 61	[692]	JMP      	1	; to 64
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_63;
  }

  // 62	[692]	MOVE     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x00000200);
    setobjs2s(L, ra, RB(i));
  }

  // 63	[693]	GETTABUP 	6 0 1	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x0100030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 64	[693]	GETFIELD 	6 6 14	; "check"
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x0e06030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 65	[693]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 66	[693]	CALL     	6 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x01020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 67	[694]	GETTABUP 	6 0 15	; _ENV "ext"
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x0f00030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 68	[694]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 69	[694]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 70	[694]	MOVE     	4 6
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x00060200);
    setobjs2s(L, ra, RB(i));
  }

  // 71	[697]	NEWTABLE 	6 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x00000313);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 72	[697]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 73	[698]	SELF     	7 4 16k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x10048394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 74	[698]	LOADK    	9 17	; "[^\r\n]+"
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x00088483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 75	[698]	CALL     	7 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x050303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 76	[698]	TFORPREP 	7 4	; to 82
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x000203cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_81;
  }

  // 77	[699]	LEN      	12 6
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x00060634);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 78	[699]	ADDI     	12 12 1
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x800c0615);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 79	[699]	MMBINI   	12 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x0680062f);
    Instruction pi = 0x800c0615;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 80	[699]	SETTABLE 	6 12 11
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x0b0c0310);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 81	[698]	TFORCALL 	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x010003cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 82	[698]	TFORLOOP 	7 6	; to 78
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x000303cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_77; /* jump back */
    }
  }

  // 83	[700]	CLOSE    	7
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x000003b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 84	[709]	CLOSURE  	7 0	; 0x7fbced00e030
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x000003cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 85	[702]	SETTABUP 	0 18 7	; _ENV "getname"
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x0712000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 86	[712]	NEWTABLE 	7 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x00000393);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 87	[712]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 88	[713]	GETTABUP 	8 0 19	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x1300040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 89	[713]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 90	[713]	CALL     	8 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x05020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 91	[713]	TFORPREP 	8 34	; to 127
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x0011044b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_126;
  }

  // 92	[714]	SELF     	14 13 20k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x140d8714);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 93	[714]	LOADI    	16 1
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x80000801);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 94	[714]	LOADI    	17 1
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x80000881);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 95	[714]	CALL     	14 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x02040744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 96	[715]	LOADI    	15 1
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x80000781);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 97	[717]	EQK      	14 21 1	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_101
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x0015873c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 98	[717]	JMP      	2	; to 102
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_101;
  }

  // 99	[717]	EQK      	14 22 0	; "\t"
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_110
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x0016073c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 100	[717]	JMP      	9	; to 111
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_110;
  }

  // 101	[718]	MOVE     	16 15
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x000f0800);
    setobjs2s(L, ra, RB(i));
  }

  // 102	[718]	ADDI     	15 15 1
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x800f0795);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 103	[718]	MMBINI   	15 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x068007af);
    Instruction pi = 0x800f0795;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 104	[719]	SELF     	16 13 20k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x140d8814);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 105	[719]	MOVE     	18 15
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x000f0900);
    setobjs2s(L, ra, RB(i));
  }

  // 106	[719]	MOVE     	19 15
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x000f0980);
    setobjs2s(L, ra, RB(i));
  }

  // 107	[719]	CALL     	16 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x02040844);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 108	[719]	MOVE     	14 16
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_97
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x00100700);
    setobjs2s(L, ra, RB(i));
  }

  // 109	[720]	JMP      	-13	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x7ffff938);
    updatetrap(ci);
    goto label_97;
  }

  // 110	[722]	EQK      	14 23 0	; "#"
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_126
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x0017073c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 111	[722]	JMP      	14	; to 127
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x800006b8);
    updatetrap(ci);
    goto label_126;
  }

  // 112	[723]	SELF     	16 13 20k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x140d8814);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 113	[723]	MOVE     	18 15
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x000f0900);
    setobjs2s(L, ra, RB(i));
  }

  // 114	[723]	LEN      	19 13
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x000d09b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 115	[723]	CALL     	16 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x02040844);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 116	[723]	MOVE     	13 16
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x00100680);
    setobjs2s(L, ra, RB(i));
  }

  // 117	[725]	GETTABUP 	16 0 24	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x1800080b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 118	[725]	GETFIELD 	16 16 25	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x1910080e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 119	[725]	MOVE     	17 7
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x00070880);
    setobjs2s(L, ra, RB(i));
  }

  // 120	[725]	NEWTABLE 	18 0 2	; 2
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x02000913);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 121	[725]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 122	[725]	MOVE     	19 12
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x000c0980);
    setobjs2s(L, ra, RB(i));
  }

  // 123	[725]	MOVE     	20 13
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x000d0a00);
    setobjs2s(L, ra, RB(i));
  }

  // 124	[725]	SETLIST  	18 2 0
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x0002094e);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 125	[725]	CALL     	16 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x01030844);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 126	[713]	TFORCALL 	8 2
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x0200044c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 127	[713]	TFORLOOP 	8 36	; to 93
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x0012044d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_92; /* jump back */
    }
  }

  // 128	[727]	CLOSE    	8
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x00000436);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 129	[730]	NEWTABLE 	8 3 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x00030413);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 130	[730]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_132
  label_130: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 131	[731]	SETFIELD 	8 26 27k	; "cobalt" true
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_133
  label_131: {
    aot_vmfetch(0x1b1a8412);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 132	[732]	SETFIELD 	8 28 29k	; "cobaltversion" "23"
  #undef  AOT_PC
  #define AOT_PC (code + 133)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_134
  label_132: {
    aot_vmfetch(0x1d1c8412);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 133	[733]	SETFIELD 	8 30 31k	; "edition" "standard"
  #undef  AOT_PC
  #define AOT_PC (code + 134)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_135
  label_133: {
    aot_vmfetch(0x1f1e8412);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 134	[734]	SETFIELD 	8 32 33k	; "cplusplus" false
  #undef  AOT_PC
  #define AOT_PC (code + 135)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_136
  label_134: {
    aot_vmfetch(0x21208412);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 135	[737]	GETTABUP 	9 0 24	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 136)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_137
  label_135: {
    aot_vmfetch(0x1800048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 136	[737]	GETFIELD 	9 9 35	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 137)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_138
  label_136: {
    aot_vmfetch(0x2309048e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 137	[737]	VARARG   	10 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 138)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_139
  label_137: {
    aot_vmfetch(0x00000550);
    int n = GETARG_C(i) - 1;  /* required results */
    Protect(luaT_getvarargs(L, ci, ra, n));
  }

  // 138	[737]	CALL     	9 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 139)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_140
  label_138: {
    aot_vmfetch(0x020004c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 139	[737]	SETTABUP 	0 34 9	; _ENV "envitems"
  #undef  AOT_PC
  #define AOT_PC (code + 140)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_141
  label_139: {
    aot_vmfetch(0x0922000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 140	[738]	NEWTABLE 	9 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 141)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_142
  label_140: {
    aot_vmfetch(0x00000493);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 141	[738]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 142)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_143
  label_141: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 142	[738]	SETTABUP 	0 36 9	; _ENV "inenv"
  #undef  AOT_PC
  #define AOT_PC (code + 143)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_144
  label_142: {
    aot_vmfetch(0x0924000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 143	[739]	GETTABUP 	9 0 19	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 144)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_145
  label_143: {
    aot_vmfetch(0x1300048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 144	[739]	GETTABUP 	10 0 34	; _ENV "envitems"
  #undef  AOT_PC
  #define AOT_PC (code + 145)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_146
  label_144: {
    aot_vmfetch(0x2200050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 145	[739]	CALL     	9 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 146)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_147
  label_145: {
    aot_vmfetch(0x050204c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 146	[739]	TFORPREP 	9 22	; to 170
  #undef  AOT_PC
  #define AOT_PC (code + 147)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_148
  label_146: {
    aot_vmfetch(0x000b04cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_169;
  }

  // 147	[740]	GETTABUP 	15 0 37	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 148)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_149
  label_147: {
    aot_vmfetch(0x2500078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 148	[740]	MOVE     	16 14
  #undef  AOT_PC
  #define AOT_PC (code + 149)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_150
  label_148: {
    aot_vmfetch(0x000e0800);
    setobjs2s(L, ra, RB(i));
  }

  // 149	[740]	CALL     	15 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 150)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_151
  label_149: {
    aot_vmfetch(0x020207c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 150	[740]	EQK      	15 38 0	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 151)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_153
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_152
  label_150: {
    aot_vmfetch(0x002607bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 151	[740]	JMP      	1	; to 154
  #undef  AOT_PC
  #define AOT_PC (code + 152)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_171
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_153
  label_151: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_153;
  }

  // 152	[741]	JMP      	18	; to 172
  #undef  AOT_PC
  #define AOT_PC (code + 153)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_154
  label_152: {
    aot_vmfetch(0x800008b8);
    updatetrap(ci);
    goto label_171;
  }

  // 153	[743]	SELF     	15 14 39k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 154)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_155
  label_153: {
    aot_vmfetch(0x270e8794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 154	[743]	LOADK    	17 40	; "-"
  #undef  AOT_PC
  #define AOT_PC (code + 155)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_156
  label_154: {
    aot_vmfetch(0x00140883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 155	[743]	LOADK    	18 41	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 156)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_157
  label_155: {
    aot_vmfetch(0x00148903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 156	[743]	CALL     	15 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 157)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_158
  label_156: {
    aot_vmfetch(0x020407c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 157	[743]	SELF     	15 15 42k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 158)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_159
  label_157: {
    aot_vmfetch(0x2a0f8794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 158	[743]	LOADK    	17 43	; "="
  #undef  AOT_PC
  #define AOT_PC (code + 159)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_160
  label_158: {
    aot_vmfetch(0x00158883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 159	[743]	CALL     	15 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 160)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_161
  label_159: {
    aot_vmfetch(0x020307c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 160	[744]	GETTABUP 	16 0 36	; _ENV "inenv"
  #undef  AOT_PC
  #define AOT_PC (code + 161)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_162
  label_160: {
    aot_vmfetch(0x2400080b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 161	[744]	GETI     	17 15 1
  #undef  AOT_PC
  #define AOT_PC (code + 162)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_163
  label_161: {
    aot_vmfetch(0x010f088d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 162	[744]	GETTABUP 	18 0 44	; _ENV "loadstring"
  #undef  AOT_PC
  #define AOT_PC (code + 163)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_164
  label_162: {
    aot_vmfetch(0x2c00090b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 163	[744]	LOADK    	19 45	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 164)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_165
  label_163: {
    aot_vmfetch(0x00168983);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 164	[744]	GETI     	20 15 2
  #undef  AOT_PC
  #define AOT_PC (code + 165)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_166
  label_164: {
    aot_vmfetch(0x020f0a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 165	[744]	CONCAT   	19 2
  #undef  AOT_PC
  #define AOT_PC (code + 166)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_167
  label_165: {
    aot_vmfetch(0x000209b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 166	[744]	CALL     	18 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 167)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_168
  label_166: {
    aot_vmfetch(0x02020944);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 167	[744]	CALL     	18 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 168)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_169
  label_167: {
    aot_vmfetch(0x02010944);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 168	[744]	SETTABLE 	16 17 18
  #undef  AOT_PC
  #define AOT_PC (code + 169)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_170
  label_168: {
    aot_vmfetch(0x12110810);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 169	[739]	TFORCALL 	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 170)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_171
  label_169: {
    aot_vmfetch(0x020004cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 170	[739]	TFORLOOP 	9 24	; to 148
  #undef  AOT_PC
  #define AOT_PC (code + 171)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_172
  label_170: {
    aot_vmfetch(0x000c04cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_147; /* jump back */
    }
  }

  // 171	[745]	CLOSE    	9
  #undef  AOT_PC
  #define AOT_PC (code + 172)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_173
  label_171: {
    aot_vmfetch(0x000004b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 172	[748]	GETTABUP 	9 0 19	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 173)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_174
  label_172: {
    aot_vmfetch(0x1300048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 173	[748]	GETTABUP 	10 0 36	; _ENV "inenv"
  #undef  AOT_PC
  #define AOT_PC (code + 174)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_175
  label_173: {
    aot_vmfetch(0x2400050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 174	[748]	CALL     	9 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 175)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_176
  label_174: {
    aot_vmfetch(0x050204c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 175	[748]	TFORPREP 	9 11	; to 188
  #undef  AOT_PC
  #define AOT_PC (code + 176)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_177
  label_175: {
    aot_vmfetch(0x000584cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_187;
  }

  // 176	[749]	GETTABUP 	15 0 37	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 177)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_178
  label_176: {
    aot_vmfetch(0x2500078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 177	[749]	MOVE     	16 14
  #undef  AOT_PC
  #define AOT_PC (code + 178)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_179
  label_177: {
    aot_vmfetch(0x000e0800);
    setobjs2s(L, ra, RB(i));
  }

  // 178	[749]	CALL     	15 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 179)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_180
  label_178: {
    aot_vmfetch(0x020207c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 179	[749]	EQK      	15 46 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 180)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_186
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_181
  label_179: {
    aot_vmfetch(0x002e07bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 180	[749]	JMP      	5	; to 187
  #undef  AOT_PC
  #define AOT_PC (code + 181)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_182
  label_180: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_186;
  }

  // 181	[749]	LOADK    	15 47	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 182)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_183
  label_181: {
    aot_vmfetch(0x00178783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 182	[749]	MOVE     	16 14
  #undef  AOT_PC
  #define AOT_PC (code + 183)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_184
  label_182: {
    aot_vmfetch(0x000e0800);
    setobjs2s(L, ra, RB(i));
  }

  // 183	[749]	LOADK    	17 47	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 184)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_185
  label_183: {
    aot_vmfetch(0x00178883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 184	[749]	CONCAT   	15 3
  #undef  AOT_PC
  #define AOT_PC (code + 185)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_186
  label_184: {
    aot_vmfetch(0x000307b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 185	[749]	MOVE     	14 15
  #undef  AOT_PC
  #define AOT_PC (code + 186)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_187
  label_185: {
    aot_vmfetch(0x000f0700);
    setobjs2s(L, ra, RB(i));
  }

  // 186	[750]	SETTABLE 	8 13 14
  #undef  AOT_PC
  #define AOT_PC (code + 187)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_188
  label_186: {
    aot_vmfetch(0x0e0d0410);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 187	[748]	TFORCALL 	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 188)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_189
  label_187: {
    aot_vmfetch(0x020004cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 188	[748]	TFORLOOP 	9 13	; to 177
  #undef  AOT_PC
  #define AOT_PC (code + 189)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_190
  label_188: {
    aot_vmfetch(0x000684cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_176; /* jump back */
    }
  }

  // 189	[751]	CLOSE    	9
  #undef  AOT_PC
  #define AOT_PC (code + 190)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_191
  label_189: {
    aot_vmfetch(0x000004b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 190	[752]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 191)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_192
  label_190: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 191	[753]	NEWTABLE 	10 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 192)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_193
  label_191: {
    aot_vmfetch(0x00000513);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 192	[753]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 193)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_194
  label_192: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 193	[754]	LOADTRUE 	11
  #undef  AOT_PC
  #define AOT_PC (code + 194)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_195
  label_193: {
    aot_vmfetch(0x00000587);
    setbtvalue(s2v(ra));
  }

  // 194	[755]	LOADFALSE	12
  #undef  AOT_PC
  #define AOT_PC (code + 195)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_196
  label_194: {
    aot_vmfetch(0x00000605);
    setbfvalue(s2v(ra));
  }

  // 195	[779]	CLOSURE  	13 1	; 0x7fbced00e8c0
  #undef  AOT_PC
  #define AOT_PC (code + 196)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_197
  label_195: {
    aot_vmfetch(0x000086cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 196	[757]	SETTABUP 	0 48 13	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 197)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_198
  label_196: {
    aot_vmfetch(0x0d30000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 197	[780]	GETTABUP 	13 0 49	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 198)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_199
  label_197: {
    aot_vmfetch(0x3100068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 198	[780]	MOVE     	14 6
  #undef  AOT_PC
  #define AOT_PC (code + 199)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_200
  label_198: {
    aot_vmfetch(0x00060700);
    setobjs2s(L, ra, RB(i));
  }

  // 199	[780]	CALL     	13 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 200)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_201
  label_199: {
    aot_vmfetch(0x050206c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 200	[780]	TFORPREP 	13 107	; to 309
  #undef  AOT_PC
  #define AOT_PC (code + 201)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_202
  label_200: {
    aot_vmfetch(0x003586cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_308;
  }

  // 201	[784]	LOADI    	19 1
  #undef  AOT_PC
  #define AOT_PC (code + 202)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_203
  label_201: {
    aot_vmfetch(0x80000981);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 202	[784]	LEN      	20 18
  #undef  AOT_PC
  #define AOT_PC (code + 203)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_204
  label_202: {
    aot_vmfetch(0x00120a34);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 203	[784]	LOADI    	21 1
  #undef  AOT_PC
  #define AOT_PC (code + 204)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_205
  label_203: {
    aot_vmfetch(0x80000a81);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 204	[784]	FORPREP  	19 26	; to 232
  #undef  AOT_PC
  #define AOT_PC (code + 205)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_206
  label_204: {
    aot_vmfetch(0x000d09ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_232; /* skip the loop */
  }

  // 205	[785]	SELF     	23 18 20k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 206)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_207
  label_205: {
    aot_vmfetch(0x14128b94);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 206	[785]	MOVE     	25 22
  #undef  AOT_PC
  #define AOT_PC (code + 207)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_208
  label_206: {
    aot_vmfetch(0x00160c80);
    setobjs2s(L, ra, RB(i));
  }

  // 207	[785]	MOVE     	26 22
  #undef  AOT_PC
  #define AOT_PC (code + 208)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_209
  label_207: {
    aot_vmfetch(0x00160d00);
    setobjs2s(L, ra, RB(i));
  }

  // 208	[785]	CALL     	23 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 209)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_210
  label_208: {
    aot_vmfetch(0x02040bc4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 209	[786]	EQK      	23 50 0	; "/"
  #undef  AOT_PC
  #define AOT_PC (code + 210)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_220
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_211
  label_209: {
    aot_vmfetch(0x00320bbc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 210	[786]	JMP      	9	; to 221
  #undef  AOT_PC
  #define AOT_PC (code + 211)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_212
  label_210: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_220;
  }

  // 211	[786]	SELF     	24 18 20k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 212)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_213
  label_211: {
    aot_vmfetch(0x14128c14);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 212	[786]	ADDI     	26 22 1
  #undef  AOT_PC
  #define AOT_PC (code + 213)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_214
  label_212: {
    aot_vmfetch(0x80160d15);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 213	[786]	MMBINI   	22 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 214)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_215
  label_213: {
    aot_vmfetch(0x06800b2f);
    Instruction pi = 0x80160d15;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 214	[786]	ADDI     	27 22 1
  #undef  AOT_PC
  #define AOT_PC (code + 215)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_216
  label_214: {
    aot_vmfetch(0x80160d95);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 215	[786]	MMBINI   	22 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 216)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_217
  label_215: {
    aot_vmfetch(0x06800b2f);
    Instruction pi = 0x80160d95;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 216	[786]	CALL     	24 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 217)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_218
  label_216: {
    aot_vmfetch(0x02040c44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 217	[786]	EQK      	24 51 0	; "*"
  #undef  AOT_PC
  #define AOT_PC (code + 218)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_220
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_219
  label_217: {
    aot_vmfetch(0x00330c3c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 218	[786]	JMP      	1	; to 221
  #undef  AOT_PC
  #define AOT_PC (code + 219)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_220
  label_218: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_220;
  }

  // 219	[787]	LOADTRUE 	12
  #undef  AOT_PC
  #define AOT_PC (code + 220)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_221
  label_219: {
    aot_vmfetch(0x00000607);
    setbtvalue(s2v(ra));
  }

  // 220	[789]	EQK      	23 51 0	; "*"
  #undef  AOT_PC
  #define AOT_PC (code + 221)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_231
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_222
  label_220: {
    aot_vmfetch(0x00330bbc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 221	[789]	JMP      	9	; to 232
  #undef  AOT_PC
  #define AOT_PC (code + 222)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_223
  label_221: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_231;
  }

  // 222	[789]	SELF     	24 18 20k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 223)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_224
  label_222: {
    aot_vmfetch(0x14128c14);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 223	[789]	ADDI     	26 22 1
  #undef  AOT_PC
  #define AOT_PC (code + 224)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_225
  label_223: {
    aot_vmfetch(0x80160d15);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 224	[789]	MMBINI   	22 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 225)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_226
  label_224: {
    aot_vmfetch(0x06800b2f);
    Instruction pi = 0x80160d15;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 225	[789]	ADDI     	27 22 1
  #undef  AOT_PC
  #define AOT_PC (code + 226)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_227
  label_225: {
    aot_vmfetch(0x80160d95);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 226	[789]	MMBINI   	22 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 227)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_228
  label_226: {
    aot_vmfetch(0x06800b2f);
    Instruction pi = 0x80160d95;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 227	[789]	CALL     	24 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 228)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_229
  label_227: {
    aot_vmfetch(0x02040c44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 228	[789]	EQK      	24 50 0	; "/"
  #undef  AOT_PC
  #define AOT_PC (code + 229)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_231
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_230
  label_228: {
    aot_vmfetch(0x00320c3c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 229	[789]	JMP      	1	; to 232
  #undef  AOT_PC
  #define AOT_PC (code + 230)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_231
  label_229: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_231;
  }

  // 230	[790]	LOADFALSE	12
  #undef  AOT_PC
  #define AOT_PC (code + 231)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_232
  label_230: {
    aot_vmfetch(0x00000605);
    setbfvalue(s2v(ra));
  }

  // 231	[784]	FORLOOP  	19 27	; to 206
  #undef  AOT_PC
  #define AOT_PC (code + 232)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_233
  label_231: {
    aot_vmfetch(0x000d89c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_205; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_205; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 232	[793]	TEST     	12 0
  #undef  AOT_PC
  #define AOT_PC (code + 233)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_235
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_234
  label_232: {
    aot_vmfetch(0x00000642);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 233	[793]	JMP      	1	; to 236
  #undef  AOT_PC
  #define AOT_PC (code + 234)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_308
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_235
  label_233: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_235;
  }

  // 234	[794]	JMP      	73	; to 309
  #undef  AOT_PC
  #define AOT_PC (code + 235)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_236
  label_234: {
    aot_vmfetch(0x80002438);
    updatetrap(ci);
    goto label_308;
  }

  // 235	[796]	LOADFALSE	19
  #undef  AOT_PC
  #define AOT_PC (code + 236)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_237
  label_235: {
    aot_vmfetch(0x00000985);
    setbfvalue(s2v(ra));
  }

  // 236	[797]	GETTABUP 	20 0 49	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 237)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_238
  label_236: {
    aot_vmfetch(0x31000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 237	[797]	MOVE     	21 7
  #undef  AOT_PC
  #define AOT_PC (code + 238)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_239
  label_237: {
    aot_vmfetch(0x00070a80);
    setobjs2s(L, ra, RB(i));
  }

  // 238	[797]	CALL     	20 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 239)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_240
  label_238: {
    aot_vmfetch(0x05020a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 239	[797]	TFORPREP 	20 6	; to 247
  #undef  AOT_PC
  #define AOT_PC (code + 240)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_241
  label_239: {
    aot_vmfetch(0x00030a4b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_246;
  }

  // 240	[798]	GETI     	26 25 1
  #undef  AOT_PC
  #define AOT_PC (code + 241)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_242
  label_240: {
    aot_vmfetch(0x01190d0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 241	[798]	EQ       	26 17 0
  #undef  AOT_PC
  #define AOT_PC (code + 242)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_246
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_243
  label_241: {
    aot_vmfetch(0x00110d39);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 242	[798]	JMP      	3	; to 247
  #undef  AOT_PC
  #define AOT_PC (code + 243)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_244
  label_242: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_246;
  }

  // 243	[799]	MOVE     	18 25
  #undef  AOT_PC
  #define AOT_PC (code + 244)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_245
  label_243: {
    aot_vmfetch(0x00190900);
    setobjs2s(L, ra, RB(i));
  }

  // 244	[800]	LOADTRUE 	19
  #undef  AOT_PC
  #define AOT_PC (code + 245)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_248
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_246
  label_244: {
    aot_vmfetch(0x00000987);
    setbtvalue(s2v(ra));
  }

  // 245	[801]	JMP      	2	; to 249
  #undef  AOT_PC
  #define AOT_PC (code + 246)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_247
  label_245: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_248;
  }

  // 246	[797]	TFORCALL 	20 2
  #undef  AOT_PC
  #define AOT_PC (code + 247)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_248
  label_246: {
    aot_vmfetch(0x02000a4c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 247	[797]	TFORLOOP 	20 8	; to 241
  #undef  AOT_PC
  #define AOT_PC (code + 248)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_249
  label_247: {
    aot_vmfetch(0x00040a4d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_240; /* jump back */
    }
  }

  // 248	[803]	CLOSE    	20
  #undef  AOT_PC
  #define AOT_PC (code + 249)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_250
  label_248: {
    aot_vmfetch(0x00000a36);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 249	[804]	TEST     	19 1
  #undef  AOT_PC
  #define AOT_PC (code + 250)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_255
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_251
  label_249: {
    aot_vmfetch(0x000089c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 250	[804]	JMP      	4	; to 256
  #undef  AOT_PC
  #define AOT_PC (code + 251)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_252
  label_250: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_255;
  }

  // 251	[805]	TEST     	11 1
  #undef  AOT_PC
  #define AOT_PC (code + 252)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_308
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_253
  label_251: {
    aot_vmfetch(0x000085c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 252	[805]	JMP      	55	; to 309
  #undef  AOT_PC
  #define AOT_PC (code + 253)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_254
  label_252: {
    aot_vmfetch(0x80001b38);
    updatetrap(ci);
    goto label_308;
  }

  // 253	[806]	SETTABLE 	9 17 52k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 254)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_308
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_255
  label_253: {
    aot_vmfetch(0x34118490);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 254	[808]	JMP      	53	; to 309
  #undef  AOT_PC
  #define AOT_PC (code + 255)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_256
  label_254: {
    aot_vmfetch(0x80001a38);
    updatetrap(ci);
    goto label_308;
  }

  // 255	[820]	CLOSURE  	20 2	; 0x7fbced00ee70
  #undef  AOT_PC
  #define AOT_PC (code + 256)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_257
  label_255: {
    aot_vmfetch(0x00010a4f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 256	[812]	SETTABUP 	0 53 20	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 257)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_258
  label_256: {
    aot_vmfetch(0x1435000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 257	[823]	GETI     	20 18 2
  #undef  AOT_PC
  #define AOT_PC (code + 258)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_259
  label_257: {
    aot_vmfetch(0x02120a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 258	[823]	SELF     	20 20 20k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 259)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_260
  label_258: {
    aot_vmfetch(0x14148a14);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 259	[823]	LOADI    	22 2
  #undef  AOT_PC
  #define AOT_PC (code + 260)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_261
  label_259: {
    aot_vmfetch(0x80008b01);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 260	[823]	LOADI    	23 2
  #undef  AOT_PC
  #define AOT_PC (code + 261)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_262
  label_260: {
    aot_vmfetch(0x80008b81);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 261	[823]	CALL     	20 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 262)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_263
  label_261: {
    aot_vmfetch(0x02040a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 262	[823]	EQK      	20 54 0	; "!"
  #undef  AOT_PC
  #define AOT_PC (code + 263)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_267
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_264
  label_262: {
    aot_vmfetch(0x00360a3c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 263	[823]	JMP      	3	; to 268
  #undef  AOT_PC
  #define AOT_PC (code + 264)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_265
  label_263: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_267;
  }

  // 264	[824]	GETI     	20 18 1
  #undef  AOT_PC
  #define AOT_PC (code + 265)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_266
  label_264: {
    aot_vmfetch(0x01120a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 265	[824]	SETTABLE 	9 20 52k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 266)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_267
  label_265: {
    aot_vmfetch(0x34148490);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 266	[825]	RETURN   	20 1 5	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 267)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_268
  label_266: {
    aot_vmfetch(0x05018a46);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 267	[828]	GETTABUP 	20 0 55	; _ENV "switch"
  #undef  AOT_PC
  #define AOT_PC (code + 268)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_269
  label_267: {
    aot_vmfetch(0x37000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 268	[828]	GETI     	21 18 2
  #undef  AOT_PC
  #define AOT_PC (code + 269)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_270
  label_268: {
    aot_vmfetch(0x02120a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 269	[828]	SELF     	21 21 56k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 270)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_271
  label_269: {
    aot_vmfetch(0x38158a94);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 270	[828]	LOADK    	23 57	; "%S+"
  #undef  AOT_PC
  #define AOT_PC (code + 271)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_272
  label_270: {
    aot_vmfetch(0x001c8b83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 271	[828]	CALL     	21 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 272)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_273
  label_271: {
    aot_vmfetch(0x02030ac4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 272	[828]	NEWTABLE 	22 5 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 273)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_274
  label_272: {
    aot_vmfetch(0x00050b13);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 273	[828]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 274)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_275
  label_273: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 274	[843]	CLOSURE  	23 3	; 0x7fbced00e1a0
  #undef  AOT_PC
  #define AOT_PC (code + 275)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_276
  label_274: {
    aot_vmfetch(0x00018bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 275	[843]	SETFIELD 	22 58 23	; "#open"
  #undef  AOT_PC
  #define AOT_PC (code + 276)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_277
  label_275: {
    aot_vmfetch(0x173a0b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 276	[891]	CLOSURE  	23 4	; 0x7fbced00f860
  #undef  AOT_PC
  #define AOT_PC (code + 277)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_278
  label_276: {
    aot_vmfetch(0x00020bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 277	[891]	SETFIELD 	22 59 23	; "#define"
  #undef  AOT_PC
  #define AOT_PC (code + 278)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_279
  label_277: {
    aot_vmfetch(0x173b0b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 278	[939]	CLOSURE  	23 5	; 0x7fbced00c6c0
  #undef  AOT_PC
  #define AOT_PC (code + 279)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_280
  label_278: {
    aot_vmfetch(0x00028bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 279	[939]	SETFIELD 	22 60 23	; "##line"
  #undef  AOT_PC
  #define AOT_PC (code + 280)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_281
  label_279: {
    aot_vmfetch(0x173c0b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 280	[989]	CLOSURE  	23 6	; 0x7fbced0105e0
  #undef  AOT_PC
  #define AOT_PC (code + 281)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_282
  label_280: {
    aot_vmfetch(0x00030bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 281	[989]	SETFIELD 	22 61 23	; "##include"
  #undef  AOT_PC
  #define AOT_PC (code + 282)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_283
  label_281: {
    aot_vmfetch(0x173d0b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 282	[1026]	CLOSURE  	23 7	; 0x7fbced010dc0
  #undef  AOT_PC
  #define AOT_PC (code + 283)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_284
  label_282: {
    aot_vmfetch(0x00038bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 283	[1026]	SETFIELD 	22 62 23	; "#if"
  #undef  AOT_PC
  #define AOT_PC (code + 284)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_285
  label_283: {
    aot_vmfetch(0x173e0b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 284	[1063]	CLOSURE  	23 8	; 0x7fbced011710
  #undef  AOT_PC
  #define AOT_PC (code + 285)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_286
  label_284: {
    aot_vmfetch(0x00040bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 285	[1063]	SETFIELD 	22 63 23	; "#ifdef"
  #undef  AOT_PC
  #define AOT_PC (code + 286)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_287
  label_285: {
    aot_vmfetch(0x173f0b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 286	[1100]	CLOSURE  	23 9	; 0x7fbced011fb0
  #undef  AOT_PC
  #define AOT_PC (code + 287)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_288
  label_286: {
    aot_vmfetch(0x00048bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 287	[1100]	SETFIELD 	22 64 23	; "#ifndef"
  #undef  AOT_PC
  #define AOT_PC (code + 288)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_289
  label_287: {
    aot_vmfetch(0x17400b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 288	[1140]	CLOSURE  	23 10	; 0x7fbced012750
  #undef  AOT_PC
  #define AOT_PC (code + 289)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_290
  label_288: {
    aot_vmfetch(0x00050bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 289	[1140]	SETFIELD 	22 65 23	; "#elif"
  #undef  AOT_PC
  #define AOT_PC (code + 290)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_291
  label_289: {
    aot_vmfetch(0x17410b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 290	[1144]	CLOSURE  	23 11	; 0x7fbced0130c0
  #undef  AOT_PC
  #define AOT_PC (code + 291)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_292
  label_290: {
    aot_vmfetch(0x00058bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 291	[1144]	SETFIELD 	22 66 23	; "#else"
  #undef  AOT_PC
  #define AOT_PC (code + 292)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_293
  label_291: {
    aot_vmfetch(0x17420b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 292	[1149]	CLOSURE  	23 12	; 0x7fbced013150
  #undef  AOT_PC
  #define AOT_PC (code + 293)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_294
  label_292: {
    aot_vmfetch(0x00060bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 293	[1149]	SETFIELD 	22 67 23	; "#endif"
  #undef  AOT_PC
  #define AOT_PC (code + 294)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_295
  label_293: {
    aot_vmfetch(0x17430b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 294	[1159]	CLOSURE  	23 13	; 0x7fbced0131e0
  #undef  AOT_PC
  #define AOT_PC (code + 295)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_296
  label_294: {
    aot_vmfetch(0x00068bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 295	[1159]	SETFIELD 	22 68 23	; "#undef"
  #undef  AOT_PC
  #define AOT_PC (code + 296)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_297
  label_295: {
    aot_vmfetch(0x17440b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 296	[1165]	CLOSURE  	23 14	; 0x7fbced013370
  #undef  AOT_PC
  #define AOT_PC (code + 297)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_298
  label_296: {
    aot_vmfetch(0x00070bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 297	[1165]	SETFIELD 	22 69 23	; "#error"
  #undef  AOT_PC
  #define AOT_PC (code + 298)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_299
  label_297: {
    aot_vmfetch(0x17450b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 298	[1170]	CLOSURE  	23 15	; 0x7fbced013600
  #undef  AOT_PC
  #define AOT_PC (code + 299)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_300
  label_298: {
    aot_vmfetch(0x00078bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 299	[1170]	SETFIELD 	22 70 23	; "#warning"
  #undef  AOT_PC
  #define AOT_PC (code + 300)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_301
  label_299: {
    aot_vmfetch(0x17460b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 300	[1173]	CLOSURE  	23 16	; 0x7fbced013920
  #undef  AOT_PC
  #define AOT_PC (code + 301)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_302
  label_300: {
    aot_vmfetch(0x00080bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 301	[1173]	SETFIELD 	22 71 23	; "#config"
  #undef  AOT_PC
  #define AOT_PC (code + 302)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_303
  label_301: {
    aot_vmfetch(0x17470b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 302	[1177]	CLOSURE  	23 17	; 0x7fbced0139f0
  #undef  AOT_PC
  #define AOT_PC (code + 303)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_304
  label_302: {
    aot_vmfetch(0x00088bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 303	[1177]	SETFIELD 	22 72 23	; "#ext"
  #undef  AOT_PC
  #define AOT_PC (code + 304)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_305
  label_303: {
    aot_vmfetch(0x17480b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 304	[1197]	CLOSURE  	23 18	; 0x7fbced013b40
  #undef  AOT_PC
  #define AOT_PC (code + 305)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_306
  label_304: {
    aot_vmfetch(0x00090bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 305	[1197]	SETFIELD 	22 73 23	; "default"
  #undef  AOT_PC
  #define AOT_PC (code + 306)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_307
  label_305: {
    aot_vmfetch(0x17490b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 306	[828]	CALL     	20 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 307)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_308
  label_306: {
    aot_vmfetch(0x01030a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 307	[1200]	CLOSE    	17
  #undef  AOT_PC
  #define AOT_PC (code + 308)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_309
  label_307: {
    aot_vmfetch(0x000008b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 308	[780]	TFORCALL 	13 2
  #undef  AOT_PC
  #define AOT_PC (code + 309)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_310
  label_308: {
    aot_vmfetch(0x020006cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 309	[780]	TFORLOOP 	13 109	; to 202
  #undef  AOT_PC
  #define AOT_PC (code + 310)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_311
  label_309: {
    aot_vmfetch(0x003686cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_201; /* jump back */
    }
  }

  // 310	[1203]	LEN      	13 10
  #undef  AOT_PC
  #define AOT_PC (code + 311)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_312
  label_310: {
    aot_vmfetch(0x000a06b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 311	[1203]	GTI      	13 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 312)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_316
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_313
  label_311: {
    aot_vmfetch(0x007f06c0);
    op_orderI(L, l_gti, luai_numgt, 1, TM_LT);
  }

  // 312	[1203]	JMP      	3	; to 317
  #undef  AOT_PC
  #define AOT_PC (code + 313)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_314
  label_312: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_316;
  }

  // 313	[1204]	GETTABUP 	13 0 74	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 314)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_315
  label_313: {
    aot_vmfetch(0x4a00068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 314	[1204]	LOADK    	14 75	; "Missing #endif(s)"
  #undef  AOT_PC
  #define AOT_PC (code + 315)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_316
  label_314: {
    aot_vmfetch(0x00258703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 315	[1204]	CALL     	13 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 316)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_317
  label_315: {
    aot_vmfetch(0x010206c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 316	[1206]	LOADNIL  	6 1	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 317)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_318
  label_316: {
    aot_vmfetch(0x00010308);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 317	[1208]	LOADNIL  	0 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 318)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_319
  label_317: {
    aot_vmfetch(0x00000008);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 318	[1209]	LOADK    	13 76	; "/* Preprocessed with the built in Cobalt preprocessor */\n\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 319)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_320
  label_318: {
    aot_vmfetch(0x00260683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 319	[1210]	GETTABUP 	14 0 77	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 320)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_321
  label_319: {
    aot_vmfetch(0x4d00070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 320	[1210]	MOVE     	15 9
  #undef  AOT_PC
  #define AOT_PC (code + 321)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_322
  label_320: {
    aot_vmfetch(0x00090780);
    setobjs2s(L, ra, RB(i));
  }

  // 321	[1210]	CALL     	14 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 322)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_323
  label_321: {
    aot_vmfetch(0x05020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 322	[1210]	TFORPREP 	14 8	; to 332
  #undef  AOT_PC
  #define AOT_PC (code + 323)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_324
  label_322: {
    aot_vmfetch(0x0004074b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_331;
  }

  // 323	[1211]	EQK      	19 78 0	; null
  #undef  AOT_PC
  #define AOT_PC (code + 324)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_326
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_325
  label_323: {
    aot_vmfetch(0x004e09bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 324	[1211]	JMP      	1	; to 327
  #undef  AOT_PC
  #define AOT_PC (code + 325)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_331
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_326
  label_324: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_326;
  }

  // 325	[1212]	JMP      	5	; to 332
  #undef  AOT_PC
  #define AOT_PC (code + 326)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_327
  label_325: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_331;
  }

  // 326	[1214]	MOVE     	20 13
  #undef  AOT_PC
  #define AOT_PC (code + 327)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_328
  label_326: {
    aot_vmfetch(0x000d0a00);
    setobjs2s(L, ra, RB(i));
  }

  // 327	[1214]	MOVE     	21 19
  #undef  AOT_PC
  #define AOT_PC (code + 328)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_329
  label_327: {
    aot_vmfetch(0x00130a80);
    setobjs2s(L, ra, RB(i));
  }

  // 328	[1214]	LOADK    	22 79	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 329)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_330
  label_328: {
    aot_vmfetch(0x00278b03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 329	[1214]	CONCAT   	20 3
  #undef  AOT_PC
  #define AOT_PC (code + 330)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_331
  label_329: {
    aot_vmfetch(0x00030a35);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 330	[1214]	MOVE     	13 20
  #undef  AOT_PC
  #define AOT_PC (code + 331)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_332
  label_330: {
    aot_vmfetch(0x00140680);
    setobjs2s(L, ra, RB(i));
  }

  // 331	[1210]	TFORCALL 	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 332)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_333
  label_331: {
    aot_vmfetch(0x0200074c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 332	[1210]	TFORLOOP 	14 10	; to 324
  #undef  AOT_PC
  #define AOT_PC (code + 333)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_334
  label_332: {
    aot_vmfetch(0x0005074d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_323; /* jump back */
    }
  }

  // 333	[1215]	CLOSE    	14
  #undef  AOT_PC
  #define AOT_PC (code + 334)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_335
  label_333: {
    aot_vmfetch(0x00000736);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 334	[1216]	LOADNIL  	9 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 335)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_336
  label_334: {
    aot_vmfetch(0x00000488);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 335	[1217]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 336)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_347
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_337
  label_335: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 336	[1217]	JMP      	10	; to 348
  #undef  AOT_PC
  #define AOT_PC (code + 337)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_338
  label_336: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_347;
  }

  // 337	[1219]	GETTABUP 	14 0 80	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 338)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_339
  label_337: {
    aot_vmfetch(0x5000070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 338	[1219]	GETFIELD 	14 14 81	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 339)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_340
  label_338: {
    aot_vmfetch(0x510e070e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 339	[1219]	MOVE     	15 3
  #undef  AOT_PC
  #define AOT_PC (code + 340)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_341
  label_339: {
    aot_vmfetch(0x00030780);
    setobjs2s(L, ra, RB(i));
  }

  // 340	[1219]	LOADK    	16 82	; "w"
  #undef  AOT_PC
  #define AOT_PC (code + 341)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_342
  label_340: {
    aot_vmfetch(0x00290803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 341	[1219]	CALL     	14 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 342)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_343
  label_341: {
    aot_vmfetch(0x02030744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 342	[1220]	SELF     	15 14 83k	; "write"
  #undef  AOT_PC
  #define AOT_PC (code + 343)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_344
  label_342: {
    aot_vmfetch(0x530e8794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 343	[1220]	MOVE     	17 13
  #undef  AOT_PC
  #define AOT_PC (code + 344)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_345
  label_343: {
    aot_vmfetch(0x000d0880);
    setobjs2s(L, ra, RB(i));
  }

  // 344	[1220]	CALL     	15 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 345)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_346
  label_344: {
    aot_vmfetch(0x010307c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 345	[1221]	SELF     	15 14 84k	; "close"
  #undef  AOT_PC
  #define AOT_PC (code + 346)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_347
  label_345: {
    aot_vmfetch(0x540e8794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 346	[1221]	CALL     	15 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 347)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_348
  label_346: {
    aot_vmfetch(0x010207c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 347	[1223]	GETTABUP 	14 0 85	; _ENV "collectgarbage"
  #undef  AOT_PC
  #define AOT_PC (code + 348)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_349
  label_347: {
    aot_vmfetch(0x5500070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 348	[1223]	CALL     	14 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 349)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_350
  label_348: {
    aot_vmfetch(0x01010744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 349	[1224]	RETURN   	13 2 5	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 350)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_349: {
    aot_vmfetch(0x050286c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 350	[1225]	RETURN   	14 1 5	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 351)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_350: {
    aot_vmfetch(0x05018746);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 702 - 709
static
CallInfo *magic_implementation_65(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
  }

  // 0	[703]	GETUPVAL 	0 0	; ogstr
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[703]	TEST     	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 2	[703]	JMP      	9	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_12;
  }

  // 3	[705]	GETTABUP 	0 1 0	; _ENV "filex"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0001000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[705]	GETFIELD 	0 0 1	; "join"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100000e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[705]	GETTABUP 	1 1 2	; _ENV "filesystem"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0201008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[705]	GETFIELD 	1 1 3	; "currentdir"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[705]	CALL     	1 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x020100c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[705]	GETUPVAL 	2 0	; ogstr
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 9	[705]	TAILCALL 	0 3 0	; 2 in
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00030045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 10	[705]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 11	[706]	JMP      	10	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_22;
  }

  // 12	[707]	GETTABUP 	0 1 4	; _ENV "debug"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0401000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[707]	GETFIELD 	0 0 5	; "getinfo"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0500000e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 14	[707]	LOADI    	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80008081);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 15	[707]	LOADK    	2 6	; "S"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00030103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 16	[707]	CALL     	0 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x02030044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 17	[707]	GETFIELD 	0 0 7	; "source"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0700000e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 18	[707]	SELF     	0 0 8k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x08008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[707]	LOADI    	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x80008101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 20	[707]	TAILCALL 	0 3 0	; 2 in
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00030045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 21	[707]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_21: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 22	[709]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_22: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 757 - 779
static
CallInfo *magic_implementation_66(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
  }

  // 0	[758]	LOADK    	1 0	; "{"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[759]	GETTABUP 	2 0 1	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[759]	GETUPVAL 	3 1	; env
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[759]	CALL     	2 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x05020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[759]	TFORPREP 	2 26	; to 32
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000d014b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_31;
  }

  // 5	[760]	GETTABUP 	8 0 2	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[760]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 7	[760]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[760]	EQK      	8 3 0	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_16
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0003043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 9	[760]	JMP      	6	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_16;
  }

  // 10	[761]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 11	[761]	MOVE     	9 7
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00070480);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[761]	LOADK    	10 4	; ","
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00020503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[761]	CONCAT   	8 3
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00030435);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 14	[761]	MOVE     	1 8
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_31
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00080080);
    setobjs2s(L, ra, RB(i));
  }

  // 15	[762]	JMP      	15	; to 32
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000738);
    updatetrap(ci);
    goto label_31;
  }

  // 16	[762]	GETTABUP 	8 0 2	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0200040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[762]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 18	[762]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[762]	EQK      	8 5 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_31
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0005043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 20	[762]	JMP      	10	; to 32
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_31;
  }

  // 21	[763]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[763]	LOADK    	9 6	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00030483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 23	[763]	MOVE     	10 6
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00060500);
    setobjs2s(L, ra, RB(i));
  }

  // 24	[763]	LOADK    	11 7	; "\": "
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00038583);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 25	[763]	GETTABUP 	12 0 8	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x0800060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 26	[763]	MOVE     	13 7
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00070680);
    setobjs2s(L, ra, RB(i));
  }

  // 27	[763]	CALL     	12 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x02020644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 28	[763]	LOADK    	13 4	; ","
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00020683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 29	[763]	CONCAT   	8 6
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00060435);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 30	[763]	MOVE     	1 8
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00080080);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[759]	TFORCALL 	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x0200014c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 32	[759]	TFORLOOP 	2 28	; to 6
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x000e014d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_05; /* jump back */
    }
  }

  // 33	[765]	CLOSE    	2
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x00000136);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 34	[766]	MOVE     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00010100);
    setobjs2s(L, ra, RB(i));
  }

  // 35	[766]	LOADK    	3 9	; "}"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x00048183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 36	[766]	CONCAT   	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00020135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 37	[766]	MOVE     	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00020080);
    setobjs2s(L, ra, RB(i));
  }

  // 38	[767]	GETTABUP 	2 0 10	; _ENV "loadstring"
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x0a00010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 39	[768]	LOADK    	3 11	; "// Cobalt execution environment: Ignore.\n            env = "
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00058183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 40	[768]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 41	[778]	LOADK    	5 12	; ";\n            for (i, v in pairs(env)){\n                _ENV[i] = v\n            }\n            core = import(\"core\")\n            function defined(val){\n                // check if it is in env, if it return the value\n                if (env[val] != null && env[val] != false) {\n                    return env[val]\n                }\n            }"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x00060283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 42	[778]	MOVE     	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x00000300);
    setobjs2s(L, ra, RB(i));
  }

  // 43	[778]	CONCAT   	3 4
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x000401b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 44	[767]	TAILCALL 	2 2 0	; 1 in
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x00028145);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 45	[778]	RETURN   	2 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_45: {
    aot_vmfetch(0x00008146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 46	[779]	RETURN   	2 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_46: {
    aot_vmfetch(0x00018146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 812 - 820
static
CallInfo *magic_implementation_67(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
  }

  // 0	[813]	GETTABUP 	1 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[813]	LOADK    	2 1	; "\027[1;31mPreprocessor error:\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[813]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[814]	GETTABUP 	1 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[814]	LOADK    	2 2	; "\027[1;31mError with the '"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[814]	GETUPVAL 	3 1	; v
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[814]	GETI     	3 3 2
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0203018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 7	[814]	LOADK    	4 3	; "' preprocessor command.\027[0m\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00018203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 8	[814]	CONCAT   	2 3
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00030135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 9	[814]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[815]	TEST     	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_18
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 11	[815]	JMP      	6	; to 19
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_18;
  }

  // 12	[816]	GETTABUP 	1 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[816]	LOADK    	2 4	; "\027[1;31m"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00020103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 14	[816]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 15	[816]	LOADK    	4 5	; "\027[0m\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00028203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 16	[816]	CONCAT   	2 3
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00030135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 17	[816]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[818]	GETTABUP 	1 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 19	[818]	LOADK    	2 6	; "\027[1;31mStopping preprocessor.\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00030103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 20	[818]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 21	[819]	GETTABUP 	1 0 7	; _ENV "os"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0700008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 22	[819]	GETFIELD 	1 1 8	; "exit"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0801008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 23	[819]	CALL     	1 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_23: {
    aot_vmfetch(0x010100c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[820]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_24: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 829 - 843
static
CallInfo *magic_implementation_68(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
  }

  // 0	[834]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[834]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[834]	SELF     	0 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[834]	LOADK    	2 1	; "#open "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[834]	LOADK    	3 2	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[834]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[835]	GETUPVAL 	1 1	; env
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[835]	GETTABLE 	1 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0001008c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[836]	EQK      	1 3 0	; null
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_16
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x000300bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 9	[836]	JMP      	6	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_16;
  }

  // 10	[837]	GETTABUP 	2 2 4	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0402010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 11	[837]	LOADK    	3 5	; "Macro '"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00028183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 12	[837]	MOVE     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000200);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[837]	LOADK    	5 6	; "' is not defined"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00030283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 14	[837]	CONCAT   	3 3
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x000301b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 15	[837]	CALL     	2 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x01020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[839]	GETUPVAL 	2 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 17	[839]	GETI     	3 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0102018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 18	[839]	GETUPVAL 	2 3	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00030109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 19	[839]	LOADK    	4 7	; "var "
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00038203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 20	[839]	GETTABUP 	5 2 8	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0802028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 21	[839]	MOVE     	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00000300);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[839]	CALL     	5 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x020202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 23	[839]	LOADK    	6 9	; " = "
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00048303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 24	[839]	GETTABUP 	7 2 10	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0a02038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 25	[839]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 26	[839]	CALL     	7 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x020203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 27	[839]	EQK      	7 11 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000b03bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 28	[839]	JMP      	13	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_42;
  }

  // 29	[839]	GETUPVAL 	7 4	; str
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00040389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 30	[839]	SELF     	7 7 12k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x0c078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 31	[839]	LOADI    	9 1
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x80000481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 32	[839]	LOADI    	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x80000501);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 33	[839]	CALL     	7 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x020403c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 34	[839]	EQK      	7 13 0	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x000d03bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 35	[839]	JMP      	6	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_42;
  }

  // 36	[839]	GETUPVAL 	7 4	; str
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00040389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 37	[839]	SELF     	7 7 12k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x0c078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 38	[839]	LOADI    	9 -1
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x7fff0481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 39	[839]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 40	[839]	EQK      	7 13 1	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_55
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x000d83bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 41	[839]	JMP      	13	; to 56
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_55;
  }

  // 42	[839]	GETUPVAL 	7 4	; str
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x00040389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 43	[839]	SELF     	7 7 12k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0c078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 44	[839]	LOADI    	9 1
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x80000481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 45	[839]	LOADI    	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x80000501);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 46	[839]	CALL     	7 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x020403c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 47	[839]	EQK      	7 14 0	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_60
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x000e03bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 48	[839]	JMP      	11	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x80000538);
    updatetrap(ci);
    goto label_60;
  }

  // 49	[839]	GETUPVAL 	7 4	; str
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00040389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 50	[839]	SELF     	7 7 12k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0c078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 51	[839]	LOADI    	9 -1
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x7fff0481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 52	[839]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 53	[839]	EQK      	7 14 0	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_60
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x000e03bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 54	[839]	JMP      	5	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_60;
  }

  // 55	[839]	LOADK    	7 13	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x00068383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 56	[839]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 57	[839]	LOADK    	9 13	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00068483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 58	[839]	CONCAT   	7 3
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_64
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x000303b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 59	[839]	JMP      	4	; to 65
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_64;
  }

  // 60	[839]	GETTABUP 	8 2 8	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x0802040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 61	[839]	MOVE     	9 1
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x00010480);
    setobjs2s(L, ra, RB(i));
  }

  // 62	[839]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 63	[839]	MOVE     	7 8
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x00080380);
    setobjs2s(L, ra, RB(i));
  }

  // 64	[839]	CONCAT   	4 4
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x00040235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 65	[839]	SETTABLE 	2 3 4
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x04030110);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 66	[842]	LOADNIL  	2 1	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x00010108);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 67	[842]	MOVE     	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x00030080);
    setobjs2s(L, ra, RB(i));
  }

  // 68	[842]	MOVE     	0 2
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_68: {
    aot_vmfetch(0x00020000);
    setobjs2s(L, ra, RB(i));
  }

  // 69	[843]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_69: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 844 - 891
static
CallInfo *magic_implementation_69(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
  }

  // 0	[846]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[846]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[846]	SELF     	0 0 0k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[846]	LOADK    	2 1	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[846]	CALL     	0 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02030044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[848]	GETI     	1 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 6	[849]	GETTABUP 	2 1 2	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0201010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[849]	GETFIELD 	2 2 3	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0302010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[849]	MOVE     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010180);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[849]	LOADI    	4 -1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x7fff0201);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 10	[849]	CALL     	2 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x02030144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 11	[849]	EQK      	2 4 0	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_88
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0004013c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 12	[849]	JMP      	75	; to 89
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x80002538);
    updatetrap(ci);
    goto label_88;
  }

  // 13	[856]	GETTABUP 	2 1 2	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0201010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 14	[856]	GETFIELD 	2 2 0	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0002010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[856]	GETUPVAL 	3 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 16	[856]	GETI     	3 3 2
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0203018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 17	[856]	LOADK    	4 1	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00008203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 18	[856]	CALL     	2 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x02030144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[857]	GETI     	3 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0202018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 20	[857]	SELF     	3 3 0k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00038194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 21	[857]	LOADK    	5 5	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00028283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 22	[857]	CALL     	3 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x020301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 23	[857]	GETI     	3 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x0103018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 24	[858]	GETI     	4 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0202020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 25	[858]	SELF     	4 4 0k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00048214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 26	[858]	LOADK    	6 5	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00028303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 27	[858]	CALL     	4 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x02030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 28	[858]	GETI     	4 4 2
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x0204020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 29	[858]	SELF     	4 4 6k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x06048214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 30	[858]	LOADK    	6 7	; "%)"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00038303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 31	[858]	LOADK    	7 8	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x00040383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 32	[858]	CALL     	4 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x02040244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 33	[858]	SELF     	4 4 0k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x00048214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 34	[858]	LOADK    	6 9	; ","
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00048303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 35	[858]	CALL     	4 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x02030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 36	[859]	GETI     	5 2 3
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x0302028d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 37	[860]	LOADI    	6 4
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x80018301);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 38	[860]	LEN      	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x000203b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 39	[860]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 40	[860]	FORPREP  	6 5	; to 47
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x0002834a);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_47; /* skip the loop */
  }

  // 41	[861]	MOVE     	10 5
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x00050500);
    setobjs2s(L, ra, RB(i));
  }

  // 42	[861]	LOADK    	11 1	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x00008583);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 43	[861]	GETTABLE 	12 2 9
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0902060c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 44	[861]	CONCAT   	10 3
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x00030535);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 45	[861]	MOVE     	5 10
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000a0280);
    setobjs2s(L, ra, RB(i));
  }

  // 46	[860]	FORLOOP  	6 6	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x00030349);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_41; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_41; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 47	[863]	GETTABUP 	6 1 10	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x0a01030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 48	[863]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 49	[863]	CALL     	6 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x05020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 50	[863]	TFORPREP 	6 5	; to 57
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0002834b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_56;
  }

  // 51	[864]	SELF     	12 11 6k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x060b8614);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 52	[864]	LOADK    	14 1	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x00008703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 53	[864]	LOADK    	15 8	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00040783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 54	[864]	CALL     	12 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x02040644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 55	[864]	SETTABLE 	4 10 12
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x0c0a0210);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 56	[863]	TFORCALL 	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x0200034c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 57	[863]	TFORLOOP 	6 7	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x0003834d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_51; /* jump back */
    }
  }

  // 58	[865]	CLOSE    	6
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00000336);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 59	[867]	LOADK    	6 11	; "function("
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x00058303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 60	[867]	GETTABUP 	7 1 12	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x0c01038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 61	[867]	GETFIELD 	7 7 13	; "concat"
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x0d07038e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 62	[867]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 63	[867]	LOADK    	9 9	; ","
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x00048483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 64	[867]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 65	[867]	LOADK    	8 14	; "){ return "
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x00070403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 66	[867]	MOVE     	9 5
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x00050480);
    setobjs2s(L, ra, RB(i));
  }

  // 67	[867]	LOADK    	10 15	; "; }"
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x00078503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 68	[867]	CONCAT   	6 5
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x00050335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 69	[868]	LOADK    	7 16	; "var "
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x00080383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 70	[868]	MOVE     	8 3
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x00030400);
    setobjs2s(L, ra, RB(i));
  }

  // 71	[868]	LOADK    	9 17	; " = "
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x00088483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 72	[868]	MOVE     	10 6
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x00060500);
    setobjs2s(L, ra, RB(i));
  }

  // 73	[868]	CONCAT   	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x000403b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 74	[871]	GETUPVAL 	8 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x00000409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 75	[871]	GETI     	9 8 1
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x0108048d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 76	[871]	GETUPVAL 	8 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x00020409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 77	[871]	SETTABLE 	8 9 7
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x07090410);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 78	[872]	GETUPVAL 	8 3	; env
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x00030409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 79	[872]	SETTABLE 	8 1 6
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x06010410);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 80	[875]	LOADNIL  	8 5	; 6 out
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x00050408);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 81	[875]	MOVE     	5 13
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x000d0280);
    setobjs2s(L, ra, RB(i));
  }

  // 82	[875]	MOVE     	4 12
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x000c0200);
    setobjs2s(L, ra, RB(i));
  }

  // 83	[875]	MOVE     	7 11
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x000b0380);
    setobjs2s(L, ra, RB(i));
  }

  // 84	[875]	MOVE     	6 10
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x000a0300);
    setobjs2s(L, ra, RB(i));
  }

  // 85	[875]	MOVE     	3 9
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x00090180);
    setobjs2s(L, ra, RB(i));
  }

  // 86	[875]	MOVE     	2 8
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_131
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x00080100);
    setobjs2s(L, ra, RB(i));
  }

  // 87	[876]	JMP      	43	; to 132
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x80001538);
    updatetrap(ci);
    goto label_131;
  }

  // 88	[878]	LOADNIL  	2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x00000108);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 89	[879]	GETTABUP 	3 1 18	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x1201018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 90	[879]	LOADK    	4 19	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x00098203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 91	[879]	GETI     	5 0 3
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x0300028d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 92	[879]	CONCAT   	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x00020235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 93	[879]	TEST     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_96
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x00008242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 94	[879]	JMP      	1	; to 97
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_96;
  }

  // 95	[879]	LOADK    	4 20	; "false"
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x000a0203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 96	[879]	CALL     	3 2 3	; 1 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x030201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 97	[880]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_103
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 98	[880]	JMP      	4	; to 104
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_103;
  }

  // 99	[881]	GETTABUP 	5 1 21	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x1501028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 100	[881]	MOVE     	6 4
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x00040300);
    setobjs2s(L, ra, RB(i));
  }

  // 101	[881]	CALL     	5 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_106
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x010202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 102	[882]	JMP      	3	; to 107
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_106;
  }

  // 103	[883]	MOVE     	5 3
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x00030280);
    setobjs2s(L, ra, RB(i));
  }

  // 104	[883]	CALL     	5 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x020102c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 105	[883]	MOVE     	2 5
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x00050100);
    setobjs2s(L, ra, RB(i));
  }

  // 106	[886]	GETUPVAL 	5 3	; env
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x00030289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 107	[886]	SETTABLE 	5 1 2
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x02010290);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 108	[888]	GETUPVAL 	5 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x00000289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 109	[888]	GETI     	6 5 1
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x0105030d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 110	[888]	GETUPVAL 	5 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x00020289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 111	[888]	LOADK    	7 16	; "var "
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x00080383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 112	[888]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 113	[888]	LOADK    	9 17	; " = "
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x00088483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 114	[888]	GETTABUP 	10 1 22	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x1601050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 115	[888]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 116	[888]	CALL     	10 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x02020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 117	[888]	EQK      	10 2 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_124
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x0002053c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 118	[888]	JMP      	5	; to 125
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_124;
  }

  // 119	[888]	LOADK    	10 23	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x000b8503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 120	[888]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 121	[888]	LOADK    	12 23	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x000b8603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 122	[888]	CONCAT   	10 3
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_128
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x00030535);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 123	[888]	JMP      	4	; to 129
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_128;
  }

  // 124	[888]	GETTABUP 	11 1 24	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x1801058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 125	[888]	MOVE     	12 2
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x00020600);
    setobjs2s(L, ra, RB(i));
  }

  // 126	[888]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 127	[888]	MOVE     	10 11
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x000b0500);
    setobjs2s(L, ra, RB(i));
  }

  // 128	[888]	CONCAT   	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x000403b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 129	[888]	SETTABLE 	5 6 7
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x07060290);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 130	[889]	RETURN   	5 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_130: {
    aot_vmfetch(0x000182c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 131	[891]	RETURN   	2 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_131: {
    aot_vmfetch(0x00018146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 892 - 939
static
CallInfo *magic_implementation_70(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
  }

  // 0	[898]	GETTABUP 	0 0 0	; _ENV "warn"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[898]	LOADK    	1 1	; "Using #line is not recommended, Use import() instead"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[898]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[899]	GETUPVAL 	0 1	; v
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00010009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[899]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 5	[899]	SELF     	0 0 2k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 6	[899]	LOADK    	2 3	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[899]	CALL     	0 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x02030044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[900]	GETI     	1 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0200008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 9	[901]	LOADNIL  	2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000108);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 10	[902]	GETI     	3 0 3
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0300018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 11	[902]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_17
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 12	[902]	JMP      	4	; to 18
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_17;
  }

  // 13	[903]	GETTABUP 	3 0 4	; _ENV "getname"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0400018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 14	[903]	CALL     	3 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x020101c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 15	[903]	MOVE     	2 3
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00030100);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[904]	JMP      	7	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_24;
  }

  // 17	[905]	GETTABUP 	3 0 5	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0500018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 18	[905]	GETFIELD 	3 3 6	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0603018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[905]	GETI     	4 0 3
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0300020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 20	[905]	LOADI    	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x80008281);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 21	[905]	LOADI    	6 -2
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x7ffe8301);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 22	[905]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 23	[905]	MOVE     	2 3
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00030100);
    setobjs2s(L, ra, RB(i));
  }

  // 24	[907]	GETTABUP 	3 0 7	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0700018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 25	[907]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 26	[907]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 27	[908]	GETTABUP 	3 0 8	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0800018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 28	[908]	GETFIELD 	3 3 9	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x0903018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 29	[908]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 30	[908]	CALL     	3 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x020201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 31	[909]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_57
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 32	[909]	JMP      	24	; to 58
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x80000bb8);
    updatetrap(ci);
    goto label_57;
  }

  // 33	[910]	GETTABUP 	4 0 4	; _ENV "getname"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x0400020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 34	[910]	CALL     	4 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x02010244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 35	[911]	SELF     	5 4 10k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x0a048294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 36	[911]	LOADK    	7 11	; "(.*/)"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00058383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 37	[911]	CALL     	5 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x020302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 38	[912]	EQK      	5 12 0	; null
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_41
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x000c02bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 39	[912]	JMP      	1	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_41;
  }

  // 40	[913]	LOADK    	5 13	; "./"
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00068283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 41	[915]	GETTABUP 	6 0 8	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x0800030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 42	[915]	GETFIELD 	6 6 9	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0906030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 43	[915]	MOVE     	7 5
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x00050380);
    setobjs2s(L, ra, RB(i));
  }

  // 44	[915]	MOVE     	8 2
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x00020400);
    setobjs2s(L, ra, RB(i));
  }

  // 45	[915]	CONCAT   	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000203b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 46	[915]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 47	[915]	MOVE     	3 6
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00060180);
    setobjs2s(L, ra, RB(i));
  }

  // 48	[916]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_57
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 49	[916]	JMP      	7	; to 58
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_57;
  }

  // 50	[917]	GETTABUP 	6 0 14	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0e00030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 51	[917]	LOADK    	7 15	; "File '"
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00078383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 52	[917]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 53	[917]	MOVE     	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00020480);
    setobjs2s(L, ra, RB(i));
  }

  // 54	[917]	LOADK    	10 16	; "' not found"
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x00080503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 55	[917]	CONCAT   	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x000403b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 56	[917]	CALL     	6 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x01020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 57	[921]	SELF     	4 3 17k	; "read"
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x11038214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 58	[921]	LOADK    	6 18	; "*all"
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00090303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 59	[921]	CALL     	4 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x02030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 60	[922]	SELF     	5 3 19k	; "close"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x13038294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 61	[922]	CALL     	5 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x010202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 62	[924]	GETTABUP 	5 0 20	; _ENV "process"
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x1400028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 63	[924]	MOVE     	6 4
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x00040300);
    setobjs2s(L, ra, RB(i));
  }

  // 64	[924]	LOADNIL  	7 1	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x00010388);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 65	[924]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 66	[924]	MOVE     	4 5
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x00050200);
    setobjs2s(L, ra, RB(i));
  }

  // 67	[926]	SELF     	5 4 2k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x02048294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 68	[926]	LOADK    	7 21	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x000a8383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 69	[926]	CALL     	5 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x020302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 70	[926]	MOVE     	0 5
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x00050000);
    setobjs2s(L, ra, RB(i));
  }

  // 71	[927]	LOADK    	5 22	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x000b0283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 72	[928]	GETTABUP 	6 0 23	; _ENV "tonumber"
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x1700030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 73	[928]	MOVE     	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x00010380);
    setobjs2s(L, ra, RB(i));
  }

  // 74	[928]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 75	[928]	LEN      	7 0
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x000003b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 76	[928]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 77	[928]	FORPREP  	6 5	; to 84
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x0002834a);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_84; /* skip the loop */
  }

  // 78	[929]	MOVE     	10 5
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x00050500);
    setobjs2s(L, ra, RB(i));
  }

  // 79	[929]	GETTABLE 	11 0 9
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x0900058c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 80	[929]	LOADK    	12 21	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x000a8603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 81	[929]	CONCAT   	10 3
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x00030535);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 82	[929]	MOVE     	5 10
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x000a0280);
    setobjs2s(L, ra, RB(i));
  }

  // 83	[928]	FORLOOP  	6 6	; to 79
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x00030349);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_78; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_78; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 84	[931]	GETUPVAL 	6 1	; v
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x00010309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 85	[931]	GETI     	7 6 1
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x0106038d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 86	[931]	GETUPVAL 	6 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x00020309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 87	[931]	SETTABLE 	6 7 5
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x05070310);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 88	[934]	LOADNIL  	3 2	; 3 out
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x00020188);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 89	[937]	LOADNIL  	0 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x00000008);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 90	[938]	LOADNIL  	6 1	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x00010308);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 91	[938]	MOVE     	1 7
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x00070080);
    setobjs2s(L, ra, RB(i));
  }

  // 92	[938]	SETTABUP 	0 24 6	; _ENV "file"
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_92: {
    aot_vmfetch(0x0618000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 93	[939]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_93: {
    aot_vmfetch(0x00010347);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 940 - 989
static
CallInfo *magic_implementation_71(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
  }

  // 0	[941]	GETTABUP 	0 0 0	; _ENV "warn"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[941]	LOADK    	1 1	; "Using #include is not recommended, Use import() instead"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[941]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[943]	GETUPVAL 	0 1	; v
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00010009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[943]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 5	[943]	SELF     	0 0 2k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 6	[943]	LOADK    	2 3	; "#include \""
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[943]	LOADK    	3 4	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00020183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 8	[943]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[944]	MOVE     	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000080);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[947]	LOADI    	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80000101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 11	[947]	LEN      	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000001b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 12	[947]	LOADI    	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x80000201);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 13	[947]	FORPREP  	2 13	; to 28
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0006814a);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_28; /* skip the loop */
  }

  // 14	[948]	SELF     	6 0 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x05008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[948]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[948]	MOVE     	9 5
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00050480);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[948]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[949]	EQK      	6 6 0	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_27
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0006033c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 19	[949]	JMP      	7	; to 28
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_27;
  }

  // 20	[950]	SELF     	7 0 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x05008394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 21	[950]	LOADI    	9 1
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x80000481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 22	[950]	ADDI     	10 5 -1
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x7e050515);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 23	[950]	MMBINI   	5 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x078002af);
    Instruction pi = 0x7e050515;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 24	[950]	CALL     	7 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x020403c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 25	[950]	MOVE     	0 7
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_28
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00070000);
    setobjs2s(L, ra, RB(i));
  }

  // 26	[951]	JMP      	1	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_28;
  }

  // 27	[947]	FORLOOP  	2 14	; to 15
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00070149);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_14; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_14; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 28	[955]	LOADNIL  	2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00000108);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 29	[956]	GETTABUP 	3 0 7	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0700018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 30	[956]	GETTABUP 	4 0 8	; _ENV "package"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x0800020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 31	[956]	GETFIELD 	4 4 9	; "searchers"
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x0904020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 32	[956]	CALL     	3 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x050201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 33	[956]	TFORPREP 	3 26	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x000d01cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_60;
  }

  // 34	[957]	GETTABUP 	9 0 10	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x0a00048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 35	[957]	GETFIELD 	9 9 11	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x0b09048e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 36	[957]	MOVE     	10 8
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00080500);
    setobjs2s(L, ra, RB(i));
  }

  // 37	[957]	MOVE     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00000580);
    setobjs2s(L, ra, RB(i));
  }

  // 38	[957]	CALL     	10 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 39	[957]	CALL     	9 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x020004c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 40	[957]	LEN      	9 9
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x000904b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 41	[957]	EQI      	9 2 0
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_60
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x008104bd);
    int cond;
    int im = GETARG_sB(i);
    if (ttisinteger(s2v(ra)))
      cond = (ivalue(s2v(ra)) == im);
    else if (ttisfloat(s2v(ra)))
      cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));
    else
      cond = 0;  /* other types cannot be equal to a number */
    docondjump();
  }

  // 42	[957]	JMP      	17	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x80000838);
    updatetrap(ci);
    goto label_60;
  }

  // 43	[957]	GETTABUP 	9 0 10	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0a00048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 44	[957]	GETFIELD 	9 9 11	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x0b09048e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 45	[957]	MOVE     	10 8
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x00080500);
    setobjs2s(L, ra, RB(i));
  }

  // 46	[957]	MOVE     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x00000580);
    setobjs2s(L, ra, RB(i));
  }

  // 47	[957]	CALL     	10 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 48	[957]	CALL     	9 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x020004c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 49	[957]	GETI     	9 9 1
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x0109048d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 50	[957]	EQK      	9 12 1	; null
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_60
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x000c84bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 51	[957]	JMP      	8	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_60;
  }

  // 52	[958]	GETTABUP 	9 0 10	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x0a00048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 53	[958]	GETFIELD 	9 9 11	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x0b09048e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 54	[958]	MOVE     	10 8
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x00080500);
    setobjs2s(L, ra, RB(i));
  }

  // 55	[958]	MOVE     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x00000580);
    setobjs2s(L, ra, RB(i));
  }

  // 56	[958]	CALL     	10 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x00020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 57	[958]	CALL     	9 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x020004c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 58	[958]	MOVE     	2 9
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_62
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00090100);
    setobjs2s(L, ra, RB(i));
  }

  // 59	[959]	JMP      	2	; to 63
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_62;
  }

  // 60	[956]	TFORCALL 	3 2
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x020001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 61	[956]	TFORLOOP 	3 28	; to 35
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x000e01cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_34; /* jump back */
    }
  }

  // 62	[961]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 63	[962]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_88
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 64	[962]	JMP      	23	; to 89
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x80000b38);
    updatetrap(ci);
    goto label_88;
  }

  // 65	[963]	GETTABUP 	3 0 13	; _ENV "getname"
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x0d00018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 66	[963]	CALL     	3 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x020101c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 67	[964]	SELF     	4 3 14k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x0e038214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 68	[964]	LOADK    	6 15	; "(.*/)"
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x00078303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 69	[964]	CALL     	4 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x02030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 70	[965]	EQK      	4 12 0	; null
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_73
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x000c023c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 71	[965]	JMP      	1	; to 74
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_73;
  }

  // 72	[966]	LOADK    	4 16	; "./"
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x00080203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 73	[969]	GETTABUP 	5 0 17	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x1100028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 74	[969]	GETFIELD 	5 5 18	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x1205028e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 75	[969]	MOVE     	6 4
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x00040300);
    setobjs2s(L, ra, RB(i));
  }

  // 76	[969]	MOVE     	7 0
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x00000380);
    setobjs2s(L, ra, RB(i));
  }

  // 77	[969]	CONCAT   	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x00020335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 78	[969]	CALL     	5 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x020202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 79	[969]	MOVE     	2 5
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x00050100);
    setobjs2s(L, ra, RB(i));
  }

  // 80	[970]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_88
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 81	[970]	JMP      	6	; to 89
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_88;
  }

  // 82	[971]	GETTABUP 	5 0 19	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x1300028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 83	[971]	LOADK    	6 20	; "File '"
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x000a0303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 84	[971]	MOVE     	7 0
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x00000380);
    setobjs2s(L, ra, RB(i));
  }

  // 85	[971]	LOADK    	8 21	; "' not found"
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x000a8403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 86	[971]	CONCAT   	6 3
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x00030335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 87	[971]	CALL     	5 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x010202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 88	[974]	GETTABUP 	3 0 22	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x1600018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 89	[974]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 90	[974]	CALL     	3 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x020201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 91	[974]	EQK      	3 23 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_99
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x001701bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 92	[974]	JMP      	6	; to 100
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_99;
  }

  // 93	[975]	GETTABUP 	3 0 17	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x1100018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 94	[975]	GETFIELD 	3 3 18	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x1203018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 95	[975]	GETI     	4 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x0202020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 96	[975]	CALL     	3 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x020201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 97	[975]	MOVE     	0 3
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_100
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x00030000);
    setobjs2s(L, ra, RB(i));
  }

  // 98	[976]	JMP      	1	; to 101
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_100;
  }

  // 99	[977]	MOVE     	0 2
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x00020000);
    setobjs2s(L, ra, RB(i));
  }

  // 100	[979]	SELF     	3 0 24k	; "read"
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x18008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 101	[979]	LOADK    	5 25	; "*all"
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x000c8283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 102	[979]	CALL     	3 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x020301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 103	[980]	SELF     	4 0 26k	; "close"
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x1a008214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 104	[980]	CALL     	4 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x01020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 105	[984]	GETUPVAL 	4 1	; v
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x00010209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 106	[984]	GETI     	5 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x0104028d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 107	[984]	GETUPVAL 	4 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x00020209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 108	[984]	GETTABUP 	6 0 28	; _ENV "process"
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x1c00030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 109	[984]	MOVE     	7 3
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x00030380);
    setobjs2s(L, ra, RB(i));
  }

  // 110	[984]	LOADNIL  	8 1	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x00010408);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 111	[984]	CALL     	6 4 3	; 3 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x03040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 112	[984]	SETTABUP 	0 27 7	; _ENV "newincludes"
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x071b000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 113	[984]	SETTABLE 	4 5 6
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x06050210);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 114	[986]	LOADNIL  	0 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x00000008);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 115	[987]	LOADNIL  	2 1	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_115: {
    aot_vmfetch(0x00010108);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 116	[989]	RETURN   	4 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_116: {
    aot_vmfetch(0x00018246);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 990 - 1026
static
CallInfo *magic_implementation_72(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
  }

  // 0	[995]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[995]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[995]	SELF     	0 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[995]	LOADK    	2 1	; "#if "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[995]	LOADK    	3 2	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[995]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[997]	LOADI    	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000081);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 7	[997]	LEN      	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000134);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 8	[997]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 9	[997]	FORPREP  	1 13	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_24; /* skip the loop */
  }

  // 10	[998]	SELF     	5 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x03008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[998]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[998]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[998]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[999]	EQK      	5 4 0	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x000402bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 15	[999]	JMP      	7	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_23;
  }

  // 16	[1000]	SELF     	6 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 17	[1000]	ADDI     	8 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x80040415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 18	[1000]	MMBINI   	4 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0680022f);
    Instruction pi = 0x80040415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 19	[1000]	LEN      	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000004b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 20	[1000]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 21	[1000]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[1001]	JMP      	1	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_24;
  }

  // 23	[997]	FORLOOP  	1 14	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_10; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_10; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 24	[1004]	LEN      	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x000000b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 25	[1004]	LOADI    	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80000101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 26	[1004]	LOADI    	3 -1
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x7fff0181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 27	[1004]	FORPREP  	1 13	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_42; /* skip the loop */
  }

  // 28	[1005]	SELF     	5 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x03008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 29	[1005]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 30	[1005]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[1005]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[1006]	EQK      	5 5 0	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_41
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x000502bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 33	[1006]	JMP      	7	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_41;
  }

  // 34	[1007]	SELF     	6 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 35	[1007]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 36	[1007]	ADDI     	9 4 -1
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x7e040495);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 37	[1007]	MMBINI   	4 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x0780022f);
    Instruction pi = 0x7e040495;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 38	[1007]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 39	[1007]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 40	[1008]	JMP      	1	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_42;
  }

  // 41	[1004]	FORLOOP  	1 14	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_28; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_28; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 42	[1012]	GETTABUP 	1 1 6	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0601008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[1014]	CLOSURE  	2 0	; 0x7fbced010f60
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0000014f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 44	[1016]	CLOSURE  	3 1	; 0x7fbced0114c0
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x000081cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 45	[1012]	CALL     	1 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x030300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 46	[1017]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 47	[1017]	JMP      	3	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_51;
  }

  // 48	[1018]	GETTABUP 	3 1 7	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x0701018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 49	[1018]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 50	[1018]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 51	[1021]	GETUPVAL 	3 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 52	[1021]	GETI     	4 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x0103020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 53	[1021]	GETUPVAL 	3 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00020189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 54	[1021]	SETTABLE 	3 4 8k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x08048190);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 55	[1022]	GETTABUP 	3 1 9	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x0901018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 56	[1022]	GETFIELD 	3 3 10	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x0a03018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 57	[1022]	GETUPVAL 	4 3	; activeifs
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00030209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 58	[1022]	MOVE     	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00020280);
    setobjs2s(L, ra, RB(i));
  }

  // 59	[1022]	CALL     	3 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x010301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 60	[1025]	SETUPVAL 	2 4	; run
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_60: {
    aot_vmfetch(0x0004010a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 61	[1026]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_61: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1012 - 1014
static
CallInfo *magic_implementation_73(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
  }

  // 0	[1013]	GETTABUP 	0 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1013]	LOADK    	1 1	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[1013]	GETUPVAL 	2 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[1013]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 4	[1013]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[1013]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_20
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 6	[1013]	JMP      	13	; to 21
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_20;
  }

  // 7	[1013]	GETTABUP 	0 0 2	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0200000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[1013]	LOADK    	1 3	; "Failed to check condition\n"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00018083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[1013]	GETTABUP 	2 0 4	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 10	[1013]	GETFIELD 	2 2 5	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0502010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[1013]	GETTABUP 	3 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[1013]	LOADK    	4 1	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00008203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[1013]	GETUPVAL 	5 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00010289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 14	[1013]	CONCAT   	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00020235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 15	[1013]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[1013]	CALL     	2 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x02000144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 17	[1013]	GETI     	2 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0202010d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 18	[1013]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 19	[1013]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[1013]	TAILCALL 	0 1 0	; 0 in
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00010045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 21	[1013]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_21: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 22	[1014]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_22: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1014 - 1016
static
CallInfo *magic_implementation_74(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1015]	GETTABUP 	1 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1015]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1015]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1016]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1027 - 1063
static
CallInfo *magic_implementation_75(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
  }

  // 0	[1032]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1032]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[1032]	SELF     	0 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[1032]	LOADK    	2 1	; "#if "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1032]	LOADK    	3 2	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[1032]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[1034]	LOADI    	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000081);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 7	[1034]	LEN      	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000134);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 8	[1034]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 9	[1034]	FORPREP  	1 13	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_24; /* skip the loop */
  }

  // 10	[1035]	SELF     	5 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x03008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[1035]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[1035]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[1035]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[1036]	EQK      	5 4 0	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x000402bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 15	[1036]	JMP      	7	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_23;
  }

  // 16	[1037]	SELF     	6 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 17	[1037]	ADDI     	8 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x80040415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 18	[1037]	MMBINI   	4 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0680022f);
    Instruction pi = 0x80040415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 19	[1037]	LEN      	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000004b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 20	[1037]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 21	[1037]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[1038]	JMP      	1	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_24;
  }

  // 23	[1034]	FORLOOP  	1 14	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_10; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_10; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 24	[1041]	LEN      	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x000000b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 25	[1041]	LOADI    	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80000101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 26	[1041]	LOADI    	3 -1
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x7fff0181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 27	[1041]	FORPREP  	1 13	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_42; /* skip the loop */
  }

  // 28	[1042]	SELF     	5 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x03008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 29	[1042]	GETUPVAL 	7 1	; i
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00010389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 30	[1042]	GETUPVAL 	8 1	; i
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00010409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 31	[1042]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[1043]	EQK      	5 5 0	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_41
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x000502bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 33	[1043]	JMP      	7	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_41;
  }

  // 34	[1044]	SELF     	6 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 35	[1044]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 36	[1044]	ADDI     	9 4 -1
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x7e040495);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 37	[1044]	MMBINI   	4 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x0780022f);
    Instruction pi = 0x7e040495;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 38	[1044]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 39	[1044]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 40	[1045]	JMP      	1	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_42;
  }

  // 41	[1041]	FORLOOP  	1 14	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_28; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_28; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 42	[1049]	GETTABUP 	1 2 6	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0602008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[1051]	CLOSURE  	2 0	; 0x7fbced0117a0
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0000014f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 44	[1053]	CLOSURE  	3 1	; 0x7fbced011da0
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x000081cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 45	[1049]	CALL     	1 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x030300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 46	[1054]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 47	[1054]	JMP      	3	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_51;
  }

  // 48	[1055]	GETTABUP 	3 2 7	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x0702018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 49	[1055]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 50	[1055]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 51	[1058]	GETUPVAL 	3 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 52	[1058]	GETI     	4 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x0103020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 53	[1058]	GETUPVAL 	3 3	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00030189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 54	[1058]	SETTABLE 	3 4 8k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x08048190);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 55	[1059]	GETTABUP 	3 2 9	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x0902018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 56	[1059]	GETFIELD 	3 3 10	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x0a03018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 57	[1059]	GETUPVAL 	4 4	; activeifs
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00040209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 58	[1059]	MOVE     	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00020280);
    setobjs2s(L, ra, RB(i));
  }

  // 59	[1059]	CALL     	3 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x010301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 60	[1062]	SETUPVAL 	2 5	; run
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_60: {
    aot_vmfetch(0x0005010a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 61	[1063]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_61: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1049 - 1051
static
CallInfo *magic_implementation_76(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
  }

  // 0	[1050]	GETTABUP 	0 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1050]	LOADK    	1 1	; "return defined(\""
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[1050]	GETUPVAL 	2 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[1050]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 4	[1050]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[1050]	LOADK    	2 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[1050]	LOADK    	3 3	; "\")"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[1050]	CONCAT   	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000300b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 8	[1050]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[1050]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_30
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 10	[1050]	JMP      	19	; to 31
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80000938);
    updatetrap(ci);
    goto label_30;
  }

  // 11	[1050]	GETTABUP 	0 0 4	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0400000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[1050]	LOADK    	1 5	; "Failed to check condition\n"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00028083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[1050]	GETTABUP 	2 0 6	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0600010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 14	[1050]	GETFIELD 	2 2 7	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0702010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[1050]	GETTABUP 	3 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 16	[1050]	LOADK    	4 8	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00040203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 17	[1050]	GETUPVAL 	5 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00010289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 18	[1050]	TEST     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_21
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x000082c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 19	[1050]	JMP      	1	; to 22
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_21;
  }

  // 20	[1050]	LOADK    	5 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00010283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 21	[1050]	CONCAT   	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00020235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 22	[1050]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 23	[1050]	CALL     	2 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x02000144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[1050]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_27
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 25	[1050]	JMP      	1	; to 28
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_27;
  }

  // 26	[1050]	LOADK    	2 9	; "Failed to error"
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00048103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 27	[1050]	GETI     	2 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0202010d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 28	[1050]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 29	[1050]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 30	[1050]	TAILCALL 	0 1 0	; 0 in
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00010045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 31	[1050]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_31: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 32	[1051]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_32: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1051 - 1053
static
CallInfo *magic_implementation_77(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1052]	GETTABUP 	1 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1052]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1052]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1053]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1064 - 1100
static
CallInfo *magic_implementation_78(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
  }

  // 0	[1069]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1069]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[1069]	SELF     	0 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[1069]	LOADK    	2 1	; "#if "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1069]	LOADK    	3 2	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[1069]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[1071]	LOADI    	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000081);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 7	[1071]	LEN      	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000134);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 8	[1071]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 9	[1071]	FORPREP  	1 13	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_24; /* skip the loop */
  }

  // 10	[1072]	SELF     	5 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x03008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[1072]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[1072]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[1072]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[1073]	EQK      	5 4 0	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x000402bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 15	[1073]	JMP      	7	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_23;
  }

  // 16	[1074]	SELF     	6 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 17	[1074]	ADDI     	8 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x80040415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 18	[1074]	MMBINI   	4 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0680022f);
    Instruction pi = 0x80040415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 19	[1074]	LEN      	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000004b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 20	[1074]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 21	[1074]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[1075]	JMP      	1	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_24;
  }

  // 23	[1071]	FORLOOP  	1 14	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_10; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_10; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 24	[1078]	LEN      	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x000000b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 25	[1078]	LOADI    	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80000101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 26	[1078]	LOADI    	3 -1
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x7fff0181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 27	[1078]	FORPREP  	1 13	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_42; /* skip the loop */
  }

  // 28	[1079]	SELF     	5 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x03008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 29	[1079]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 30	[1079]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[1079]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[1080]	EQK      	5 5 0	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_41
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x000502bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 33	[1080]	JMP      	7	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_41;
  }

  // 34	[1081]	SELF     	6 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 35	[1081]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 36	[1081]	ADDI     	9 4 -1
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x7e040495);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 37	[1081]	MMBINI   	4 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x0780022f);
    Instruction pi = 0x7e040495;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 38	[1081]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 39	[1081]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 40	[1082]	JMP      	1	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_42;
  }

  // 41	[1078]	FORLOOP  	1 14	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_28; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_28; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 42	[1086]	GETTABUP 	1 1 6	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0601008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[1088]	CLOSURE  	2 0	; 0x7fbced012100
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0000014f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 44	[1090]	CLOSURE  	3 1	; 0x7fbced012580
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x000081cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 45	[1086]	CALL     	1 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x030300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 46	[1091]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 47	[1091]	JMP      	3	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_51;
  }

  // 48	[1092]	GETTABUP 	3 1 7	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x0701018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 49	[1092]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 50	[1092]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 51	[1095]	GETUPVAL 	3 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 52	[1095]	GETI     	4 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x0103020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 53	[1095]	GETUPVAL 	3 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00020189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 54	[1095]	SETTABLE 	3 4 8k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x08048190);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 55	[1096]	GETTABUP 	3 1 9	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x0901018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 56	[1096]	GETFIELD 	3 3 10	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x0a03018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 57	[1096]	GETUPVAL 	4 3	; activeifs
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00030209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 58	[1096]	MOVE     	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00020280);
    setobjs2s(L, ra, RB(i));
  }

  // 59	[1096]	CALL     	3 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x010301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 60	[1099]	SETUPVAL 	2 4	; run
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_60: {
    aot_vmfetch(0x0004010a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 61	[1100]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_61: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1086 - 1088
static
CallInfo *magic_implementation_79(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
  }

  // 0	[1087]	GETTABUP 	0 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1087]	LOADK    	1 1	; "return !defined(\""
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[1087]	GETUPVAL 	2 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[1087]	LOADK    	3 2	; "\")"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1087]	CONCAT   	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000300b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 5	[1087]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[1087]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_21
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 7	[1087]	JMP      	13	; to 22
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_21;
  }

  // 8	[1087]	GETTABUP 	0 0 3	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0300000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 9	[1087]	LOADK    	1 4	; "Failed to check condition\n"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00020083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 10	[1087]	GETTABUP 	2 0 5	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0500010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 11	[1087]	GETFIELD 	2 2 6	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0602010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 12	[1087]	GETTABUP 	3 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[1087]	LOADK    	4 7	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00038203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 14	[1087]	GETUPVAL 	5 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00010289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 15	[1087]	CONCAT   	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00020235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 16	[1087]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 17	[1087]	CALL     	2 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x02000144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[1087]	GETI     	2 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0202010d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 19	[1087]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 20	[1087]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 21	[1087]	TAILCALL 	0 1 0	; 0 in
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00010045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 22	[1087]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_22: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 23	[1088]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_23: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1088 - 1090
static
CallInfo *magic_implementation_80(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1089]	GETTABUP 	1 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1089]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1089]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1090]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1101 - 1140
static
CallInfo *magic_implementation_81(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
  }

  // 0	[1104]	GETUPVAL 	0 0	; run
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1104]	TEST     	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 2	[1104]	JMP      	5	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_08;
  }

  // 3	[1105]	GETUPVAL 	0 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00020009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[1105]	GETI     	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 5	[1105]	GETUPVAL 	0 1	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[1105]	SETTABLE 	0 1 0k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018010);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 7	[1106]	RETURN   	0 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00018046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[1109]	GETUPVAL 	0 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00020009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 9	[1109]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 10	[1109]	SELF     	0 0 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x01008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[1109]	LOADK    	2 2	; "#elif "
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00010103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 12	[1109]	LOADK    	3 3	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[1109]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[1111]	LOADI    	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80000081);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 15	[1111]	LEN      	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000134);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 16	[1111]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 17	[1111]	FORPREP  	1 13	; to 32
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_32; /* skip the loop */
  }

  // 18	[1112]	SELF     	5 0 4k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x04008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[1112]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[1112]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 21	[1112]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 22	[1113]	EQK      	5 5 0	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_31
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000502bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 23	[1113]	JMP      	7	; to 32
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_31;
  }

  // 24	[1114]	SELF     	6 0 4k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x04008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 25	[1114]	ADDI     	8 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80040415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 26	[1114]	MMBINI   	4 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x0680022f);
    Instruction pi = 0x80040415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 27	[1114]	LEN      	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000004b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 28	[1114]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 29	[1114]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_32
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 30	[1115]	JMP      	1	; to 33
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_32;
  }

  // 31	[1111]	FORLOOP  	1 14	; to 19
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_18; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_18; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 32	[1118]	LEN      	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x000000b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 33	[1118]	LOADI    	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x80000101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 34	[1118]	LOADI    	3 -1
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x7fff0181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 35	[1118]	FORPREP  	1 13	; to 50
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_50; /* skip the loop */
  }

  // 36	[1119]	SELF     	5 0 4k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x04008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 37	[1119]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 38	[1119]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 39	[1119]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 40	[1120]	EQK      	5 6 0	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_49
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x000602bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 41	[1120]	JMP      	7	; to 50
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_49;
  }

  // 42	[1121]	SELF     	6 0 4k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x04008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 43	[1121]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 44	[1121]	ADDI     	9 4 -1
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x7e040495);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 45	[1121]	MMBINI   	4 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x0780022f);
    Instruction pi = 0x7e040495;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 46	[1121]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 47	[1121]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_50
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 48	[1122]	JMP      	1	; to 51
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_50;
  }

  // 49	[1118]	FORLOOP  	1 14	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_36; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_36; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 50	[1126]	GETTABUP 	1 3 7	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0703008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 51	[1128]	CLOSURE  	2 0	; 0x7fbced012ba0
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x0000014f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 52	[1130]	CLOSURE  	3 1	; 0x7fbced012cb0
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x000081cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 53	[1126]	CALL     	1 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x030300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 54	[1131]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_59
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 55	[1131]	JMP      	3	; to 60
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_59;
  }

  // 56	[1132]	GETTABUP 	3 3 8	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x0803018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 57	[1132]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 58	[1132]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 59	[1135]	GETUPVAL 	3 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x00020189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 60	[1135]	GETI     	4 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x0103020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 61	[1135]	GETUPVAL 	3 1	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x00010189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 62	[1135]	SETTABLE 	3 4 0k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x00048190);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 63	[1136]	GETTABUP 	3 3 9	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x0903018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 64	[1136]	GETFIELD 	3 3 10	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x0a03018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 65	[1136]	GETUPVAL 	4 4	; activeifs
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x00040209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 66	[1136]	MOVE     	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x00020280);
    setobjs2s(L, ra, RB(i));
  }

  // 67	[1136]	CALL     	3 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x010301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 68	[1139]	SETUPVAL 	2 0	; run
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_68: {
    aot_vmfetch(0x0000010a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 69	[1140]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_69: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1126 - 1128
static
CallInfo *magic_implementation_82(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
  }

  // 0	[1127]	GETTABUP 	0 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1127]	LOADK    	1 1	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[1127]	GETUPVAL 	2 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[1127]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 4	[1127]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[1127]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_20
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 6	[1127]	JMP      	13	; to 21
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_20;
  }

  // 7	[1127]	GETTABUP 	0 0 2	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0200000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[1127]	LOADK    	1 3	; "Failed to check condition\n"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00018083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[1127]	GETTABUP 	2 0 4	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 10	[1127]	GETFIELD 	2 2 5	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0502010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[1127]	GETTABUP 	3 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[1127]	LOADK    	4 1	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00008203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[1127]	GETUPVAL 	5 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00010289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 14	[1127]	CONCAT   	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00020235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 15	[1127]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[1127]	CALL     	2 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x02000144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 17	[1127]	GETI     	2 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0202010d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 18	[1127]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 19	[1127]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[1127]	TAILCALL 	0 1 0	; 0 in
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00010045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 21	[1127]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_21: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 22	[1128]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_22: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1128 - 1130
static
CallInfo *magic_implementation_83(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1129]	GETTABUP 	1 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1129]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1129]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1130]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1141 - 1144
static
CallInfo *magic_implementation_84(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
  }

  // 0	[1142]	GETUPVAL 	0 0	; run
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1142]	NOT      	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000033);
    TValue *rb = vRB(i);
    if (l_isfalse(rb))
      setbtvalue(s2v(ra));
    else
      setbfvalue(s2v(ra));
  }

  // 2	[1142]	SETUPVAL 	0 0	; run
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0000000a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 3	[1143]	GETUPVAL 	0 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00020009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[1143]	GETI     	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 5	[1143]	GETUPVAL 	0 1	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[1143]	SETTABLE 	0 1 0k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x00018010);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 7	[1144]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1145 - 1149
static
CallInfo *magic_implementation_85(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
  }

  // 0	[1146]	GETUPVAL 	0 0	; activeifs
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1146]	LEN      	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x000000b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 2	[1146]	GETUPVAL 	0 0	; activeifs
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[1146]	SETTABLE 	0 1 0k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00018010);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 4	[1147]	GETUPVAL 	0 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00020009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 5	[1147]	GETI     	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0100008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 6	[1147]	GETUPVAL 	0 1	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[1147]	SETTABLE 	0 1 0k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00018010);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 8	[1148]	LOADTRUE 	0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000007);
    setbtvalue(s2v(ra));
  }

  // 9	[1148]	SETUPVAL 	0 3	; run
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x0003000a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 10	[1149]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_10: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1150 - 1159
static
CallInfo *magic_implementation_86(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
  }

  // 0	[1152]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1152]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[1152]	SELF     	0 0 0k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[1152]	LOADK    	2 1	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1152]	CALL     	0 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02030044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[1154]	GETI     	1 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 6	[1156]	GETUPVAL 	2 1	; env
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[1156]	SETTABLE 	2 1 2k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x02018110);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 8	[1158]	GETUPVAL 	2 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 9	[1158]	GETI     	3 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0102018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 10	[1158]	GETUPVAL 	2 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 11	[1158]	SETTABLE 	2 3 2k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x02038110);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 12	[1159]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1160 - 1165
static
CallInfo *magic_implementation_87(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
  }

  // 0	[1161]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1161]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[1161]	SELF     	0 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[1161]	LOADK    	2 1	; "#error "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1161]	LOADK    	3 2	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[1161]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[1162]	GETTABUP 	1 1 3	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[1162]	LOADK    	2 4	; "\027[1;31mRaised error:\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00020103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 8	[1162]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[1163]	GETTABUP 	1 1 3	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0301008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 10	[1163]	LOADK    	2 5	; "\027[1;31m"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00028103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[1163]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[1163]	LOADK    	4 6	; "\027[0m\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00030203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[1163]	CONCAT   	2 3
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00030135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 14	[1163]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 15	[1164]	MOVE     	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000080);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[1164]	LOADK    	2 7	; "Ending preprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00038103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 17	[1164]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_17: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[1165]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_18: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1166 - 1170
static
CallInfo *magic_implementation_88(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
  }

  // 0	[1167]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1167]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[1167]	SELF     	0 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[1167]	LOADK    	2 1	; "#warning "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1167]	LOADK    	3 2	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[1167]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[1168]	GETTABUP 	1 1 3	; _ENV "warn"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[1168]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[1168]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[1169]	GETUPVAL 	1 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 10	[1169]	GETI     	2 1 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0101010d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 11	[1169]	GETUPVAL 	1 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 12	[1169]	SETTABLE 	1 2 4k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x04028090);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 13	[1170]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1171 - 1173
static
CallInfo *magic_implementation_89(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1172]	GETTABUP 	0 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1172]	LOADK    	1 1	; "Config is not supported"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[1172]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1173]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1174 - 1177
static
CallInfo *magic_implementation_90(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1176]	GETTABUP 	0 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1176]	LOADK    	1 1	; "Extensions are not supported"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[1176]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1177]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1178 - 1197
static
CallInfo *magic_implementation_91(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
  }

  // 0	[1179]	GETUPVAL 	1 0	; run
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1179]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 2	[1179]	JMP      	5	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_08;
  }

  // 3	[1180]	GETUPVAL 	1 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[1180]	GETI     	2 1 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0101010d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 5	[1180]	GETUPVAL 	1 1	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[1180]	SETTABLE 	1 2 0k	; null
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00028090);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 7	[1181]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[1185]	GETUPVAL 	1 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 9	[1185]	GETI     	1 1 2
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0201008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 10	[1185]	SELF     	1 1 1k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x01018094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[1185]	LOADI    	3 2
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80008181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 12	[1185]	GETUPVAL 	4 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00020209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 13	[1185]	GETI     	4 4 2
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0204020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 14	[1185]	LEN      	4 4
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00040234);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 15	[1185]	CALL     	1 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x020400c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[1187]	GETTABUP 	2 3 2	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0203010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[1189]	CLOSURE  	3 0	; 0x7fbced013cd0
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x000001cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 18	[1191]	CLOSURE  	4 1	; 0x7fbced013e20
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0000824f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 19	[1187]	CALL     	2 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x03030144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[1192]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_26
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 21	[1192]	JMP      	4	; to 27
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_26;
  }

  // 22	[1193]	GETTABUP 	4 3 3	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0303020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 23	[1193]	MOVE     	5 3
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00030280);
    setobjs2s(L, ra, RB(i));
  }

  // 24	[1193]	CALL     	4 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_30
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x01020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 25	[1194]	JMP      	4	; to 31
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_30;
  }

  // 26	[1195]	GETUPVAL 	4 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00020209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 27	[1195]	GETI     	5 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0104028d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 28	[1195]	GETUPVAL 	4 1	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00010209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 29	[1195]	SETTABLE 	4 5 3
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_29: {
    aot_vmfetch(0x03050210);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 30	[1197]	RETURN   	4 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_30: {
    aot_vmfetch(0x00018246);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1187 - 1189
static
CallInfo *magic_implementation_92(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
  }

  // 0	[1188]	GETTABUP 	0 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1188]	GETUPVAL 	1 1	; code
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 2	[1188]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1188]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 4	[1188]	JMP      	3	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_08;
  }

  // 5	[1188]	GETTABUP 	0 0 1	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0100000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[1188]	LOADK    	1 2	; "Failed to load preprocessor command"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[1188]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[1188]	TAILCALL 	0 1 0	; 0 in
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b, 0);  /* prepare call frame */
    return ci;
  }

  // 9	[1188]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 10	[1189]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_10: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1189 - 1191
static
CallInfo *magic_implementation_93(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1190]	GETTABUP 	1 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1190]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1190]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1191]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

static AotCompiledFunction AOT_FUNCTIONS[] = {
  magic_implementation_00,
  magic_implementation_01,
  magic_implementation_02,
  magic_implementation_03,
  magic_implementation_04,
  magic_implementation_05,
  magic_implementation_06,
  magic_implementation_07,
  magic_implementation_08,
  magic_implementation_09,
  magic_implementation_10,
  magic_implementation_11,
  magic_implementation_12,
  magic_implementation_13,
  magic_implementation_14,
  magic_implementation_15,
  magic_implementation_16,
  magic_implementation_17,
  magic_implementation_18,
  magic_implementation_19,
  magic_implementation_20,
  magic_implementation_21,
  magic_implementation_22,
  magic_implementation_23,
  magic_implementation_24,
  magic_implementation_25,
  magic_implementation_26,
  magic_implementation_27,
  magic_implementation_28,
  magic_implementation_29,
  magic_implementation_30,
  magic_implementation_31,
  magic_implementation_32,
  magic_implementation_33,
  magic_implementation_34,
  magic_implementation_35,
  magic_implementation_36,
  magic_implementation_37,
  magic_implementation_38,
  magic_implementation_39,
  magic_implementation_40,
  magic_implementation_41,
  magic_implementation_42,
  magic_implementation_43,
  magic_implementation_44,
  magic_implementation_45,
  magic_implementation_46,
  magic_implementation_47,
  magic_implementation_48,
  magic_implementation_49,
  magic_implementation_50,
  magic_implementation_51,
  magic_implementation_52,
  magic_implementation_53,
  magic_implementation_54,
  magic_implementation_55,
  magic_implementation_56,
  magic_implementation_57,
  magic_implementation_58,
  magic_implementation_59,
  magic_implementation_60,
  magic_implementation_61,
  magic_implementation_62,
  magic_implementation_63,
  magic_implementation_64,
  magic_implementation_65,
  magic_implementation_66,
  magic_implementation_67,
  magic_implementation_68,
  magic_implementation_69,
  magic_implementation_70,
  magic_implementation_71,
  magic_implementation_72,
  magic_implementation_73,
  magic_implementation_74,
  magic_implementation_75,
  magic_implementation_76,
  magic_implementation_77,
  magic_implementation_78,
  magic_implementation_79,
  magic_implementation_80,
  magic_implementation_81,
  magic_implementation_82,
  magic_implementation_83,
  magic_implementation_84,
  magic_implementation_85,
  magic_implementation_86,
  magic_implementation_87,
  magic_implementation_88,
  magic_implementation_89,
  magic_implementation_90,
  magic_implementation_91,
  magic_implementation_92,
  magic_implementation_93,
  NULL
};

static const char AOT_MODULE_SOURCE_CODE[] = {
   47,  47,  32,  66, 117, 105, 108, 116,  32, 105, 110,  32, 112, 114, 101, 112,
  114, 111,  99, 101, 115, 115, 111, 114,  32, 102, 111, 114,  32,  99, 111,  98,
   97, 108, 116,  10,  47,  47,  32,  84, 104, 101,  32, 112, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 101, 114,  32, 105, 115,  32, 110, 111, 116,  32,  97,
  112,  97, 114, 116,  32, 111, 102,  32, 116, 104, 101,  32,  99, 111, 109, 112,
  105, 108, 101, 114,  10,  47,  47,  32,  97, 110, 100,  32, 110, 101, 101, 100,
  115,  32, 116, 111,  32,  98, 101,  32,  98, 117, 105, 108, 116,  32, 117, 115,
  105, 110, 103,  32,  96,  99, 109,  97, 107, 101,  32,  46,  32,  38,  38,  32,
  109,  97, 107, 101,  96,  32,  97, 110, 100,  10,  47,  47,  32, 117, 115, 101,
  100,  32,  98, 101, 102, 111, 114, 101,  32,  99, 111, 109, 112, 105, 108, 105,
  110, 103,  32, 116, 104, 101,  32, 115, 111, 117, 114,  99, 101,  32,  99, 111,
  100, 101,  10,  10,  47,  47,  32,  84, 104, 101,  32, 112, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 111, 114,  32, 114, 101, 112, 108,  97,  99, 101, 115,
   32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32, 100, 105,
  114, 101,  99, 116, 105, 118, 101, 115,  32, 119, 105, 116, 104,  10,  47,  47,
   32,  99, 111,  98,  97, 108, 116,  32,  99, 111, 100, 101,  32, 100, 101, 112,
  101, 110, 100, 105, 110, 103,  32, 111, 110,  32, 115, 121, 115, 116, 101, 109,
   32,  97, 110, 100,  32, 111, 116, 104, 101, 114,  32, 102,  97,  99, 116, 111,
  114, 115,  10,  10,  47,  47,  32,  78, 111, 116,  32, 117, 115, 101, 100,  32,
  100, 105, 114, 101,  99, 116, 108, 121,  44,  32, 114,  97, 116, 104, 101, 114,
   32,  99, 111, 109, 112, 105, 108, 101, 100,  32, 116, 111,  32,  67,  32,  97,
  110, 100,  32, 105, 110,  99, 108, 117, 100, 101, 100,  32, 105, 110,  32, 115,
  111, 117, 114,  99, 101,  46,  10,  10,  47,  47,  32,  73,  78,  73,  84,  10,
  102, 105, 108, 101, 115, 121, 115, 116, 101, 109,  32,  61,  32, 102, 105, 108,
  101,  32,  47,  47,  32,  70, 105, 108, 101,  32, 108, 105,  98, 114,  97, 114,
  121,  32, 102, 111, 114,  32,  99, 111,  98,  97, 108, 116,  10, 102, 105, 108,
  101, 120,  32,  61,  32, 105, 109, 112, 111, 114, 116,  40,  34, 101, 120, 116,
   46, 102, 105, 108, 101,  34,  41,  32,  47,  47,  32,  69, 120, 116, 101, 110,
  100, 101, 100,  32,  70, 105, 108, 101,  32, 108, 105,  98, 114,  97, 114, 121,
   32, 102, 111, 114,  32,  99, 111,  98,  97, 108, 116,  10,  10, 109,  97,  99,
  114, 111, 115,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41,
  123, 125,  32,  47,  47,  32,  99, 111, 114, 101,  46, 109,  97,  99, 114, 111,
  115,  10,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 115, 119, 105, 116,
   99, 104,  40, 118,  97, 108, 117, 101,  44,  32,  99,  97, 115, 101, 115,  41,
  123,  10,  32,  32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40,  99,
   97, 115, 101, 115,  41,  32,  33,  61,  32,  34, 116,  97,  98, 108, 101,  34,
   41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114,
   40,  34,  83, 119, 105, 116,  99, 104,  32, 101, 120, 112, 101,  99, 116, 115,
   32,  97,  32, 116,  97,  98, 108, 101,  32,  97, 115,  32, 116, 104, 101,  32,
  115, 101,  99, 111, 110, 100,  32,  97, 114, 103, 117, 109, 101, 110, 116,  34,
   41,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  10,  32,  32,  32,
   32, 105, 102,  40,  99,  97, 115, 101, 115,  91, 118,  97, 108, 117, 101,  93,
   41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 116,
  121, 112, 101,  40,  99,  97, 115, 101, 115,  91, 118,  97, 108, 117, 101,  93,
   41,  32,  61,  61,  32,  34, 115, 116, 114, 105, 110, 103,  34,  41, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110,
  116,  40,  99,  97, 115, 101, 115,  91, 118,  97, 108, 117, 101,  93,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117,
  114, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  32, 101, 108, 115,
  101,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   99,  97, 115, 101, 115,  91, 118,  97, 108, 117, 101,  93,  40, 118,  97, 108,
  117, 101,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 105, 102,  40,  99,  97,
  115, 101, 115,  91,  34, 100, 101, 102,  97, 117, 108, 116,  34,  93,  41, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 116, 121, 112,
  101,  40,  99,  97, 115, 101, 115,  91,  34, 100, 101, 102,  97, 117, 108, 116,
   34,  93,  41,  32,  61,  61,  32,  34, 115, 116, 114, 105, 110, 103,  34,  41,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114,
  105, 110, 116,  40,  99,  97, 115, 101, 115,  91,  34, 100, 101, 102,  97, 117,
  108, 116,  34,  93,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 114, 101, 116, 117, 114, 110,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  32, 101, 108, 115, 101,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  99,  97, 115, 101, 115,  91,  34, 100, 101, 102,
   97, 117, 108, 116,  34,  93,  40, 118,  97, 108, 117, 101,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 125,
   10,  32,  32,  32,  32, 119,  97, 114, 110,  40,  34,  83, 119, 105, 116,  99,
  104,  32,  99,  97, 110, 110, 111, 116,  32, 102, 105, 110, 100,  32,  97,  32,
   99,  97, 115, 101,  32, 102, 111, 114,  32,  34,  32,  46,  46,  32, 116, 111,
  115, 116, 114, 105, 110, 103,  40, 118,  97, 108, 117, 101,  41,  32,  46,  46,
   32,  34,  32,  97, 110, 100,  32, 110, 111,  32, 100, 101, 102,  97, 117, 108,
  116,  32,  99,  97, 115, 101,  32, 119,  97, 115,  32, 112, 114, 111, 118, 105,
  100, 101, 100,  34,  41,  10, 125,  10,  10,  10,  47,  47,  32,  83,  69,  67,
   84,  73,  79,  78,  32,  49,  58,  32,  84,  89,  80,  69,  67,  72,  69,  67,
   75,  69,  82,  10,  10,  47,  42,  32,  84,  79,  68,  79,  58,  10,  32,  45,
   32,  65, 108, 108, 111, 119,  32,  99, 117, 115, 116, 111, 109,  32, 116, 121,
  112, 101, 115,  10,  32,  45,  32,  70, 117, 110,  99, 116, 105, 111, 110, 115,
   32,  99,  97, 110,  32, 104,  97, 118, 101,  32,  97, 114, 103, 117, 109, 101,
  110, 116, 115,  32, 116, 111,  32,  98, 101,  32, 116, 121, 112, 101,  99, 104,
  101,  99, 107, 101, 100,  10,  32,  45,  32,  71, 101, 110, 101, 114, 105,  99,
  115,  10,  32,  45,  32,  70, 105, 120,  32, 105, 115, 115, 117, 101,  32, 119,
  104, 101, 114, 101,  32, 116, 121, 112, 101,  32,  99,  97, 110,  32,  98, 101,
   32,  99, 104,  97, 110, 103, 101, 100,  32,  97, 102, 116, 101, 114,  32, 100,
  101, 102, 105, 110, 105, 116, 111, 110,  10,  42,  47,  10,  10,  47,  42,  32,
   83,  89,  83,  84,  69,  77,  58,  10,  32,  84, 104, 101,  32, 115, 121, 115,
  116, 101, 109,  32, 114, 101, 109, 111, 118, 101, 115,  32,  97, 108, 108,  32,
   99, 111, 109, 109, 101, 110, 116, 115,  32,  97, 110, 100,  32,  99, 108, 101,
   97, 114, 115,  32, 115, 116, 114, 105, 110, 103, 115,  32,  97, 110, 100,  32,
  115,  97, 118, 101, 115,  32, 105, 116,  32, 116, 111,  32,  97,  32, 116,  97,
   98, 108, 101,  32, 111, 102,  32,  34, 100, 101,  97, 100,  34,  32, 115, 116,
  114, 105, 110, 103, 115,  44,  32,  10,  32, 116, 104, 101, 110,  32, 105, 116,
   32, 108, 111, 111, 107, 115,  32, 102, 111, 114,  32, 100, 101, 102, 105, 110,
  105, 116, 105, 111, 110, 115,  32,  96, 118,  97, 114,  32, 120,  58,  32, 121,
   32,  61,  32, 122,  96,  32, 116, 111,  32, 115, 116, 111, 114, 101,  32, 105,
  110,  32,  97,  32,  99,  97,  99, 104, 101,  32,  97, 110, 100,  32,  97, 115,
  115, 105, 103, 110, 109, 101, 110, 116, 115,  32,  96, 120,  58,  32, 121,  32,
   61,  32, 122,  96,  32,  97, 110, 100,  32, 101, 118, 101, 110,  32,  10,  32,
  110, 111, 114, 109,  97, 108,  32,  97, 115, 115, 105, 103, 110, 109, 101, 110,
  116, 115,  32,  96,  97,  32,  61,  32, 122,  96,  32, 112,  97, 116, 116, 101,
  114, 110, 115,  44,  32,  97, 110, 100,  32, 116, 104, 101, 110,  32, 105, 116,
   32,  99, 104, 101,  99, 107, 115,  32, 116, 104, 101,  32, 116, 121, 112, 101,
  115,  32, 111, 102,  32, 116, 104, 101,  32, 118,  97, 108, 117, 101, 115,  32,
  119, 105, 116, 104,  32,  10,  32, 116, 104, 101,  32,  34, 100, 101,  97, 100,
   34,  32, 115, 116, 114, 105, 110, 103, 115,  32, 114, 101,  98, 111, 114, 110,
   46,  10,  10,  32,  73, 116,  32, 105, 115,  32, 115, 105, 109, 112, 108, 101,
   32,  97, 110, 100,  32, 115, 104, 111, 114, 116,  44,  32, 105, 116,  32, 105,
  115,  32, 105, 110,  32,  66,  69,  84,  65,  32,  98, 117, 116,  32, 105, 115,
  115, 117, 101, 115,  32, 119, 105, 108, 108,  32,  98, 101,  32, 114,  97, 114,
  101,  32, 105, 116,  32, 104,  97, 115,  32,  98, 101, 101, 110,  32, 116, 101,
  115, 116, 101, 100,  32, 111, 110,  32, 101, 118, 101, 110,  32, 116, 104, 105,
  115,  32,  10,  32, 102, 105, 108, 101,  32,  97, 110, 100,  32, 105, 116,  32,
  119, 111, 114, 107, 115,  32, 102, 105, 110, 101,  46,  10,  10,  32,  73, 102,
   32, 121, 111, 117,  32, 100, 111,  32, 110, 111, 116,  32, 117, 115, 101,  32,
  116, 104, 101,  32, 116, 121, 112, 101,  99, 104, 101,  99, 107, 101, 114,  32,
  116, 121, 112, 101,  32,  97, 110, 110, 111, 116,  97, 116, 105, 111, 110, 115,
   32,  97, 114, 101,  32, 115, 117, 112, 112, 111, 114, 116, 101, 100,  32,  98,
  121,  32, 116, 104, 101,  32, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101,
  114,  32,  98, 117, 116,  32, 119, 111, 110, 116,  10,  32, 104,  97, 118, 101,
   32,  97, 110, 121,  32, 118,  97, 108, 117, 101,  46,  32,  66, 117, 116,  32,
  116, 104, 101,  32, 115,  97, 109, 101,  32,  99,  97, 110, 110, 111, 116,  32,
   98, 101,  32, 115,  97, 105, 100,  32, 102, 111, 114,  32, 112, 114, 101, 112,
  114, 111,  99, 101, 115, 115, 111, 114,  32, 100, 105, 114, 101,  99, 116, 105,
  118, 101, 115,  44,  32, 116, 104, 101, 121,  32,  97, 114, 101,  32, 110, 111,
  116,  32, 115, 117, 112, 112, 111, 114, 116, 101, 100,  32,  10,  32, 105, 110,
   32, 116, 104, 101,  32, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 114,
   46,  10,  10,  32,  73, 102,  32, 116, 104, 101,  32, 116, 121, 112, 101,  99,
  104, 101,  99, 107, 101, 114,  32, 102,  97, 105, 108, 115,  32, 116, 111,  32,
   99, 104, 101,  99, 107,  32, 105, 116,  32, 119, 105, 108, 108,  32, 105, 103,
  110, 111, 114, 101,  46,  10,  42,  47,  10,  10,  47,  47,  32,  71,  76,  79,
   66,  65,  76,  83,  10, 100, 101,  97, 100,  32,  61,  32, 123, 125,  10,  10,
   47,  47,  32,  69,  82,  82,  79,  82,  10, 102, 117, 110,  99, 116, 105, 111,
  110,  32, 116, 121, 112, 101, 114, 114, 111, 114,  40, 101, 114, 114, 111, 114,
  105, 110,  44,  32, 108, 105, 110, 101,  44,  32, 110, 111, 116, 101,  41, 123,
   10,  32,  32, 112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,
   51,  49, 109,  84, 121, 112, 101,  99, 104, 101,  99, 107, 101, 114,  32, 101,
  114, 114, 111, 114,  58,  92,  50,  55,  91,  48, 109,  34,  41,  10,  32,  32,
  105, 102,  32,  40, 101, 114, 114, 111, 114, 105, 110,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,
   49,  59,  51,  49, 109,  34,  46,  46, 101, 114, 114, 111, 114, 105, 110,  46,
   46,  34,  92,  50,  55,  91,  48, 109,  92, 110,  92, 110,  34,  41,  10,  32,
   32, 125,  10,  32,  32, 112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,
   49,  59,  51,  49, 109,  83, 110, 105, 112, 112, 101, 116,  58,  92,  50,  55,
   91,  48, 109,  34,  41,  10,  32,  32, 112, 114, 105, 110, 116,  40, 114, 101,
  118, 105, 118, 101,  40, 108, 105, 110, 101,  41,  41,  10,  32,  32, 105, 102,
   32,  40, 110, 111, 116, 101,  41, 123,  10,  32,  32,  32,  32, 112, 114, 105,
  110, 116,  40,  34,  92, 110,  92,  50,  55,  91,  49,  59,  51,  49, 109,  84,
  121, 112, 101,  99, 104, 101,  99, 107, 101, 114,  32, 112, 114, 111, 118, 105,
  100, 101, 100,  32, 110, 111, 116, 101,  58,  92,  50,  55,  91,  48, 109,  34,
   41,  10,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,  34,  92, 110,  92,
   50,  55,  91,  49,  59,  51,  49, 109,  34,  46,  46, 110, 111, 116, 101,  46,
   46,  34,  92,  50,  55,  91,  48, 109,  34,  41,  10,  32,  32, 125,  10,  32,
   32, 112, 114, 105, 110, 116,  40,  34,  92, 110,  92,  50,  55,  91,  49,  59,
   51,  49, 109,  83, 116, 111, 112, 112, 105, 110, 103,  32,  84, 121, 112, 101,
   99, 104, 101,  99, 107, 101, 114,  46,  92,  50,  55,  91,  48, 109,  34,  41,
   10,  32,  32, 111, 115,  46, 101, 120, 105, 116,  40,  41,  10, 125,  10,  47,
   47,  32,  76,  79,  65,  68,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32,
  116,  97,  98, 108, 101, 116, 111, 115, 116, 114, 105, 110, 103,  40, 116,  98,
  108,  41, 123,  10,  32,  32,  47,  47,  32,  67, 111, 110, 118, 101, 114, 116,
  115,  32,  97,  32, 116,  97,  98, 108, 101,  32, 116, 111,  32,  97,  32, 115,
  116, 114, 105, 110, 103,  10,  32,  32, 118,  97, 114,  32, 114, 101, 115, 117,
  108, 116,  32,  61,  32,  34, 123,  34,  10,  32,  32, 102, 111, 114,  32,  40,
  105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 116,  98,
  108,  41,  41,  32, 123,  10,  32,  32,  32,  32, 105, 102,  32,  40,  33, 118,
   41, 123,  10,  32,  32,  32,  32,  32,  32, 118,  32,  61,  32,  34, 110, 117,
  108, 108,  34,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 118,  32,
   61,  32,  40, 108, 111,  97, 100, 115, 116, 114, 105, 110, 103,  40,  34, 114,
  101, 116, 117, 114, 110,  32,  34,  46,  46,  40, 118,  32, 124, 124,  32,  34,
  110, 117, 108, 108,  34,  41,  41,  32, 124, 124,  32, 108, 111,  97, 100, 101,
  110, 118,  40,  34, 114, 101, 116, 117, 114, 110,  32,  34,  46,  46,  40, 118,
   32, 124, 124,  32,  34, 110, 117, 108, 108,  34,  41,  41,  41,  10,  32,  32,
   32,  32, 120, 112,  99,  97, 108, 108,  40, 102, 117, 110,  99, 116, 105, 111,
  110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32, 118,  32,  61,  32, 118,
   40,  41,  10,  32,  32,  32,  32, 125,  44,  32,  10,  32,  32,  32,  32, 102,
  117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,
   32, 118,  32,  61,  32, 108, 111,  97, 100, 101, 110, 118,  40,  34, 114, 101,
  116, 117, 114, 110,  32,  34,  46,  46,  40, 118,  32, 124, 124,  32,  34, 110,
  117, 108, 108,  34,  41,  41,  10,  32,  32,  32,  32,  32,  32, 120, 112,  99,
   97, 108, 108,  40, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 118,  32,  61,  32, 118,  40,  41,  10,
   32,  32,  32,  32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32, 102,
  117, 110,  99, 116, 105, 111, 110,  40, 101, 114, 114,  41, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 116, 121, 112, 101, 114, 114, 111, 114,  40,  34,
   69, 114, 114, 111, 114,  32,  99, 104, 101,  99, 107, 105, 110, 103,  32, 118,
   97, 108, 117, 101,  58,  32,  34,  46,  46, 101, 114, 114,  41,  10,  32,  32,
   32,  32,  32,  32, 125,  41,  10,  32,  32,  32,  32, 125,  41,  10,  10,  32,
   32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40, 118,  41,  32,  61,
   61,  32,  34, 115, 116, 114, 105, 110, 103,  34,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32, 114, 101, 115,
  117, 108, 116,  46,  46, 105,  46,  46,  34,  32,  61,  32,  92,  34,  34,  46,
   46, 118,  46,  46,  34,  92,  34,  44,  34,  10,  32,  32,  32,  32, 125,  32,
  101, 108, 115, 101,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40, 118,  41,
   32,  61,  61,  32,  34, 116,  97,  98, 108, 101,  34,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32, 114, 101,
  115, 117, 108, 116,  46,  46, 105,  46,  46,  34,  32,  61,  32,  34,  46,  46,
  116,  97,  98, 108, 101, 116, 111, 115, 116, 114, 105, 110, 103,  40, 118,  41,
   46,  46,  34,  44,  32,  34,  10,  32,  32,  32,  32, 125,  32, 101, 108, 115,
  101,  32, 123,  10,  32,  32,  32,  32,  32,  32, 114, 101, 115, 117, 108, 116,
   32,  61,  32, 114, 101, 115, 117, 108, 116,  46,  46, 105,  46,  46,  34,  32,
   61,  32,  34,  46,  46,  40, 118,  32, 124, 124,  32,  34, 110, 117, 108, 108,
   34,  41,  46,  46,  34,  44,  34,  10,  32,  32,  32,  32, 125,  10,  32,  32,
  125,  10,  32,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32, 114, 101, 115,
  117, 108, 116,  46,  46,  34, 125,  34,  10,  32,  32, 114, 101, 116, 117, 114,
  110,  32, 114, 101, 115, 117, 108, 116,  10, 125,  10, 102, 117, 110,  99, 116,
  105, 111, 110,  32, 108, 111,  97, 100, 101, 110, 118,  40, 101, 110, 118,  44,
   32, 115, 116, 114,  41, 123,  10,  32,  32,  47,  47,  32,  85, 115, 101, 115,
   32, 108, 111,  97, 100, 115, 116, 114, 105, 110, 103,  44,  32,  98, 117, 116,
   32, 116, 104, 101,  32, 101, 110, 118, 105, 111, 117, 114, 109, 101, 110, 116,
   32,  99,  97, 110,  32,  98, 101,  32, 112, 114, 111, 118, 105, 100, 101, 100,
   46,  32, 101, 110, 118,  32, 105, 115,  32,  97,  32, 116,  97,  98, 108, 101,
   46,  10,  32,  32, 101, 110, 118, 115, 116, 114,  32,  61,  32, 116,  97,  98,
  108, 101, 116, 111, 115, 116, 114, 105, 110, 103,  40, 101, 110, 118,  41,  10,
   32,  32, 115, 116, 114,  32,  61,  32,  91,  91,  10,  32,  32,  32,  32, 101,
  110, 118,  32,  61,  32,  93,  93,  46,  46, 101, 110, 118, 115, 116, 114,  46,
   46,  91,  91,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105,  44,  32,
  118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 101, 110, 118,  41,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  95,  71,  91, 105,  93,  32,  61,
   32, 118,  10,  32,  32,  32,  32, 125,  10,  10,  32,  32,  93,  93,  46,  46,
  115, 116, 114,  10,  10,  32,  32, 114, 101, 116, 117, 114, 110,  32, 108, 111,
   97, 100, 115, 116, 114, 105, 110, 103,  40, 114, 101, 118, 105, 118, 101,  40,
  115, 116, 114,  41,  41,  59,  10, 125,  10,  10,  47,  47,  32,  84,  89,  80,
   69,  83,  10, 116, 121, 112, 101, 115,  32,  61,  32, 123,  10,  32,  32,  34,
  115, 116, 114, 105, 110, 103,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,
   67, 104, 101,  99, 107,  32, 105, 102,  32, 105, 116, 101, 109,  32, 105, 115,
   32,  97,  32, 115, 116, 114, 105, 110, 103,  10,  32,  32,  32,  32, 114, 101,
  116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,
   61,  61,  32,  34, 115, 116, 114, 105, 110, 103,  34,  10,  32,  32, 125,  44,
   10,  32,  32,  34, 112, 111, 115,  34,  58,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32, 114, 101,
  116, 117, 114, 110,  32, 109,  97, 116, 104,  46,  97,  98, 115,  40, 105, 116,
  101, 109,  41,  32,  61,  61,  32, 105, 116, 101, 109,  10,  32,  32, 125,  44,
   10,  32,  32,  34, 110, 101, 103,  34,  58,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32, 114, 101,
  116, 117, 114, 110,  32, 109,  97, 116, 104,  46,  97,  98, 115,  40, 105, 116,
  101, 109,  41,  32,  33,  61,  32, 105, 116, 101, 109,  10,  32,  32, 125,  44,
   10,  32,  32,  34, 112, 111, 115, 105, 110, 116,  34,  58,  32, 102, 117, 110,
   99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,
   32, 114, 101, 116, 117, 114, 110,  32, 109,  97, 116, 104,  46,  97,  98, 115,
   40, 105, 116, 101, 109,  41,  32,  61,  61,  32, 105, 116, 101, 109,  32,  38,
   38,  32, 109,  97, 116, 104,  46, 102, 108, 111, 111, 114,  40, 105, 116, 101,
  109,  41,  32,  61,  61,  32, 105, 116, 101, 109,  10,  32,  32, 125,  44,  10,
   32,  32,  34, 110, 101, 103, 105, 110, 116,  34,  58,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  32, 109,  97, 116, 104,  46,  97,  98, 115,  40,
  105, 116, 101, 109,  41,  32,  33,  61,  32, 105, 116, 101, 109,  32,  38,  38,
   32, 109,  97, 116, 104,  46, 102, 108, 111, 111, 114,  40, 105, 116, 101, 109,
   41,  32,  61,  61,  32, 105, 116, 101, 109,  10,  32,  32, 125,  44,  10,  32,
   32,  34, 112, 111, 105, 110, 116, 101, 114,  34,  58,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,
   47,  47,  32,  67, 104, 101,  99, 107,  32, 105, 102,  32, 116, 104, 101,  32,
  105, 116, 101, 109,  32, 105, 115,  32,  97,  32, 115, 116, 114, 105, 110, 103,
   32, 119, 104, 105,  99, 104,  32, 105, 115,  32, 112,  97, 114, 115, 101, 100,
   32, 108, 105, 107, 101,  32,  97,  32, 112, 111, 105, 110, 116, 101, 114,  10,
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40,
  105, 116, 101, 109,  41,  32,  61,  61,  32,  34, 115, 116, 114, 105, 110, 103,
   34,  32,  38,  38,  32,  40, 115, 116, 114, 105, 110, 103,  46, 115, 117,  98,
   40, 105, 116, 101, 109,  44,  32,  49,  44,  32,  49,  41,  32,  61,  61,  32,
   34,  38,  34,  32, 124, 124,  32, 115, 116, 114, 105, 110, 103,  46, 115, 117,
   98,  40, 105, 116, 101, 109,  44,  32,  49,  44,  32,  50,  41,  32,  61,  61,
   32,  34,  48, 120,  34,  41,  10,  32,  32, 125,  44,  10,  32,  32,  34,  97,
  114, 114,  97, 121,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,
  105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  77,  97,
  107, 101,  32, 115, 117, 114, 101,  32, 116, 104,  97, 116,  32,  97, 108, 108,
   32, 116, 104, 101,  32, 105, 110, 100, 101, 120, 101, 115,  32,  97, 114, 101,
   32, 105, 110, 116, 101, 103, 101, 114, 115,  10,  32,  32,  32,  32, 102, 111,
  114,  32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,
   40, 105, 116, 101, 109,  41,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
  105, 102,  32,  40, 116, 121, 112, 101,  40, 105,  41,  32,  33,  61,  32,  34,
  110, 117, 109,  98, 101, 114,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  10,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  32,  32,
  125,  44,  10,  32,  32,  34, 109,  97, 116, 114, 105, 120,  34,  58,  32, 102,
  117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,
   32,  32,  32,  47,  47,  32,  67, 104, 101,  99, 107,  32, 105, 102,  32,  97,
  108, 108,  32, 116, 104, 101,  32, 118,  97, 108, 117, 101, 115,  32,  97, 114,
  101,  32,  97,  32, 116,  97,  98, 108, 101,  10,  32,  32,  32,  32, 102, 111,
  114,  32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,
   40, 105, 116, 101, 109,  41,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
  105, 102,  32,  40, 116, 121, 112, 101,  40, 118,  41,  32,  33,  61,  32,  34,
  116,  97,  98, 108, 101,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  10,  32,
   32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  32,  32, 125,
   44,  10,  32,  32,  34,  86, 101,  99, 116, 111, 114,  51,  34,  58,  32, 102,
  117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,
   32,  32,  32,  47,  47,  32,  85, 115, 101, 115,  32, 116, 104, 101,  32,  96,
   86, 101,  99, 116, 111, 114,  51,  96,  32,  99, 108,  97, 115, 115,  32,  97,
  110, 100,  32,  99, 104, 101,  99, 107,  32, 105, 102,  32, 116, 111, 115, 116,
  114, 105, 110, 103,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34, 118,
  101,  99,  51,  58,  32,  60, 112, 111, 105, 110, 116, 101, 114,  62,  34,  10,
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40,
  105, 116, 101, 109,  41,  32,  61,  61,  32,  34, 117, 115, 101, 114, 100,  97,
  116,  97,  34,  32,  38,  38,  32, 115, 116, 114, 105, 110, 103,  46, 109,  97,
  116,  99, 104,  40, 116, 111, 115, 116, 114, 105, 110, 103,  40, 105, 116, 101,
  109,  41,  44,  32,  34,  94, 118, 101,  99,  51,  58,  32,  34,  41,  10,  32,
   32, 125,  44,  10,  32,  32,  34,  86, 101,  99, 116, 111, 114,  50,  34,  58,
   32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,
   10,  32,  32,  32,  32,  47,  47,  32,  85, 115, 101, 115,  32, 116, 104, 101,
   32,  96,  86, 101,  99, 116, 111, 114,  50,  96,  32,  99, 108,  97, 115, 115,
   32,  97, 110, 100,  32,  99, 104, 101,  99, 107,  32, 105, 102,  32, 116, 111,
  115, 116, 114, 105, 110, 103,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,
   34, 118, 101,  99,  50,  58,  32,  60, 112, 111, 105, 110, 116, 101, 114,  62,
   34,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 121, 112,
  101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34, 117, 115, 101, 114,
  100,  97, 116,  97,  34,  32,  38,  38,  32, 115, 116, 114, 105, 110, 103,  46,
  109,  97, 116,  99, 104,  40, 116, 111, 115, 116, 114, 105, 110, 103,  40, 105,
  116, 101, 109,  41,  44,  32,  34,  94, 118, 101,  99,  50,  58,  32,  34,  41,
   10,  32,  32, 125,  44,  10,  32,  32,  34,  67, 111, 108, 111, 114,  34,  58,
   32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,
   10,  32,  32,  32,  32,  47,  47,  32,  85, 115, 101, 115,  32, 116, 104, 101,
   32,  96,  67, 111, 108, 111, 114,  96,  32,  99, 108,  97, 115, 115,  32,  97,
  110, 100,  32,  99, 104, 101,  99, 107,  32, 105, 102,  32, 116, 111, 115, 116,
  114, 105, 110, 103,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34,  99,
  111, 108, 111, 114,  58,  32,  60, 112, 111, 105, 110, 116, 101, 114,  62,  34,
   10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,
   40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34, 117, 115, 101, 114, 100,
   97, 116,  97,  34,  32,  38,  38,  32, 115, 116, 114, 105, 110, 103,  46, 109,
   97, 116,  99, 104,  40, 116, 111, 115, 116, 114, 105, 110, 103,  40, 105, 116,
  101, 109,  41,  44,  32,  34,  94,  99, 111, 108, 111, 114,  58,  32,  34,  41,
   10,  32,  32, 125,  44,  10,  32,  32,  34,  84, 114,  97, 110, 115, 102, 111,
  114, 109,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116,
  101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  85, 115, 101, 115,
   32, 116, 104, 101,  32,  96,  84, 114,  97, 110, 115, 102, 111, 114, 109,  96,
   32,  99, 108,  97, 115, 115,  32,  97, 110, 100,  32,  99, 104, 101,  99, 107,
   32, 105, 102,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 105, 116, 101,
  109,  41,  32,  61,  61,  32,  34, 116, 114,  97, 110, 115, 102, 111, 114, 109,
   58,  32,  60, 112, 111, 105, 110, 116, 101, 114,  62,  34,  10,  32,  32,  32,
   32, 114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101,
  109,  41,  32,  61,  61,  32,  34, 117, 115, 101, 114, 100,  97, 116,  97,  34,
   32,  38,  38,  32, 115, 116, 114, 105, 110, 103,  46, 109,  97, 116,  99, 104,
   40, 116, 111, 115, 116, 114, 105, 110, 103,  40, 105, 116, 101, 109,  41,  44,
   32,  34,  94, 116, 114,  97, 110, 115, 102, 111, 114, 109,  58,  32,  34,  41,
   10,  32,  32, 125,  44,  10,  32,  32,  34, 110, 117, 109,  98, 101, 114,  34,
   58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41,
  123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99, 107,  32, 105,
  102,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97,  32, 110, 117, 109,  98,
  101, 114,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 121,
  112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34, 110, 117, 109,
   98, 101, 114,  34,  10,  32,  32, 125,  44,  10,  32,  32,  34,  98, 111, 111,
  108, 101,  97, 110,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,
  105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104,
  101,  99, 107,  32, 105, 102,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97,
   32,  98, 111, 111, 108, 101,  97, 110,  10,  32,  32,  32,  32, 114, 101, 116,
  117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,
   61,  32,  34,  98, 111, 111, 108, 101,  97, 110,  34,  10,  32,  32, 125,  44,
   10,  32,  32,  34, 116,  97,  98, 108, 101,  34,  58,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,
   47,  47,  32,  67, 104, 101,  99, 107,  32, 105, 102,  32, 105, 116, 101, 109,
   32, 105, 115,  32,  97,  32, 116,  97,  98, 108, 101,  10,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,
   41,  32,  61,  61,  32,  34, 116,  97,  98, 108, 101,  34,  10,  32,  32, 125,
   44,  10,  32,  32,  34, 102, 117, 110,  99, 116, 105, 111, 110,  34,  58,  32,
  102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,
   32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99, 107,  32, 105, 102,  32,
  105, 116, 101, 109,  32, 105, 115,  32,  97,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 121,
  112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34, 102, 117, 110,
   99, 116, 105, 111, 110,  34,  10,  32,  32, 125,  44,  10,  32,  32,  34, 117,
  115, 101, 114, 100,  97, 116,  97,  34,  58,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,
   32,  67, 104, 101,  99, 107,  32, 105, 102,  32, 105, 116, 101, 109,  32, 105,
  115,  32,  97,  32, 117, 115, 101, 114, 100,  97, 116,  97,  10,  32,  32,  32,
   32, 114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101,
  109,  41,  32,  61,  61,  32,  34, 117, 115, 101, 114, 100,  97, 116,  97,  34,
   10,  32,  32, 125,  44,  10,  32,  32,  34, 116, 104, 114, 101,  97, 100,  34,
   58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41,
  123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99, 107,  32, 105,
  102,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97,  32, 116, 104, 114, 101,
   97, 100,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 121,
  112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34, 116, 104, 114,
  101,  97, 100,  34,  10,  32,  32, 125,  44,  10,  32,  32,  34, 110, 117, 108,
  108,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101,
  109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99, 107,
   32, 105, 102,  32, 105, 116, 101, 109,  32, 105, 115,  32, 110, 117, 108, 108,
   10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,
   40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34, 110, 117, 108, 108,  34,
   10,  32,  32, 125,  44,  10,  32,  32,  34,  99, 104,  97, 114,  34,  58,  32,
  102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,
   32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99, 107,  32, 105, 102,  32,
  116, 104, 101,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97,  32, 115, 116,
  114, 105, 110, 103,  32,  97, 110, 100,  32,  49,  32,  99, 104,  97, 114,  97,
   99, 116, 101, 114,  32, 108, 111, 110, 103,  10,  32,  32,  32,  32, 114, 101,
  116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,
   61,  61,  32,  34, 115, 116, 114, 105, 110, 103,  34,  32,  38,  38,  32,  35,
  105, 116, 101, 109,  32,  61,  61,  32,  49,  59,  10,  32,  32, 125,  44,  10,
   32,  32,  34, 109, 115, 103,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,
   67, 104, 101,  99, 107,  32, 105, 102,  32, 116, 111, 115, 116, 114, 105, 110,
  103,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34, 109, 101, 115, 115,
   97, 103, 101,  58,  32,  60, 112, 111, 105, 110, 116, 101, 114,  62,  34,  10,
   32,  32,  32,  32,  47,  47,  32, 109, 101, 115, 115,  97, 103, 101, 115,  32,
   97, 114, 101,  32, 117, 115, 101, 100,  32, 105, 110,  32, 116, 104, 101,  32,
   77, 101, 115, 115,  97, 103, 101,  32, 108, 105,  98, 114,  97, 114, 121,  32,
  102, 111, 114,  32,  99, 111, 109, 109, 117, 110, 105,  99,  97, 116, 105, 111,
  110,  32,  98, 101, 116, 119, 101, 101, 110,  32, 116, 104, 114, 101,  97, 100,
  115,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 111, 115,
  116, 114, 105, 110, 103,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32, 115,
  116, 114, 105, 110, 103,  46, 109,  97, 116,  99, 104,  40,  34,  94, 109, 101,
  115, 115,  97, 103, 101,  58,  32,  34,  41,  10,  32,  32, 125,  44,  10,  32,
   32,  34,  99, 111, 109, 112, 108, 101, 120,  34,  58,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,
   47,  47,  32,  84, 114, 121,  32, 116, 111,  32, 103, 101, 116,  32, 105, 116,
  101, 109,  46,  95,  95, 110,  97, 109, 101,  44,  32, 105, 102,  32, 105, 116,
   32, 105, 115,  32,  34,  99, 111, 109, 112, 108, 101, 120,  32, 110, 117, 109,
   98, 101, 114,  34,  32, 116, 104, 101, 110,  32, 105, 116,  32, 105, 115,  32,
   97,  32,  99, 111, 109, 112, 108, 101, 120,  32, 110, 117, 109,  98, 101, 114,
   10,  32,  32,  32,  32, 115,  44,  32, 101,  32,  61,  32, 112,  99,  97, 108,
  108,  40, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  32, 105, 102,
   32,  40,  33, 105, 116, 101, 109,  46,  95,  95, 110,  97, 109, 101,  41, 123,
  101, 114, 114, 111, 114,  40,  34,  70, 111, 114,  99, 101,  32, 101, 114, 114,
  111, 114,  34,  41, 125,  32, 125,  41,  10,  32,  32,  32,  32, 114, 101, 116,
  117, 114, 110,  32, 115,  10,  32,  32, 125,  44,  10,  32,  32,  34, 100, 105,
  114, 101,  99, 116, 111, 114, 121,  34,  58,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,
   32,  70, 111, 114,  32,  96, 102, 105, 108, 101,  96,  32, 100, 105, 114, 101,
   99, 116, 111, 114, 121,  32, 116, 121, 112, 101,  10,  32,  32,  32,  32,  47,
   47,  32, 114, 101, 116, 117, 114, 110,  32, 116, 111, 115, 116, 114, 105, 110,
  103,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34, 100, 105, 114, 101,
   99, 116, 111, 114, 121,  58,  32,  60, 112, 111, 105, 110, 116, 101, 114,  62,
   34,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 111, 115,
  116, 114, 105, 110, 103,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32, 115,
  116, 114, 105, 110, 103,  46, 109,  97, 116,  99, 104,  40,  34,  94, 100, 105,
  114, 101,  99, 116, 111, 114, 121,  58,  32,  34,  41,  10,  32,  32, 125,  44,
   10,  32,  32,  34, 108, 111,  99, 107,  34,  58,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,
   47,  32,  70, 111, 114,  32,  96, 102, 105, 108, 101,  96,  32, 108, 111,  99,
  107,  32, 116, 121, 112, 101,  10,  32,  32,  32,  32,  47,  47,  32, 114, 101,
  116, 117, 114, 110,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 105, 116,
  101, 109,  41,  32,  61,  61,  32,  34, 108, 111,  99, 107,  58,  32,  60, 112,
  111, 105, 110, 116, 101, 114,  62,  34,  10,  32,  32,  32,  32, 114, 101, 116,
  117, 114, 110,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 105, 116, 101,
  109,  41,  32,  61,  61,  32, 115, 116, 114, 105, 110, 103,  46, 109,  97, 116,
   99, 104,  40,  34,  94, 108, 111,  99, 107,  58,  32,  34,  41,  10,  32,  32,
  125,  44,  10,  32,  32,  34, 112, 114, 111, 116, 101,  99, 116, 101, 100,  34,
   58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41,
  123,  10,  32,  32,  32,  32,  47,  47,  32, 114, 101, 116, 117, 114, 110,  32,
  103, 101, 116, 109, 101, 116,  97, 116,  97,  98, 108, 101,  40, 105, 116, 101,
  109,  41,  46,  95,  95, 109, 101, 116,  97, 116,  97,  98, 108, 101,  32,  33,
   61,  32, 110, 105, 108,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32, 103, 101, 116, 109, 101, 116,  97, 116,  97,  98, 108, 101,  40, 105, 116,
  101, 109,  41,  46,  95,  95, 109, 101, 116,  97, 116,  97,  98, 108, 101,  32,
   33,  61,  32, 110, 117, 108, 108,  10,  32,  32, 125,  44,  10,  32,  32,  34,
   95,  76,  85,  65,  66,  79,  88,  34,  58,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,
   32,  67, 104, 101,  99, 107,  32, 105, 102,  32, 116, 111, 115, 116, 114, 105,
  110, 103,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34,  76,  85,  65,
   66,  79,  88,  58,  32,  60, 112, 111, 105, 110, 116, 101, 114,  62,  34,  10,
   32,  32,  32,  32,  47,  47,  32, 116, 104, 105, 115,  32, 115, 104, 111, 117,
  108, 100, 110, 116,  32,  98, 101,  32, 117, 115, 101, 100,  32, 102, 111, 114,
   32,  97, 118, 101, 114,  97, 103, 101,  32,  99, 111, 100, 101,  44,  32,  76,
   85,  65,  66,  79,  88,  32, 105, 115,  32, 105, 110, 116, 101, 114, 110,  97,
  108,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 111, 115,
  116, 114, 105, 110, 103,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32, 115,
  116, 114, 105, 110, 103,  46, 109,  97, 116,  99, 104,  40,  34,  94,  76,  85,
   65,  66,  79,  88,  58,  32,  34,  41,  10,  32,  32, 125,  44,  10,  32,  32,
   34,  97, 110, 121,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,
  105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104,
  101,  99, 107,  32, 105, 102,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97,
  110, 121,  32, 116, 121, 112, 101,  10,  32,  32,  32,  32, 114, 101, 116, 117,
  114, 110,  32, 116, 114, 117, 101,  10,  32,  32, 125,  44,  10,  32,  32,  34,
  116, 104, 114, 101,  97, 100,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,
   67, 104, 101,  99, 107,  32, 105, 102,  32, 105, 116, 101, 109,  32, 105, 115,
   32,  97,  32, 116, 104, 114, 101,  97, 100,  10,  32,  32,  32,  32, 114, 101,
  116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,
   61,  61,  32,  34, 116, 104, 114, 101,  97, 100,  34,  10,  32,  32, 125,  44,
   10,  32,  32,  34, 105, 110, 116,  34,  58,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,
   32,  67, 104, 101,  99, 107,  32, 105, 102,  32, 105, 116, 101, 109,  32, 105,
  115,  32,  97, 110,  32, 105, 110, 116, 101, 103, 101, 114,  10,  32,  32,  32,
   32, 114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101,
  109,  41,  32,  61,  61,  32,  34, 110, 117, 109,  98, 101, 114,  34,  32,  38,
   38,  32, 109,  97, 116, 104,  46, 102, 108, 111, 111, 114,  40, 105, 116, 101,
  109,  41,  32,  61,  61,  32, 105, 116, 101, 109,  10,  32,  32, 125,  44,  10,
   32,  32,  34, 102, 108, 111,  97, 116,  34,  58,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,
   47,  32,  67, 104, 101,  99, 107,  32, 105, 102,  32, 105, 116, 101, 109,  32,
  105, 115,  32,  97,  32, 102, 108, 111,  97, 116,  10,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,
   32,  61,  61,  32,  34, 110, 117, 109,  98, 101, 114,  34,  32,  38,  38,  32,
  109,  97, 116, 104,  46, 102, 108, 111, 111, 114,  40, 105, 116, 101, 109,  41,
   32,  33,  61,  32, 105, 116, 101, 109,  10,  32,  32, 125,  44,  10,  32,  32,
   34, 100, 111, 117,  98, 108, 101,  34,  58,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,
   32,  67, 104, 101,  99, 107,  32, 105, 102,  32, 105, 116, 101, 109,  32, 105,
  115,  32,  97,  32, 100, 111, 117,  98, 108, 101,  10,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,
   32,  61,  61,  32,  34, 110, 117, 109,  98, 101, 114,  34,  32,  38,  38,  32,
  109,  97, 116, 104,  46, 102, 108, 111, 111, 114,  40, 105, 116, 101, 109,  41,
   32,  33,  61,  32, 105, 116, 101, 109,  10,  32,  32, 125,  44,  10, 125,  59,
   10,  97, 108, 108, 116, 121, 112, 101, 115,  32,  61,  32,  91,  93,  10,  10,
  102, 111, 114,  32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105,
  114, 115,  40, 116, 121, 112, 101, 115,  41,  41,  32, 123,  10,  32,  32, 116,
   97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40,  97, 108, 108, 116,
  121, 112, 101, 115,  44,  32, 105,  41,  10, 125,  10,  10,  47,  47,  32,  80,
   65,  82,  83,  69,  82,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 100,
  101, 102, 102, 105, 110, 100,  40, 115, 116, 114,  41,  32, 123,  10,  32,  32,
   32,  32,  47,  47,  32,  84,  97, 107, 101, 115,  32, 105, 110,  32,  99, 111,
  100, 101,  32,  97, 110, 100,  32, 108, 111, 111, 107, 115,  32, 102, 111, 114,
   32, 100, 101, 102, 105, 110, 105, 116, 105, 111, 110, 115,  32, 119, 105, 116,
  104,  32,  97, 110, 110, 111, 116,  97, 116, 105, 111, 110, 115,  10,  32,  32,
   32,  32, 118,  97, 114,  32, 112,  97, 116, 116, 101, 114, 110,  32,  61,  32,
   34,  94,  37, 115,  42, 118,  97, 114,  37, 115,  43,  40,  91,  94,  37, 115,
   93,  43,  41,  37, 115,  42,  58,  37, 115,  42,  40,  91,  94,  37, 115,  93,
   43,  41,  37, 115,  42,  61,  37, 115,  42,  40,  91,  94,  37, 115,  93,  43,
   41,  37, 115,  42,  36,  34,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  112,  97, 116, 116, 101, 114, 110,  32,  61,  32,  34,  94,  37, 115,  42, 118,
   97, 114,  37, 115,  43,  40,  91,  94,  37, 115,  93,  43,  41,  37, 115,  42,
   58,  37, 115,  42,  40,  91,  94,  37, 115,  93,  43,  41,  37, 115,  42,  61,
   37, 115,  42,  40,  46,  45,  41,  37, 115,  42,  36,  34,  59,  10,  32,  32,
   32,  32, 118,  97, 114,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32, 123,
  125,  59,  10,  32,  32,  32,  32, 102, 111, 114,  40,  32, 108, 105, 110, 101,
   32, 105, 110,  32, 115, 116, 114,  45,  62, 103, 109,  97, 116,  99, 104,  40,
   34,  91,  94,  92, 114,  92, 110,  93,  43,  34,  41,  32,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 118,  97, 114, 116,  44,  32,
  107, 101, 121,  44,  32, 118,  97, 108, 117, 101,  32,  61,  32, 108, 105, 110,
  101,  45,  62, 109,  97, 116,  99, 104,  40, 112,  97, 116, 116, 101, 114, 110,
   41,  59,  10,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 118,  97, 114,
  116,  32,  38,  38,  32, 107, 101, 121,  32,  38,  38,  32, 118,  97, 108, 117,
  101,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 116,  97,
   98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40, 114, 101, 115, 117, 108,
  116,  44,  32, 123, 118,  97, 114, 116,  44,  32, 107, 101, 121,  44,  32, 118,
   97, 108, 117, 101,  44,  32, 108, 105, 110, 101, 125,  41,  59,  10,  32,  32,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  32, 114, 101, 115, 117, 108, 116,  59,  10, 125,
   10, 102, 117, 110,  99, 116, 105, 111, 110,  32,  97, 115, 115, 105, 103, 110,
   40, 115, 116, 114,  41,  32, 123,  10,  32,  32,  32,  32,  47,  47,  32,  84,
   97, 107, 101, 115,  32, 105, 110,  32,  99, 111, 100, 101,  32, 108, 111, 111,
  107, 115,  32, 102, 111, 114,  32,  97, 115, 115, 105, 103, 110, 109, 101, 110,
  116, 115,  32, 119, 105, 116, 104,  32,  97, 110, 110, 111, 116,  97, 116, 105,
  111, 110, 115,  10,  32,  32,  32,  32, 118,  97, 114,  32, 112,  97, 116, 116,
  101, 114, 110,  32,  61,  32,  34,  37, 115,  42,  40,  91,  94,  37, 115,  93,
   43,  41,  37, 115,  42,  58,  37, 115,  42,  40,  91,  94,  37, 115,  93,  43,
   41,  37, 115,  42,  61,  37, 115,  42,  40,  91,  94,  37, 115,  93,  43,  41,
   37, 115,  42,  34,  59,  10,  32,  32,  32,  32, 118,  97, 114,  32, 114, 101,
  115, 117, 108, 116,  32,  61,  32, 123, 125,  59,  10,  32,  32,  32,  32, 102,
  111, 114,  40,  32, 108, 105, 110, 101,  32, 105, 110,  32, 115, 116, 114,  45,
   62, 103, 109,  97, 116,  99, 104,  40,  34,  91,  94,  92, 114,  92, 110,  93,
   43,  34,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32, 118,  97, 114, 116,  44,  32, 107, 101, 121,  44,  32, 118,  97, 108,
  117, 101,  32,  61,  32, 108, 105, 110, 101,  45,  62, 109,  97, 116,  99, 104,
   40, 112,  97, 116, 116, 101, 114, 110,  41,  59,  10,  32,  32,  32,  32,  32,
   32, 105, 102,  40,  32, 118,  97, 114, 116,  32,  38,  38,  32, 107, 101, 121,
   32,  38,  38,  32, 118,  97, 108, 117, 101,  32,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  47,  47,  32,  86, 101, 114, 105, 102, 121,  32,
  118,  97, 114,  44,  32, 107, 101, 121,  44,  32, 118,  97, 108, 117, 101,  32,
   97, 114, 101,  32, 110, 111, 116,  32, 101, 108, 105, 103, 105,  98, 108, 101,
   32, 102, 111, 114,  32, 100, 101, 102,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  40,  32,  33,  32, 100, 101, 102, 102, 105, 110, 100,  40, 108,
  105, 110, 101,  41,  91,  49,  93,  32,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105, 110,
  115, 101, 114, 116,  40, 114, 101, 115, 117, 108, 116,  44,  32, 123, 118,  97,
  114, 116,  44,  32, 107, 101, 121,  44,  32, 118,  97, 108, 117, 101,  44,  32,
  108, 105, 110, 101, 125,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 114, 101, 115, 117, 108,
  116,  59,  10, 125,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 102, 105,
  110, 100, 102, 117, 110,  99, 116, 105, 111, 110, 115,  40, 115, 116, 114,  41,
  123,  10,  32,  32,  47,  47,  32,  76, 111, 111, 107, 115,  32, 102, 111, 114,
   32,  96, 102, 117, 110,  99, 116, 105, 111, 110,  32, 120,  40,  60,  63,  62,
   41,  96,  32,  97, 110, 100,  32, 114, 101, 116, 117, 114, 110, 115,  32,  97,
   32, 116,  97,  98, 108, 101,  32, 111, 102,  32,  97, 108, 108,  32, 116, 104,
  101,  32, 102, 117, 110,  99, 116, 105, 111, 110, 115,  32,  97, 110, 100,  32,
  115, 111, 117, 114,  99, 101,  32,  99, 111, 100, 101,  10,  32,  32, 118,  97,
  114,  32, 112,  97, 116, 116, 101, 114, 110,  32,  61,  32,  34,  94,  37, 115,
   42, 102, 117, 110,  99, 116, 105, 111, 110,  37, 115,  43,  40,  91,  94,  37,
  115,  93,  43,  41,  37, 115,  42,  37,  40,  40,  91,  94,  37, 115,  93,  42,
   41,  37,  41,  37, 115,  42,  36,  34,  59,  10,  32,  32, 118,  97, 114,  32,
  114, 101, 115, 117, 108, 116,  32,  61,  32, 123, 125,  59,  10,  32,  32, 102,
  111, 114,  40,  32, 108, 105, 110, 101,  32, 105, 110,  32, 115, 116, 114,  45,
   62, 103, 109,  97, 116,  99, 104,  40,  34,  91,  94,  92, 114,  92, 110,  93,
   43,  34,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32, 118,  97, 114,  32,
  107, 101, 121,  44,  32, 118,  97, 108, 117, 101,  32,  61,  32, 108, 105, 110,
  101,  45,  62, 109,  97, 116,  99, 104,  40, 112,  97, 116, 116, 101, 114, 110,
   41,  59,  10,  32,  32,  32,  32, 105, 102,  40,  32, 107, 101, 121,  32,  38,
   38,  32, 118,  97, 108, 117, 101,  32,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40, 114,
  101, 115, 117, 108, 116,  44,  32, 123, 107, 101, 121,  44,  32, 118,  97, 108,
  117, 101,  44,  32, 108, 105, 110, 101, 125,  41,  59,  10,  32,  32,  32,  32,
  125,  10,  32,  32, 125,  10,  32,  32, 114, 101, 116, 117, 114, 110,  32, 114,
  101, 115, 117, 108, 116,  59,  10, 125,  10, 102, 117, 110,  99, 116, 105, 111,
  110,  32,  97, 108, 108,  97, 115, 115, 105, 103, 110,  40, 115, 116, 114,  41,
  123,  10,  32,  32,  47,  47,  32,  85, 115, 101, 100,  32, 116, 111,  32, 108,
  111, 111, 107,  32, 102, 111, 114,  32, 116, 121, 112, 101, 108, 101, 115, 115,
   32,  97, 115, 115, 105, 103, 110, 109, 101, 110, 116, 115,  10,  32,  32, 118,
   97, 114,  32, 112,  97, 116, 116, 101, 114, 110,  32,  61,  32,  34,  37, 115,
   42,  40,  91,  94,  37, 115,  93,  43,  41,  37, 115,  42,  61,  37, 115,  42,
   40,  91,  94,  37, 115,  93,  43,  41,  37, 115,  42,  34,  59,  10,  32,  32,
  118,  97, 114,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32, 123, 125,  59,
   10,  32,  32, 102, 111, 114,  40,  32, 108, 105, 110, 101,  32, 105, 110,  32,
  115, 116, 114,  45,  62, 103, 109,  97, 116,  99, 104,  40,  34,  91,  94,  92,
  114,  92, 110,  93,  43,  34,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32,
  118,  97, 114,  32, 107, 101, 121,  44,  32, 118,  97, 108, 117, 101,  32,  61,
   32, 108, 105, 110, 101,  45,  62, 109,  97, 116,  99, 104,  40, 112,  97, 116,
  116, 101, 114, 110,  41,  59,  10,  32,  32,  32,  32, 105, 102,  40,  32, 107,
  101, 121,  32,  38,  38,  32, 118,  97, 108, 117, 101,  32,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33,  32, 100, 101, 102, 102,
  105, 110, 100,  40, 108, 105, 110, 101,  41,  91,  49,  93,  32,  38,  38,  32,
   33,  32,  97, 115, 115, 105, 103, 110,  40, 108, 105, 110, 101,  41,  91,  49,
   93,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98,
  108, 101,  46, 105, 110, 115, 101, 114, 116,  40, 114, 101, 115, 117, 108, 116,
   44,  32, 123, 107, 101, 121,  44,  32, 118,  97, 108, 117, 101,  44,  32, 108,
  105, 110, 101, 125,  41,  59,  10,  32,  32,  32,  32,  32,  32, 125,  10,  32,
   32,  32,  32, 125,  10,  32,  32, 125,  10,  32,  32, 114, 101, 116, 117, 114,
  110,  32, 114, 101, 115, 117, 108, 116,  59,  10, 125,  10, 102, 117, 110,  99,
  116, 105, 111, 110,  32, 102, 105, 110, 100,  97, 108, 108,  40, 115, 116, 114,
   41, 123,  10,  32,  32,  47,  47,  32,  85, 115, 101, 100,  32, 116, 111,  32,
  108, 111, 111, 107,  32, 102, 111, 114,  32,  37, 115,  61,  37, 115,  10,  32,
   32, 118,  97, 114,  32, 112,  97, 116, 116, 101, 114, 110,  32,  61,  32,  34,
   37, 115,  42,  61,  37, 115,  42,  34,  59,  10,  32,  32, 118,  97, 114,  32,
  114, 101, 115, 117, 108, 116,  32,  61,  32, 123, 125,  59,  10,  32,  32, 102,
  111, 114,  40,  32, 108, 105, 110, 101,  32, 105, 110,  32, 115, 116, 114,  45,
   62, 103, 109,  97, 116,  99, 104,  40,  34,  91,  94,  92, 114,  92, 110,  93,
   43,  34,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32, 118,  97, 114,  32,
  107, 101, 121,  44,  32, 118,  97, 108, 117, 101,  32,  61,  32, 108, 105, 110,
  101,  45,  62, 109,  97, 116,  99, 104,  40, 112,  97, 116, 116, 101, 114, 110,
   41,  59,  10,  32,  32,  32,  32, 105, 102,  40,  32, 107, 101, 121,  32,  38,
   38,  32, 118,  97, 108, 117, 101,  32,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40, 114,
  101, 115, 117, 108, 116,  44,  32, 123, 107, 101, 121,  44,  32, 118,  97, 108,
  117, 101,  44,  32, 108, 105, 110, 101, 125,  41,  59,  10,  32,  32,  32,  32,
  125,  10,  32,  32, 125,  10,  32,  32, 114, 101, 116, 117, 114, 110,  32, 114,
  101, 115, 117, 108, 116,  59,  10, 125,  10, 102, 117, 110,  99, 116, 105, 111,
  110,  32, 114, 101, 118, 105, 118, 101,  40, 115, 116, 114,  41, 123,  10,  32,
   32, 102, 111, 114,  32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97,
  105, 114, 115,  40, 100, 101,  97, 100,  41,  41, 123,  10,  32,  32,  32,  32,
  118,  97, 114,  32, 105, 110, 100, 101, 120,  32,  61,  32,  34,  39,  68,  69,
   65,  68,  86,  65,  76,  85,  69,  83,  84,  82,  84,  89,  80,  69,  67,  72,
   69,  67,  75,  45,  34,  46,  46,  40, 105,  41,  46,  46,  34,  39,  34,  10,
   10,  32,  32,  32,  32,  47,  47,  32,  71, 111,  32,  99, 104,  97, 114,  97,
   99, 116, 101, 114,  32,  98, 121,  32,  99, 104,  97, 114,  97,  99, 116, 101,
  114,  32,  97, 110, 100,  32, 108, 111, 111, 107,  32, 102, 111, 114,  32, 105,
  110, 100, 101, 120,  10,  32,  32,  32,  32,  47,  47,  32,  73,  32, 119,  97,
  110, 116,  32, 116, 111,  32, 117, 115, 101,  32,  45,  62, 103, 115, 117,  98,
   32,  98, 117, 116,  32, 116, 104,  97, 116,  32, 100, 111, 101, 115, 110, 116,
   32, 119, 111, 114, 107,  32, 102, 111, 114,  32, 115, 117, 109,  32, 114, 101,
   97, 115, 111, 110,  32, 115, 111,  32,  73,  32,  97, 109,  32, 117, 115, 105,
  110, 103,  32,  97,  32,  10,  32,  32,  32,  32,  47,  47,  32, 109,  97, 110,
  117,  97, 108,  32, 109, 101, 116, 104, 111, 100,  10,  32,  32,  32,  32, 118,
   97, 114,  32,  99, 105,  32,  61,  32,  49,  59,  10,  32,  32,  32,  32, 118,
   97, 114,  32,  99, 115, 111, 102,  97, 114,  32,  61,  32,  34,  34,  59,  10,
   32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,  32,  61,  32,  49,  44,
   32,  35, 115, 116, 114,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32,  99, 104,  97, 114,  32,  61,  32, 115, 116, 114,  45,  62, 115,
  117,  98,  40, 105, 105,  44,  32, 105, 105,  41,  59,  10,  32,  32,  32,  32,
   32,  32, 105, 102,  32,  40,  99, 104,  97, 114,  32,  61,  61,  32, 105, 110,
  100, 101, 120,  45,  62, 115, 117,  98,  40,  99, 105,  44,  32,  99, 105,  41,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  99, 105,  43,  43,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  99, 115, 111, 102,  97, 114,
   32,  61,  32,  99, 115, 111, 102,  97, 114,  46,  46,  99, 104,  97, 114,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  99, 115, 111,
  102,  97, 114,  32,  61,  61,  32, 105, 110, 100, 101, 120,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116, 114,  32,  61,  32,
  115, 116, 114,  45,  62, 115, 117,  98,  40,  49,  44,  32, 105, 105,  32,  45,
   32,  35, 105, 110, 100, 101, 120,  41,  46,  46, 118,  46,  46, 115, 116, 114,
   45,  62, 115, 117,  98,  40, 105, 105,  32,  43,  32,  49,  44,  32,  35, 115,
  116, 114,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114,
  101,  97, 107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,
   32,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  99, 105,  32,  61,  32,  49,  59,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  99, 115, 111, 102,  97, 114,  32,  61,  32,  34,
   34,  59,  10,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 125,
   10,  32,  32, 125,  10,  32,  32, 114, 101, 116, 117, 114, 110,  32, 115, 116,
  114,  10, 125,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32,  99, 108, 101,
   97, 110,  40, 115, 116, 114,  41,  32, 123,  10,  32,  32,  47,  47,  32,  84,
   97, 107, 101, 115,  32, 105, 110,  32,  99, 111, 100, 101,  32,  97, 110, 100,
   32, 114, 101, 109, 111, 118, 101, 115,  32,  99, 111, 109, 109, 101, 110, 116,
  115,  44,  32, 115, 116, 114, 105, 110, 103, 115,  46,  10,  32,  32,  47,  47,
   32,  82, 101, 109, 111, 118, 101,  32, 115, 116, 114, 105, 110, 103, 115,  32,
   97, 110, 100,  32,  97, 100, 100,  32, 105, 116,  32, 116, 111,  32,  34, 100,
  101,  97, 100,  34,  32, 116,  97,  98, 108, 101,  10,  32,  32, 118,  97, 114,
   32, 100, 101,  97, 100,  32,  61,  32, 123, 125,  59,  10,  32,  32, 118,  97,
  114,  32, 105,  32,  61,  32,  48,  59,  10,  32,  32, 111, 103, 115, 116, 114,
   32,  61,  32, 115, 116, 114,  59,  10,  32,  32, 105, 102,  32,  40,  33, 115,
  116, 114,  91,  34, 103, 115, 117,  98,  34,  93,  41,  32, 116, 121, 112, 101,
  114, 114, 111, 114,  40,  34, 115, 116, 114, 105, 110, 103,  46, 103, 115, 117,
   98,  32, 105, 115,  32, 110, 111, 116,  32,  97,  32, 102, 111, 117, 110, 100,
   32, 102, 117, 110,  99, 116, 105, 111, 110,  44,  32,  65, 114, 101,  32, 121,
  111, 117,  32, 115, 117, 114, 101,  32, 121, 111, 117,  32, 112, 114, 111, 118,
  105, 100, 101, 100,  32,  97,  32, 115, 116, 114, 105, 110, 103,  63,  34,  41,
   10,  32,  32, 115, 116, 114,  32,  61,  32, 115, 116, 114,  45,  62, 103, 115,
  117,  98,  40,  34,  39,  91,  94,  39,  93,  45,  39,  34,  44,  32, 102, 117,
  110,  99, 116, 105, 111, 110,  40, 109,  97, 116,  99, 104,  41, 123,  10,  32,
   32,  32,  32, 105,  43,  43,  59,  10,  32,  32,  32,  32, 100, 101,  97, 100,
   91, 105,  93,  32,  61,  32, 109,  97, 116,  99, 104,  59,  10,  32,  32,  32,
   32, 114, 101, 116, 117, 114, 110,  32,  34,  39,  68,  69,  65,  68,  86,  65,
   76,  85,  69,  83,  84,  82,  84,  89,  80,  69,  67,  72,  69,  67,  75,  45,
   34,  46,  46,  40, 105,  41,  46,  46,  34,  39,  34,  59,  10,  32,  32, 125,
   41,  45,  62, 103, 115, 117,  98,  40,  39,  34,  91,  94,  34,  93,  45,  34,
   39,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 109,  97, 116,  99,
  104,  41, 123,  10,  32,  32,  32,  32, 105,  43,  43,  59,  10,  32,  32,  32,
   32, 100, 101,  97, 100,  91, 105,  93,  32,  61,  32, 109,  97, 116,  99, 104,
   59,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  34,  39,  68,
   69,  65,  68,  86,  65,  76,  85,  69,  83,  84,  82,  84,  89,  80,  69,  67,
   72,  69,  67,  75,  45,  34,  46,  46,  40, 105,  41,  46,  46,  34,  39,  34,
   59,  10,  32,  32, 125,  41,  45,  62, 103, 115, 117,  98,  40,  39,  37,  91,
   37,  91,  46,  45,  37,  93,  37,  93,  39,  44,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40, 109,  97, 116,  99, 104,  41, 123,  10,  32,  32,  32,  32,
  105,  43,  43,  59,  10,  32,  32,  32,  32, 100, 101,  97, 100,  91, 105,  93,
   32,  61,  32, 109,  97, 116,  99, 104,  59,  10,  32,  32,  32,  32, 114, 101,
  116, 117, 114, 110,  32,  34,  39,  68,  69,  65,  68,  86,  65,  76,  85,  69,
   83,  84,  82,  84,  89,  80,  69,  67,  72,  69,  67,  75,  45,  34,  46,  46,
   40, 105,  41,  46,  46,  34,  39,  34,  59,  10,  32,  32, 125,  41,  59,  10,
   32,  32, 114, 101, 116, 117, 114, 110,  32, 115, 116, 114,  45,  62, 103, 115,
  117,  98,  40,  39,  47,  47,  46,  45,  92, 110,  39,  44,  32,  39,  92, 110,
   39,  41,  45,  62, 103, 115, 117,  98,  40,  39,  47,  37,  42,  46,  45,  37,
   42,  47,  39,  44,  32,  39,  92, 110,  39,  41,  44,  32, 100, 101,  97, 100,
   59,  10, 125,  10,  10,  47,  47,  32,  67,  72,  69,  67,  75,  69,  82,  10,
  116, 121, 112, 101, 111, 102,  32,  61,  32, 116, 121, 112, 101,  59,  10, 102,
  117, 110,  99, 116, 105, 111, 110,  32,  99, 104, 101,  99, 107,  40, 116, 121,
  112, 101,  44,  32, 118,  97, 108, 117, 101,  44,  32, 118, 110,  97, 109, 101,
   44,  32, 107, 110, 111, 119, 110,  86,  97, 108, 117, 101, 115,  44,  32, 108,
  105, 110, 101,  41,  32, 123,  10,  32,  32, 118,  97, 108, 117, 101,  44,  32,
  101, 114, 114,  32,  61,  32, 108, 111,  97, 100, 101, 110, 118,  40, 107, 110,
  111, 119, 110,  86,  97, 108, 117, 101, 115,  44,  32,  34, 114, 101, 116, 117,
  114, 110,  32,  34,  32,  46,  46,  32, 118,  97, 108, 117, 101,  41,  10,  32,
   32, 105, 102,  32,  40,  33, 118,  97, 108, 117, 101,  41, 123,  10,  32,  32,
   32,  32, 116, 121, 112, 101, 114, 114, 111, 114,  40,  34,  67, 104, 101,  99,
  107,  32, 101, 114, 114, 111, 114,  58,  32,  34,  46,  46, 101, 114, 114,  44,
   32, 108, 105, 110, 101,  41,  10,  32,  32, 125,  10,  32,  32, 120, 112,  99,
   97, 108, 108,  40, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,
   32,  32,  32,  32, 118,  97, 108, 117, 101,  32,  61,  32, 118,  97, 108, 117,
  101,  40,  41,  59,  10,  32,  32, 125,  44,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  40, 101, 114, 114,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,
   73, 103, 110, 111, 114, 101,  32,  97, 110, 100,  32, 114, 101, 116, 117, 114,
  110,  32, 116, 114, 117, 101,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114,
  110,  32, 116, 114, 117, 101,  59,  10,  32,  32, 125,  41,  10,  32,  32, 105,
  102,  40,  32, 116, 121, 112, 101, 115,  91, 116, 121, 112, 101,  93,  32,  41,
   32, 123,  10,  32,  32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101, 115,
   91, 116, 121, 112, 101,  93,  40, 118,  97, 108, 117, 101,  41,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 114,
  117, 101,  59,  10,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,
   10,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101, 111,
  102,  40, 118,  97, 108, 117, 101,  41,  32,  61,  61,  32,  34, 102, 117, 110,
   99, 116, 105, 111, 110,  34,  41,  32, 114, 101, 116, 117, 114, 110,  32, 116,
  114, 117, 101,  59,  32,  47,  47,  32,  73, 103, 110, 111, 114, 101,  32, 102,
  111, 114,  32, 110, 111, 119,  10,  32,  32,  32,  32,  32,  32, 116, 121, 112,
  101, 114, 114, 111, 114,  40,  99, 111, 114, 101,  46, 101, 114, 114, 111, 114,
   46, 115, 116, 114, 101, 114, 114, 111, 114,  40,  49,  49,  49,  41,  45,  62,
  102, 111, 114, 109,  97, 116,  40, 116, 121, 112, 101,  44,  32,  40, 116, 111,
  115, 116, 114, 105, 110, 103,  40, 116, 121, 112, 101, 111, 102,  40, 118,  97,
  108, 117, 101,  41,  41,  46,  46,  34,  32,  40,  97, 110, 100,  32, 105, 116,
   39, 115,  32, 100, 101, 115,  99, 101, 110, 100, 101, 110, 116, 115,  41,  34,
   41,  44,  32, 118, 110,  97, 109, 101,  41,  44,  32, 108, 105, 110, 101,  41,
   59,  10,  32,  32,  32,  32, 125,  10,  32,  32, 125,  32, 101, 108, 115, 101,
   32, 123,  10,  32,  32,  32,  32, 116, 121, 112, 101, 114, 114, 111, 114,  40,
   99, 111, 114, 101,  46, 101, 114, 114, 111, 114,  46, 115, 116, 114, 101, 114,
  114, 111, 114,  40,  49,  49,  50,  41,  45,  62, 102, 111, 114, 109,  97, 116,
   40, 116, 121, 112, 101,  41,  44,  32, 108, 105, 110, 101,  44,  32,  34,  85,
  115, 101,  32,  96,  99, 111,  98,  97, 108, 116, 112, 114, 101,  32,  45, 116,
  121, 112, 101, 115,  96,  32, 116, 111,  32, 115, 101, 101,  32,  97, 108, 108,
   32, 116, 121, 112, 101, 115,  34,  41,  59,  10,  32,  32, 125,  10, 125,  10,
   10,  47,  47,  32,  77,  65,  73,  78,  10, 102, 117, 110,  99, 116, 105, 111,
  110,  32, 116, 121, 112, 101,  99, 104, 101,  99, 107,  40,  99, 111, 100, 101,
   41, 123,  10,  32,  32,  99, 108, 101,  97, 110, 101, 100,  67, 111, 100, 101,
   44,  32, 110, 101, 119, 100, 101,  97, 100,  32,  61,  32,  99, 108, 101,  97,
  110,  40,  99, 111, 100, 101,  41,  59,  10,  32,  32, 100, 101,  97, 100,  32,
   61,  32, 110, 101, 119, 100, 101,  97, 100,  59,  10,  32,  32, 102, 111, 114,
   32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40,
   99, 108, 101,  97, 110, 101, 100,  67, 111, 100, 101,  45,  62, 115, 112, 108,
  105, 116,  40,  34,  92, 110,  34,  41,  41,  41, 123,  10,  32,  32,  32,  32,
   99, 108, 101,  97, 110, 101, 100,  67, 111, 100, 101,  32,  61,  32,  99, 108,
  101,  97, 110, 101, 100,  67, 111, 100, 101,  45,  62, 115, 112, 108, 105, 116,
   40,  34,  92, 110,  34,  41,  91, 105,  93,  32, 124, 124,  32,  34,  34,  59,
   10,  32,  32,  32,  32, 118,  97, 114,  32, 100, 101, 102, 115,  32,  61,  32,
  100, 101, 102, 102, 105, 110, 100,  40,  99, 108, 101,  97, 110, 101, 100,  67,
  111, 100, 101,  41,  59,  10,  32,  32,  32,  32, 118,  97, 114,  32,  97, 115,
  115, 105, 103, 110, 115,  32,  61,  32,  97, 115, 115, 105, 103, 110,  40,  99,
  108, 101,  97, 110, 101, 100,  67, 111, 100, 101,  41,  59,  10,  32,  32,  32,
   32, 118,  97, 114,  32,  97, 108, 108,  97, 115, 115, 105, 103, 110, 115,  32,
   61,  32,  97, 108, 108,  97, 115, 115, 105, 103, 110,  40,  99, 108, 101,  97,
  110, 101, 100,  67, 111, 100, 101,  41,  59,  10,  32,  32,  32,  32, 118,  97,
  114,  32, 102, 117, 110,  99, 116, 105, 111, 110, 115,  32,  61,  32, 102, 105,
  110, 100, 102, 117, 110,  99, 116, 105, 111, 110, 115,  40,  99, 108, 101,  97,
  110, 101, 100,  67, 111, 100, 101,  41,  59,  10,  32,  32,  32,  32, 118,  97,
  114,  32,  97, 108, 108,  32,  61,  32, 102, 105, 110, 100,  97, 108, 108,  40,
   99, 108, 101,  97, 110, 101, 100,  67, 111, 100, 101,  41,  59,  10,  10,  32,
   32,  32,  32, 118,  97, 114,  32, 107, 110, 111, 119, 110,  84, 121, 112, 101,
  115,  32,  61,  32, 123, 125,  59,  10,  32,  32,  32,  32, 118,  97, 114,  32,
  107, 110, 111, 119, 110,  86,  97, 108, 117, 101, 115,  32,  61,  32, 123, 125,
   59,  32,  10,  32,  32,  32,  32, 102, 111, 114,  40,  32,  95,  44,  32, 100,
  101, 102,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 100, 101, 102, 115,
   41,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  99, 104, 101,  99,
  107,  40, 100, 101, 102,  91,  50,  93,  44,  32, 100, 101, 102,  91,  51,  93,
   44,  32, 100, 101, 102,  91,  49,  93,  44,  32, 107, 110, 111, 119, 110,  86,
   97, 108, 117, 101, 115,  44,  32, 100, 101, 102,  91,  52,  93,  41,  10,  32,
   32,  32,  32,  32,  32, 118,  97, 108, 117, 101,  44,  32, 101, 114, 114,  32,
   61,  32, 108, 111,  97, 100, 101, 110, 118,  40, 107, 110, 111, 119, 110,  86,
   97, 108, 117, 101, 115,  44,  32,  34, 114, 101, 116, 117, 114, 110,  32,  34,
   32,  46,  46,  32, 100, 101, 102,  91,  51,  93,  41,  10,  32,  32,  32,  32,
   32,  32, 105, 102,  32,  40,  33, 118,  97, 108, 117, 101,  41, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 116, 121, 112, 101, 114, 114, 111, 114,  40,
   34,  67, 104, 101,  99, 107,  32, 101, 114, 114, 111, 114,  58,  32,  34,  46,
   46, 101, 114, 114,  41,  10,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32, 107, 110, 111, 119, 110,  84, 121, 112, 101, 115,  91, 100,
  101, 102,  91,  49,  93,  93,  32,  61,  32, 100, 101, 102,  91,  50,  93,  59,
   10,  32,  32,  32,  32,  32,  32, 120, 112,  99,  97, 108, 108,  40, 102, 117,
  110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 107, 110, 111, 119, 110,  86,  97, 108, 117, 101, 115,  91, 100, 101,
  102,  91,  49,  93,  93,  32,  61,  32, 118,  97, 108, 117, 101,  40,  41,  59,
   10,  32,  32,  32,  32,  32,  32, 125,  44,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  40, 101, 114, 114,  41, 123, 125,  41,  10,  32,  32,  32,  32,  32,
   32,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 102, 111, 114,  40,
   32,  95,  44,  32,  97, 108, 108,  97, 115, 115, 105, 103, 110,  32, 105, 110,
   32, 112,  97, 105, 114, 115,  40,  97, 108, 108,  97, 115, 115, 105, 103, 110,
  115,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32, 105, 102,  32,
   40, 107, 110, 111, 119, 110,  84, 121, 112, 101, 115,  91,  97, 108, 108,  97,
  115, 115, 105, 103, 110,  91,  49,  93,  93,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  99, 104, 101,  99, 107,  40, 107, 110, 111, 119, 110,
   84, 121, 112, 101, 115,  91,  97, 108, 108,  97, 115, 115, 105, 103, 110,  91,
   49,  93,  93,  44,  32,  97, 108, 108,  97, 115, 115, 105, 103, 110,  91,  50,
   93,  44,  32,  97, 108, 108,  97, 115, 115, 105, 103, 110,  91,  49,  93,  44,
   32, 107, 110, 111, 119, 110,  86,  97, 108, 117, 101, 115,  44,  32,  97, 108,
  108,  97, 115, 115, 105, 103, 110,  91,  51,  93,  41,  59,  10,  32,  32,  32,
   32,  32,  32, 125, 101, 108, 115, 101,  32, 105, 102,  40,  33, 107, 110, 111,
  119, 110,  86,  97, 108, 117, 101, 115,  91,  97, 108, 108,  97, 115, 115, 105,
  103, 110,  91,  49,  93,  93,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 107, 110, 111, 119, 110,  86,  97, 108, 117, 101, 115,  91,  97, 108,
  108,  97, 115, 115, 105, 103, 110,  91,  49,  93,  93,  32,  61,  32,  97, 108,
  108,  97, 115, 115, 105, 103, 110,  91,  50,  93,  59,  10,  32,  32,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 102, 111,
  114,  40,  32,  95,  44,  32,  97, 115, 115, 105, 103, 110,  32, 105, 110,  32,
  112,  97, 105, 114, 115,  40,  97, 115, 115, 105, 103, 110, 115,  41,  32,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  99, 104, 101,  99, 107,  40,  97,
  115, 115, 105, 103, 110,  91,  50,  93,  44,  32,  97, 115, 115, 105, 103, 110,
   91,  51,  93,  44,  32,  97, 115, 115, 105, 103, 110,  91,  49,  93,  44,  32,
  107, 110, 111, 119, 110,  86,  97, 108, 117, 101, 115,  44,  32,  97, 115, 115,
  105, 103, 110,  91,  52,  93,  41,  59,  10,  32,  32,  32,  32,  32,  32, 107,
  110, 111, 119, 110,  86,  97, 108, 117, 101, 115,  91,  97, 115, 115, 105, 103,
  110,  91,  49,  93,  93,  32,  61,  32,  97, 115, 115, 105, 103, 110,  91,  51,
   93,  59,  10,  32,  32,  32,  32,  32,  32, 107, 110, 111, 119, 110,  84, 121,
  112, 101, 115,  91,  97, 115, 115, 105, 103, 110,  91,  49,  93,  93,  32,  61,
   32,  97, 115, 115, 105, 103, 110,  91,  50,  93,  59,  10,  32,  32,  32,  32,
  125,  10,  32,  32, 125,  10,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116,
  114, 117, 101,  59,  10, 125,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32,
   97, 108, 108,  40,  41, 123,  10,  32,  32,  47,  47,  32,  80, 114, 105, 110,
  116, 115,  32,  97, 108, 108,  32, 116, 121, 112, 101, 115,  10,  32,  32, 112,
  114, 105, 110, 116,  40,  34,  65, 108, 108,  32, 118,  97, 108, 105, 100,  32,
   99, 104, 101,  99, 107,  97,  98, 108, 101,  32, 116, 121, 112, 101, 115,  58,
   34,  41,  10,  32,  32, 102, 111, 114,  32,  40, 105,  44,  32, 118,  32, 105,
  110,  32, 112,  97, 105, 114, 115,  40,  97, 108, 108, 116, 121, 112, 101, 115,
   41,  41,  32, 123,  10,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,  34,
   32,  32,  34,  46,  46, 118,  41,  10,  32,  32, 125,  10, 125,  10,  10, 116,
  121, 112, 101,  99, 104, 101,  99, 107, 101, 114,  32,  61,  32, 123,  10,  32,
   32,  34,  97, 108, 108,  34,  58,  32,  97, 108, 108,  44,  10,  32,  32,  34,
   99, 104, 101,  99, 107,  34,  58,  32, 116, 121, 112, 101,  99, 104, 101,  99,
  107,  44,  10,  32,  32,  34,  99, 108, 101,  97, 110,  34,  58,  32,  99, 108,
  101,  97, 110,  44,  10,  32,  32,  34, 114, 101, 118, 105, 118, 101,  34,  58,
   32, 114, 101, 118, 105, 118, 101,  44,  10, 125,  10,  10,  47,  47,  32,  83,
   69,  67,  84,  73,  79,  78,  32,  50,  58,  32,  76,  97, 110, 103, 117,  97,
  103, 101,  32, 101, 120, 116, 101, 110, 115, 105, 111, 110, 115,  10,  10,  47,
   42,  32,  69,  88,  84,  69,  78,  68,  83,  58,  10,  45,  32, 102,  34, 123,
  120, 125,  34,  32,  61,  32, 115, 116, 114, 105, 110, 103,  46, 102, 111, 114,
  109,  97, 116,  40,  34,  37, 115,  34,  44,  32, 120,  41,  10,  45,  32,  36,
  116,  97,  98, 108, 101,  32,  61,  32, 112,  97, 105, 114, 115,  40, 116,  97,
   98, 108, 101,  41,  10,  45,  32,  64, 116,  97,  98, 108, 101,  32,  61,  32,
  105, 112,  97, 105, 114, 115,  40, 116,  97,  98, 108, 101,  41,  10,  45,  32,
  120, 126, 121,  32,  61,  32,  95,  71,  46, 120,  32,  61,  32, 121,  44,  32,
  114, 101, 116, 117, 114, 110,  32, 121,  10,  45,  32, 114, 101, 109, 111, 118,
  101, 115,  32,  99, 111, 109, 109, 101, 110, 116, 115,  10,  45,  32, 118,  97,
  114,  32,  91, 120,  44,  32, 121,  44,  32, 122,  93,  32,  61,  32, 116,  98,
  108,  32,  40, 120,  44,  32, 121,  44,  32, 122,  32,  97, 114, 101,  32, 116,
  104, 101,  32, 107, 101, 121, 115,  32, 111, 102,  32, 116,  98, 108,  41,  10,
   45,  32, 118,  97, 114,  32, 120,  32,  60, 112, 114, 101,  62,  32,  61,  32,
  121,  32,  40, 119, 105, 108, 108,  32,  99,  97, 108,  99, 117, 108,  97, 116,
  101,  32, 121,  32, 111, 110,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115,
  115, 111, 114,  41,  10,  42,  47,  10,  10,  47,  42,  32,  84,  79,  68,  79,
   58,  10,  32,  32,  45,  32,  70, 105, 120,  32, 116, 104, 101,  32, 110, 101,
  115, 116, 101, 100,  32, 115, 116, 114, 105, 110, 103,  32,  98, 117, 103,  10,
   32,  32,  45,  32,  83, 116, 114, 105, 110, 103, 115,  32, 116, 104,  97, 116,
   32,  97, 114, 101,  32, 111, 112, 116, 105, 109, 105, 122, 101, 100,  32, 116,
  111,  32,  98, 101,  32,  34,  44,  32,  39,  32, 115, 104, 111, 117, 108, 100,
   32, 110, 111, 116,  32, 108, 111, 115, 101,  32, 112, 111, 119, 101, 114,  10,
   42,  47,  10,  10,  47,  42,  32,  83,  89,  83,  84,  69,  77,  58,  10,  32,
   84, 104, 105, 115,  32, 117, 115, 101, 115,  32, 116, 104, 101,  32, 116, 121,
  112, 101,  99, 104, 101,  99, 107, 101, 114,  39, 115,  32, 100, 101,  97, 100,
   32,  38,  32,  97, 108, 105, 118, 101,  32, 115, 121, 115, 116, 101, 109,  32,
  116, 111,  32,  10,  32, 107, 105, 108, 108,  32,  97, 108, 108,  32, 110, 111,
  110,  32, 115, 121, 110, 116,  97, 120,  32, 115, 116,  97, 116, 101, 109, 101,
  110, 116, 115,  32,  97, 110, 100,  32, 119, 105, 108, 108,  32, 108, 111, 111,
  107,  32, 102, 111, 114,  32,  97,  32,  10,  32, 102,  34, 120,  32, 123, 115,
  116, 114, 105, 110, 103, 125,  32, 123, 115, 116, 114, 105, 110, 103,  50, 125,
   34,  32,  97, 110, 100,  32, 114, 101, 112, 108,  97,  99, 101,  32, 105, 116,
   32, 119, 105, 116, 104,  32, 115, 116, 114, 105, 110, 103,  46, 102, 111, 114,
  109,  97, 116,  40,  34, 120,  32,  37, 115,  34,  44,  32, 115, 116, 114, 105,
  110, 103,  44,  32, 115, 116, 114, 105, 110, 103,  50,  41,  46,  10,  42,  47,
   10,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 103, 115, 117,  98,  40,
  115, 116, 114,  44,  32, 112,  97, 116, 116, 101, 114, 110,  44,  32, 114, 101,
  112, 108,  97,  99, 101,  41, 123,  10,  32,  32,  47,  47,  32,  82,  97, 119,
   32,  71,  83,  85,  66,  32, 102, 117, 110,  99, 116, 105, 111, 110,  10,  32,
   32, 118,  97, 114,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32,  34,  34,
   10,  32,  32, 118,  97, 114,  32, 112,  97, 116, 116, 101, 114, 110,  95, 108,
  101, 110,  32,  61,  32,  35, 112,  97, 116, 116, 101, 114, 110,  10,  32,  32,
  118,  97, 114,  32, 105,  32,  61,  32,  49,  10,  32,  32, 119, 104, 105, 108,
  101,  32,  40, 105,  32,  60,  61,  32,  35, 115, 116, 114,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 115, 116, 114,  45,  62, 115,
  117,  98,  40, 105,  44,  32, 105,  32,  43,  32, 112,  97, 116, 116, 101, 114,
  110,  95, 108, 101, 110,  32,  45,  32,  49,  41,  32,  61,  61,  32, 112,  97,
  116, 116, 101, 114, 110,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32, 114, 101, 115, 117,
  108, 116,  32,  46,  46,  32, 114, 101, 112, 108,  97,  99, 101,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  43,  32,
  112,  97, 116, 116, 101, 114, 110,  95, 108, 101, 110,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 125, 101, 108, 115, 101, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32, 114, 101,
  115, 117, 108, 116,  32,  46,  46,  32, 115, 116, 114,  45,  62, 115, 117,  98,
   40, 105,  44,  32, 105,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 105,  32,  61,  32, 105,  32,  43,  32,  49,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  32,  32, 114, 101, 116,
  117, 114, 110,  32, 114, 101, 115, 117, 108, 116,  10, 125,  10,  10, 102, 117,
  110,  99, 116, 105, 111, 110,  32, 102, 105, 110, 100,  40, 115, 116, 114,  44,
   32, 112,  97, 116, 116, 101, 114, 110,  44,  32, 105, 110, 105, 116,  41, 123,
   10,  32,  32, 105, 110, 105, 116,  32,  61,  32, 105, 110, 105, 116,  32, 124,
  124,  32,  49,  10,  32,  32, 118,  97, 114,  32, 112,  97, 116, 116, 101, 114,
  110,  95, 108, 101, 110,  32,  61,  32,  35, 112,  97, 116, 116, 101, 114, 110,
   10,  32,  32, 118,  97, 114,  32, 105,  32,  61,  32, 105, 110, 105, 116,  10,
   32,  32, 119, 104, 105, 108, 101,  32,  40, 105,  32,  60,  61,  32,  35, 115,
  116, 114,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,
  115, 116, 114,  45,  62, 115, 117,  98,  40, 105,  44,  32, 105,  32,  43,  32,
  112,  97, 116, 116, 101, 114, 110,  95, 108, 101, 110,  32,  45,  32,  49,  41,
   32,  61,  61,  32, 112,  97, 116, 116, 101, 114, 110,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,
  105,  44,  32, 105,  32,  43,  32, 112,  97, 116, 116, 101, 114, 110,  95, 108,
  101, 110,  32,  45,  32,  49,  10,  32,  32,  32,  32,  32,  32, 125,  10,  32,
   32,  32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  43,  32,  49,  10,  32,
   32, 125,  10,  32,  32, 114, 101, 116, 117, 114, 110,  32, 110, 117, 108, 108,
   10, 125,  10,  10, 101, 120, 116,  32,  61,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  40, 115, 116, 114,  41, 123,  10,  32,  32,  99, 108, 101,  97, 110,
  101, 100,  67, 111, 100, 101,  44,  32, 100, 101,  97, 100,  32,  61,  32, 116,
  121, 112, 101,  99, 104, 101,  99, 107, 101, 114,  46,  99, 108, 101,  97, 110,
   40, 115, 116, 114,  41,  10,  32,  32,  10,  32,  32, 108, 105, 110, 101, 115,
   32,  61,  32,  99, 108, 101,  97, 110, 101, 100,  67, 111, 100, 101,  45,  62,
  115, 112, 108, 105, 116,  40,  34,  92, 110,  34,  41,  10,  10,  10,  32,  32,
  102, 111, 114,  32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105,
  114, 115,  40, 108, 105, 110, 101, 115,  41,  41, 123,  10,  32,  32,  32,  32,
  118,  99, 108, 101,  97, 110,  32,  61,  32,  32, 116, 121, 112, 101,  99, 104,
  101,  99, 107, 101, 114,  46, 114, 101, 118, 105, 118, 101,  40, 118,  44,  32,
  100, 101,  97, 100,  41,  10,  32,  32,  32,  32,  47,  47,  32, 108, 111, 111,
  107,  32, 102, 111, 114,  32, 118,  97, 114,  32,  37, 115,  32,  60, 112, 114,
  101,  62,  32,  61,  32,  37, 115,  32,  10,  32,  32,  32,  32, 118,  97, 114,
   32, 112,  97, 116, 116, 101, 114, 110,  32,  61,  32,  34, 118,  97, 114,  37,
  115,  43,  40,  91,  94,  37, 115,  93,  43,  41,  37, 115,  43,  60, 112, 114,
  101,  62,  37, 115,  42,  61,  37, 115,  42,  40,  46,  45,  41,  37, 115,  42,
   36,  34,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40, 109,  97, 116,  99,
  104,  44,  32, 109,  97, 116,  99, 104,  50,  32, 105, 110,  32, 118,  99, 108,
  101,  97, 110,  45,  62, 103, 109,  97, 116,  99, 104,  40, 112,  97, 116, 116,
  101, 114, 110,  41,  41, 123,  10,  32,  32,  32,  32,  32,  32, 110, 101, 119,
  118,  97, 108,  32,  61,  32,  34,  34,  10,  32,  32,  32,  32,  32,  32, 120,
  112,  99,  97, 108, 108,  40, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119, 118,  97, 108,
   32,  61,  32, 108, 111,  97, 100, 115, 116, 114, 105, 110, 103,  40,  34, 114,
  101, 116, 117, 114, 110,  32,  34,  46,  46, 109,  97, 116,  99, 104,  50,  41,
   40,  41,  10,  32,  32,  32,  32,  32,  32, 125,  44,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  40, 101, 114, 114,  41, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  40,  34,  69, 114, 114, 111, 114,  32, 114, 101, 110, 100,
  101, 114, 105, 110, 103,  32,  60, 112, 114, 101,  62,  32, 118,  97, 108, 117,
  101,  58,  32,  34,  46,  46, 101, 114, 114,  44,  32, 118,  41,  10,  32,  32,
   32,  32,  32,  32, 125,  41,  10,  10,  32,  32,  32,  32,  32,  32,  47,  47,
   32,  70, 111, 114, 109,  97, 116,  32, 110, 101, 119, 118,  97, 108,  10,  32,
   32,  32,  32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40, 110, 101,
  119, 118,  97, 108,  41,  32,  61,  61,  32,  34, 115, 116, 114, 105, 110, 103,
   34,  41,  32, 110, 101, 119, 118,  97, 108,  32,  61,  32,  39,  34,  39,  46,
   46, 110, 101, 119, 118,  97, 108,  46,  46,  39,  34,  39,  10,  32,  32,  32,
   32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40, 110, 101, 119, 118,
   97, 108,  41,  32,  61,  61,  32,  34, 116,  97,  98, 108, 101,  34,  41,  32,
  110, 101, 119, 118,  97, 108,  32,  61,  32, 116,  97,  98, 108, 101, 116, 111,
  115, 116, 114, 105, 110, 103,  40, 110, 101, 119, 118,  97, 108,  41,  10,  32,
   32,  32,  32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40, 110, 101,
  119, 118,  97, 108,  41,  32,  61,  61,  32,  34, 102, 117, 110,  99, 116, 105,
  111, 110,  34,  41,  32, 110, 101, 119, 118,  97, 108,  32,  61,  32, 101, 114,
  114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40,
   34,  70, 117, 110,  99, 116, 105, 111, 110, 115,  32,  97, 114, 101,  32, 110,
  111, 116,  32, 115, 117, 112, 112, 111, 114, 116, 101, 100,  32, 105, 110,  32,
   60, 112, 114, 101,  62,  32, 118,  97, 108, 117, 101, 115,  34,  44,  32, 118,
   41,  10,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101,
   40, 110, 101, 119, 118,  97, 108,  41,  32,  61,  61,  32,  34, 117, 115, 101,
  114, 100,  97, 116,  97,  34,  41,  32, 110, 101, 119, 118,  97, 108,  32,  61,
   32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,
  111, 114,  40,  34,  85, 115, 101, 114, 100,  97, 116,  97,  32, 105, 115,  32,
  110, 111, 116,  32, 115, 117, 112, 112, 111, 114, 116, 101, 100,  32, 105, 110,
   32,  60, 112, 114, 101,  62,  32, 118,  97, 108, 117, 101, 115,  34,  44,  32,
  118,  41,  10,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 116, 121, 112,
  101,  40, 110, 101, 119, 118,  97, 108,  41,  32,  61,  61,  32,  34, 116, 104,
  114, 101,  97, 100,  34,  41,  32, 110, 101, 119, 118,  97, 108,  32,  61,  32,
  101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111,
  114,  40,  34,  84, 104, 114, 101,  97, 100, 115,  32,  97, 114, 101,  32, 110,
  111, 116,  32, 115, 117, 112, 112, 111, 114, 116, 101, 100,  32, 105, 110,  32,
   60, 112, 114, 101,  62,  32, 118,  97, 108, 117, 101, 115,  34,  44,  32, 118,
   41,  10,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101,
   40, 110, 101, 119, 118,  97, 108,  41,  32,  61,  61,  32,  34, 110, 117, 108,
  108,  34,  41,  32, 110, 101, 119, 118,  97, 108,  32,  61,  32,  34, 110, 117,
  108, 108,  34,  10,  10,  10,  10,  32,  32,  32,  32,  32,  32, 118,  32,  61,
   32, 118,  45,  62, 103, 115, 117,  98,  40,  34, 118,  97, 114,  37, 115,  43,
   40,  91,  94,  37, 115,  93,  43,  41,  37, 115,  43,  60, 112, 114, 101,  62,
   37, 115,  42,  61,  37, 115,  42,  40,  46,  45,  41,  37, 115,  42,  36,  34,
   44,  32,  34, 118,  97, 114,  32,  34,  46,  46, 109,  97, 116,  99, 104,  46,
   46,  34,  32,  61,  32,  34,  46,  46, 110, 101, 119, 118,  97, 108,  41,  10,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  47,  47,  32,  82, 101, 112,
  108,  97,  99, 101,  32,  36, 116,  97,  98, 108, 101,  32, 119, 105, 116, 104,
   32, 112,  97, 105, 114, 115,  40, 116,  97,  98, 108, 101,  41,  44,  32,  97,
  110, 100,  32,  36,  36, 116,  97,  98, 108, 101,  32, 119, 105, 116, 104,  32,
  105, 112,  97, 105, 114, 115,  40, 116,  97,  98, 108, 101,  41,  46,  32,  77,
   97, 107, 101,  32, 115, 117, 114, 101,  32, 116, 104, 101,  32,  36,  36,  32,
  100, 111, 101, 115, 110, 116,  32, 114, 101, 110, 100, 101, 114,  32,  97, 115,
   32,  36,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40, 109,  97, 116,  99,
  104,  32, 105, 110,  32, 118,  99, 108, 101,  97, 110,  45,  62, 103, 109,  97,
  116,  99, 104,  40,  34,  64,  91,  97,  45, 122,  65,  45,  90,  48,  45,  57,
   95,  93,  43,  34,  41,  41, 123,  10,  32,  32,  32,  32,  32,  32, 118,  32,
   61,  32, 118,  45,  62, 103, 115, 117,  98,  40, 109,  97, 116,  99, 104,  44,
   32,  34, 105, 112,  97, 105, 114, 115,  40,  34,  46,  46,  40, 109,  97, 116,
   99, 104,  45,  62, 115, 117,  98,  40,  50,  41,  41,  46,  46,  34,  41,  34,
   41,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 102, 111, 114,  32,
   40, 109,  97, 116,  99, 104,  32, 105, 110,  32, 118,  99, 108, 101,  97, 110,
   45,  62, 103, 109,  97, 116,  99, 104,  40,  34,  36,  91,  97,  45, 122,  65,
   45,  90,  48,  45,  57,  95,  93,  43,  34,  41,  41, 123,  10,  32,  32,  32,
   32,  32,  32, 118,  32,  61,  32, 118,  45,  62, 103, 115, 117,  98,  40, 109,
   97, 116,  99, 104,  44,  32,  34, 112,  97, 105, 114, 115,  40,  34,  46,  46,
  109,  97, 116,  99, 104,  45,  62, 115, 117,  98,  40,  50,  41,  46,  46,  34,
   41,  34,  41,  10,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  47,
   47,  32, 120, 126, 121,  32,  40, 121,  32, 105, 115,  32,  97, 110, 121, 116,
  104, 105, 110, 103,  32, 117, 110, 116, 105, 108,  32, 119, 104, 105, 116, 101,
  115, 112,  97,  99, 101,  32,  40, 110, 111, 116,  32, 105, 110, 115, 105, 100,
  101,  32,  97,  32, 115, 116, 114, 105, 110, 103,  41,  41,  32, 119, 105, 108,
  108,  32,  97, 100, 100,  32, 116, 111,  32, 116, 104, 101,  32, 115, 116,  97,
  114, 116,  32,  95,  71,  46, 120,  61, 121,  59,  32,  97, 110, 100,  32, 116,
  104, 101, 110,  32, 119, 105, 108, 108,  32, 114, 101, 112, 108,  97,  99, 101,
   32, 116, 104, 101,  32, 120, 126, 121,  32, 119, 105, 116, 104,  32, 120,  10,
   32,  32,  32,  32, 102, 111, 114,  32,  40, 109,  97, 116,  99, 104,  32, 105,
  110,  32, 118,  45,  62, 103, 109,  97, 116,  99, 104,  40,  34,  91,  97,  45,
  122,  65,  45,  90,  48,  45,  57,  95,  93,  43, 126,  91,  94,  37, 115,  93,
   43,  34,  41,  41, 123,  10,  32,  32,  32,  32,  32,  32,  47,  42,  10,  32,
   32,  32,  32,  32,  32, 118,  32,  61,  32,  34,  95,  71,  91,  92,  34,  34,
   46,  46, 109,  97, 116,  99, 104,  45,  62, 115, 117,  98,  40,  49,  44,  32,
  109,  97, 116,  99, 104,  45,  62, 102, 105, 110, 100,  40,  34, 126,  34,  41,
   45,  49,  41,  46,  46,  34,  92,  34,  93,  32,  61,  32,  34,  46,  46, 109,
   97, 116,  99, 104,  45,  62, 115, 117,  98,  40, 109,  97, 116,  99, 104,  45,
   62, 102, 105, 110, 100,  40,  34, 126,  34,  41,  43,  49,  41,  46,  46,  34,
   59,  32,  34,  46,  46, 118,  10,  32,  32,  32,  32,  10,  32,  32,  32,  32,
   32,  32,  47,  47,  32, 114, 101, 112, 108,  97,  99, 101,  32, 109,  97, 116,
   99, 104,  32, 119, 105, 116, 104,  32, 116, 104, 101,  32, 102, 105, 114, 115,
  116,  32, 112,  97, 114, 116,  32, 111, 102,  32, 116, 104, 101,  32, 109,  97,
  116,  99, 104,  46,  32,  66, 117, 116,  32, 100, 111,  32, 110, 111, 116,  32,
  117, 115, 101,  32, 103, 115, 117,  98,  10,  32,  32,  32,  32,  32,  32, 118,
   32,  61,  32, 103, 115, 117,  98,  40, 118,  44,  32, 109,  97, 116,  99, 104,
   44,  32, 109,  97, 116,  99, 104,  45,  62, 115, 117,  98,  40,  49,  44,  32,
  109,  97, 116,  99, 104,  45,  62, 102, 105, 110, 100,  40,  34, 126,  34,  41,
   45,  49,  41,  41,  10,  32,  32,  32,  32,  32,  32,  42,  47,  10,  32,  32,
   32,  32,  32,  32,  97, 114, 103,  49,  32,  61,  32, 109,  97, 116,  99, 104,
   45,  62, 115, 117,  98,  40,  49,  44,  32, 109,  97, 116,  99, 104,  45,  62,
  102, 105, 110, 100,  40,  34, 126,  34,  41,  45,  49,  41,  10,  32,  32,  32,
   32,  32,  32,  97, 114, 103,  50,  32,  61,  32, 109,  97, 116,  99, 104,  45,
   62, 115, 117,  98,  40, 109,  97, 116,  99, 104,  45,  62, 102, 105, 110, 100,
   40,  34, 126,  34,  41,  43,  49,  41,  10,  32,  32,  32,  32,  32,  32, 118,
   32,  61,  32, 103, 115, 117,  98,  40, 118,  44,  32, 109,  97, 116,  99, 104,
   44,  32,  34,  95,  46, 103, 108, 111,  98,  97, 108,  40,  92,  34,  34,  46,
   46,  97, 114, 103,  49,  46,  46,  34,  92,  34,  44,  32,  34,  46,  46,  97,
  114, 103,  50,  46,  46,  34,  41,  34,  41,  10,  32,  32,  32,  32, 125,  10,
   10,  32,  32,  32,  32,  47,  47,  32, 116,  97,  98, 108, 101,  32,  91, 120,
   44,  32, 121,  44,  32, 122,  93,  32,  61,  32, 116,  98, 108,  10,  32,  32,
   32,  32,  47,  42,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40, 109,  97,
  116,  99, 104,  32, 105, 110,  32, 118,  45,  62, 103, 109,  97, 116,  99, 104,
   40,  34,  40,  91,  97,  45, 122,  65,  45,  90,  48,  45,  57,  95,  93,  43,
   41,  37, 115,  42,  37,  91,  40,  46,  45,  41,  37,  93,  37, 115,  42,  61,
   34,  41,  41, 123,  10,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110, 116,
   40, 118,  41,  10,  32,  32,  32,  32,  32,  32,  47,  47,  32, 114, 101, 112,
  108,  97,  99, 101,  32, 116, 104, 101,  32, 109,  97, 116,  99, 104,  32, 119,
  105, 116, 104,  32, 116, 104, 101,  32, 102, 105, 114, 115, 116,  32, 112,  97,
  114, 116,  32, 111, 102,  32, 116, 104, 101,  32, 109,  97, 116,  99, 104,  10,
   32,  32,  32,  32,  32,  32, 118,  32,  61,  32, 103, 115, 117,  98,  40, 118,
   44,  32, 109,  97, 116,  99, 104,  44,  32, 109,  97, 116,  99, 104,  45,  62,
  115, 117,  98,  40,  49,  44,  32, 102, 105, 110, 100,  40, 109,  97, 116,  99,
  104,  44,  32,  34,  91,  34,  41,  45,  49,  41,  41,  10,  32,  32,  32,  32,
   32,  32,  47,  47,  32, 114, 101, 112, 108,  97,  99, 101,  32, 116, 104, 101,
   32, 109,  97, 116,  99, 104,  32, 119, 105, 116, 104,  32, 116, 104, 101,  32,
  116,  97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40, 116,  98, 108,
   44,  32, 120,  44,  32, 121,  44,  32, 122,  41,  10,  32,  32,  32,  32,  32,
   32, 118,  32,  61,  32, 103, 115, 117,  98,  40, 118,  44,  32, 109,  97, 116,
   99, 104,  44,  32,  34, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101, 114,
  116,  40,  34,  46,  46, 109,  97, 116,  99, 104,  45,  62, 115, 117,  98,  40,
  102, 105, 110, 100,  40, 109,  97, 116,  99, 104,  44,  32,  34,  61,  34,  41,
   43,  49,  41,  46,  46,  34,  44,  32,  34,  46,  46, 109,  97, 116,  99, 104,
   45,  62, 115, 117,  98,  40, 102, 105, 110, 100,  40, 109,  97, 116,  99, 104,
   44,  32,  34,  91,  34,  41,  43,  49,  44,  32, 102, 105, 110, 100,  40, 109,
   97, 116,  99, 104,  44,  32,  34,  93,  34,  41,  45,  49,  41,  46,  46,  34,
   41,  34,  41,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  42,  47,
   10,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40, 109,  97, 116,  99, 104,
   32, 105, 110,  32, 118,  45,  62, 103, 109,  97, 116,  99, 104,  40,  34, 102,
   39,  40,  46,  45,  41,  39,  34,  41,  41, 123,  10,  32,  32,  32,  32,  32,
   32,  47,  47,  32, 114, 101, 112, 108,  97,  99, 101,  32, 116, 104, 101,  32,
  102,  39, 123, 125,  39,  32, 119, 105, 116, 104,  32, 115, 116, 114, 105, 110,
  103,  46, 102, 111, 114, 109,  97, 116,  40,  34, 123, 125,  34,  44,  32,  46,
   46,  46,  41,  10,  32,  32,  32,  32,  32,  32, 118,  32,  61,  32, 116, 121,
  112, 101,  99, 104, 101,  99, 107, 101, 114,  46, 114, 101, 118, 105, 118, 101,
   40, 118,  45,  62, 103, 115, 117,  98,  40,  34, 102,  39,  40,  46,  45,  41,
   39,  34,  44,  32,  34, 115, 116, 114, 105, 110, 103,  46, 102, 111, 114, 109,
   97, 116,  40,  39,  34,  46,  46, 109,  97, 116,  99, 104,  46,  46,  34,  39,
   34,  41,  44,  32, 100, 101,  97, 100,  41,  10,  32,  32,  32,  32,  32,  32,
   47,  47,  32, 102, 105, 110, 100,  32,  97, 108, 108,  32, 123, 125,  32, 105,
  110,  32, 116, 104, 101,  32, 115, 116, 114, 105, 110, 103,  10,  32,  32,  32,
   32,  32,  32, 102, 111, 114,  32,  40, 105, 116,  32, 105, 110,  32, 118,  45,
   62, 103, 109,  97, 116,  99, 104,  40,  34, 123,  40,  46,  45,  41, 125,  34,
   41,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  70,
  111, 114,  32, 101,  97,  99, 104,  32, 123, 125,  32,  97, 100, 100,  32,  97,
   32,  44,  32,  97, 110, 100,  32, 116, 104, 101,  32, 118,  97, 108, 117, 101,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  32,  61,  32, 118,  46,  46,
   34,  44,  32,  34,  46,  46, 105, 116,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  47,  47,  32,  97, 108, 115, 111,  32, 114, 101, 112, 108,  97,  99, 101,
   32, 116, 104, 101,  32, 123, 125,  32, 119, 105, 116, 104,  32,  37, 115,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 118,  32,  61,  32, 118,  45,  62, 103,
  115, 117,  98,  40,  34, 123,  40,  46,  45,  41, 125,  34,  44,  32,  34,  37,
   37, 115,  34,  41,  10,  32,  32,  32,  32,  32,  32, 125,  10,  10,  32,  32,
   32,  32,  32,  32,  47,  47,  32,  97, 100, 100,  32, 116, 104, 101,  32,  99,
  108, 111, 115, 105, 110, 103,  32,  98, 114,  97,  99, 107, 101, 116,  10,  32,
   32,  32,  32,  32,  32, 118,  32,  61,  32, 118,  46,  46,  34,  41,  34,  10,
   32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40,
  109,  97, 116,  99, 104,  32, 105, 110,  32, 118,  45,  62, 103, 109,  97, 116,
   99, 104,  40,  34, 102,  91,  91,  40,  46,  42,  41,  93,  93,  34,  41,  41,
  123,  10,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,  34,  92,
   50,  55,  91,  49,  59,  51,  49, 109,  80, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  32, 101, 114, 114, 111, 114,  58,  92,  50,  55,  91,  48,
  109,  34,  41,  10,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,
   34,  92,  50,  55,  91,  49,  59,  51,  49, 109,  69, 114, 114, 111, 114,  32,
  119, 105, 116, 104,  32, 116, 104, 101,  32,  39, 102,  91,  91,  39,  32, 112,
  114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32,  99, 111, 109, 109,
   97, 110, 100,  46,  92,  50,  55,  91,  48, 109,  92, 110,  92, 110,  34,  41,
   10,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 101, 114, 114, 111, 114,
  105, 110,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49, 109,
   77, 117, 108, 116, 105, 108, 105, 110, 101,  32, 102, 111, 114, 109,  97, 116,
  116, 101, 100,  32, 115, 116, 114, 105, 110, 103, 115,  32,  97, 114, 101,  32,
  110, 111, 116,  32, 115, 117, 112, 112, 111, 114, 116, 101, 100,  46,  92,  50,
   55,  91,  48, 109,  92, 110,  92, 110,  34,  41,  10,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,  34,
   92,  50,  55,  91,  49,  59,  51,  49, 109,  83, 116, 111, 112, 112, 105, 110,
  103,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46,  92,
   50,  55,  91,  48, 109,  34,  41,  10,  32,  32,  32,  32,  32,  32, 111, 115,
   46, 101, 120, 105, 116,  40,  41,  10,  32,  32,  32,  32, 125,  10,  10,  32,
   32,  32,  32, 108, 105, 110, 101, 115,  91, 105,  93,  32,  61,  32, 116, 121,
  112, 101,  99, 104, 101,  99, 107, 101, 114,  46, 114, 101, 118, 105, 118, 101,
   40, 118,  41,  10,  32,  32, 125,  10,  10,  10,  32,  32, 114, 101, 116, 117,
  114, 110,  32, 116,  97,  98, 108, 101,  46,  99, 111, 110,  99,  97, 116,  40,
  108, 105, 110, 101, 115,  44,  34,  92, 110,  34,  41,  10, 125,  10,  10,  47,
   47,  32,  83,  69,  67,  84,  73,  79,  78,  32,  51,  58,  32,  73, 110, 116,
  101, 114, 102,  97,  99, 101,  32,  38,  32,  80, 114, 101, 112, 114, 111,  99,
  101, 115, 115, 111, 114,  32, 100, 105, 114, 101,  99, 116, 105, 118, 101, 115,
   10,  10,  47,  42,  32,  68, 101, 112, 101, 110, 100, 101, 110,  99, 105, 101,
  115,  10,  32,  32,  32,  47,  47,  32, 102, 105, 108, 101, 120,  32,  40,  73,
  110, 115, 116,  97, 108, 108, 101, 100,  32, 119, 105, 116, 104,  32,  96, 109,
   97, 107, 101,  32, 115, 101, 116, 117, 112,  96,  41,  10,  32,  32,  32,  47,
   47,  32,  99, 111, 114, 101,  10,  32,  32,  32,  47,  47,  32, 102, 102, 105,
   10,  32,  32,  32,  47,  47,  32,  98,  97, 115, 101,  32, 108, 105,  98, 114,
   97, 114, 105, 101, 115,  10,  42,  47,  10,  10,  47,  42,  32,  78, 111, 116,
  101, 115,  10,  32,  32,  32,  32,  45,  32,  84, 104, 101,  32, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  32, 105, 115,  32, 110, 111, 116,
   32,  97, 112,  97, 114, 116,  32, 111, 102,  32, 116, 104, 101,  32,  99, 111,
  109, 112, 105, 108, 101, 114,  10,  32,  32,  32,  32,  45,  32,  85, 115, 105,
  110, 103,  32,  67,  32,  77,  97,  99, 114, 111, 115,  32, 114, 101, 113, 117,
  105, 114, 101,  32,  71,  67,  67,  32, 116, 111,  32,  98, 101,  32, 105, 110,
  115, 116,  97, 108, 108, 101, 100,  32,  40,  65, 115,  32, 111, 102,  32, 116,
  104, 101,  32,  96,  99, 111, 114, 101,  96,  32, 108, 105,  98, 114,  97, 114,
  121,  32, 100, 101, 112, 101, 110, 100, 101, 110,  99, 121,  41,  10,  42,  47,
   10,  10,  47,  42,  32,  84,  79,  68,  79,  58,  10,  32,  32,  32,  32,  45,
   32,  65,  99, 116, 117,  97, 108, 108, 121,  32, 115, 117,  98, 115, 116, 105,
  116, 117, 116, 101,  32, 109,  97,  99, 114, 111, 115,  32,  38,  32, 100, 101,
  102, 105, 110, 105, 116, 105, 111, 110, 115,  10,  42,  47,  10,  10,  47,  42,
   32,  83, 117, 112, 112, 111, 114, 116, 115,  10,  32,  32,  32,  47,  47,  32,
   69, 110,  97,  98, 108, 101, 100,  58,  10,  32,  32,  32,  32,  47,  47,  32,
   35, 111, 112, 101, 110,  32,  40, 110,  97, 109, 101,  41,  58,  32,  67, 104,
  101,  99, 107, 115,  32, 105, 102,  32,  97,  32,  77,  97,  99, 114, 111,  32,
  105, 115,  32, 100, 101, 102, 105, 110, 101, 100,  32,  97, 110, 100,  32, 111,
  112, 101, 110, 115,  32, 105, 116,  32, 115, 111,  32, 116, 104,  97, 116,  32,
  116, 104, 101,  32, 112, 114, 111, 103, 114,  97, 109,  32,  99,  97, 110,  32,
  117, 115, 101,  32, 105, 116,  10,  32,  32,  32,  32,  47,  47,  32,  35, 100,
  101, 102, 105, 110, 101,  32,  40, 110,  97, 109, 101,  41,  32,  40, 118,  97,
  108, 117, 101,  32,  60, 111, 112, 116, 105, 111, 110,  97, 108,  62,  41,  58,
   32,  83, 101, 116, 115,  32,  97,  32, 109,  97,  99, 114, 111,  10,  32,  32,
   32,  32,  47,  47,  32,  35, 100, 101, 102, 105, 110, 101,  32,  40, 108,  97,
  109,  98, 100,  97, 110,  97, 109, 101,  41,  40,  97, 114, 103, 115,  41,  32,
   40, 102, 117, 110,  99, 116, 105, 111, 110,  41,  58,  32,  83, 101, 116, 115,
   32,  97,  32, 109,  97,  99, 114, 111,  32, 116, 111,  32,  97,  32, 108,  97,
  109,  98, 100,  97,  32, 102, 117, 110,  99, 116, 105, 111, 110,  10,  32,  32,
   32,  32,  47,  47,  32,  35, 117, 110, 100, 101, 102,  32,  40, 110,  97, 109,
  101,  41,  58,  32,  82, 101, 109, 111, 118, 101, 115,  32,  97,  32, 109,  97,
   99, 114, 111,  10,  32,  32,  32,  32,  47,  47,  32,  35, 105, 102, 100, 101,
  102,  32,  40, 110,  97, 109, 101,  41,  58,  32,  73, 102,  32, 109,  97,  99,
  114, 111,  32, 105, 115,  32, 100, 101, 102, 105, 110, 101, 100,  44,  32,  67,
  111, 110, 100, 105, 116, 105, 111, 110,  32, 109, 117, 115, 116,  32,  98, 101,
   32, 119, 114,  97, 112, 112, 101, 100,  32, 105, 110,  32,  40,  41,  10,  32,
   32,  32,  32,  47,  47,  32,  35, 105, 102, 110, 100, 101, 102,  32,  40, 110,
   97, 109, 101,  41,  58,  32,  73, 102,  32, 109,  97,  99, 114, 111,  32, 105,
  115,  32, 110, 111, 116,  32, 100, 101, 102, 105, 110, 101, 100,  44,  32,  67,
  111, 110, 100, 105, 116, 105, 111, 110,  32, 109, 117, 115, 116,  32,  98, 101,
   32, 119, 114,  97, 112, 112, 101, 100,  32, 105, 110,  32,  40,  41,  10,  32,
   32,  32,  32,  47,  47,  32,  35, 101, 108, 105, 102,  32,  40, 110,  97, 109,
  101,  41,  58,  32,  69, 108, 115, 101,  32, 105, 102,  32, 109,  97,  99, 114,
  111,  32, 105, 115,  32, 100, 101, 102, 105, 110, 101, 100,  44,  32,  67, 111,
  110, 100, 105, 116, 105, 111, 110,  32, 109, 117, 115, 116,  32,  98, 101,  32,
  119, 114,  97, 112, 112, 101, 100,  32, 105, 110,  32,  40,  41,  10,  32,  32,
   32,  32,  47,  47,  32,  35, 101, 108, 115, 101,  58,  32,  69, 108, 115, 101,
   44,  32, 110, 111,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  10,  32,
   32,  32,  32,  47,  47,  32,  35, 101, 110, 100, 105, 102,  58,  32,  69, 110,
  100,  32, 105, 102,  10,  32,  32,  32,  32,  47,  47,  32,  35, 101, 114, 114,
  111, 114,  32,  40, 109, 101, 115, 115,  97, 103, 101,  41,  58,  32,  82,  97,
  105, 115, 101, 115,  32,  97, 110,  32, 101, 114, 114, 111, 114,  10,  32,  32,
   32,  32,  47,  47,  32,  35, 119,  97, 114, 110, 105, 110, 103,  32,  40, 109,
  101, 115, 115,  97, 103, 101,  41,  58,  32,  82,  97, 105, 115, 101, 115,  32,
   97,  32, 119,  97, 114, 110, 105, 110, 103,  10,  10,  32,  32,  32,  47,  47,
   32,  68, 105, 115,  97,  98, 108, 101, 100,  58,  10,  32,  32,  32,  32,  47,
   47,  32,  35, 105, 110,  99, 108, 117, 100, 101,  32,  34, 102, 105, 108, 101,
   46,  99, 111,  98,  97, 108, 116,  34,  58,  32,  73, 110,  99, 108, 117, 100,
  101, 115,  32,  97,  32, 102, 105, 108, 101,  32,  40,  67, 121,  99, 108, 105,
   99,  32, 100, 101, 112, 101, 110, 100, 101, 110,  99, 105, 101, 115,  32, 119,
  105, 108, 108,  32, 108, 101,  97, 118, 101,  32, 116, 104, 101,  32, 112, 114,
  101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32, 105, 110,  32,  97, 110,
   32, 105, 110, 102, 105, 110, 105, 116, 101,  32, 108, 111, 111, 112,  41,  32,
   40,  78,  97, 109, 101,  32, 109, 117, 115, 116,  32,  98, 101,  32, 105, 110,
   32,  34,  34,  41,  10,  32,  32,  32,  32,  47,  47,  32,  35, 108, 105, 110,
  101,  32,  40, 108, 105, 110, 101,  41,  32,  34, 102, 105, 108, 101,  46,  99,
  111,  98,  97, 108, 116,  32,  60, 111, 112, 116, 105, 111, 110,  97, 108,  62,
   34,  58,  32,  83, 101, 116, 115,  32, 116, 104, 101,  32, 108, 105, 110, 101,
   32, 110, 117, 109,  98, 101, 114,  32,  97, 110, 100,  32, 102, 105, 108, 101,
   32, 110,  97, 109, 101,  32, 102, 111, 114,  32, 116, 104, 101,  32, 112, 114,
  101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32,  40,  67, 121,  99, 108,
  105,  99,  32, 100, 101, 112, 101, 110, 100, 101, 110,  99, 105, 101, 115,  32,
  119, 105, 108, 108,  32, 108, 101,  97, 118, 101,  32, 116, 104, 101,  32, 112,
  114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32, 105, 110,  32,  97,
  110,  32, 105, 110, 102, 105, 110, 105, 116, 101,  32, 108, 111, 111, 112,  41,
   32,  40,  78,  97, 109, 101,  32, 109, 117, 115, 116,  32,  98, 101,  32, 105,
  110,  32,  34,  34,  41,  10,  10,  10,  32,  32,  32,  32,  47,  47,  32,  69,
  118, 101, 114, 121, 116, 104, 105, 110, 103,  32, 101, 108, 115, 101,  32, 116,
  104,  97, 116,  32, 115, 116,  97, 114, 116, 115,  32, 119, 105, 116, 104,  32,
   97,  32,  35,  32, 119, 105, 108, 108,  32,  98, 101,  32, 101, 120, 101,  99,
  117, 116, 101, 100,  32,  97, 115,  32,  97,  32,  99, 111,  98,  97, 108, 116,
   32, 115, 111, 117, 114,  99, 101,  32, 108, 105, 110, 101,  10,  32,  32,  32,
   32,  47,  47,  32,  67,  32,  77,  97,  99, 114, 111, 115,  32,  97, 114, 101,
   32, 115, 117, 112, 112, 111, 114, 116, 101, 100,  32, 105, 102,  32,  71,  67,
   67,  32, 105, 115,  32, 105, 110, 115, 116,  97, 108, 108, 101, 100,  44,  32,
  105, 102,  32, 110, 111, 116,  44,  32, 116, 104, 101, 121,  32, 119, 105, 108,
  108,  32,  98, 101,  32, 105, 103, 110, 111, 114, 101, 100,  46,  10,  32,  32,
   32,  32,  47,  47,  32,  99, 111,  98,  97, 108, 116,  32,  97, 110, 100,  32,
   99, 111,  98,  97, 108, 116, 118, 101, 114, 115, 105, 111, 110,  32,  97, 114,
  101,  32, 105, 110,  99, 108, 117, 100, 101, 100,  32, 109,  97,  99, 114, 111,
  115,  10,  42,  47,  10,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 112,
  114, 111,  99, 101, 115, 115,  40, 115, 116, 114,  44,  32, 105, 116, 101, 109,
  116, 121, 112, 101,  44,  32, 111, 117, 116,  44,  32, 111, 117, 116, 102, 105,
  108, 101,  44,  32,  46,  46,  46,  41, 123,  10,  32,  32,  32,  32,  47,  47,
   32,  48,  58,  32,  73, 110, 105, 116,  10,  32,  32,  32,  32,  10,  32,  32,
   32,  32,  47,  47,  47,  32,  67, 104, 101,  99, 107,  32, 109, 111, 100, 101,
   58,  10,  32,  32,  32,  32, 105, 102,  32,  40, 111, 117, 116, 102, 105, 108,
  101,  32,  61,  61,  32,  34,  45, 116, 121, 112, 101, 115,  34,  32, 124, 124,
   32,  40, 115, 116, 114,  32,  61,  61,  32,  34,  45, 116, 121, 112, 101, 115,
   34,  32,  38,  38,  32,  33, 111, 117, 116, 102, 105, 108, 101,  41,  32,  41,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 116, 121, 112, 101,  99, 104,
  101,  99, 107, 101, 114,  46,  97, 108, 108,  40,  41,  32,  47,  47,  32,  80,
  114, 105, 110, 116,  32,  97, 108, 108,  32, 118,  97, 108, 105, 100,  32, 116,
  121, 112, 101, 115,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116,
  117, 114, 110,  59,  10,  32,  32,  32,  32, 125, 105, 102,  32,  40, 123,  46,
   46,  46, 125,  32,  61,  61,  32, 123, 125,  41, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 101, 114, 114, 111, 114,  40,  34,  78, 111,  32,  97, 114,
  103, 117, 109, 101, 110, 116, 115,  32, 111, 114,  32, 105, 110, 118,  97, 108,
  105, 100,  32, 102, 108,  97, 103, 115,  32, 112, 114, 111, 118, 105, 100, 101,
  100,  46,  34,  41,  10,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,
   47,  47,  47,  32,  73, 110, 105, 116,  32, 109,  97,  99, 114, 111, 115,  10,
   32,  32,  32,  32, 109,  97,  99, 114, 111, 115,  40,  41,  10,  10,  32,  32,
   32,  32,  47,  47,  32,  49,  58,  32,  83, 112, 108, 105, 116,  32, 108, 105,
  110, 101, 115,  10,  32,  32,  32,  32, 118,  97, 114,  32, 110, 115, 116, 114,
   10,  32,  32,  32,  32, 118,  97, 114,  32, 111, 103, 115, 116, 114,  32,  61,
   32, 111, 117, 116,  32,  63,  32, 115, 116, 114,  32,  58,  32, 110, 117, 108,
  108,  10,  32,  32,  32,  32, 105, 102,  32,  40, 105, 116, 101, 109, 116, 121,
  112, 101,  32,  61,  61,  32,  34, 102, 105, 108, 101,  34,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 102, 105, 108, 101,
   32,  61,  32, 105, 111,  46, 111, 112, 101, 110,  40, 115, 116, 114,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33, 102, 105, 108,
  101,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  101, 114, 114, 111, 114,  40,  99, 111, 114, 101,  46, 101, 114, 114, 111, 114,
   46, 115, 116, 114, 101, 114, 114, 111, 114,  40,  50,  41,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  110, 115, 116, 114,  32,  61,  32, 102, 105, 108, 101,  45,  62, 114, 101,  97,
  100,  40,  34,  42,  97, 108, 108,  34,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 102, 105, 108, 101,  45,  62,  99, 108, 111, 115, 101,  40,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33, 110, 115, 116,
  114,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  101, 114, 114, 111, 114,  40,  99, 111, 114, 101,  46, 101, 114, 114, 111, 114,
   46, 115, 116, 114, 101, 114, 114, 111, 114,  40,  50,  41,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  47,  47,  32,  48,  58,  32,  82, 117, 110,  32, 116, 121, 112, 101,
   99, 104, 101,  99, 107, 101, 114,  32,  97, 110, 100,  32, 108,  97, 110, 103,
  117,  97, 103, 101,  32, 101, 120, 116, 101, 110, 115, 105, 111, 110, 115,  10,
   32,  32,  32,  32,  10,  32,  32,  32,  32, 105, 102,  32,  40,  33, 110, 115,
  116, 114,  41,  32, 110, 115, 116, 114,  32,  61,  32, 115, 116, 114,  10,  32,
   32,  32,  32, 116, 121, 112, 101,  99, 104, 101,  99, 107, 101, 114,  46,  99,
  104, 101,  99, 107,  40, 110, 115, 116, 114,  41,  10,  32,  32,  32,  32, 110,
  115, 116, 114,  32,  61,  32, 101, 120, 116,  40, 110, 115, 116, 114,  41,  10,
   10,  32,  32,  32,  32,  47,  47,  32,  48,  46,  53,  58,  32,  83, 112, 108,
  105, 116,  32, 108, 105, 110, 101, 115,  10,  32,  32,  32,  32, 118,  97, 114,
   32, 108, 105, 110, 101, 115,  32,  61,  32,  91,  93,  10,  32,  32,  32,  32,
  102, 111, 114,  32,  40, 108, 105, 110, 101,  32, 105, 110,  32, 110, 115, 116,
  114,  45,  62, 103, 109,  97, 116,  99, 104,  40,  34,  91,  94,  92, 114,  92,
  110,  93,  43,  34,  41,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 108, 105, 110, 101, 115,  91,  35, 108, 105, 110, 101, 115,  32,  43,  32,
   49,  93,  32,  61,  32, 108, 105, 110, 101,  10,  32,  32,  32,  32, 125,  10,
   10,  32,  32,  32,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32, 103, 101,
  116, 110,  97, 109, 101,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  32,  40, 111, 103, 115, 116, 114,  41, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  99, 119, 100,  47,
  111, 103, 115, 116, 114,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 114, 101, 116, 117, 114, 110,  32, 102, 105, 108, 101, 120,  46, 106,
  111, 105, 110,  40, 102, 105, 108, 101, 115, 121, 115, 116, 101, 109,  46,  99,
  117, 114, 114, 101, 110, 116, 100, 105, 114,  40,  41,  44,  32, 111, 103, 115,
  116, 114,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125, 101, 108, 115,
  101, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32, 100, 101,  98, 117, 103,  46, 103, 101, 116, 105,
  110, 102, 111,  40,  50,  44,  32,  34,  83,  34,  41,  46, 115, 111, 117, 114,
   99, 101,  45,  62, 115, 117,  98,  40,  50,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,
   47,  47,  32,  50,  58,  32,  76, 111, 111, 107,  32, 102, 111, 114,  32, 112,
  114, 101, 112, 114, 111,  99, 101, 115, 115,  32, 108, 105, 110, 101, 115,  10,
   32,  32,  32,  32, 118,  97, 114,  32, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115,  32,  61,  32,  91,  93,  10,  32,  32,  32,  32, 102, 111, 114,  32,
   40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 108,
  105, 110, 101, 115,  41,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 118,  97, 114,  32, 102, 105, 114, 115, 116,  32,  61,  32, 118,  45,  62,
  115, 117,  98,  40,  49,  44,  32,  49,  41,  32,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 118,  97, 114,  32,  99, 104,  97, 114,  32,  61,  32,  49,  10,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101,  32,  40,
  102, 105, 114, 115, 116,  32,  61,  61,  32,  34,  32,  34,  32, 124, 124,  32,
  102, 105, 114, 115, 116,  32,  61,  61,  32,  34,  92, 116,  34,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 104,  97,
  114,  43,  43,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 102, 105, 114, 115, 116,  32,  61,  32, 118,  45,  62, 115, 117,  98,  40,
   99, 104,  97, 114,  44,  32,  99, 104,  97, 114,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  32,  40, 102, 105, 114, 115, 116,  32,  61,  61,  32,  34,  35,  34,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   32,  61,  32, 118,  45,  62, 115, 117,  98,  40,  99, 104,  97, 114,  44,  32,
   35, 118,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105,
  110, 115, 101, 114, 116,  40, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,
   44,  32,  91, 105,  44,  32, 118,  93,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  10,  32,
   32,  32,  32,  47,  47,  32,  51,  58,  32,  69, 120, 101,  99, 117, 116, 101,
   32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,  32, 108, 105, 110, 101,
  115,  10,  32,  32,  32,  32, 118,  97, 114,  32, 101, 110, 118,  32,  61,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  34,  99, 111,  98,  97, 108,
  116,  34,  58,  32, 116, 114, 117, 101,  44,  32,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  34,  99, 111,  98,  97, 108, 116, 118, 101, 114, 115, 105, 111,
  110,  34,  58,  32,  34,  50,  51,  34,  44,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  34, 101, 100, 105, 116, 105, 111, 110,  34,  58,  32,  34, 115, 116,
   97, 110, 100,  97, 114, 100,  34,  44,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  34,  99, 112, 108, 117, 115, 112, 108, 117, 115,  34,  58,  32, 102,  97,
  108, 115, 101,  44,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  47,
   47,  32, 105, 110, 101, 110, 118,  32, 119, 105, 108, 108,  32,  98, 101,  32,
  108, 105, 107, 101,  58,  32,  45,  88,  61,  34, 116,  34,  32,  45,  77,  61,
   50,  32,  45,  90,  61, 116, 114, 117, 101,  32, 119, 105, 108, 108,  32,  98,
  101,  99, 111, 109, 101,  32, 123,  91,  34,  88,  34,  93,  61,  34, 116,  34,
   44,  32,  91,  34,  77,  34,  93,  61,  50,  44,  32,  91,  34,  90,  34,  93,
   61, 116, 114, 117, 101, 125,  10,  32,  32,  32,  32, 101, 110, 118, 105, 116,
  101, 109, 115,  32,  61,  32, 116,  97,  98, 108, 101,  46, 112,  97,  99, 107,
   40,  46,  46,  46,  41,  10,  32,  32,  32,  32, 105, 110, 101, 110, 118,  32,
   61,  32, 123, 125,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105,  44,
   32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 101, 110, 118, 105,
  116, 101, 109, 115,  41,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  32,  40, 116, 121, 112, 101,  40, 118,  41,  32,  61,  61,  32,  34,
  110, 117, 109,  98, 101, 114,  34,  41, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32, 115, 112, 108, 105, 116,  32,  61,  32, 118,  45,  62, 103, 115,
  117,  98,  40,  34,  45,  34,  44,  32,  34,  34,  41,  45,  62, 115, 112, 108,
  105, 116,  40,  34,  61,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 110, 101, 110, 118,  91, 115, 112, 108, 105, 116,  91,  49,  93,  93,  32,
   61,  32, 108, 111,  97, 100, 115, 116, 114, 105, 110, 103,  40,  34, 114, 101,
  116, 117, 114, 110,  32,  34,  46,  46, 115, 112, 108, 105, 116,  91,  50,  93,
   41,  40,  41,  10,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  47,
   47,  32,  52,  58,  32,  65, 100, 100,  32, 105, 110, 101, 110, 118,  32, 116,
  111,  32, 101, 110, 118,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105,
   44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 105, 110, 101,
  110, 118,  41,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,
   32,  40, 116, 121, 112, 101,  40, 118,  41,  32,  61,  61,  32,  34, 115, 116,
  114, 105, 110, 103,  34,  41,  32, 118,  32,  61,  32,  39,  34,  39,  46,  46,
  118,  46,  46,  39,  34,  39,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101,
  110, 118,  91, 105,  93,  32,  61,  32, 118,  10,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32, 118,  97, 114,  32, 110, 101, 119, 108, 105, 110, 101, 115,
   32,  61,  32, 108, 105, 110, 101, 115,  10,  32,  32,  32,  32, 118,  97, 114,
   32,  97,  99, 116, 105, 118, 101, 105, 102, 115,  32,  61,  32,  91,  93,  10,
   32,  32,  32,  32, 118,  97, 114,  32, 114, 117, 110,  32,  61,  32, 116, 114,
  117, 101,  10,  32,  32,  32,  32, 118,  97, 114,  32, 105, 110,  99, 111, 109,
  109, 101, 110, 116,  32,  61,  32, 102,  97, 108, 115, 101,  10,  10,  32,  32,
   32,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32, 101, 110, 118, 108, 111,
   97, 100,  40, 115, 116, 114,  50,  41, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32, 116,  98, 108, 100,  32,  61,  32,  34, 123,  34,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 107,  44,
   32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 101, 110, 118,  41,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  32,  40, 116, 121, 112, 101,  40, 107,  41,  32,  61,  61,  32,  34,
  110, 117, 109,  98, 101, 114,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116,  98, 108, 100,  32,
   61,  32, 116,  98, 108, 100,  32,  46,  46,  32, 118,  32,  46,  46,  32,  34,
   44,  34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
  101, 108, 115, 101,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40, 107,  41,
   32,  61,  61,  32,  34, 115, 116, 114, 105, 110, 103,  34,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  116,  98, 108, 100,  32,  61,  32, 116,  98, 108, 100,  32,  46,  46,  32,  39,
   34,  39,  32,  46,  46,  32, 107,  32,  46,  46,  32,  39,  34,  58,  32,  39,
   32,  46,  46,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 118,  41,  32,
   46,  46,  32,  34,  44,  34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 116,  98, 108, 100,  32,  61,  32, 116,  98,
  108, 100,  32,  46,  46,  32,  34, 125,  34,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 114, 101, 116, 117, 114, 110,  32, 108, 111,  97, 100, 115, 116, 114,
  105, 110, 103,  40,  91,  61,  91,  47,  47,  32,  67, 111,  98,  97, 108, 116,
   32, 101, 120, 101,  99, 117, 116, 105, 111, 110,  32, 101, 110, 118, 105, 114,
  111, 110, 109, 101, 110, 116,  58,  32,  73, 103, 110, 111, 114, 101,  46,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 118,  32,
   61,  32,  93,  61,  93,  46,  46, 116,  98, 108, 100,  46,  46,  91,  61,  91,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111,
  114,  32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,
   40, 101, 110, 118,  41,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  95,  69,  78,  86,  91, 105,  93,  32,
   61,  32, 118,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111,
  114, 101,  32,  61,  32, 105, 109, 112, 111, 114, 116,  40,  34,  99, 111, 114,
  101,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  102, 117, 110,  99, 116, 105, 111, 110,  32, 100, 101, 102, 105, 110, 101, 100,
   40, 118,  97, 108,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  99, 104, 101,  99, 107,  32,
  105, 102,  32, 105, 116,  32, 105, 115,  32, 105, 110,  32, 101, 110, 118,  44,
   32, 105, 102,  32, 105, 116,  32, 114, 101, 116, 117, 114, 110,  32, 116, 104,
  101,  32, 118,  97, 108, 117, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 101, 110, 118,  91,
  118,  97, 108,  93,  32,  33,  61,  32, 110, 117, 108, 108,  32,  38,  38,  32,
  101, 110, 118,  91, 118,  97, 108,  93,  32,  33,  61,  32, 102,  97, 108, 115,
  101,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,
  101, 110, 118,  91, 118,  97, 108,  93,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  93,  61,  93,  46,  46, 115, 116, 114,
   50,  41,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 102, 111, 114,
   32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40,
  108, 105, 110, 101, 115,  41,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  47,  47,  32,  67, 104, 101,  99, 107,  32, 105, 102,  32, 105,  32,
  105, 115,  32, 118,  91,  49,  93,  32, 102, 111, 114,  32, 111, 110, 101,  32,
  111, 102,  32, 116, 104, 101,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115,
  115,  32, 108, 105, 110, 101, 115,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  47,  32,  71, 111,  32, 116, 104, 114, 111, 117, 103, 104,  32, 101,
  118, 101, 114, 121,  32,  99, 104,  97, 114,  97,  99, 116, 101, 114,  44,  32,
  105, 102,  32,  97,  32,  47,  42,  32, 105, 115,  32, 102, 111, 117, 110, 100,
   32, 109,  97, 107, 101,  32, 105, 110,  99, 111, 109, 109, 101, 110, 116,  32,
  116, 114, 117, 101,  44,  32, 105, 102,  32,  97,  32,  42,  47,  32, 105, 115,
   32, 102, 111, 117, 110, 100,  32, 109,  97, 107, 101,  32, 105, 110,  99, 111,
  109, 109, 101, 110, 116,  32, 102,  97, 108, 115, 101,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  47,  32,  73, 102,  32, 105, 110,  99, 111, 109,
  109, 101, 110, 116,  32, 105, 115,  32, 116, 114, 117, 101,  44,  32, 114, 101,
  109, 111, 118, 101,  32, 116, 104, 101,  32, 108, 105, 110, 101,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,  32,  61,  32,
   49,  44,  32,  35, 118,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 118,  97, 114,  32,  99, 104,  97, 114,  32,  61,  32,
  118,  45,  62, 115, 117,  98,  40, 105, 105,  44,  32, 105, 105,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  99,
  104,  97, 114,  32,  61,  61,  32,  34,  47,  34,  32,  38,  38,  32, 118,  45,
   62, 115, 117,  98,  40, 105, 105,  32,  43,  32,  49,  44,  32, 105, 105,  32,
   43,  32,  49,  41,  32,  61,  61,  32,  34,  42,  34,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  110,  99, 111, 109, 109, 101, 110, 116,  32,  61,  32, 116, 114, 117, 101,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  99, 104,
   97, 114,  32,  61,  61,  32,  34,  42,  34,  32,  38,  38,  32, 118,  45,  62,
  115, 117,  98,  40, 105, 105,  32,  43,  32,  49,  44,  32, 105, 105,  32,  43,
   32,  49,  41,  32,  61,  61,  32,  34,  47,  34,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 110,
   99, 111, 109, 109, 101, 110, 116,  32,  61,  32, 102,  97, 108, 115, 101,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  32,  40, 105, 110,  99, 111, 109, 109, 101, 110, 116,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 110,
  116, 105, 110, 117, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 102, 111, 117,
  110, 100,  32,  61,  32, 102,  97, 108, 115, 101,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 102, 111, 114,  32,  40, 105,  50,  44,  32, 118,  50,  32, 105,
  110,  32, 112,  97, 105, 114, 115,  40, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115,  41,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 102,  32,  40, 118,  50,  91,  49,  93,  32,  61,  61,  32,
  105,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 118,  32,  61,  32, 118,  50,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 117, 110,
  100,  32,  61,  32, 116, 114, 117, 101,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  32,  40,  33, 102, 111, 117, 110, 100,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33, 114,
  117, 110,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 105,
   93,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  99, 111, 110, 116, 105, 110, 117, 101,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32,  71, 101, 116,  32, 116, 104, 101,  32, 102, 105, 114, 115, 116,
   32, 119, 111, 114, 100,  32, 111, 102,  32, 116, 104, 101,  32, 108, 105, 110,
  101,  10,  32,  32,  32,  32,  32,  32,  32,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  40, 101, 114, 114, 111, 114, 105, 110,  41, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110, 116,
   40,  34,  92,  50,  55,  91,  49,  59,  51,  49, 109,  80, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 111, 114,  32, 101, 114, 114, 111, 114,  58,  92,  50,
   55,  91,  48, 109,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,
   51,  49, 109,  69, 114, 114, 111, 114,  32, 119, 105, 116, 104,  32, 116, 104,
  101,  32,  39,  34,  46,  46, 118,  91,  50,  93,  46,  46,  34,  39,  32, 112,
  114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32,  99, 111, 109, 109,
   97, 110, 100,  46,  92,  50,  55,  91,  48, 109,  92, 110,  92, 110,  34,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,
   40, 101, 114, 114, 111, 114, 105, 110,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110,
  116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49, 109,  34,  46,  46, 101,
  114, 114, 111, 114, 105, 110,  46,  46,  34,  92,  50,  55,  91,  48, 109,  92,
  110,  92, 110,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49, 109,
   83, 116, 111, 112, 112, 105, 110, 103,  32, 112, 114, 101, 112, 114, 111,  99,
  101, 115, 115, 111, 114,  46,  92,  50,  55,  91,  48, 109,  34,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 111, 115,  46, 101, 120,
  105, 116,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  73, 102,  32, 116, 104,
  101,  32, 115, 101,  99, 111, 110, 100,  32,  99, 104,  97, 114,  97,  99, 116,
  101, 114,  32, 105, 115,  32,  97,  32,  33,  44,  32, 105, 103, 110, 111, 114,
  101,  32, 116, 104, 101,  32, 108, 105, 110, 101,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 102,  32,  40, 118,  91,  50,  93,  45,  62, 115, 117,  98,
   40,  50,  44,  32,  50,  41,  32,  61,  61,  32,  34,  33,  34,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119,
  108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 110, 117,
  108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32,  47,  47,  32,  83, 107, 105, 112,  32, 116, 104,
  105, 115,  32, 108, 105, 110, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32, 115, 119, 105, 116,  99,
  104,  40, 118,  91,  50,  93,  45,  62, 109,  97, 116,  99, 104,  40,  34,  37,
   83,  43,  34,  41,  44,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  34,  35, 111, 112, 101, 110,  34,  58,  32, 102, 117, 110,
   99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  69, 120,  97, 109,
  112, 108, 101,  58,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32,  35, 111, 112, 101, 110,  32,  88,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32, 116, 104, 105, 115,  32, 105, 115,  32,  97, 115, 115, 117, 109,
  105, 110, 103,  32,  88,  32, 105, 115,  32, 105, 110,  32, 116, 104, 101,  32,
  101, 110, 118,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32, 118,  97, 114,  32,  88,  32,  61,  32,  60,
  119, 104,  97, 116, 101, 118, 101, 114,  32,  88,  32, 105, 115,  32, 105, 110,
   32, 116, 104, 101,  32, 101, 110, 118,  62,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 110,  97,
  109, 101,  32,  61,  32, 118,  91,  50,  93,  45,  62, 103, 115, 117,  98,  40,
   34,  35, 111, 112, 101, 110,  32,  34,  44,  32,  34,  34,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32, 118,  97, 108, 117, 101,  32,  61,  32, 101, 110, 118,  91, 110,  97,
  109, 101,  93,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  32,  40, 118,  97, 108, 117, 101,  32,  61,  61,
   32, 110, 117, 108, 108,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114,
  111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40,  34,
   77,  97,  99, 114, 111,  32,  39,  34,  46,  46, 110,  97, 109, 101,  46,  46,
   34,  39,  32, 105, 115,  32, 110, 111, 116,  32, 100, 101, 102, 105, 110, 101,
  100,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,
   91,  49,  93,  93,  32,  61,  32,  34, 118,  97, 114,  32,  34,  46,  46, 116,
  111, 115, 116, 114, 105, 110, 103,  40, 110,  97, 109, 101,  41,  46,  46,  34,
   32,  61,  32,  34,  46,  46,  40,  40, 116, 121, 112, 101,  40, 118,  97, 108,
  117, 101,  41,  32,  61,  61,  32,  34, 115, 116, 114, 105, 110, 103,  34,  32,
   38,  38,  32,  40, 115, 116, 114,  45,  62, 115, 117,  98,  40,  49,  44,  49,
   41,  32,  61,  61,  32,  39,  34,  39,  32,  38,  38,  32, 115, 116, 114,  45,
   62, 115, 117,  98,  40,  45,  49,  41,  32,  61,  61,  32,  39,  34,  39,  41,
   32, 124, 124,  32,  40, 115, 116, 114,  45,  62, 115, 117,  98,  40,  49,  44,
   49,  41,  32,  61,  61,  32,  34,  39,  34,  32,  38,  38,  32, 115, 116, 114,
   45,  62, 115, 117,  98,  40,  45,  49,  41,  32,  61,  61,  32,  34,  39,  34,
   41,  41,  32,  63,  32,  39,  34,  39,  46,  46, 118,  97, 108, 117, 101,  46,
   46,  39,  34,  39,  32,  58,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40,
  118,  97, 108, 117, 101,  41,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  65, 118, 111, 105,
  100,  32, 109, 101, 109, 111, 114, 121,  32, 108, 101,  97, 107, 115,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110,
   97, 109, 101,  44,  32, 118,  97, 108, 117, 101,  32,  61,  32, 110, 117, 108,
  108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  44,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  35, 100,
  101, 102, 105, 110, 101,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,
   40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32, 115, 112, 108, 105, 116,  32, 118,  91,  50,
   93,  32,  98, 121,  32, 115, 112,  97,  99, 101, 115,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,
  115, 112, 108, 105, 116,  32,  61,  32, 118,  91,  50,  93,  45,  62, 115, 112,
  108, 105, 116,  40,  34,  32,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  49,  58,  32,  71,
  101, 116,  32, 116, 104, 101,  32, 110,  97, 109, 101,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,
  110,  97, 109, 101,  32,  61,  32, 115, 112, 108, 105, 116,  91,  50,  93,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  32,  40, 115, 116, 114, 105, 110, 103,  46, 115, 117,  98,  40, 110,
   97, 109, 101,  44,  32,  45,  49,  41,  32,  61,  61,  32,  34,  41,  34,  41,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  47,  47,  32,  69, 120,  97, 109, 112, 108, 101,
   58,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  47,  47,  32,  35, 100, 101, 102, 105, 110, 101,
   32,  82,  65,  68,  84,  79,  68,  69,  71,  40, 114,  97, 100,  41,  32,  40,
  114,  97, 100,  32,  42,  32,  49,  56,  48,  32,  47,  32,  80,  73,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32, 115, 104, 111, 117, 108, 100,  32,  98, 101,
   99, 111, 109, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 118,  97, 114,  32,
   82,  65,  68,  84,  79,  68,  69,  71,  32,  61,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40, 114,  97, 100,  41, 123,  32, 114, 101, 116, 117, 114, 110,
   32,  40, 114,  97, 100,  32,  42,  32,  49,  56,  48,  32,  47,  32,  80,  73,
   41, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  49,  58,  32,  71, 101,
  116,  32, 116, 104, 101,  32, 110,  97, 109, 101,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32, 118,  97, 108, 117, 101, 115,  32,  61,  32, 115, 116, 114, 105,
  110, 103,  46, 115, 112, 108, 105, 116,  40, 118,  91,  50,  93,  44,  32,  34,
   32,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 100, 101, 102, 110,
   97, 109, 101,  32,  61,  32, 118,  97, 108, 117, 101, 115,  91,  50,  93,  45,
   62, 115, 112, 108, 105, 116,  40,  34,  40,  34,  41,  91,  49,  93,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 118,  97, 114,  32,  97, 114, 103, 115,  32,  61,  32, 118,  97,
  108, 117, 101, 115,  91,  50,  93,  45,  62, 115, 112, 108, 105, 116,  40,  34,
   40,  34,  41,  91,  50,  93,  45,  62, 103, 115, 117,  98,  40,  34,  37,  41,
   34,  44,  32,  34,  34,  41,  45,  62, 115, 112, 108, 105, 116,  40,  34,  44,
   34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 102, 117, 110,  99,  32,
   61,  32, 118,  97, 108, 117, 101, 115,  91,  51,  93,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  102, 111, 114,  32,  40, 105, 105,  32,  61,  32,  52,  44,  32,  35, 118,  97,
  108, 117, 101, 115,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  102, 117, 110,  99,  32,  61,  32, 102, 117, 110,  99,  46,  46,  34,  32,  34,
   46,  46, 118,  97, 108, 117, 101, 115,  91, 105, 105,  93,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,  44,  32,
  118, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40,  97, 114, 103, 115,
   41,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  97, 114, 103, 115,
   91, 105, 105,  93,  32,  61,  32, 118, 118,  45,  62, 103, 115, 117,  98,  40,
   34,  32,  34,  44,  32,  34,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 118,  97, 114,  32, 102, 117, 110,  99, 100, 101, 102,  32,
   61,  32,  34, 102, 117, 110,  99, 116, 105, 111, 110,  40,  34,  46,  46, 116,
   97,  98, 108, 101,  46,  99, 111, 110,  99,  97, 116,  40,  97, 114, 103, 115,
   44,  32,  34,  44,  34,  41,  46,  46,  34,  41, 123,  32, 114, 101, 116, 117,
  114, 110,  32,  34,  46,  46, 102, 117, 110,  99,  46,  46,  34,  59,  32, 125,
   34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 118,  97, 108, 100, 101, 102,
   32,  61,  32,  34, 118,  97, 114,  32,  34,  46,  46, 100, 101, 102, 110,  97,
  109, 101,  46,  46,  34,  32,  61,  32,  34,  46,  46, 102, 117, 110,  99, 100,
  101, 102,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  50,  58,  32,  83, 101,
  116,  32, 118,  97, 108, 117, 101, 115,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119,
  108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 118,  97,
  108, 100, 101, 102,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 118,  91, 110,  97, 109,
  101,  93,  32,  61,  32, 102, 117, 110,  99, 100, 101, 102,  10,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  47,  47,  32,  51,  58,  32,  67, 108, 101,  97, 114,  32, 109, 101,
  109, 111, 114, 121,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 108, 117, 101, 115,  44,
   32, 100, 101, 102, 110,  97, 109, 101,  44,  32, 102, 117, 110,  99, 100, 101,
  102,  44,  32, 118,  97, 108, 100, 101, 102,  44,  32,  97, 114, 103, 115,  44,
   32, 102, 117, 110,  99,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125, 101, 108,
  115, 101, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  50,  58,  32,  71, 101,
  116,  32, 116, 104, 101,  32, 118,  97, 108, 117, 101,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 118,  97, 108, 117, 101,  32,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32, 102, 117, 110,  44,  32, 101, 114, 114,  32,  61,  32, 101, 110,
  118, 108, 111,  97, 100,  40,  34, 114, 101, 116, 117, 114, 110,  32,  34,  46,
   46, 115, 112, 108, 105, 116,  91,  51,  93,  32, 124, 124,  32,  34, 102,  97,
  108, 115, 101,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33, 102,
  117, 110,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114,
  111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40, 101,
  114, 114,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125, 101, 108, 115, 101, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 108, 117, 101,  32,  61,  32, 102,
  117, 110,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,
   47,  32,  51,  58,  32,  83, 101, 116,  32, 116, 104, 101,  32, 118,  97, 108,
  117, 101,  32, 105, 110,  32, 116, 104, 101,  32, 101, 110, 118,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 101, 110, 118,  91, 110,  97, 109, 101,  93,  32,  61,  32, 118,  97,
  108, 117, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  52,  58,  32,  82, 101,
  109, 111, 118, 101,  32, 116, 104, 101,  32, 108, 105, 110, 101,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,
   32,  61,  32,  34, 118,  97, 114,  32,  34,  46,  46, 110,  97, 109, 101,  46,
   46,  34,  32,  61,  32,  34,  46,  46,  40, 116, 121, 112, 101,  40, 118,  97,
  108, 117, 101,  41,  32,  61,  61,  32,  34, 115, 116, 114, 105, 110, 103,  34,
   32,  63,  32,  39,  34,  39,  46,  46, 118,  97, 108, 117, 101,  46,  46,  39,
   34,  39,  32,  58,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 118,  97,
  108, 117, 101,  41,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  35,
   35, 108, 105, 110, 101,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,
   40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32,  69, 120,  97, 109, 112, 108, 101,  58,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32,  35, 108, 105, 110, 101,  32,  49,  32,  34, 102, 105, 108, 101,
   46,  99, 111,  98,  97, 108, 116,  34,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  87, 105, 108, 108,
   32,  97, 100, 100,  32, 101, 118, 101, 114, 121, 116, 104, 105, 110, 103,  32,
   97, 102, 116, 101, 114,  32, 116, 104,  97, 116,  32, 108, 105, 110, 101,  32,
  105, 110,  32, 116, 104,  97, 116,  32, 102, 105, 108, 101,  32, 116, 111,  32,
  116, 104, 101,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 105,  93,  32,
  116,  97,  98, 108, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  47,  47,  32,  34, 102, 105, 108, 101,  46,  99,
  111,  98,  97, 108, 116,  34,  32, 105, 102,  32, 105, 116,  32, 105, 115,  32,
  110, 111, 116,  32, 112, 114, 111, 118, 105, 100, 101, 100,  32, 105, 116,  32,
  105, 115,  32, 116, 104, 101,  32,  99, 117, 114, 114, 101, 110, 116,  32, 102,
  105, 108, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32,  49,  32, 105, 115,  32, 116, 104, 101,  32,
  108, 105, 110, 101,  32, 110, 117, 109,  98, 101, 114,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 119,  97, 114, 110,
   40,  34,  85, 115, 105, 110, 103,  32,  35, 108, 105, 110, 101,  32, 105, 115,
   32, 110, 111, 116,  32, 114, 101,  99, 111, 109, 109, 101, 110, 100, 101, 100,
   44,  32,  85, 115, 101,  32, 105, 109, 112, 111, 114, 116,  40,  41,  32, 105,
  110, 115, 116, 101,  97, 100,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 115, 112, 108,
  105, 116,  32,  61,  32, 118,  91,  50,  93,  45,  62, 115, 112, 108, 105, 116,
   40,  34,  32,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 108, 105, 110, 101,  32,  61,
   32, 115, 112, 108, 105, 116,  91,  50,  93,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 102, 105,
  108, 101, 110,  97, 109, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33, 115, 112, 108, 105,
  116,  91,  51,  93,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 105, 108, 101,
  110,  97, 109, 101,  32,  61,  32, 103, 101, 116, 110,  97, 109, 101,  40,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125, 101, 108, 115, 101, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 105, 108, 101,
  110,  97, 109, 101,  32,  61,  32, 115, 116, 114, 105, 110, 103,  46, 115, 117,
   98,  40, 115, 112, 108, 105, 116,  91,  51,  93,  44,  32,  50,  44,  32,  45,
   50,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40, 102, 105, 108, 101, 110,
   97, 109, 101,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 118,  97, 114,  32, 102,  32,  61,  32, 105, 111,  46,
  111, 112, 101, 110,  40, 102, 105, 108, 101, 110,  97, 109, 101,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  32,  40,  33, 102,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,
   32, 115,  99, 114, 105, 112, 116,  95, 112,  97, 116, 104,  32,  61,  32, 103,
  101, 116, 110,  97, 109, 101,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,
   32, 115,  99, 114, 105, 112, 116,  95, 100, 105, 114,  32,  61,  32, 115,  99,
  114, 105, 112, 116,  95, 112,  97, 116, 104,  45,  62, 109,  97, 116,  99, 104,
   40,  34,  40,  46,  42,  47,  41,  34,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,
   32,  40, 115,  99, 114, 105, 112, 116,  95, 100, 105, 114,  32,  61,  61,  32,
  110, 117, 108, 108,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  115,  99, 114, 105, 112, 116,  95, 100, 105, 114,  32,  61,  32,  34,  46,  47,
   34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102,  32,  61,  32,
  105, 111,  46, 111, 112, 101, 110,  40, 115,  99, 114, 105, 112, 116,  95, 100,
  105, 114,  46,  46, 102, 105, 108, 101, 110,  97, 109, 101,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  32,  40,  33, 102,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99,
  101, 115, 115, 111, 114,  40,  34,  70, 105, 108, 101,  32,  39,  34,  46,  46,
  115,  99, 114, 105, 112, 116,  95, 100, 105, 114,  46,  46, 102, 105, 108, 101,
  110,  97, 109, 101,  46,  46,  34,  39,  32, 110, 111, 116,  32, 102, 111, 117,
  110, 100,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32,  99, 111, 110, 116, 101, 110, 116,  32,  61,  32, 102,  45,  62, 114,
  101,  97, 100,  40,  34,  42,  97, 108, 108,  34,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102,  45,  62,  99,
  108, 111, 115, 101,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  83, 101, 116,  32, 105,  32,
  108, 105, 110, 101,  32, 110, 117, 109,  98, 101, 114,  32, 116, 111,  32, 114,
   40,  99, 111, 110, 116, 101, 110, 116,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 110, 116, 101, 110,
  116,  32,  61,  32, 112, 114, 111,  99, 101, 115, 115,  40,  99, 111, 110, 116,
  101, 110, 116,  44,  32, 110, 117, 108, 108,  44,  32, 110, 117, 108, 108,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  47,  47,  32,  83, 112, 108, 105, 116,  32,  99, 111, 110, 116, 101, 110,
  116,  32, 116, 111,  32, 101, 118, 101, 114, 121, 116, 104, 105, 110, 103,  32,
   97, 102, 116, 101, 114,  32, 116, 111, 110, 117, 109,  98, 101, 114,  40, 108,
  105, 110, 101,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 115, 112, 108, 105, 116,  32,  61,  32,  99, 111, 110,
  116, 101, 110, 116,  45,  62, 115, 112, 108, 105, 116,  40,  34,  92, 110,  34,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32, 110, 101, 119,  99, 111, 110, 116, 101, 110, 116,
   32,  61,  32,  34,  34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,  32,  61,  32,
  116, 111, 110, 117, 109,  98, 101, 114,  40, 108, 105, 110, 101,  41,  44,  32,
   35, 115, 112, 108, 105, 116,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101,
  119,  99, 111, 110, 116, 101, 110, 116,  32,  61,  32, 110, 101, 119,  99, 111,
  110, 116, 101, 110, 116,  46,  46, 115, 112, 108, 105, 116,  91, 105, 105,  93,
   46,  46,  34,  92, 110,  34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101,
  115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 110, 101, 119,  99, 111, 110,
  116, 101, 110, 116,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  47,  47,  32,  65, 118, 111, 105, 100,  32, 109,
  101, 109, 111, 114, 121,  32, 108, 101,  97, 107, 115,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102,  32,  61,  32,
  110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  99, 111, 110, 116, 101, 110, 116,  32,  61,  32, 110,
  117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 110, 101, 119,  99, 111, 110, 116, 101, 110, 116,  32,  61,
   32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 115, 112, 108, 105, 116,  32,  61,  32, 110, 117,
  108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 102, 105, 108, 101,  44,  32, 108, 105, 110, 101,  32,  61,  32,
  110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   34,  35,  35, 105, 110,  99, 108, 117, 100, 101,  34,  58,  32, 102, 117, 110,
   99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 119,  97, 114, 110,  40,  34,  85,
  115, 105, 110, 103,  32,  35, 105, 110,  99, 108, 117, 100, 101,  32, 105, 115,
   32, 110, 111, 116,  32, 114, 101,  99, 111, 109, 109, 101, 110, 100, 101, 100,
   44,  32,  85, 115, 101,  32, 105, 109, 112, 111, 114, 116,  40,  41,  32, 105,
  110, 115, 116, 101,  97, 100,  34,  41,  10,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 102, 105,
  108, 101,  32,  61,  32, 118,  91,  50,  93,  45,  62, 103, 115, 117,  98,  40,
   34,  35, 105, 110,  99, 108, 117, 100, 101,  32,  92,  34,  34,  44,  32,  34,
   34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 118,  97, 114,  32, 111, 103, 102, 105, 108, 101,  32,  61,  32,
  102, 105, 108, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32,  70, 105, 108, 101,  32, 115, 104, 111,
  117, 108, 100,  32,  98, 101,  32,  97,  32, 115, 116, 114, 105, 110, 103,  32,
  116, 104,  97, 116,  32, 101, 110, 100, 115,  32, 119, 105, 116, 104,  32,  34,
   32,  97, 110, 100,  32, 109,  97, 121,  32, 104,  97, 118, 101,  32, 115, 116,
  117, 102, 102,  32,  97, 102, 116, 101, 114,  32, 116, 104, 101,  32,  34,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32,  82, 101, 109, 111, 118, 101,  32, 116, 104, 101,  32, 108,  97,
  115, 116,  32,  34,  32,  97, 110, 100,  32, 111, 110, 108, 121,  32, 107, 101,
  101, 112,  32, 101, 118, 101, 114, 121, 116, 104, 105, 110, 103,  32,  98, 101,
  102, 111, 114, 101,  32, 105, 116,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,  32,
   61,  32,  49,  44,  32,  35, 102, 105, 108, 101,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32, 118, 118,  32,  61,  32, 102, 105, 108, 101,  45,
   62, 115, 117,  98,  40, 105, 105,  44,  32, 105, 105,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  32,  40, 118, 118,  32,  61,  61,  32,  34,  92,  34,  34,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 105, 108, 101,  32,
   61,  32, 102, 105, 108, 101,  45,  62, 115, 117,  98,  40,  49,  44,  32, 105,
  105,  32,  45,  32,  49,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  98,
  114, 101,  97, 107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32, 102,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40,  95,  44,  32, 118, 118,
   32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 112,  97,  99, 107,  97, 103,
  101,  46, 115, 101,  97, 114,  99, 104, 101, 114, 115,  41,  41, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 102,  32,  40,  35, 116,  97,  98, 108, 101,  46, 112,  97,
   99, 107,  40, 118, 118,  40, 102, 105, 108, 101,  41,  41,  32,  61,  61,  32,
   50,  32,  38,  38,  32,  32, 116,  97,  98, 108, 101,  46, 112,  97,  99, 107,
   40, 118, 118,  40, 102, 105, 108, 101,  41,  41,  91,  49,  93,  32,  33,  61,
   32, 110, 117, 108, 108,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 102,  32,  61,  32, 116,  97,  98, 108, 101,  46, 112,  97,  99, 107,  40,
  118, 118,  40, 102, 105, 108, 101,  41,  41,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  32,  40,  33, 102,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 115,  99, 114, 105, 112, 116,  95, 112,  97, 116, 104,  32,
   61,  32, 103, 101, 116, 110,  97, 109, 101,  40,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 115,  99, 114, 105, 112, 116,  95, 100, 105, 114,  32,  61,
   32, 115,  99, 114, 105, 112, 116,  95, 112,  97, 116, 104,  45,  62, 109,  97,
  116,  99, 104,  40,  34,  40,  46,  42,  47,  41,  34,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  32,  40, 115,  99, 114, 105, 112, 116,  95, 100, 105, 114,  32,
   61,  61,  32, 110, 117, 108, 108,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 115,  99, 114, 105, 112, 116,  95, 100, 105, 114,  32,  61,  32,
   34,  46,  47,  34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  102,  32,  61,  32,  40, 105, 111,  46, 111, 112, 101, 110,  40, 115,  99, 114,
  105, 112, 116,  95, 100, 105, 114,  46,  46, 102, 105, 108, 101,  41,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  32,  40,  33, 102,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 111, 114,  40,  34,  70, 105, 108, 101,  32,  39,  34,
   46,  46, 102, 105, 108, 101,  46,  46,  34,  39,  32, 110, 111, 116,  32, 102,
  111, 117, 110, 100,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  32,  40, 116, 121, 112, 101,  40, 102,  41,  61,  61,  34, 115, 116, 114,
  105, 110, 103,  34,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 105, 108, 101,  32,
   61,  32, 105, 111,  46, 111, 112, 101, 110,  40, 102,  91,  50,  93,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125, 101, 108, 115, 101, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 105, 108, 101,  32,
   61,  32, 102,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  99, 111, 110, 116, 101, 110,
  116,  32,  61,  32, 102, 105, 108, 101,  45,  62, 114, 101,  97, 100,  40,  34,
   42,  97, 108, 108,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 102, 105, 108, 101,  45,  62,  99, 108, 111,
  115, 101,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  47,  47,  32,  83, 101, 116,  32, 105,  32, 108,
  105, 110, 101,  32, 110, 117, 109,  98, 101, 114,  32, 116, 111,  32, 114,  40,
   99, 111, 110, 116, 101, 110, 116,  41,  10,  32,  32,  32,  32,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101,
  119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,  44,  32, 110, 101,
  119, 105, 110,  99, 108, 117, 100, 101, 115,  32,  61,  32, 112, 114, 111,  99,
  101, 115, 115,  40,  99, 111, 110, 116, 101, 110, 116,  44,  32, 110, 117, 108,
  108,  44,  32, 110, 117, 108, 108,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  65, 118, 111, 105,
  100,  32, 109, 101, 109, 111, 114, 121,  32, 108, 101,  97, 107, 115,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102,
  105, 108, 101,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 110, 116, 101,
  110, 116,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102,  32,  61,  32, 110, 117,
  108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  35,
  105, 102,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  47,  47,  32,  69, 120,  97, 109, 112, 108, 101,  58,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   35, 105, 102,  32,  40, 116, 114, 117, 101,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  49,
   58,  32,  71, 101, 116,  32, 116, 104, 101,  32,  99, 111, 110, 100, 105, 116,
  105, 111, 110,  44,  32,  69, 118, 101, 114, 121, 116, 104, 105, 110, 103,  32,
  105, 110,  32,  98, 101, 116, 119, 101, 101, 110,  32, 116, 104, 101,  32,  40,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  32,
   61,  32, 118,  91,  50,  93,  45,  62, 103, 115, 117,  98,  40,  34,  35, 105,
  102,  32,  34,  44,  32,  34,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  47,  32,  71, 101, 116,
   32, 101, 118, 101, 114, 121, 116, 104, 105, 110, 103,  32, 105, 110,  32,  98,
  101, 116, 119, 101, 101, 110,  32, 116, 104, 101,  32,  40,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111,
  114,  32,  40, 105, 105,  32,  61,  32,  49,  44,  32,  35,  99, 111, 110, 100,
  105, 116, 105, 111, 110,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,
   32, 118, 118,  32,  61,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,
   62, 115, 117,  98,  40, 105, 105,  44,  32, 105, 105,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  32,  40, 118, 118,  32,  61,  61,  32,  34,  40,  34,  41,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 110, 100, 105, 116,
  105, 111, 110,  32,  61,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,
   62, 115, 117,  98,  40, 105, 105,  32,  43,  32,  49,  44,  32,  35,  99, 111,
  110, 100, 105, 116, 105, 111, 110,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  102, 111, 114,  32,  40, 105, 105,  32,  61,  32,  35,  99, 111, 110, 100, 105,
  116, 105, 111, 110,  44,  32,  49,  44,  32,  45,  49,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 118,  97, 114,  32, 118, 118,  32,  61,  32,  99, 111, 110, 100,
  105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40, 105, 105,  44,  32, 105,
  105,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 118, 118,  32,  61,  61,
   32,  34,  41,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   99, 111, 110, 100, 105, 116, 105, 111, 110,  32,  61,  32,  99, 111, 110, 100,
  105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40,  49,  44,  32, 105, 105,
   32,  45,  32,  49,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114,
  101,  97, 107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   50,  58,  32,  69, 118,  97, 108, 117,  97, 116, 101,  32, 116, 104, 101,  32,
   99, 111, 110, 100, 105, 116, 105, 111, 110,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 115, 117,
   99,  99, 101, 115, 115,  44,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32,
  120, 112,  99,  97, 108, 108,  40, 102, 117, 110,  99, 116, 105, 111, 110,  40,
   41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  40, 101,
  110, 118, 108, 111,  97, 100,  40,  34, 114, 101, 116, 117, 114, 110,  32,  34,
   46,  46,  99, 111, 110, 100, 105, 116, 105, 111, 110,  41,  32, 124, 124,  32,
  101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111,
  114,  40,  34,  70,  97, 105, 108, 101, 100,  32, 116, 111,  32,  99, 104, 101,
   99, 107,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  92, 110,  34,  46,
   46, 116,  97,  98, 108, 101,  46, 112,  97,  99, 107,  40, 101, 110, 118, 108,
  111,  97, 100,  40,  34, 114, 101, 116, 117, 114, 110,  32,  34,  46,  46,  99,
  111, 110, 100, 105, 116, 105, 111, 110,  41,  41,  91,  50,  93,  41,  41,  40,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 101, 114,
  114,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  40, 101, 114, 114,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  32,  40,  33, 115, 117,  99,  99, 101, 115, 115,  41,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 111, 114,  40, 114, 101, 115, 117, 108, 116,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  47,  47,  32,  51,  58,  32,  82, 101, 109, 111, 118, 101,  32, 116,
  104, 101,  32, 108, 105, 110, 101,  32,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101,
  115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 110, 117, 108, 108,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116,
   97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40,  97,  99, 116, 105,
  118, 101, 105, 102, 115,  44,  32, 114, 101, 115, 117, 108, 116,  41,  10,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32,  52,  58,  32,  82, 101, 109, 111, 118, 101,  32,  97, 108, 108,
   32,  99, 111, 100, 101,  32, 105, 102,  32, 114, 101, 115, 117, 108, 116,  32,
  105, 115,  32, 102,  97, 108, 115, 101,  32, 117, 110, 116, 105, 108,  32,  35,
  101, 110, 100, 105, 102,  32, 111, 114,  32,  35, 101, 108, 115, 101,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  117, 110,  32,  61,  32, 114, 101, 115, 117, 108, 116,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  34,  35, 105, 102, 100, 101, 102,  34,  58,
   32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   69, 120,  97, 109, 112, 108, 101,  58,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  35, 105, 102, 100,
  101, 102,  32,  40,  95,  95,  65,  80,  80,  76,  69,  95,  95,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32,  49,  58,  32,  71, 101, 116,  32, 116, 104, 101,  32,  99, 111,
  110, 100, 105, 116, 105, 111, 110,  44,  32,  69, 118, 101, 114, 121, 116, 104,
  105, 110, 103,  32, 105, 110,  32,  98, 101, 116, 119, 101, 101, 110,  32, 116,
  104, 101,  32,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  99, 111, 110, 100, 105, 116,
  105, 111, 110,  32,  61,  32, 118,  91,  50,  93,  45,  62, 103, 115, 117,  98,
   40,  34,  35, 105, 102,  32,  34,  44,  32,  34,  34,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  47,
   32,  71, 101, 116,  32, 101, 118, 101, 114, 121, 116, 104, 105, 110, 103,  32,
  105, 110,  32,  98, 101, 116, 119, 101, 101, 110,  32, 116, 104, 101,  32,  40,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 102, 111, 114,  32,  40, 105, 105,  32,  61,  32,  49,  44,  32,  35,
   99, 111, 110, 100, 105, 116, 105, 111, 110,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 118,  97, 114,  32, 118, 118,  32,  61,  32,  99, 111, 110, 100, 105, 116,
  105, 111, 110,  45,  62, 115, 117,  98,  40, 105, 105,  44,  32, 105, 105,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 105, 102,  32,  40, 118, 118,  32,  61,  61,  32,  34,
   40,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111,
  110, 100, 105, 116, 105, 111, 110,  32,  61,  32,  99, 111, 110, 100, 105, 116,
  105, 111, 110,  45,  62, 115, 117,  98,  40, 105, 105,  32,  43,  32,  49,  44,
   32,  35,  99, 111, 110, 100, 105, 116, 105, 111, 110,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,  32,  61,  32,  35,  99,
  111, 110, 100, 105, 116, 105, 111, 110,  44,  32,  49,  44,  32,  45,  49,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 118, 118,  32,  61,  32,
   99, 111, 110, 100, 105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40, 105,
   44,  32, 105,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 118, 118,  32,
   61,  61,  32,  34,  41,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  32,  61,  32,  99, 111,
  110, 100, 105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40,  49,  44,  32,
  105, 105,  32,  45,  32,  49,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   98, 114, 101,  97, 107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,
   47,  32,  50,  58,  32,  69, 118,  97, 108, 117,  97, 116, 101,  32, 116, 104,
  101,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,
  115, 117,  99,  99, 101, 115, 115,  44,  32, 114, 101, 115, 117, 108, 116,  32,
   61,  32, 120, 112,  99,  97, 108, 108,  40, 102, 117, 110,  99, 116, 105, 111,
  110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,
   40, 101, 110, 118, 108, 111,  97, 100,  40,  34, 114, 101, 116, 117, 114, 110,
   32, 100, 101, 102, 105, 110, 101, 100,  40,  92,  34,  34,  46,  46,  40,  99,
  111, 110, 100, 105, 116, 105, 111, 110,  32, 124, 124,  32,  34, 110, 117, 108,
  108,  34,  41,  46,  46,  34,  92,  34,  41,  34,  41,  32, 124, 124,  32, 101,
  114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,
   40,  34,  70,  97, 105, 108, 101, 100,  32, 116, 111,  32,  99, 104, 101,  99,
  107,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  92, 110,  34,  46,  46,
   40, 116,  97,  98, 108, 101,  46, 112,  97,  99, 107,  40, 101, 110, 118, 108,
  111,  97, 100,  40,  34, 114, 101, 116, 117, 114, 110,  32,  34,  46,  46,  40,
   99, 111, 110, 100, 105, 116, 105, 111, 110,  32, 124, 124,  32,  34, 110, 117,
  108, 108,  34,  41,  41,  41,  32, 124, 124,  32,  34,  70,  97, 105, 108, 101,
  100,  32, 116, 111,  32, 101, 114, 114, 111, 114,  34,  41,  91,  50,  93,  41,
   41,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,
  101, 114, 114,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112,
  114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40, 101, 114, 114,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  32,  40,  33, 115, 117,  99,  99, 101, 115, 115,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  40, 114, 101, 115, 117, 108, 116,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32,  51,  58,  32,  82, 101, 109, 111, 118, 101,
   32, 116, 104, 101,  32, 108, 105, 110, 101,  32,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105,
  110, 101, 115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 110, 117, 108, 108,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40,  97,  99,
  116, 105, 118, 101, 105, 102, 115,  44,  32, 114, 101, 115, 117, 108, 116,  41,
   10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  47,  47,  32,  52,  58,  32,  82, 101, 109, 111, 118, 101,  32,  97,
  108, 108,  32,  99, 111, 100, 101,  32, 105, 102,  32, 114, 101, 115, 117, 108,
  116,  32, 105, 115,  32, 102,  97, 108, 115, 101,  32, 117, 110, 116, 105, 108,
   32,  35, 101, 110, 100, 105, 102,  32, 111, 114,  32,  35, 101, 108, 115, 101,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 114, 117, 110,  32,  61,  32, 114, 101, 115, 117, 108, 116,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  44,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  35, 105, 102, 110, 100, 101,
  102,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32,  69, 120,  97, 109, 112, 108, 101,  58,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  35,
  105, 102, 100, 101, 102,  32,  40,  95,  95,  65,  80,  80,  76,  69,  95,  95,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  47,  47,  32,  49,  58,  32,  71, 101, 116,  32, 116, 104, 101,
   32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  44,  32,  69, 118, 101, 114,
  121, 116, 104, 105, 110, 103,  32, 105, 110,  32,  98, 101, 116, 119, 101, 101,
  110,  32, 116, 104, 101,  32,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  99, 111, 110,
  100, 105, 116, 105, 111, 110,  32,  61,  32, 118,  91,  50,  93,  45,  62, 103,
  115, 117,  98,  40,  34,  35, 105, 102,  32,  34,  44,  32,  34,  34,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  47,  32,  71, 101, 116,  32, 101, 118, 101, 114, 121, 116, 104, 105,
  110, 103,  32, 105, 110,  32,  98, 101, 116, 119, 101, 101, 110,  32, 116, 104,
  101,  32,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,  32,  61,  32,  49,
   44,  32,  35,  99, 111, 110, 100, 105, 116, 105, 111, 110,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 118,  97, 114,  32, 118, 118,  32,  61,  32,  99, 111, 110,
  100, 105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40, 105, 105,  44,  32,
  105, 105,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 118, 118,  32,  61,
   61,  32,  34,  40,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  32,  61,  32,  99, 111, 110,
  100, 105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40, 105, 105,  32,  43,
   32,  49,  44,  32,  35,  99, 111, 110, 100, 105, 116, 105, 111, 110,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,  32,  61,
   32,  35,  99, 111, 110, 100, 105, 116, 105, 111, 110,  44,  32,  49,  44,  32,
   45,  49,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 118, 118,
   32,  61,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,  62, 115, 117,
   98,  40, 105, 105,  44,  32, 105, 105,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,
   32,  40, 118, 118,  32,  61,  61,  32,  34,  41,  34,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,
   32,  61,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,  62, 115, 117,
   98,  40,  49,  44,  32, 105, 105,  32,  45,  32,  49,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32,  50,  58,  32,  69, 118,  97, 108, 117,  97,
  116, 101,  32, 116, 104, 101,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 118,  97, 114,  32, 115, 117,  99,  99, 101, 115, 115,  44,  32, 114, 101,
  115, 117, 108, 116,  32,  61,  32, 120, 112,  99,  97, 108, 108,  40, 102, 117,
  110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101,
  116, 117, 114, 110,  32,  40, 101, 110, 118, 108, 111,  97, 100,  40,  34, 114,
  101, 116, 117, 114, 110,  32,  33, 100, 101, 102, 105, 110, 101, 100,  40,  92,
   34,  34,  46,  46,  99, 111, 110, 100, 105, 116, 105, 111, 110,  46,  46,  34,
   92,  34,  41,  34,  41,  32, 124, 124,  32, 101, 114, 114, 111, 114, 112, 114,
  101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40,  34,  70,  97, 105, 108,
  101, 100,  32, 116, 111,  32,  99, 104, 101,  99, 107,  32,  99, 111, 110, 100,
  105, 116, 105, 111, 110,  92, 110,  34,  46,  46, 116,  97,  98, 108, 101,  46,
  112,  97,  99, 107,  40, 101, 110, 118, 108, 111,  97, 100,  40,  34, 114, 101,
  116, 117, 114, 110,  32,  34,  46,  46,  99, 111, 110, 100, 105, 116, 105, 111,
  110,  41,  41,  91,  50,  93,  41,  41,  40,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  44,  32, 102, 117,
  110,  99, 116, 105, 111, 110,  40, 101, 114, 114,  41, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,
  111, 114,  40, 101, 114, 114,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33,
  115, 117,  99,  99, 101, 115, 115,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101,
  114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,
   40, 114, 101, 115, 117, 108, 116,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  51,  58,
   32,  82, 101, 109, 111, 118, 101,  32, 116, 104, 101,  32, 108, 105, 110, 101,
   32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,
   32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105, 110,
  115, 101, 114, 116,  40,  97,  99, 116, 105, 118, 101, 105, 102, 115,  44,  32,
  114, 101, 115, 117, 108, 116,  41,  10,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  52,  58,  32,  82,
  101, 109, 111, 118, 101,  32,  97, 108, 108,  32,  99, 111, 100, 101,  32, 105,
  102,  32, 114, 101, 115, 117, 108, 116,  32, 105, 115,  32, 102,  97, 108, 115,
  101,  32, 117, 110, 116, 105, 108,  32,  35, 101, 110, 100, 105, 102,  32, 111,
  114,  32,  35, 101, 108, 115, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 114, 117, 110,  32,  61,  32, 114, 101,
  115, 117, 108, 116,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   34,  35, 101, 108, 105, 102,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32,  69, 120,  97, 109, 112, 108, 101,  58,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  47,  47,  32,  35, 101, 108, 105, 102,  32,  40, 116, 114, 117, 101,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  32,  40, 114, 117, 110,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,  32,  61,
   32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32,  47,  47,  32,  83, 107, 105, 112,  32, 116, 104, 105, 115,  32, 108, 105,
  110, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32,  49,  58,  32,  71, 101, 116,  32, 116,
  104, 101,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  44,  32,  69, 118,
  101, 114, 121, 116, 104, 105, 110, 103,  32, 105, 110,  32,  98, 101, 116, 119,
  101, 101, 110,  32, 116, 104, 101,  32,  40,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  99,
  111, 110, 100, 105, 116, 105, 111, 110,  32,  61,  32, 118,  91,  50,  93,  45,
   62, 103, 115, 117,  98,  40,  34,  35, 101, 108, 105, 102,  32,  34,  44,  32,
   34,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  47,  32,  71, 101, 116,  32, 101, 118, 101, 114,
  121, 116, 104, 105, 110, 103,  32, 105, 110,  32,  98, 101, 116, 119, 101, 101,
  110,  32, 116, 104, 101,  32,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,
   32,  61,  32,  49,  44,  32,  35,  99, 111, 110, 100, 105, 116, 105, 111, 110,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 118, 118,  32,  61,
   32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40,
  105, 105,  44,  32, 105, 105,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,
  118, 118,  32,  61,  61,  32,  34,  40,  34,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  32,  61,
   32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40,
  105, 105,  32,  43,  32,  49,  44,  32,  35,  99, 111, 110, 100, 105, 116, 105,
  111, 110,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97,
  107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40,
  105, 105,  32,  61,  32,  35,  99, 111, 110, 100, 105, 116, 105, 111, 110,  44,
   32,  49,  44,  32,  45,  49,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32, 118, 118,  32,  61,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,
   45,  62, 115, 117,  98,  40, 105, 105,  44,  32, 105, 105,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  32,  40, 118, 118,  32,  61,  61,  32,  34,  41,  34,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 110, 100, 105,
  116, 105, 111, 110,  32,  61,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,
   45,  62, 115, 117,  98,  40,  49,  44,  32, 105, 105,  32,  45,  32,  49,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  50,  58,  32,  69, 118,
   97, 108, 117,  97, 116, 101,  32, 116, 104, 101,  32,  99, 111, 110, 100, 105,
  116, 105, 111, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 118,  97, 114,  32, 115, 117,  99,  99, 101, 115, 115,
   44,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32, 120, 112,  99,  97, 108,
  108,  40, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 114, 101, 116, 117, 114, 110,  32,  40, 101, 110, 118, 108, 111,  97,
  100,  40,  34, 114, 101, 116, 117, 114, 110,  32,  34,  46,  46,  99, 111, 110,
  100, 105, 116, 105, 111, 110,  41,  32, 124, 124,  32, 101, 114, 114, 111, 114,
  112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40,  34,  70,  97,
  105, 108, 101, 100,  32, 116, 111,  32,  99, 104, 101,  99, 107,  32,  99, 111,
  110, 100, 105, 116, 105, 111, 110,  92, 110,  34,  46,  46, 116,  97,  98, 108,
  101,  46, 112,  97,  99, 107,  40, 101, 110, 118, 108, 111,  97, 100,  40,  34,
  114, 101, 116, 117, 114, 110,  32,  34,  46,  46,  99, 111, 110, 100, 105, 116,
  105, 111, 110,  41,  41,  91,  50,  93,  41,  41,  40,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  44,  32,
  102, 117, 110,  99, 116, 105, 111, 110,  40, 101, 114, 114,  41, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  40, 101, 114, 114,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,
   40,  33, 115, 117,  99,  99, 101, 115, 115,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,
  111, 114,  40, 114, 101, 115, 117, 108, 116,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   51,  58,  32,  82, 101, 109, 111, 118, 101,  32, 116, 104, 101,  32, 108, 105,
  110, 101,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,  49,
   93,  93,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46,
  105, 110, 115, 101, 114, 116,  40,  97,  99, 116, 105, 118, 101, 105, 102, 115,
   44,  32, 114, 101, 115, 117, 108, 116,  41,  10,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  52,  58,
   32,  82, 101, 109, 111, 118, 101,  32,  97, 108, 108,  32,  99, 111, 100, 101,
   32, 105, 102,  32, 114, 101, 115, 117, 108, 116,  32, 105, 115,  32, 102,  97,
  108, 115, 101,  32, 117, 110, 116, 105, 108,  32,  35, 101, 110, 100, 105, 102,
   32, 111, 114,  32,  35, 101, 108, 115, 101,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 117, 110,  32,  61,  32,
  114, 101, 115, 117, 108, 116,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  34,  35, 101, 108, 115, 101,  34,  58,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 114, 117, 110,  32,  61,  32,  33, 114, 117,
  110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,
   32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  34,  35, 101, 110, 100, 105, 102,  34,  58,  32, 102, 117, 110,
   99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  97,  99, 116, 105, 118, 101, 105,
  102, 115,  91,  35,  97,  99, 116, 105, 118, 101, 105, 102, 115,  93,  32,  61,
   32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,
   91,  49,  93,  93,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 117, 110,  32,
   61,  32, 116, 114, 117, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  34,  35, 117, 110, 100, 101, 102,  34,  58,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 115, 112, 108, 105, 116,
   32, 118,  91,  50,  93,  32,  98, 121,  32, 115, 112,  97,  99, 101, 115,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 115, 112, 108, 105, 116,  32,  61,  32, 118,  91,  50,  93,
   45,  62, 115, 112, 108, 105, 116,  40,  34,  32,  34,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   49,  58,  32,  71, 101, 116,  32, 116, 104, 101,  32, 110,  97, 109, 101,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 110,  97, 109, 101,  32,  61,  32, 115, 112, 108, 105, 116,
   91,  50,  93,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32,  50,  58,  32,  82, 101, 109, 111, 118, 101,
   32, 116, 104, 101,  32, 118,  97, 108, 117, 101,  32, 105, 110,  32, 116, 104,
  101,  32, 101, 110, 118,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 101, 110, 118,  91, 110,  97, 109, 101,  93,  32,
   61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  51,  58,  32,  82, 101, 109,
  111, 118, 101,  32, 116, 104, 101,  32, 108, 105, 110, 101,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119,
  108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 110, 117,
  108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  35,
  101, 114, 114, 111, 114,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,
   40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 118,  97, 114,  32, 101, 114, 114, 111, 114,  32,  61,  32,
  118,  91,  50,  93,  45,  62, 103, 115, 117,  98,  40,  34,  35, 101, 114, 114,
  111, 114,  32,  34,  44,  32,  34,  34,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,
   34,  92,  50,  55,  91,  49,  59,  51,  49, 109,  82,  97, 105, 115, 101, 100,
   32, 101, 114, 114, 111, 114,  58,  92,  50,  55,  91,  48, 109,  34,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49, 109,
   34,  46,  46, 101, 114, 114, 111, 114,  46,  46,  34,  92,  50,  55,  91,  48,
  109,  92, 110,  92, 110,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114,  40,  34,  69,
  110, 100, 105, 110, 103,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,
  111, 114,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   34,  35, 119,  97, 114, 110, 105, 110, 103,  34,  58,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 119,  97, 114, 110,
  105, 110, 103,  32,  61,  32, 118,  91,  50,  93,  45,  62, 103, 115, 117,  98,
   40,  34,  35, 119,  97, 114, 110, 105, 110, 103,  32,  34,  44,  32,  34,  34,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 119,  97, 114, 110,  40, 119,  97, 114, 110, 105, 110, 103,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,  32,  61,
   32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  34,  35,  99, 111, 110, 102, 105, 103,  34,  58,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  40,  34,  67, 111, 110, 102, 105,
  103,  32, 105, 115,  32, 110, 111, 116,  32, 115, 117, 112, 112, 111, 114, 116,
  101, 100,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   34,  35, 101, 120, 116,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,
   40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32,  73, 110, 115, 116,  97, 108, 108, 115,  32,
   97, 110,  32, 101, 120, 116, 101, 110, 115, 105, 111, 110,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114,
  111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40,  34,
   69, 120, 116, 101, 110, 115, 105, 111, 110, 115,  32,  97, 114, 101,  32, 110,
  111, 116,  32, 115, 117, 112, 112, 111, 114, 116, 101, 100,  34,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  44,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34, 100, 101, 102,  97, 117,
  108, 116,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 118,  97,
  108, 117, 101,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33, 114, 117, 110,  41, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,
   49,  93,  93,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32,  47,  47,  32,  83, 107, 105, 112,  32, 116, 104,
  105, 115,  32, 108, 105, 110, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  69, 120,
  101,  99, 117, 116, 101,  32, 101, 118, 101, 114, 121, 116, 104, 105, 110, 103,
   32, 112,  97, 115, 116,  32, 116, 104, 101,  32,  35,  32,  97, 115,  32,  97,
   32,  99, 111,  98,  97, 108, 116,  32, 108, 105, 110, 101,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,
   32,  99, 111, 100, 101,  32,  61,  32, 118,  91,  50,  93,  45,  62, 115, 117,
   98,  40,  50,  44,  32,  35, 118,  91,  50,  93,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,
   32, 115, 117,  99,  99, 101, 115, 115,  44,  32, 114, 101, 115, 117, 108, 116,
   32,  61,  32, 120, 112,  99,  97, 108, 108,  40, 102, 117, 110,  99, 116, 105,
  111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32,  40, 101, 110, 118, 108, 111,  97, 100,  40,  99, 111, 100, 101,  41,  32,
  124, 124,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  40,  34,  70,  97, 105, 108, 101, 100,  32, 116, 111,  32,
  108, 111,  97, 100,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111,
  114,  32,  99, 111, 109, 109,  97, 110, 100,  34,  41,  41,  40,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 101, 114, 114,  41, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,
   99, 101, 115, 115, 111, 114,  40, 101, 114, 114,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  32,  40,  33, 115, 117,  99,  99, 101, 115, 115,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  40, 114, 101, 115, 117, 108, 116,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125, 101, 108,
  115, 101,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101,
  115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 114, 101, 115, 117, 108, 116,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32,  82, 101, 109, 111, 118, 101,  32, 108, 105,
  110, 101,  32, 102, 114, 111, 109,  32, 110, 101, 119, 108, 105, 110, 101, 115,
   32,  10,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  47,  47,  32,
   52,  58,  32,  74, 111, 105, 110,  32, 110, 101, 119, 108, 105, 110, 101, 115,
   32,  97, 110, 100,  32, 114, 101, 116, 117, 114, 110,  10,  32,  32,  32,  32,
  105, 102,  32,  40,  35,  97,  99, 116, 105, 118, 101, 105, 102, 115,  32,  62,
   32,  48,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114,
  114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40,
   34,  77, 105, 115, 115, 105, 110, 103,  32,  35, 101, 110, 100, 105, 102,  40,
  115,  41,  34,  41,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 108,
  105, 110, 101, 115,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,
  112, 114, 101, 112, 114, 111,  99, 101, 115, 115,  32,  61,  32, 110, 117, 108,
  108,  10,  32,  32,  32,  32, 115, 116, 114,  32,  61,  32, 110, 117, 108, 108,
   10,  32,  32,  32,  32, 118,  97, 114,  32, 106, 111, 105, 110, 101, 100,  32,
   61,  32,  34,  47,  42,  32,  80, 114, 101, 112, 114, 111,  99, 101, 115, 115,
  101, 100,  32, 119, 105, 116, 104,  32, 116, 104, 101,  32,  98, 117, 105, 108,
  116,  32, 105, 110,  32,  67, 111,  98,  97, 108, 116,  32, 112, 114, 101, 112,
  114, 111,  99, 101, 115, 115, 111, 114,  32,  42,  47,  92, 110,  92, 110,  92,
  110,  34,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105,  44,  32, 118,
   32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 110, 101, 119, 108, 105, 110,
  101, 115,  41,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  32,  40, 118,  32,  61,  61,  32, 110, 117, 108, 108,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 110, 116,
  105, 110, 117, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 106, 111, 105, 110, 101, 100,  32,  61,
   32, 106, 111, 105, 110, 101, 100,  46,  46, 118,  46,  46,  34,  92, 110,  34,
   10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 110, 101, 119, 108, 105,
  110, 101, 115,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32, 105,
  102,  32,  40, 111, 117, 116,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  47,  47,  32,  87, 114, 105, 116, 101,  32, 116, 111,  32, 111, 117, 116,
   32,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 102, 105,
  108, 101,  32,  61,  32, 105, 111,  46, 111, 112, 101, 110,  40, 111, 117, 116,
  102, 105, 108, 101,  44,  32,  34, 119,  34,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 102, 105, 108, 101,  45,  62, 119, 114, 105, 116, 101,  40, 106,
  111, 105, 110, 101, 100,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 102,
  105, 108, 101,  45,  62,  99, 108, 111, 115, 101,  40,  41,  10,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  99, 111, 108, 108, 101,  99, 116, 103,  97,
  114,  98,  97, 103, 101,  40,  41,  32,  47,  47,  32,  67, 111, 108, 108, 101,
   99, 116,  32, 103,  97, 114,  98,  97, 103, 101,  10,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32, 106, 111, 105, 110, 101, 100,  10, 125,  10,  10,
   47,  47, 112, 114, 111,  99, 101, 115, 115,  40,  34, 116, 101, 115, 116,  46,
   99, 111,  98,  97, 108, 116,  34,  44,  32,  34, 102, 105, 108, 101,  34,  44,
   32, 116, 114, 117, 101,  44,  32,  34, 116, 101, 115, 116,  50,  46,  99, 111,
   98,  97, 108, 116,  34,  41,  10, 114, 101, 116, 117, 114, 110,  32, 112, 114,
  111,  99, 101, 115, 115,   0
};
#define EXTERNAL LUALIB_API // changed by developer
#define AOT_LUAOPEN_NAME luaopen_preprocess // changed by developer

#include "../aot_footer.c" // changed by developer
