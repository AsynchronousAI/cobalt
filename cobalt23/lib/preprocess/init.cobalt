/* ============================================================================== //
// This file is apart of the Cobalt Programming Language. Cobalt is under the MIT //
// License. Read `cobalt.h` for license information.                              //
// ============================================================================== */

var preprocessor = {};
var ok, bit = require("bit");
coroutine = coroutine ? coroutine : (pcall(require, "coroutine") ? require("coroutine") : thread); /* for beta versions of cobalt */
if( ! ok ) {
bit = {
        lshift = function (x, y) {
                if( y < 0 ) { return bit.rshift(x,-y); } 
                return (x * 2**y) % (2**32);
        },
        rshift = function (x, y) {
                if( y < 0 ) { return bit.lshift(x,-y); }
                return math.floor(x % (2**32) / (2**y));
        },
        bxor = function (x, y) {
                // from http://lua-users.org/wiki/BitUtils
                var z = 0;
                for( i = 0, 31 ) {
                        if( (x % 2 == 0) ) {                      // x had a '0' in bit i
                                if( ( y % 2 == 1) ) {                  // y had a '1' in bit i
                                        --y    ; 
                                        z = z + 2 ** i;                       // set bit i of z to '1' 
                                }
                        } else {                                      // x had a '1' in bit i
                                --x    ;
                                if( (y % 2 == 0) ) {                  // y had a '0' in bit i
                                        z = z + 2 ** i;                       // set bit i of z to '1' 
                                } else {
                                        --y    ; 
                                }
                        }
                        y /=   2;
                        x /=   2;
                }
                return z;
        },
        bnot = function (x) {
                // if word size is not defined, I think it better than 0xFFFFFFFF - x.
                return -1 - x;
        },
        band = function (x, y) {
                return ((x + y) - bit.bxor(x, y)) / 2;
        },
        bor = function (x, y) {
                return bit.bnot(bit.band(bit.bnot(x), bit.bnot(y)));
        },
};
}

// CONFIG
preprocessor.PRE_FFI         = pcall(require, "ffi");   // whether to use preprocessor to preprocess LuaJIT ffi code (ffi.cdef)
preprocessor.PRE_TEST        = false;   // whether to run preprocessor unit tests when loading preprocessor module
preprocessor.ENV              = {};      // static predefines (env-like)
preprocessor.FAST             = false;   // perf. tweaks when enabled. con: breaks minor stuff like LINE macros
preprocessor.DEBUG            = false;

// PREDEFINES
var FILE  = "FILE";
var LINE        = "LINE";
var DATE        = "DATE";
var TIME        = "TIME";
var PRE_INDENT  = "PRE_INDENT";

// BNF LEAVES
var ENDL            = "$";
var STARTL          = "^";
var NEWL            = "\n";
var NEWL_BYTE       = NEWL->byte(1);
var NEWL_ESC        = "\\";
var NEWML           = "\\\n";
var CMD             = "#";
var CMD_BYTE        = CMD->byte(1);
var COMMENT         = "^(.-)//.-$";
var MLCOMMENT       = "/[*].-[*]/";
var WHITESPACES     = "%s+";
var OPTSPACES       = "%s*";
var IDENTIFIER      = "[_%a][_%w]*";
var NOIDENTIFIER    = "[^%w_]+";
var FILENAME        = "[0-9a-zA-Z.%-_/\\]+";
var TEXT            = ".+";
var STRINGIFY       = "#";
var STRINGIFY_BYTE  = STRINGIFY->byte(1);
var STRING_LITERAL  = ".*";

// BNF WORDS
var _INCLUDE        = "include";
var _INCLUDE_NEXT   = "include_next";
var _DEFINE         = "define";
var _IFDEF          = "ifdef";
var _IFNDEF         = "ifndef";
var _ENDIF          = "endif";
var _UNDEF          = "undef";
var _IF             = "if";
var _ELSE           = "else";
var _ELIF           = "elif";
var _NOT            = "!";
var _ERROR          = "error";
var _WARNING        = "warning";
var _PRAGMA         = "pragma";

// BNF RULES
var INCLUDE         = STARTL.._INCLUDE..WHITESPACES.."[<]("..FILENAME..")[>]"..OPTSPACES..ENDL;
var LOCAL_INCLUDE   = STARTL.._INCLUDE..WHITESPACES.."[\"]("..FILENAME..")[\"]"..OPTSPACES..ENDL;
var INCLUDE_NEXT    = STARTL.._INCLUDE_NEXT..WHITESPACES.."[\"<]("..FILENAME..")[\">]"..OPTSPACES..ENDL;
var DEFINE          = STARTL.._DEFINE;
var IFDEF           = STARTL.._IFDEF..WHITESPACES.."("..IDENTIFIER..")"..OPTSPACES..ENDL;
var IFNDEF          = STARTL.._IFNDEF..WHITESPACES.."("..IDENTIFIER..")"..OPTSPACES..ENDL;
var ENDIF           = STARTL.._ENDIF..OPTSPACES..ENDL;
var UNDEF           = STARTL.._UNDEF..WHITESPACES.."("..IDENTIFIER..")"..OPTSPACES..ENDL;
var IF              = STARTL.._IF..WHITESPACES.."(.*)"..ENDL;
var ELSE            = STARTL.._ELSE..OPTSPACES..ENDL;
var ELIF            = STARTL.._ELIF..WHITESPACES.."(.*)"..ENDL;
var ELSEIF          = STARTL.._ELSE..WHITESPACES.._IF..WHITESPACES.."(.*)"..ENDL;
var ERROR           = STARTL.._ERROR..WHITESPACES.."("..TEXT..")"..OPTSPACES..ENDL;
var WARNING         = STARTL.._WARNING..WHITESPACES.."("..TEXT..")"..OPTSPACES..ENDL;
var ERROR_NOTEXT    = STARTL.._ERROR..OPTSPACES..ENDL;  //> not required when we have POSIX regex
var PRAGMA          = STARTL.._PRAGMA;

// speedups
var TRUEMACRO = STARTL.."("..IDENTIFIER..")%s*$";
var REPLMACRO = STARTL.."("..IDENTIFIER..")"..WHITESPACES.."(.+)$";
var FUNCMACRO = STARTL.."("..IDENTIFIER..")%(([_%s%w,]*)%)%s*(.*)";


// ------------
// LOCAL UTILS
// ------------
preprocessor.STATE = {lineno = 0}; // current state for debugging the last operation
var function error(msg) { 
    print(string.format("\x1b[1;31mpreprocessor (ERROR) [%04i] %s\x1b[0m", preprocessor.STATE.lineno, msg)); 
    os.exit(1);
}
var function print(msg) { 
    _G.print(string.format("preprocessor (LOG) [%04i] %s", preprocessor.STATE.lineno, msg));
 }

// splits a string using a pattern into a table of substrings
var function gsplit(str, pat) {
        var function _split(str, pat) {
                var t = {};  // NOTE: use {n = 0} in Lua-5.0
                var fpat = "(.-)"..pat;
                var last_end = 1;
                var s, e, cap = str->find(fpat, 1);
                while( s ) {
                        if( s != 1 || cap != "" ) {
                                coroutine.yield(cap);
                        }
                        last_end = e + 1;
                        s, e, cap = str->find(fpat, last_end);
                }
                if( last_end <= #str ) {
                        cap = str->sub(last_end);
                        coroutine.yield(cap);
                }
        }
        return coroutine.wrap(function() { _split(str, pat); });
}
var function split(str, pat) {
        var t = {};
        for( str in gsplit(str, pat) ) { table.insert(t, str); }
        return t;
}

// Checks whether a string starts with a given substring
// offset is optional
var function strsw(str, pat, offset) {
        if( ! str ) { return false; }
        if( ! offset ) { offset = 0; }
        return string.sub(str, 1+offset, string.len(pat)+offset) == pat;
}

// Checks whether a string ends with a given substring
var function strew(str, pat) {
        if( ! str ) { return false; }
        return pat=='' || string.sub(str,-string.len(pat)) == pat;
}

// string trim12 from lua wiki
var function trim(str) {
        var from = str->match("^%s*()");
        return from > #str && "" || str->match(".*%S", from);
}

// returns the number of string occurrences
var function findn(input, what) {
        var count = 0;
        var offset = 0;
        var _;
        while( true ) { 
                        _, offset = string.find(input, what, offset+1, true);
                        if( ! offset ) { return count; }
                        ++count    ;
        }
}

// C literal string concatenation
var function concatStringLiteral(input) {
        // screener does remove multiline definition, so just check ".*"%s*".*" pattern
        return input->gsub("\"("..STRING_LITERAL..")\""..OPTSPACES.."\"("..STRING_LITERAL..")\"", "\"%1%2\"");
}

// c style boolean check (thus, 0 will be false)
var function CBoolean(value) {
        return value && (value != 0);
}

// eval with c style number parse (UL, LL, L)
var function CEval(expr) {
        var ok, r = pcall(loadstring, "return " .. parseCInteger(expr));
        if( ok && r ) {
                return r();
        } else {
                error(r);
        }
}

// a lightweight and flexible tokenizer
var function _tokenizer(str, setup) {
                var defsetup = {
                        // EXAMPLE patterns have to be pretended with "^" for the tokenizer
                        ["identifier"] = '^[_%a][_%w]*',
                        ["number"] = '^[%+%-]?%d+[%.]?%d*[UL]*',
                        ["ignore"] = '^%s+', 
                        ["string"] = true,
                        ["keywords"] = { 
                                // ["NAME"] = '^pattern',
                                // ...
                        },
                };
        if( ! setup ) {
                setup = defsetup;
        }
        setup.identifier = setup.identifier || defsetup.identifier;
        setup.number = setup.number || defsetup.number;
        setup.ignore = setup.ignore || defsetup.ignore;
        if( null == setup.string ) { setup.string = true; }
        setup.keywords = setup.keywords || {};

        var strlen = #str;
        var i = 1;
        var i1, i2;
        var keyword;

        var function find(pat) {
                i1, i2 = str->find(pat,i);
                return i1 != null;
        }

        var function cut() {
                return str->sub(i, i2);
        }

        var findKeyword;
        if( setup.keywords_order ) {
                findKeyword = function () {
                        for( _, name in ipairs(setup.keywords_order) ) {
                                assert(setup.keywords[name]);
                                var pat = setup.keywords[name];
                                var result = find(pat);
                                if( result ) {
                                        keyword = name; 
                                        return true; 
                                }
                        }
                };
        } else {
                findKeyword = function () {
                        for( name, pat in pairs(setup.keywords) ) {
                                var result = find(pat);
                                if( result ) {
                                        keyword = name; 
                                        return true; 
                                }
                        }
                };
        }

        while( true ) {
                if( i > strlen ) { return 'eof', null, strlen, strlen; }
                if( findKeyword() ) {
                        coroutine.yield(keyword, cut(), i1, i2);
                } else if( find(setup.ignore) ) {
                        coroutine.yield("ignore", cut(), i1, i2);
                } else if( find(setup.number) ) {
                        coroutine.yield('number', tonumber(cut()), i1, i2);
                } else if( find(setup.identifier) ) {
                        coroutine.yield('identifier', cut(), i1, i2);
                } else if( setup.string && (find('^"[^"]*"') || find("^'[^']*'")) ) {
                        // strip the quotes
                        coroutine.yield('string', cut()->sub(2,-2), i1, i2);
                } else { // any other unknown character
                        i1 = i;
                        i2 = i;
                        coroutine.yield('unknown', cut(), i1, i2);
                }
                i = i2+1;
        }
}
var function tokenizer(str, setup) {
        return coroutine.wrap(function() { _tokenizer(str, setup); });
}


// ------------
// PARSER
// ------------

var PRE_TOKENIZE_COMMENT = {
        string = false,
        keywords = { 
                MLCOMMENT = "^/%*.-%*/",
                SLCOMMENT = "^//.-\n",
                STRING_LITERAL = '^"[^"]*"',
        },
};
// hint: LuaJIT ffi does not rely on us to remove the comments, but maybe other usecases
var function removeComments(input) {
        var out = {};
        for( k, v, start, end_ in tokenizer(input, PRE_TOKENIZE_COMMENT) ) {
                if( k == "MLCOMMENT" ) {
                        var newlineCount = findn(input->sub(start, end_), "\n");
                        var newlines = string.rep("\n", newlineCount);
                        table.insert(out, newlines);
                } else if( k == "SLCOMMENT" ) { 
                        table.insert(out, "\n");
                } else {
                        table.insert(out, input->sub(start, end_));
                }
        }
        return table.concat(out);
}

// C style number parse (UL, LL, L) and (octet, hex, binary)
var PRE_TOKENIZE_INTEGER = {
        string = false,
        keywords_order = {
                "STRING_LITERAL",
                "CHAR_LITERAL",
                "HEX_LITERAL",
                "BIN_LITERAL",
                "OCT_LITERAL",
                "FPNUM_LITERAL",
                "NUMBER_LITERAL",
        },
        keywords = { 
                STRING_LITERAL = '^"[^"]*"',
                CHAR_LITERAL = "^L'.*'",
                HEX_LITERAL = '^[%+%-]?%s*0x[a-fA-F%d]+[UL]*',
                BIN_LITERAL = '^[%+%-]?%s*0b%d+[UL]*',
                OCT_LITERAL = '^[%+%-]?%s*0%d+[UL]*',
                FPNUM_LITERAL = '^[%+%-]?%s*%d+[%.]?%d*e[%+%-]%d*',
                NUMBER_LITERAL = '^[%+%-]?%s*%d+[%.]?%d*[UL]+',
        },
};
var function parseCInteger(input) {
        // print('parseCInteger:input:' .. input)
        var out = {};
        var unary;
        for( k, v, start, end_ in tokenizer(input, PRE_TOKENIZE_INTEGER) ) {
        // print('parseCInteger:' .. k .. "|" .. v)
                if( k == "CHAR_LITERAL" ) {
                        table.insert(out, tostring(string.byte(loadstring("return \"" .. v->gsub("^L%'(.+)%'", "%1") .. "\"")())));
                } else if( k == "HEX_LITERAL" ) { 
                        unary, v = v->match('([%+%-]?)0x([a-fA-F%d]+)[UL]*');
                        var n = tonumber(v, 16);
                        table.insert(out, unary..tostring(n));
                } else if( k == "NUMBER_LITERAL" ) { 
                        v = v->match('([^UL]+)[UL]+');
                        table.insert(out, v);
                } else if( k == "BIN_LITERAL" ) { 
                        unary, v = v->match('([%+%-]?)0b([01]+)[UL]*');
                        var n = tonumber(v, 2);
                        table.insert(out, unary..tostring(n));
                } else if( k == "OCT_LITERAL" ) { 
                        unary, v = v->match('([%+%-]?)(0%d+)[UL]*');
                        var n = tonumber(v, 8);
                        table.insert(out, unary..tostring(n));
                } else {
                        table.insert(out, input->sub(start, end_));
                }
        }
        var str = table.concat(out);
        // print('parseCInteger:result:'..str)
        return str;
}

// screener: revmoce comments, trim, ml concat...
// it only splits to cpp input lines and removes comments. it does not tokenize. 
var function screener(input) {
        var function _screener(input) {
                input = removeComments(input);

                // concat mulit-line input.
                var count = 1;
                while( count > 0 ) { input, count = string.gsub(input, "^(.-)\\\n(.-)$", "%1 %2\n"); }

                // trim and join blocks not starting with "#"
                var buffer = {};
                for( line in gsplit(input, NEWL) ) {
                        //print('newline:'..line)
                        line = trim(line);
                        if( #line > 0 ) {
                                if( line->byte(1) == CMD_BYTE ) { 
                                        line = line->gsub("#%s*(.*)", "#%1");   // remove optinal whitespaces after "#". reduce triming later.
                                        if( #buffer > 0 ) { 
                                                coroutine.yield(table.concat(buffer, NEWL));
                                                buffer = {}; 
                                        }
                                        coroutine.yield(line); 
                                } else {
                                        if( preprocessor.FAST ) {
                                                table.insert(buffer, line); 
                                        } else {
                                                coroutine.yield(line); 
                                        }
                                }
                        } else if( ! preprocessor.FAST ) {
                                coroutine.yield(line); 
                        }
                }
                if( #buffer > 0 ) { 
                        coroutine.yield(table.concat(buffer, NEWL));
                }
        }

        return coroutine.wrap(function() { _screener(input); });
}

// apply currently known macros to input (and returns it)
var PRE_TOKENIZE_APPLY_MACRO = {
        keywords = { 
                DEFINED = "^defined%s*%(%s*"..IDENTIFIER.."%s*%)"       ,
        },
};
var function apply(state, input) {
        while( true ) {
                var out = {};
                var functions = {};
                var expand;

                for( k, v, start, end_ in tokenizer(input, PRE_TOKENIZE_APPLY_MACRO) ) {
                        // print('tokenize:'..tostring(k).."|"..tostring(v))
                        if( k == "identifier" ) { 
                                var repl = v;
                                var macro = state.defines[v]; 
                                if( macro ) {
                                        if( type(macro)     == "boolean" ) {
                                                repl = "";
                                                expand = true;
                                        } else if( type(macro) == "string" ) {
                                                repl = macro;
                                                expand = (repl != v);
                                        } else if( type(macro) == "number" ) {
                                                repl = tostring(macro);
                                                expand = (repl != v);
                                        } else if( type(macro) == "function" ) {
                                                var decl,cnt = input->sub(start)->gsub("^[_%a][_%w]*%s*%b()", "%1");
                                                // print('matching:'..input.."|"..decl.."|"..cnt)
                                                if( cnt > 0 ) {
                                                        repl = macro(decl);
                                                        // print("d&r:"..decl.."|"..repl)
                                                        expand = true;
                                                        table.insert(out, repl);
                                                        table.insert(out, input->sub(end_ + #decl));
                                                        break;
                                                } else {
                                                        if( input->sub(start)->find("^[_%a][_%w]*%s*%(") ) {
                                                                // that is part of functional macro declaration.
                                                                // print(v ..': cannot replace:<'..input..'> read more line')
                                                                return input,true;
                                                        } else {
                                                                // on macro name is also used as the symbol of some C declaration
                                                                // (e.g. /usr/include/spawn.h, /usr/include/sys/select.h on centos 6.4)
                                                                // no need to preprocess.
                                                                print(v .. ': macro name but used as C declaration in:' .. input);
                                                        }
                                                }
                                        }
                                }
                                table.insert(out, repl);
                        } else if( k == "DEFINED" ) {
                                table.insert(out, input->sub(start, end_));
                        } else {
                                table.insert(out, input->sub(start, end_));
                        }
                }
                input = table.concat(out);
                if( ! expand ) {
                        break;
                }
        }

        // C liberal string concatenation, processing U,L,UL,LL
        return parseCInteger(concatStringLiteral(input)),false;
}

// processes an input line. called from preprocessor doWork loop
var function processLine(state, line) {
        if( ! line || #line == 0 ) { return line; }
        var cmd = null; 
        if( line->byte(1) == CMD_BYTE ) { cmd = line->sub(2); }
        // print("process:"..line)--.."|"..tostring(state:skip()))

        /* IF/THEN/ELSE STRUCTURAL BLOCKS *///
        if( cmd ) {
                var ifdef   = cmd->match(IFDEF);
                var ifexp   = cmd->match(IF);
                var ifndef  = cmd->match(IFNDEF);
                var elif    = cmd->match(ELIF);
                var elseif_ = cmd->match(ELSEIF);
                var else_   = cmd->match(ELSE);
                var endif   = cmd->match(ENDIF);
                var struct  = ifdef || ifexp || ifndef || elif || elseif_ || else_ || endif;

                if( struct ) { 
                        var skip = state->skip();
                        if( ifdef   ) { state->openBlock(state->defined(ifdef));      }
                        // if skipped, it may have undefined expression. so not parse them
                        if( ifexp   ) { state->openBlock(skip && true || CBoolean(state->parseExpr(ifexp)));    }
                        if( ifndef  ) { state->openBlock(! state->defined(ifndef)); }
                        if( elif    ) { state->elseBlock((skip && skip < #state.stack) && true || CBoolean(state->parseExpr(elif)));     }
                        if( elseif_ ) { state->elseBlock((skip && skip < #state.stack) && true || CBoolean(state->parseExpr(elseif_)));  }
                        if( else_   ) { state->elseBlock(true);                      }
                        if( endif   ) { state->closeBlock();                         }
                        return; // remove structural directives
                }
        }


        /* SKIPPING */// 
        if( state->skip() ) { 
                // print('skip:' .. line)
                return; 
        }


        /* READ NEW DIRECTIVES *///
        if( cmd ) {
                // handle #undef ...
                var key = cmd->match(UNDEF);
                if( type(key) == "string" ) {
                        state->undefine(key);
                        return;
                }

                // read "#define >FooBar...<" directives
                if( cmd->match(DEFINE) ) {
                        var define = trim(cmd->sub(DEFINE->len()+1));
                        var macroname, replacement;

                        // simple "true" defines
                        macroname = define->match(TRUEMACRO);
                        if( macroname ) {
                                state->define(macroname, true);
                        } else {

                        // replace macro defines
                        macroname, replacement = define->match(REPLMACRO);
                        if( macroname && replacement ) {
                                state->define(macroname, replacement);
                        } else {

                        // read functional macros
                        macroname, replacement, source = state->parseFunction(define);
                        if( macroname && replacement ) {
                                // add original text for definition to check identify
                                state->define(macroname, replacement, false, source);
                        }

                        }
                        }

                        return;
                }

                // handle #include ...
                var filename = cmd->match(INCLUDE);
                if( filename ) {
                        return state->includeFile(filename);
                }
                filename = cmd->match(LOCAL_INCLUDE);
                if( filename ) {
                        return state->includeFile(filename, false, true);
                }
                filename = cmd->match(INCLUDE_NEXT);
                if( filename ) {
                //print("include_next:"..filename)
                        return state->includeFile(filename, true);
                }

                // ignore, because we dont have any pragma directives yet
                if( cmd->match(PRAGMA) ) { return; }

                // handle #error
                var errMsg = cmd->match(ERROR);
                var errNoTxt = cmd->match(ERROR_NOTEXT);
                var warnMsg = cmd->match(WARNING);
                if( errMsg ) { error(errMsg); }
                if( errNoTxt ) { error("<ERROR MESSAGE NOT SET>"); }
                if( warnMsg ) { 
                        print(warnMsg); 
                        return;
                }

                // abort on unknown keywords
                error("unknown directive: "..line);
        }

        if( state.incompleteLine ) {
                //print('merge with incompleteLine:'..state.incompleteLine)
                line = (state.incompleteLine .. line);
                state.incompleteLine = null;
        }


        /* APPLY MACROS *///
        // print(line)
        var _line,more = state->apply(line);
        // print('endprocess:'.._line)
        if( more ) {
                state.incompleteLine = line;
                return "";
        } else {
                return _line;
        }

        return line;
}

var function doWork(state) {
        var function _doWork(state) {
                if( ! state->defined(FILE) ) { state->define(FILE, "<USER_CHUNK>", true); }
                var oldIndent = state->getIndent();
                while( true ) {
                        var input = state->getLine();
                        if( ! input ) { break; }
                        var output = processLine(state, input);
                        if( ! preprocessor.FAST && ! output ) { output = ""; } // output empty skipped lines
                        if( preprocessor.DEBUG ) { output = output.." -- "..input; } // input as comment when DEBUG
                        if( output ) { coroutine.yield(output); }
                }
                if( (oldIndent != state->getIndent()) ) { error("indentation level must be balanced within a file. was:"..oldIndent.." is:"..state->getIndent()); }
        }
        return coroutine.wrap(function() { _doWork(state); });
}

var function includeFile(state, filename, next, _local) {
        var result, result_state = preprocessor.compileFile(filename, state.defines, state.macro_sources, next, _local);
        // now, we take the define table of the sub file for further processing
        state.defines = result_state.defines;
        // and return the compiled result
        return result;
}

// sets a global define
var function define(state, key, value, override, macro_source) {
        //print("define:"..key.." type:"..tostring(value).." value:"..tostring(pval))
        if( value && ! override ) {
                if( type(value) == 'function' ) {
                        assert(macro_source, "macro source should specify to check identity");
                        var pval = state.macro_sources[key];
                        if( pval && (pval != macro_source) ) { error("already defined: "..key); }
                        state.macro_sources[key] = macro_source;
                } else {
                        var pval = state.defines[key];
                        if( pval && (pval != value) ) { error("already defined: "..key); }
                }
        }
        state.defines[key] = state->prepareMacro(value);
}

// parses CPP exressions
// i.e.: #if !defined(_UNICODE) && !defined(UNICODE)
//
//BNF:
//  EXPR     -> (BRACKET_OPEN)(EXPR)(BRACKET_CLOSE)
//  EXPR     -> (EXPR)(OR)(EXPR)
//  EXPR     -> (EXPR)(AND)(EXPR)
//  EXPR     -> (NOT)(EXPR)
//  EXPR     -> (FUNCTION)
//  FUNCTION -> (IDENTIFIER)(BRACKET_OPEN)(ARGS)(BRACKET_CLOSE)
//  ARGS     -> ((IDENTIFIER)[(COMMA)(IDENTIFIER)])?
//LEAVES:
//  IGNORE -> " \t"
//  BRACKET_OPEN  -> "("
//  BRACKET_CLOSE -> ")"
//  OR -> "||"
//  AND -> "&&"
//  NOT -> "!"
//  IDENTIFIER -> "[0-9a-zA-Z_]"
//

var PRE_TOKENIZE_MACRO = {
        string = true,
        keywords_order = {
                "CONCAT",
                "SPACE",
        },
        keywords = { 
                CONCAT = "^%s*##%s*",
                SPACE = "^%s",
        },
};
var PRE_TOKENIZE_MACRO_ARGS = {
        string = true,
        keywords_order = {
                "STRING_LITERAL",
                "PARENTHESE",
                "FUNCTIONAL",
                "ARGS",
                "SINGLE_CHARACTER_ARGS",
                "COMMA",
        },
        keywords = { 
                PARENTHESE = "^%s*%b()",
                FUNCTIONAL = "^".. IDENTIFIER .. "%s*%b()",
                STRING_LITERAL = '^"[^"]*"',
                ARGS = "^[^,%s][^,]*[^,%s]",
                SINGLE_CHARACTER_ARGS = "^[^,%s]",
                COMMA = "^,",
        },
};
var PRE_TOKENIZE_EXPR = {
        string = false,
        keywords_order = {
                "DEFINED", 
                "FUNCTIONAL_MACRO",
                "BROPEN", 
                "BRCLOSE", 

                "TENARY_START",
                "TENARY_MIDDLE",
                // binary operators
                "EQUAL",
                "NOT_EQUAL",
                "AND", 
                "OR",
                "BAND",
                "BOR",
                "BXOR",
                "PLUS",
                "MINUS",
                "MULTIPLY",
                "DIV",
                "MOD",
                "LTE",
                "MTE",
                "LSHIFT",
                "RSHIFT",
                "LT",
                "MT",
                // unary operator
                "NOT", 
                "BNOT", 
                // literal
                "STRING_LITERAL",
                "CHAR_LITERAL",
                "HEX_LITERAL",
                "FPNUM_LITERAL",
                "NUMBER_LITERAL",
        },
        keywords = { 
                DEFINED = '^defined', 
                FUNCTIONAL_MACRO = '^' .. IDENTIFIER .. "%s*%b()",
                BROPEN = '^[(]', 
                BRCLOSE = '^[)]', 

                TENARY_START = '^%?',
                TENARY_MIDDLE = '^%:',

                EQUAL = '^==',
                NOT_EQUAL = '^!=',
                AND = '^&&', 
                OR = '^||',
                BAND = '^&', 
                BOR = '^|',
                BXOR = '^%^',
                PLUS = '^%+',
                MINUS = '^%-',
                MULTIPLY = '^%*',
                DIV = '^%/',
                MOD = '^%%',
                LTE = '^<=',
                MTE = '^>=',
                LSHIFT = '^<<',
                RSHIFT = '^>>',
                LT = '^<',
                MT = '^>',

                NOT = '^!', 
                BNOT = '^~',

                STRING_LITERAL = '^L?"[^"]*"',
                CHAR_LITERAL = "^L?'.*'",
                HEX_LITERAL = '^[%+%-]?0?x[a-fA-F%d]+[UL]*',
                FPNUM_LITERAL = '^[%+%-]?%d+[%.]?%d*e[%+%-]%d*',
                NUMBER_LITERAL = '^[%+%-]?0?b?%d+[%.]?%d*[UL]*',
        },
};

var function parseDefined(state, input) {
        var result = false;
        var bropen = false;
        var brclose = false;
        var ident = null;

        for( key, value in input ) {
                if( key == "BROPEN" ) {
                        bropen = true;
                }
                if( key == "identifier" ) {
                         ident = value;
                         if( ! bropen ) { break; }
                }
                if( key == "BRCLOSE" && ident ) {
                        brclose = true;
                        break;
                }
        }

        // wiht and w/o brackets allowed
        if( ident && ((bropen && brclose) || (! bropen && ! brclose)) ) {
                return state->defined(ident);
        }

        error("expression parse error: defined(ident)");
}


/*
order : smaller is higher priority
1       ()   []   ->   .  
2        !   ~   -   +   *   &   sizeof   type cast   ++   --  
3       *   /   %
4       +   -
5       <<   >>
6       <   <=   >   >=
7       ==   !=
8       &
9       ^
10      |
11      &&
12      ||
13       ?:   =   +=   -=   *=   /=   %=   &=   |=   ^=   <<=   >>=
14      ,
*/
var combination_order = function (op, unary) {
        if( unary ) {
                if( op == '-' || op == '!' || op == '~' ) {
                        return 2;
                } else {
                        assert(false, 'unsupported unary operator:' .. op);
                }
        } else {
                if( op == '*' || op == '/' || op == '%' ) {
                        return 3;
                } else if( op == '+' || op == '-' ) {
                        return 4;
                } else if( op == '>>' || op == '<<' ) {
                        return 5;
                } else if( op == '<' || op == '>' || op == '<=' || op == '>=' ) {
                        return 6;
                } else if( op == '==' || op == '!=' ) {
                        return 7;
                } else if( op == '&' ) {
                        return 8;
                } else if( op == '^' ) {
                        return 9;
                } else if( op == '|' ) {
                        return 10;
                } else if( op == '&&' ) {
                        return 11;
                } else if( op == '||' ) {
                        return 12;
                } else if( op == '?' || op == ':' ) {
                        return 13;
                } else {
                        assert(false, 'unsupported operator:' .. op);
                }
        }
};

var evaluate;
evaluate = function (node) {
        if( ! node.op ) { // leaf node or leaf node with unary operators
                var v = node.v;
                if( node.uops ) {
                        for( _, uop in ipairs(node.uops) ) {
                                // print('apply uop:'..uop.."|"..tostring(v))
                                if( uop == '-' ) {
                                        v = -v;
                                } else if( uop == '!' ) {
                                        v = (! v);
                                } else if( uop == '~' ) {
                                        v = bit.bnot(v);
                                } else {
                                        assert(false, 'invalid uop:' .. tostring(uop));
                                }
                        }
                }
                // print('after apply:'..tostring(v))
                return v;
        }
        // print(node.op..':'..tostring(node.l.v or node.l.op).."("..type(node.l.v)..")|"..tostring(node.r.v or node.r.op).."("..type(node.r.v)..")")
        if( node.op == '+' ) { // binary operators
                return (evaluate(node.l) + evaluate(node.r));
        } else if( node.op == '-' ) {
                return (evaluate(node.l) - evaluate(node.r));
        } else if( node.op == '*' ) {
                return (evaluate(node.l) * evaluate(node.r));
        } else if( node.op == '/' ) {
                return (evaluate(node.l) / evaluate(node.r));
        } else if( node.op == '%' ) {
                return (evaluate(node.l) % evaluate(node.r));
        } else if( node.op == '==' ) {
                return (evaluate(node.l) == evaluate(node.r));
        } else if( node.op == '!=' ) {
                return (evaluate(node.l) != evaluate(node.r));
        } else if( node.op == '<<' ) {
                return bit.lshift(evaluate(node.l), evaluate(node.r));
        } else if( node.op == '>>' ) {
                return bit.rshift(evaluate(node.l), evaluate(node.r));
        } else if( node.op == '&&' ) {
                return (CBoolean(evaluate(node.l)) && CBoolean(evaluate(node.r)));
        } else if( node.op == '||' ) {
                return (CBoolean(evaluate(node.l)) || CBoolean(evaluate(node.r)));
        } else if( node.op == '&' ) {
                return bit.band(evaluate(node.l), evaluate(node.r));
        } else if( node.op == '|' ) {
                return bit.bor(evaluate(node.l), evaluate(node.r));
        } else if( node.op == '^' ) {
                return bit.bxor(evaluate(node.l), evaluate(node.r));
        } else if( node.op == '<=' ) {
                return (evaluate(node.l) <= evaluate(node.r));
        } else if( node.op == '>=' ) {
                return (evaluate(node.l) >= evaluate(node.r));
        } else if( node.op == '<' ) {
                return (evaluate(node.l) < evaluate(node.r));
        } else if( node.op == '>' ) {
                return (evaluate(node.l) > evaluate(node.r));
        } else {
                assert(false, 'invalid op:' .. tostring(node.op));
        }
};

var function setValue(node, v) {
        // print('setValue:' .. tostring(v).."|"..tostring(node.uops))-- .. "\t" .. debug.traceback())
        if( ! node.op ) {
                assert(! node.v, debug.traceback());
                node.v = v;
        } else {
                assert(node.l && (! node.r));
                node.r = {v = v, uops = node.uops};
        }
}

var function setUnaryOp(node, uop) {
        // print('setUnaryOp:' .. tostring(uop))-- .. "\t" .. debug.traceback())
        if( ! node.uops ) { node.uops = {}; }
        table.insert(node.uops, 1, uop);
}

var function parseExpr(state, input) { 
        var node = {};
        var root = node;
        // first call gets string input. rest uses tokenizer
        if( type(input) == "string" ) {
                // print('parse:' .. input) 
                input = tokenizer(input, PRE_TOKENIZE_EXPR); 
        }

        for( type, value in input ) {
                // print("type:"..type.." value:"..value)
                // unary operator
                if( type == "NOT" || 
                        type == "BNOT" ) {
                        setUnaryOp(node, value);
                }
                if( type == "BROPEN" ) {
                        setValue(node, state->parseExpr(input));
                }
                if( type == "BRCLOSE" ) {
                        //print('BRCLOSE:' .. tostring(result))
                        break;
                }
                if( type == "STRING_LITERAL" ) {
                        setValue(node, value->sub(value[1] == 'L' && 3 || 2,-2));
                }
                if( type == "NUMBER_LITERAL" || type == "HEX_LITERAL" || type == "FPNUM_LITERAL" || type == "CHAR_LITERAL" ) {
                        setValue(node, tonumber(parseCInteger(value)));
                }
                // tenary operator
                // tenary has lowest priority, so any other operation can be calculate now.
                if( type == "TENARY_START" ) {
                        var l = state->parseExpr(input);
                        var r = state->parseExpr(input);
                        if( evaluate(root) ) {
                                return l;
                        } else {
                                return r;
                        }
                }
                if( type == "TENARY_MIDDLE" ) {
                        break;
                }
                // binary operator
                if( type == "EQUAL" ||
                        type == "NOT_EQUAL" ||
                        type == "AND" ||
                        type == "OR" ||
                        type == "BAND" ||
                        type == "BOR" ||
                        type == "BXOR" ||
                        type == "PLUS" ||
                        type == "MINUS" ||
                        type == "MULTIPLY" ||
                        type == "DIV" ||
                        type == "MOD" ||
                        type == "LTE" ||
                        type == "MTE" ||
                        type == "LSHIFT" ||
                        type == "RSHIFT" ||
                        type == "LT" ||
                        type == "MT" ) {
                        if( node.op ) { 
                                if( ! node.r ) { // during parse right operand : uop1 uop2 ... uopN operand1 op1 uop(N+1) uop(N+2) ... [uop(N+K)]
                                        assert(type == "MINUS",  "error: operators come consequently: " .. tostring(node.op) .. " and " .. tostring(value));
                                        // unary operater after binary operator
                                        setUnaryOp(node, value);
                                } else { // uop1 uop2 ... uopN operand1 op1 uop(N+1) uop(N+2) ... uop(N+M) operand2 [op2]
                                        // print("operator processing:" .. tostring(node.op) .. "|" .. value .. "|" .. tostring(node.l) .. "|" .. tostring(node.r))
                                        var tmp = node;
                                        while( tmp ) {
                                                // print('compare ' .. value..' and ' .. tmp.op)
                                                if( combination_order(tmp.op) > combination_order(value) ) {
                                                        // print(value..' is stronger than ' .. tmp.op)
                                                        break;
                                                }
                                                tmp = tmp.parent;
                                        }
                                        if( tmp ) {
                                                node = {
                                                        op = value,
                                                        l = tmp.r,
                                                        parent = tmp
                                                };
                                                tmp.r.parent = node;
                                                tmp.r = node;
                                        } else {
                                                node = {
                                                        op = value,
                                                        l = root,
                                                };
                                                root.parent = node;
                                                root = node;
                                        }
                                }
                        } else if( node.v != null ) { // uop1 uop2 ... uopN operand1 [op]
                                var devided;
                                if( node.uops ) {
                                        for( _, uop in ipairs(node.uops) ) {
                                                if( combination_order(uop, true) > combination_order(value) ) {
                                                        // there is a binary operator which has stronger than any of the unary
                                                        devided = uop;
                                                }
                                        }
                                }
                                if( devided ) {
                                        assert(false, "TODO: can we do something about this case??:"..value.." is stronger than "..devided);
                                } else {
                                        node.l = { v = node.v, uops = node.uops };
                                        node.v = null;
                                        node.uops = null;
                                        node.op = value;
                                }
                        } else { // unary operator : uop1 uop2 ... [uopN]
                                assert(type == "MINUS", "error: invalid unary operator:" .. value);
                                setUnaryOp(node, value);
                        }
                }
                if( type == "DEFINED" ) {
                        setValue(node, parseDefined(state, input));
                } else if( type == "identifier" || type == "FUNCTIONAL_MACRO" ) {
                        // print('ident:' .. value)
                        var eval = state->apply(value);
                        // print('apply result ' .. eval .. "|" .. tostring(unprocessed))
                        if( eval != value ) {
                                eval = state->parseExpr(eval);
                                // print('re-evaluate expr ' .. tostring(eval))
                                setValue(node, eval);
                        } else {
                                // undefined macro symbol is always treated as 0.
                                // http://gcc.gnu.org/onlinedocs/cpp/If.html#If
                                setValue(node, 0);
                        }
                }
        }

        var r = evaluate(root);
        // print('evaluate:' .. tostring(r))
        return r;
}

// apply string ops "##"
var function prepareMacro(state, input) {
        if( type(input) != "string" ) { return input; }
        do {
                var out = {};
                var concat;
                for( k, v, start, end_ in tokenizer(input, PRE_TOKENIZE_MACRO) ) {
                        if( k == "CONCAT" ) {
                                // remove concat op "##"
                                concat = true;
                        } else {
                                table.insert(out, input->sub(start, end_));
                        }
                }
                input = table.concat(out);
        } while(!( ! concat) );
        return input;
}

// macro args replacement function slower but more torelant for pathological case 
var function replaceArgs(argsstr, repl) {
        var args = {};
        argsstr = argsstr->sub(2,-2);
        // print('argsstr:'..argsstr)
        var comma;
        for( k, v, start, end_ in tokenizer(argsstr, PRE_TOKENIZE_MACRO_ARGS) ) {
                // print("replaceArgs:" .. k .. "|" .. v)
                if( k == "ARGS" || k == "PARENTHESE" || k == "STRING_LITERAL" || 
                        k == "FUNCTIONAL" || k == "SINGLE_CHARACTER_ARGS" ) {
                        table.insert(args, v);
                        comma = false;
                } else if( k == "COMMA" ) {
                        if( comma ) {
                                // continued comma means empty parameter
                                table.insert(args, "");
                        }
                        comma = true;
                }
        }
        var v = repl->gsub("%$(%d+)", function (m) { return args[tonumber(m)] || ""; });
        // print("replaceArgs:" .. repl .. "|" .. tostring(#args) .. "|" .. v)
        return v;
}

// i.e.: "MAX(x, y) (((x) > (y)) ? (x) : (y))"
var function parseFunction(state, input) {
        if( ! input ) { return; }
        var concat;
        var name, argsstr, repl = input->match(FUNCMACRO);
        if( ! name || ! argsstr || ! repl ) { return; }

        // rename args to $1,$2... for later gsub
        var noargs = 0;
        for( argname in argsstr->gmatch(IDENTIFIER) ) {
                noargs = noargs + 1;
                // avoid matching substring of another identifier (eg. attrib matches attribute and replace it)
                repl = repl->gsub("(#*)(%s*)("..argname..")([_%w]?)", function (s1, s2, s3, s4) {
                        if( #s4 <= 0 ) {
                                return (#s1 == 1) && ("\"$"..noargs.."\"") || (s1..s2.."$"..noargs);
                        } else {
                                return s1..s2..s3..s4;
                        }
                });
        }
        // remove concat (after replace matching argument name to $1, $2, ...)
        repl = repl->gsub("%s*##%s*", "");

        // build macro funcion
        var func = function(input) {
                return input->gsub(name.."%s*(%b())", function (match) {
                        return replaceArgs(match, repl);
                });
        };

        return name, func, repl;
}


// ------------
// PRE INTERFACE
// ------------

//- initialies a preprocessor state. not needed manually. handy for testing
function preprocessor.init(input, predefines, macro_sources) {
        // create sate var
        var state     = {};              // init the state object
        state.defines   = {};              // the table of known defines and replacements
        state.screener  = screener(input);
        state.lineno    = 0;               // the current line number
        state.stack     = {};              // stores wether the current stack level is to be included
        state.once      = {};              // stack level was once true (first if that evals to true)
        state.macro_sources = macro_sources || {}; // original replacement text for functional macro 

        // funcs
        state.define = define;
        state.undefine = function(state, key) {
                state->define(key, null);
                state.macro_sources[key] = null;
        };
        state.defined = function(state, key) {
                return state.defines[key] != null;
        };
        state.apply = apply;
        state.includeFile = includeFile;
        state.doWork = doWork;
        state.getIndent = function(state) {
                return #state.stack;
        };
        state.openBlock = function(state, bool) {
                state.stack[#state.stack+1] = bool;
                state.once [#state.once+1]  = bool;
                state->define(PRE_INDENT, state->getIndent(), true);
        };
        state.elseBlock = function(state, bool) {
                if( state.once[#state.once] ) {
                        state.stack[#state.stack] = false;
                } else {
                        state.stack[#state.stack] = bool;
                        if( bool ) { state.once[#state.once] = true; }
                }
        };
        state.closeBlock = function(state) {
                state.stack[#state.stack] = null;
                state.once [#state.once]  = null;
                state->define(PRE_INDENT, state->getIndent(), true);
                if( state->getIndent() < 0 ) { error("Unopened block detected. Indentaion problem."); }
        };
        state.skip = function(state) {
                for( i = 1, #state.stack ) {
                        if( ! state.stack[i] ) { return i; }
                }
                return false;
        };
        state.getLine = function(state) {
                state.lineno = state.lineno + 1;
                state->define(LINE, state.lineno, true);
                return state.screener();
        };
        state.prepareMacro = prepareMacro;
        state.parseExpr = parseExpr;
        state.parseFunction = parseFunction;

        // predefines
        state->define(DATE, os.date("%B %d %Y"), true);
        state->define(TIME, os.date("%H:%M:%S"), true);
        state->define(LINE, state.lineno, true);
        state->define(PRE_INDENT, state->getIndent(), true);
        predefines = predefines || {};
        for( k,v in pairs(preprocessor.ENV) ) { state->define(k, v, true); }    // static ones
        for( k,v in pairs(predefines) ) {       state->define(k, v, true); }

        if( preprocessor.PRE_TEST ) { preprocessor.STATE = state; } // activate static state debugging

        return state;
}

//- the preprocessors main function.
// returns the preprocessed output as a string.
// @param code data as string
// @param predefines OPTIONAL a table of predefined variables
// @usage preprocessor.compile("#define bar 0x1337\nstatic const int foo = bar;")
// @usage preprocessor.compile("#define bar 0x1337\nstatic const int foo = bar;", {["bar"] = "0x1338"})
function preprocessor.compile(code, predefines, macro_sources) {
        var state = preprocessor.init(code, predefines, macro_sources);
        var buf = {};
        for( output in state->doWork() ) {
                table.insert(buf, output);
        }
        var output = table.concat(buf, NEWL);
        if( preprocessor.DEBUG ) { print(output); }
        return output, state;
}

//- preprocesses a file
// @param filename the file to read
// @param predefines OPTIONAL a table of predefined variables
// @usage out, state = preprocessor.compileFile("../odbg/plugin.h", {["MAX_PAH"]=260, ["UNICODE"]=true})
function preprocessor.compileFile(filename, predefines, macro_sources, next, _local) {
        if( ! filename ) { error("processFile() arg1 has to be a string"); }
        var file = io.open(filename, 'r');
        if( ! file ) { error("file not found: "..filename); }
        var code = file->read('*a');
        predefines = predefines || {};
        predefines[FILE] = filename;
        return preprocessor.compile(code, predefines, macro_sources);
}


// ------------
// SATIC UNIT TESTS
// ------------
function preprocessor.test(suppressMsg) {
        var testLabelCount = 0;
        var function getTestLabel() {
                ++testLabelCount    ;
                return " preprocessor_assert_"..testLabelCount;
        }

        // this ugly global is required so our testcode can find it
        _G.preprocessor_test = {
                assertTrueCalls = 0;
                assertTrueCount = 0;
                assertTrue = function() {
                        preprocessor_test.assertTrueCount = preprocessor_test.assertTrueCount + 1;
                }
        };

        var testpreprocessor = [=[]=];
        preprocessor.FAST = false;      // enable full valid output for testing
        preprocessor.SELF_TEST = true;
        var testlua = preprocessor.compile(testpreprocessor);
        preprocessor.SELF_TEST = null;
        //      print(testlua)
        assert(loadstring(testlua, "testlua"))();
        preprocessor_test.assertTrueCalls = findn(testpreprocessor, "preprocessor_test.assertTrue()");
        assert(preprocessor_test.assertTrueCount == preprocessor_test.assertTrueCalls, "assertTrue calls:"..preprocessor_test.assertTrueCalls.." count:"..preprocessor_test.assertTrueCount);
        _G.preprocessor_test = null;    // delete ugly global hack
        if( ! suppressMsg ) { print("Test run suscessully"); }
}
if( preprocessor.PRE_TEST ) { preprocessor.test(true); }


// ------------
// REGISTER PRE
// ------------

//- disable preprocessor processing for ffi, loadstring and such
preprocessor.disable = function() {
        if( /*preprocessor.PRE_LUA*/ true ) {
                // activate PRE_LUA actually does anything useful
                // _G.loadstring = _G.loadstring_preprocessor_backup
        }

        if( preprocessor.PRE_FFI && pcall(require, "ffi") ) {
                ffi = require("ffi");
                if( ffi.preprocessor_cdef_backup ) {
                        ffi.cdef = ffi.preprocessor_cdef_backup;
                        ffi.preprocessor_cdef_backup = null;
                }
        }
};

//- (re)enable preprocessor processing for ffi, loadstring and such
preprocessor.enable = function() {
        // Use PRE to process Lua code (load, loadfile, loadstring...)
        if( /*preprocessor.PRE_LUA*/ true ) {
                // TODO: make it properly work on all functions
                _G.loadstring_preprocessor_backup = _G.loadstring;
                _G.loadstring = function(str, chunk) { 
                        return loadstring_preprocessor_backup(preprocessor.compile(str), chunk); 
                };
        }
        // Use PRE as LuaJIT PreProcessor if used inside LuaJIT. i.e. Hook ffi.cdef
        if( preprocessor.PRE_FFI && pcall(require, "ffi") ) {
                ffi = require("ffi");
                if( ! ffi.preprocessor_cdef_backup ) {
                        if( ! ffi.preprocessor_defs ) { ffi.preprocessor_defs = {}; } // defs are stored and reused
                        ffi.preprocessor = function(input) { 
                                var output, state = preprocessor.compile(input, ffi.preprocessor_defs, ffi.preprocessor_macro_sources);
                                ffi.preprocessor_defs = state.defines;
                                ffi.preprocessor_macro_sources = state.macro_sources;
                                return output;
                        };
                        ffi.preprocessor_cdef_backup = ffi.cdef;
                        ffi.cdef = function(input) { 
                                if( true ) {
                                        return ffi.preprocessor_cdef_backup(ffi.preprocessor(input)); 
                                } else {
                                        var fn,cnt = input->gsub('#include ["<].-([^/]+%.h)[">]', '%1');
                                        input = ffi.preprocessor(input);
                                        if( cnt > 0 ) {
                                                var f = io.open("./tmp/"..fn, 'w');
                                                if( f ) {
                                                        f->write(input);
                                                        f->close();
                                                } else {
                                                        assert(fn->find('/'), 'cannot open: ./tmp/'..fn);
                                                }
                                        }
                                        return ffi.preprocessor_cdef_backup(input); 
                                }
                        };
                }
        }
};

preprocessor.enable();

/* interface */
function preprocessor::Interface(...){
    args = {...};

    // First arg should be a filename
    filename = args[1];

    // Second arg will be flags
    outfile = "";

    table.remove(args, 1);
    flags = {};

    for (i, v in pairs(args)){
        if (v == "-d"){
            preprocessor.DEBUG = true;
        }else if (v == "-t"){
            preprocessor.PRE_TEST = true;
        }else if (v == "-f"){
            preprocessor.FAST = true;
        }else if (v == "-o"){
            outfile = args[i+1];
        }else if (v == "-D"){
            rest = v->sub(3);
            key = rest->sub(1, rest->find("=")-1);
            value = rest->sub(rest->find("=")+1);
            flags[key] = value;
        }else if (v == "-h"){
            print("Usage: cobaltpre [flags] <filename>");
            print("Flags:");
            print("  -d: Enable debug output");
            print("  -t: Run unit tests");
            print("  -f: Enable fast mode");
            print("  -o: Output to file");
            print("  -h: Show this help");
            return;
        }
    }
    
    /* run */
    compiled = preprocessor.compileFile(filename, flags);

    if (outfile == "" || !outfile){
        error("No file to output to");
    }else{
        file = io.open(outfile, "w");
        file->write(compiled);
        file->close();
    }
}

return preprocessor;