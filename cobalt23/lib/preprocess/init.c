#include "aot_header.c"

// source = @init.cobalt
// main function
static
CallInfo *magic_implementation_00(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
    case 132: goto label_132;
    case 133: goto label_133;
    case 134: goto label_134;
    case 135: goto label_135;
    case 136: goto label_136;
    case 137: goto label_137;
    case 138: goto label_138;
    case 139: goto label_139;
    case 140: goto label_140;
    case 141: goto label_141;
    case 142: goto label_142;
    case 143: goto label_143;
    case 144: goto label_144;
    case 145: goto label_145;
    case 146: goto label_146;
    case 147: goto label_147;
    case 148: goto label_148;
    case 149: goto label_149;
    case 150: goto label_150;
    case 151: goto label_151;
    case 152: goto label_152;
    case 153: goto label_153;
    case 154: goto label_154;
    case 155: goto label_155;
    case 156: goto label_156;
    case 157: goto label_157;
    case 158: goto label_158;
    case 159: goto label_159;
    case 160: goto label_160;
    case 161: goto label_161;
    case 162: goto label_162;
    case 163: goto label_163;
    case 164: goto label_164;
    case 165: goto label_165;
    case 166: goto label_166;
    case 167: goto label_167;
  }

  // 0	[1]	VARARGPREP	0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000051);
    ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));
    if (l_unlikely(trap)) {  /* previous "Protect" updated trap */
      luaD_hookcall(L, ci);
      L->oldpc = 1;  /* next opcode will be seen as a "new" line */
    }
    updatebase(ci);  /* function has new base after adjustment */
  }

  // 1	[51]	GETTABUP 	0 0 1	; _ENV "import"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0100000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[51]	LOADK    	1 0	; "switch"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 3	[51]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[51]	SETTABUP 	0 0 0	; _ENV "switch"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0000000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 5	[52]	GETTABUP 	0 0 3	; _ENV "file"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0300000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[52]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 7	[52]	JMP      	3	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_11;
  }

  // 8	[52]	GETTABUP 	0 0 1	; _ENV "import"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0100000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 9	[52]	LOADK    	1 3	; "file"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00018083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 10	[52]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 11	[52]	SETTABUP 	0 2 0	; _ENV "filesystem"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0002000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 12	[53]	GETTABUP 	0 0 1	; _ENV "import"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0100000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[53]	LOADK    	1 5	; "ext.file"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00028083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 14	[53]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 15	[53]	SETTABUP 	0 4 0	; _ENV "filex"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x0004000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 16	[54]	GETTABUP 	0 0 6	; _ENV "core"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0600000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[54]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 18	[54]	JMP      	3	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_22;
  }

  // 19	[54]	GETTABUP 	0 0 1	; _ENV "import"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0100000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 20	[54]	LOADK    	1 6	; "core"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00030083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 21	[54]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 22	[54]	SETTABUP 	0 6 0	; _ENV "core"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0006000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 23	[56]	CLOSURE  	0 0	; 0x7fe077105310
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x0000004f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 24	[56]	SETTABUP 	0 7 0	; _ENV "macros"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0007000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 25	[88]	NEWTABLE 	0 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00000013);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 26	[88]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 27	[88]	SETTABUP 	0 8 0	; _ENV "dead"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0008000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 28	[104]	CLOSURE  	0 1	; 0x7fe077104fe0
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x0000804f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 29	[91]	SETTABUP 	0 9 0	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0009000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 30	[137]	CLOSURE  	0 2	; 0x7fe077105bf0
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x0001004f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 31	[106]	SETTABUP 	0 10 0	; _ENV "tabletostring"
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000a000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 32	[150]	CLOSURE  	0 3	; 0x7fe0771062c0
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x0001804f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 33	[138]	SETTABUP 	0 11 0	; _ENV "loadenv"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x000b000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 34	[153]	NEWTABLE 	0 7 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00070013);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 35	[153]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 36	[157]	CLOSURE  	1 4	; 0x7fe077106ac0
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x000200cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 37	[157]	SETFIELD 	0 13 1	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x010d0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 38	[160]	CLOSURE  	1 5	; 0x7fe077106c50
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x000280cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 39	[160]	SETFIELD 	0 14 1	; "pos"
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x010e0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 40	[163]	CLOSURE  	1 6	; 0x7fe077106de0
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x000300cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 41	[163]	SETFIELD 	0 15 1	; "neg"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x010f0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 42	[166]	CLOSURE  	1 7	; 0x7fe0771053a0
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x000380cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 43	[166]	SETFIELD 	0 16 1	; "posint"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x01100012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 44	[169]	CLOSURE  	1 8	; 0x7fe0771072b0
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x000400cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 45	[169]	SETFIELD 	0 17 1	; "negint"
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x01110012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 46	[173]	CLOSURE  	1 9	; 0x7fe077107400
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x000480cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 47	[173]	SETFIELD 	0 18 1	; "pointer"
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x01120012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 48	[181]	CLOSURE  	1 10	; 0x7fe077107590
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x000500cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 49	[181]	SETFIELD 	0 19 1	; "array"
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x01130012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 50	[185]	CLOSURE  	1 11	; 0x7fe077107760
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x000580cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 51	[185]	SETFIELD 	0 20 1	; "terminating"
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x01140012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 52	[189]	CLOSURE  	1 12	; 0x7fe077107930
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x000600cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 53	[189]	SETFIELD 	0 21 1	; "nonterminating"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x01150012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 54	[197]	CLOSURE  	1 13	; 0x7fe077107b00
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x000680cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 55	[197]	SETFIELD 	0 22 1	; "matrix"
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x01160012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 56	[201]	CLOSURE  	1 14	; 0x7fe077107cd0
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x000700cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 57	[201]	SETFIELD 	0 23 1	; "Vector3"
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x01170012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 58	[205]	CLOSURE  	1 15	; 0x7fe077107ee0
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x000780cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 59	[205]	SETFIELD 	0 24 1	; "Vector2"
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x01180012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 60	[209]	CLOSURE  	1 16	; 0x7fe0771081f0
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x000800cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 61	[209]	SETFIELD 	0 25 1	; "Color"
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x01190012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 62	[213]	CLOSURE  	1 17	; 0x7fe077108380
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x000880cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 63	[213]	SETFIELD 	0 26 1	; "Transform"
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x011a0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 64	[217]	CLOSURE  	1 18	; 0x7fe077108600
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x000900cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 65	[217]	SETFIELD 	0 27 1	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x011b0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 66	[221]	CLOSURE  	1 19	; 0x7fe077108910
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x000980cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 67	[221]	SETFIELD 	0 28 1	; "boolean"
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x011c0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 68	[225]	CLOSURE  	1 20	; 0x7fe077108a20
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x000a00cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 69	[225]	SETFIELD 	0 29 1	; "table"
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x011d0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 70	[229]	CLOSURE  	1 21	; 0x7fe077108bb0
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x000a80cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 71	[229]	SETFIELD 	0 30 1	; "function"
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x011e0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 72	[233]	CLOSURE  	1 22	; 0x7fe077108d40
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x000b00cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 73	[233]	SETFIELD 	0 31 1	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x011f0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 74	[237]	CLOSURE  	1 23	; 0x7fe077106f70
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x000b80cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 75	[237]	SETFIELD 	0 32 1	; "thread"
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x01200012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 76	[241]	CLOSURE  	1 24	; 0x7fe077108ed0
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x000c00cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 77	[241]	SETFIELD 	0 33 1	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x01210012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 78	[245]	CLOSURE  	1 25	; 0x7fe077109020
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x000c80cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 79	[245]	SETFIELD 	0 34 1	; "char"
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x01220012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 80	[250]	CLOSURE  	1 26	; 0x7fe077109170
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x000d00cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 81	[250]	SETFIELD 	0 35 1	; "msg"
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x01230012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 82	[255]	CLOSURE  	1 27	; 0x7fe077109300
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x000d80cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 83	[255]	SETFIELD 	0 36 1	; "complex"
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x01240012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 84	[260]	CLOSURE  	1 28	; 0x7fe077109560
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x000e00cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 85	[260]	SETFIELD 	0 37 1	; "directory"
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x01250012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 86	[265]	CLOSURE  	1 29	; 0x7fe0771096f0
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x000e80cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 87	[265]	SETFIELD 	0 38 1	; "lock"
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x01260012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 88	[269]	CLOSURE  	1 30	; 0x7fe077109880
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x000f00cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 89	[269]	SETFIELD 	0 39 1	; "protected"
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x01270012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 90	[274]	CLOSURE  	1 31	; 0x7fe077109a10
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x000f80cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 91	[274]	SETFIELD 	0 40 1	; "_LUABOX"
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x01280012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 92	[278]	CLOSURE  	1 32	; 0x7fe0771080f0
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x001000cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 93	[278]	SETFIELD 	0 41 1	; "any"
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x01290012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 94	[282]	CLOSURE  	1 33	; 0x7fe077109da0
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x001080cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 95	[282]	SETFIELD 	0 42 1	; "thread"
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x012a0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 96	[286]	CLOSURE  	1 34	; 0x7fe077109ef0
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x001100cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 97	[286]	SETFIELD 	0 43 1	; "int"
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x012b0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 98	[290]	CLOSURE  	1 35	; 0x7fe07710a080
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x001180cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 99	[290]	SETFIELD 	0 44 1	; "float"
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x012c0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 100	[294]	CLOSURE  	1 36	; 0x7fe07710a210
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x001200cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 101	[294]	SETFIELD 	0 45 1	; "double"
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x012d0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 102	[295]	SETTABUP 	0 12 0	; _ENV "types"
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x000c000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 103	[296]	NEWTABLE 	0 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x00000013);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 104	[296]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 105	[296]	SETTABUP 	0 46 0	; _ENV "alltypes"
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x002e000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 106	[298]	GETTABUP 	0 0 47	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x2f00000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 107	[298]	GETTABUP 	1 0 12	; _ENV "types"
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x0c00008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 108	[298]	CALL     	0 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x05020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 109	[298]	TFORPREP 	0 5	; to 116
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x0002804b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_115;
  }

  // 110	[299]	GETTABUP 	6 0 48	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x3000030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 111	[299]	GETFIELD 	6 6 49	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x3106030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 112	[299]	GETTABUP 	7 0 46	; _ENV "alltypes"
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x2e00038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 113	[299]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 114	[299]	CALL     	6 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x01030344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 115	[298]	TFORCALL 	0 2
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x0200004c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 116	[298]	TFORLOOP 	0 7	; to 111
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x0003804d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_110; /* jump back */
    }
  }

  // 117	[300]	CLOSE    	0
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x00000036);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 118	[315]	CLOSURE  	0 37	; 0x7fe07710a420
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x0012804f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 119	[303]	SETTABUP 	0 50 0	; _ENV "deffind"
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x0032000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 120	[330]	CLOSURE  	0 38	; 0x7fe07710a8d0
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x0013004f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 121	[316]	SETTABUP 	0 51 0	; _ENV "assign"
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x0033000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 122	[342]	CLOSURE  	0 39	; 0x7fe07710acb0
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x0013804f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 123	[331]	SETTABUP 	0 52 0	; _ENV "findfunctions"
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x0034000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 124	[356]	CLOSURE  	0 40	; 0x7fe07710af50
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x0014004f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 125	[343]	SETTABUP 	0 53 0	; _ENV "allassign"
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x0035000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 126	[368]	CLOSURE  	0 41	; 0x7fe07710b360
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x0014804f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 127	[357]	SETTABUP 	0 54 0	; _ENV "findall"
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x0036000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 128	[394]	CLOSURE  	0 42	; 0x7fe07710b670
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x0015004f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 129	[369]	SETTABUP 	0 55 0	; _ENV "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x0037000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 130	[416]	CLOSURE  	0 43	; 0x7fe077108810
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_132
  label_130: {
    aot_vmfetch(0x0015804f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 131	[395]	SETTABUP 	0 56 0	; _ENV "clean"
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_133
  label_131: {
    aot_vmfetch(0x0038000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 132	[419]	GETTABUP 	0 0 58	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 133)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_134
  label_132: {
    aot_vmfetch(0x3a00000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 133	[419]	SETTABUP 	0 57 0	; _ENV "typeof"
  #undef  AOT_PC
  #define AOT_PC (code + 134)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_135
  label_133: {
    aot_vmfetch(0x0039000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 134	[441]	CLOSURE  	0 44	; 0x7fe07710c320
  #undef  AOT_PC
  #define AOT_PC (code + 135)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_136
  label_134: {
    aot_vmfetch(0x0016004f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 135	[420]	SETTABUP 	0 59 0	; _ENV "check"
  #undef  AOT_PC
  #define AOT_PC (code + 136)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_137
  label_135: {
    aot_vmfetch(0x003b000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 136	[483]	CLOSURE  	0 45	; 0x7fe07710c9c0
  #undef  AOT_PC
  #define AOT_PC (code + 137)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_138
  label_136: {
    aot_vmfetch(0x0016804f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 137	[444]	SETTABUP 	0 60 0	; _ENV "typecheck"
  #undef  AOT_PC
  #define AOT_PC (code + 138)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_139
  label_137: {
    aot_vmfetch(0x003c000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 138	[490]	CLOSURE  	0 46	; 0x7fe077105d30
  #undef  AOT_PC
  #define AOT_PC (code + 139)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_140
  label_138: {
    aot_vmfetch(0x0017004f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 139	[484]	SETTABUP 	0 61 0	; _ENV "all"
  #undef  AOT_PC
  #define AOT_PC (code + 140)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_141
  label_139: {
    aot_vmfetch(0x003d000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 140	[492]	NEWTABLE 	0 3 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 141)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_142
  label_140: {
    aot_vmfetch(0x00030013);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 141	[492]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 142)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_143
  label_141: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 142	[493]	GETTABUP 	1 0 61	; _ENV "all"
  #undef  AOT_PC
  #define AOT_PC (code + 143)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_144
  label_142: {
    aot_vmfetch(0x3d00008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 143	[493]	SETFIELD 	0 61 1	; "all"
  #undef  AOT_PC
  #define AOT_PC (code + 144)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_145
  label_143: {
    aot_vmfetch(0x013d0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 144	[494]	GETTABUP 	1 0 60	; _ENV "typecheck"
  #undef  AOT_PC
  #define AOT_PC (code + 145)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_146
  label_144: {
    aot_vmfetch(0x3c00008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 145	[494]	SETFIELD 	0 63 1	; "check"
  #undef  AOT_PC
  #define AOT_PC (code + 146)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_147
  label_145: {
    aot_vmfetch(0x013f0012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 146	[495]	GETTABUP 	1 0 64	; _ENV "clean"
  #undef  AOT_PC
  #define AOT_PC (code + 147)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_148
  label_146: {
    aot_vmfetch(0x4000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 147	[495]	SETFIELD 	0 64 1	; "clean"
  #undef  AOT_PC
  #define AOT_PC (code + 148)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_149
  label_147: {
    aot_vmfetch(0x01400012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 148	[496]	GETTABUP 	1 0 55	; _ENV "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 149)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_150
  label_148: {
    aot_vmfetch(0x3700008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 149	[496]	SETFIELD 	0 55 1	; "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 150)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_151
  label_149: {
    aot_vmfetch(0x01370012);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 150	[497]	SETTABUP 	0 62 0	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 151)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_152
  label_150: {
    aot_vmfetch(0x003e000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 151	[539]	CLOSURE  	0 47	; 0x7fe07710d6f0
  #undef  AOT_PC
  #define AOT_PC (code + 152)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_153
  label_151: {
    aot_vmfetch(0x0017804f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 152	[524]	SETTABUP 	0 65 0	; _ENV "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 153)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_154
  label_152: {
    aot_vmfetch(0x0041000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 153	[552]	CLOSURE  	0 48	; 0x7fe07710d980
  #undef  AOT_PC
  #define AOT_PC (code + 154)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_155
  label_153: {
    aot_vmfetch(0x0018004f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 154	[541]	SETTABUP 	0 66 0	; _ENV "find"
  #undef  AOT_PC
  #define AOT_PC (code + 155)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_156
  label_154: {
    aot_vmfetch(0x0042000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 155	[624]	CLOSURE  	0 49	; 0x7fe077304180
  #undef  AOT_PC
  #define AOT_PC (code + 156)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_157
  label_155: {
    aot_vmfetch(0x0018804f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 156	[624]	SETTABUP 	0 67 0	; _ENV "ext"
  #undef  AOT_PC
  #define AOT_PC (code + 157)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_158
  label_156: {
    aot_vmfetch(0x0043000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 157	[1195]	CLOSURE  	0 50	; 0x7fe07710df90
  #undef  AOT_PC
  #define AOT_PC (code + 158)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_159
  label_157: {
    aot_vmfetch(0x0019004f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 158	[626]	SETTABUP 	0 68 0	; _ENV "process"
  #undef  AOT_PC
  #define AOT_PC (code + 159)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_160
  label_158: {
    aot_vmfetch(0x0044000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 159	[1197]	GETTABUP 	0 0 69	; _ENV "process"
  #undef  AOT_PC
  #define AOT_PC (code + 160)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_161
  label_159: {
    aot_vmfetch(0x4500000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 160	[1197]	LOADK    	1 70	; "test.cobalt"
  #undef  AOT_PC
  #define AOT_PC (code + 161)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_162
  label_160: {
    aot_vmfetch(0x00230083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 161	[1197]	LOADK    	2 71	; "file"
  #undef  AOT_PC
  #define AOT_PC (code + 162)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_163
  label_161: {
    aot_vmfetch(0x00238103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 162	[1197]	LOADTRUE 	3
  #undef  AOT_PC
  #define AOT_PC (code + 163)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_164
  label_162: {
    aot_vmfetch(0x00000187);
    setbtvalue(s2v(ra));
  }

  // 163	[1197]	LOADK    	4 72	; "test2.cobalt"
  #undef  AOT_PC
  #define AOT_PC (code + 164)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_165
  label_163: {
    aot_vmfetch(0x00240203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 164	[1197]	CALL     	0 5 1	; 4 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 165)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_166
  label_164: {
    aot_vmfetch(0x01050044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 165	[1198]	GETTABUP 	0 0 69	; _ENV "process"
  #undef  AOT_PC
  #define AOT_PC (code + 166)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_167
  label_165: {
    aot_vmfetch(0x4500000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 166	[1198]	RETURN   	0 2 1	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 167)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_166: {
    aot_vmfetch(0x01028046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 167	[1198]	RETURN   	0 1 1	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 168)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_167: {
    aot_vmfetch(0x01018046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 56 - 56
static
CallInfo *magic_implementation_01(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
  }

  // 0	[56]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_00: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 91 - 104
static
CallInfo *magic_implementation_02(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
  }

  // 0	[92]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[92]	LOADK    	4 1	; "\027[1;31mTypechecker error:\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[92]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[93]	TEST     	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 4	[93]	JMP      	6	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_11;
  }

  // 5	[94]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[94]	LOADK    	4 2	; "\027[1;31m"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[94]	MOVE     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000280);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[94]	LOADK    	6 3	; "\027[0m\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00018303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[94]	CONCAT   	4 3
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00030235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 10	[94]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 11	[96]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[96]	LOADK    	4 4	; "\027[1;31mSnippet:\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00020203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[96]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[97]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 15	[97]	GETTABUP 	4 0 5	; _ENV "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x0500020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 16	[97]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[97]	CALL     	4 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[97]	CALL     	3 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x010001c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[98]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_30
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 20	[98]	JMP      	9	; to 31
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_30;
  }

  // 21	[99]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 22	[99]	LOADK    	4 6	; "\n\027[1;31mTypechecker provided note:\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00030203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 23	[99]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[100]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 25	[100]	LOADK    	4 7	; "\n\027[1;31m"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00038203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 26	[100]	MOVE     	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00020280);
    setobjs2s(L, ra, RB(i));
  }

  // 27	[100]	LOADK    	6 8	; "\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00040303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 28	[100]	CONCAT   	4 3
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00030235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 29	[100]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 30	[102]	GETTABUP 	3 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 31	[102]	LOADK    	4 9	; "\n\027[1;31mStopping Typechecker.\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x00048203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 32	[102]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 33	[103]	GETTABUP 	3 0 10	; _ENV "os"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x0a00018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 34	[103]	GETFIELD 	3 3 11	; "exit"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x0b03018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 35	[103]	CALL     	3 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_35: {
    aot_vmfetch(0x010101c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 36	[104]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_36: {
    aot_vmfetch(0x000101c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 106 - 137
static
CallInfo *magic_implementation_03(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
  }

  // 0	[108]	LOADK    	1 0	; "{"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[109]	GETTABUP 	2 0 1	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[109]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[109]	CALL     	2 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x05020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[109]	TFORPREP 	2 62	; to 68
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x001f014b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_67;
  }

  // 5	[110]	TEST     	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000083c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 6	[110]	JMP      	1	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_08;
  }

  // 7	[111]	LOADK    	7 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00010383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 8	[113]	GETTABUP 	8 0 3	; _ENV "loadstring"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0300040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 9	[113]	LOADK    	9 4	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00020483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 10	[113]	TESTSET  	10 7 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00078543);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 11	[113]	JMP      	1	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_13;
  }

  // 12	[113]	LOADK    	10 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00010503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[113]	CONCAT   	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000204b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 14	[113]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 15	[113]	TESTSET  	7 8 1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_25
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000883c3);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 16	[113]	JMP      	8	; to 26
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_25;
  }

  // 17	[113]	GETTABUP 	8 0 5	; _ENV "loadenv"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0500040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 18	[113]	LOADK    	9 4	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00020483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 19	[113]	TESTSET  	10 7 1
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00078543);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 20	[113]	JMP      	1	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_22;
  }

  // 21	[113]	LOADK    	10 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00010503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 22	[113]	CONCAT   	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000204b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 23	[113]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[113]	MOVE     	7 8
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00080380);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[114]	GETTABUP 	8 0 6	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x0600040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 26	[116]	CLOSURE  	9 0	; 0x7fe077105e80
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x000004cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 27	[125]	CLOSURE  	10 1	; 0x7fe077105f10
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0000854f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 28	[114]	CALL     	8 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x01030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 29	[127]	GETTABUP 	8 0 7	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0700040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 30	[127]	MOVE     	9 7
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00070480);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[127]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[127]	EQK      	8 8 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x0008043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 33	[127]	JMP      	8	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_42;
  }

  // 34	[128]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 35	[128]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 36	[128]	LOADK    	10 9	; " = \""
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00048503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 37	[128]	MOVE     	11 7
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00070580);
    setobjs2s(L, ra, RB(i));
  }

  // 38	[128]	LOADK    	12 10	; "\","
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00050603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 39	[128]	CONCAT   	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00050435);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 40	[128]	MOVE     	1 8
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_66
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00080080);
    setobjs2s(L, ra, RB(i));
  }

  // 41	[129]	JMP      	24	; to 67
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x80000bb8);
    updatetrap(ci);
    goto label_66;
  }

  // 42	[129]	GETTABUP 	8 0 7	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0700040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[129]	MOVE     	9 7
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x00070480);
    setobjs2s(L, ra, RB(i));
  }

  // 44	[129]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 45	[129]	EQK      	8 11 0	; "table"
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_57
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000b043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 46	[129]	JMP      	10	; to 58
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_57;
  }

  // 47	[130]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 48	[130]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 49	[130]	LOADK    	10 12	; " = "
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00060503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 50	[130]	GETTABUP 	11 0 13	; _ENV "tabletostring"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0d00058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 51	[130]	MOVE     	12 7
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00070600);
    setobjs2s(L, ra, RB(i));
  }

  // 52	[130]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 53	[130]	LOADK    	12 14	; ", "
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00070603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 54	[130]	CONCAT   	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x00050435);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 55	[130]	MOVE     	1 8
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_66
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x00080080);
    setobjs2s(L, ra, RB(i));
  }

  // 56	[131]	JMP      	9	; to 67
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_66;
  }

  // 57	[132]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 58	[132]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 59	[132]	LOADK    	10 12	; " = "
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x00060503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 60	[132]	TESTSET  	11 7 1
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_63
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x000785c3);
    TValue *rb = vRB(i);
    if (l_isfalse(rb) == GETARG_k(i))
      goto AOT_SKIP1;
    else {
      setobj2s(L, ra, rb);
      donextjump(ci);
    }
  }

  // 61	[132]	JMP      	1	; to 64
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_63;
  }

  // 62	[132]	LOADK    	11 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x00010583);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 63	[132]	LOADK    	12 15	; ","
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x00078603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 64	[132]	CONCAT   	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x00050435);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 65	[132]	MOVE     	1 8
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x00080080);
    setobjs2s(L, ra, RB(i));
  }

  // 66	[134]	CLOSE    	6
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x00000336);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 67	[109]	TFORCALL 	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x0200014c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 68	[109]	TFORLOOP 	2 64	; to 6
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x0020014d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_05; /* jump back */
    }
  }

  // 69	[134]	CLOSE    	2
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x00000136);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 70	[135]	MOVE     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x00010100);
    setobjs2s(L, ra, RB(i));
  }

  // 71	[135]	LOADK    	3 16	; "}"
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x00080183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 72	[135]	CONCAT   	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x00020135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 73	[135]	MOVE     	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x00020080);
    setobjs2s(L, ra, RB(i));
  }

  // 74	[136]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_74: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 75	[137]	RETURN   	2 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_75: {
    aot_vmfetch(0x00018146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 114 - 116
static
CallInfo *magic_implementation_04(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[115]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[115]	CALL     	0 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x02010044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 2	[115]	SETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x0000000a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 3	[116]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 117 - 125
static
CallInfo *magic_implementation_05(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
  }

  // 0	[118]	GETTABUP 	0 1 0	; _ENV "loadenv"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0001000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[118]	LOADK    	1 1	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[118]	GETUPVAL 	2 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[118]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 4	[118]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[118]	LOADK    	2 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[118]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 7	[118]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[118]	SETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0000000a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 9	[119]	GETTABUP 	0 1 3	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0301000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 10	[121]	CLOSURE  	1 0	; 0x7fe077106040
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000000cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 11	[124]	CLOSURE  	2 1	; 0x7fe077106110
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0000814f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 12	[119]	CALL     	0 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x01030044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 13	[125]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 119 - 121
static
CallInfo *magic_implementation_06(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[120]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[120]	CALL     	0 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x02010044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 2	[120]	SETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x0000000a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 3	[121]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 122 - 124
static
CallInfo *magic_implementation_07(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
  }

  // 0	[123]	GETTABUP 	1 0 0	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[123]	LOADK    	2 1	; "Error checking value: "
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[123]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[123]	CONCAT   	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00020135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 4	[123]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_04: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[124]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_05: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 138 - 150
static
CallInfo *magic_implementation_08(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
  }

  // 0	[140]	GETTABUP 	2 0 1	; _ENV "tabletostring"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[140]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[140]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[140]	SETTABUP 	0 0 2	; _ENV "envstr"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0200000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 4	[142]	LOADK    	2 2	; "    env = "
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[142]	GETTABUP 	3 0 0	; _ENV "envstr"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[147]	LOADK    	4 3	; "    for (i, v in pairs(env)) {\n      _G[i] = v\n    }\n\n  "
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[147]	MOVE     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00010280);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[147]	CONCAT   	2 4
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00040135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 9	[147]	MOVE     	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00020080);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[149]	GETTABUP 	2 0 4	; _ENV "loadstring"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 11	[149]	GETTABUP 	3 0 5	; _ENV "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0500018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[149]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[149]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[149]	TAILCALL 	2 0 0	; -1 in
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000145);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b);  /* prepare call frame */
    return ci;
  }

  // 15	[149]	RETURN   	2 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x00000146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 16	[150]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_16: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 154 - 157
static
CallInfo *magic_implementation_09(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[156]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[156]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[156]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[156]	EQK      	1 1 1	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[156]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[156]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[156]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[156]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[157]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 158 - 160
static
CallInfo *magic_implementation_10(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
  }

  // 0	[159]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[159]	GETFIELD 	1 1 1	; "abs"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[159]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[159]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[159]	EQ       	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_07
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000080b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 5	[159]	JMP      	1	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_07;
  }

  // 6	[159]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 7	[159]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 8	[159]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 9	[160]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 161 - 163
static
CallInfo *magic_implementation_11(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
  }

  // 0	[162]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[162]	GETFIELD 	1 1 1	; "abs"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[162]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[162]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[162]	EQ       	1 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_07
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000000b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 5	[162]	JMP      	1	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_07;
  }

  // 6	[162]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 7	[162]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 8	[162]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 9	[163]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 164 - 166
static
CallInfo *magic_implementation_12(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
  }

  // 0	[165]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[165]	GETFIELD 	1 1 1	; "abs"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[165]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[165]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[165]	EQ       	1 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000000b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 5	[165]	JMP      	6	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_12;
  }

  // 6	[165]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[165]	GETFIELD 	1 1 2	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0201008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[165]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[165]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[165]	EQ       	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000080b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 11	[165]	JMP      	1	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_13;
  }

  // 12	[165]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 13	[165]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 14	[165]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 15	[166]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 167 - 169
static
CallInfo *magic_implementation_13(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
  }

  // 0	[168]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[168]	GETFIELD 	1 1 1	; "abs"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[168]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[168]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[168]	EQ       	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000080b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 5	[168]	JMP      	6	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_12;
  }

  // 6	[168]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[168]	GETFIELD 	1 1 2	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0201008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[168]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[168]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[168]	EQ       	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000080b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 11	[168]	JMP      	1	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_13;
  }

  // 12	[168]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 13	[168]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 14	[168]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 15	[169]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 170 - 173
static
CallInfo *magic_implementation_14(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
  }

  // 0	[172]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[172]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[172]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[172]	EQK      	1 1 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_09
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[172]	JMP      	4	; to 10
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_09;
  }

  // 5	[172]	SELF     	1 0 2k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02008094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 6	[172]	LOADK    	3 3	; "^%s*%*%s*$"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[172]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[172]	JMP      	2	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_11;
  }

  // 9	[172]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 10	[172]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 11	[172]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 12	[173]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 174 - 181
static
CallInfo *magic_implementation_15(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
  }

  // 0	[176]	GETTABUP 	1 0 0	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[176]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[176]	CALL     	1 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x050200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[176]	TFORPREP 	1 7	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000380cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_11;
  }

  // 4	[177]	GETTABUP 	7 0 1	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 5	[177]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 6	[177]	CALL     	7 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x020203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[177]	EQK      	7 2 1	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000283bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 8	[177]	JMP      	2	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_11;
  }

  // 9	[178]	LOADFALSE	7
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000385);
    setbfvalue(s2v(ra));
  }

  // 10	[178]	RETURN   	7 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000283c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 11	[176]	TFORCALL 	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020000cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 12	[176]	TFORLOOP 	1 9	; to 5
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000480cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_04; /* jump back */
    }
  }

  // 13	[180]	CLOSE    	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000000b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 14	[181]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 182 - 185
static
CallInfo *magic_implementation_16(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
  }

  // 0	[184]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[184]	GETFIELD 	1 1 1	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[184]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[184]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[184]	EQ       	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_15
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000080b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 5	[184]	JMP      	9	; to 16
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_15;
  }

  // 6	[184]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[184]	GETFIELD 	1 1 1	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[184]	MULK     	2 0 2	; 2
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x02000118);
    op_arithK(L, l_muli, luai_nummul);
  }

  // 9	[184]	MMBINK   	0 2 8 0	; __mul 2
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x08020030);
    Instruction pi = 0x02000118;  /* original arith. expression */
    TValue *imm = KB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 10	[184]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 11	[184]	MULK     	2 0 2	; 2
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x02000118);
    op_arithK(L, l_muli, luai_nummul);
  }

  // 12	[184]	MMBINK   	0 2 8 0	; __mul 2
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x08020030);
    Instruction pi = 0x02000118;  /* original arith. expression */
    TValue *imm = KB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 13	[184]	EQ       	1 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_16
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000280b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 14	[184]	JMP      	1	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_16;
  }

  // 15	[184]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 16	[184]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 17	[184]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_17: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 18	[185]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_18: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 186 - 189
static
CallInfo *magic_implementation_17(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
  }

  // 0	[188]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[188]	GETFIELD 	1 1 1	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[188]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[188]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[188]	EQ       	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_15
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000080b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 5	[188]	JMP      	9	; to 16
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_15;
  }

  // 6	[188]	GETTABUP 	1 0 0	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[188]	GETFIELD 	1 1 1	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[188]	MULK     	2 0 2	; 2
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x02000118);
    op_arithK(L, l_muli, luai_nummul);
  }

  // 9	[188]	MMBINK   	0 2 8 0	; __mul 2
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x08020030);
    Instruction pi = 0x02000118;  /* original arith. expression */
    TValue *imm = KB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 10	[188]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 11	[188]	MULK     	2 0 2	; 2
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x02000118);
    op_arithK(L, l_muli, luai_nummul);
  }

  // 12	[188]	MMBINK   	0 2 8 0	; __mul 2
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x08020030);
    Instruction pi = 0x02000118;  /* original arith. expression */
    TValue *imm = KB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 13	[188]	EQ       	1 2 0
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_16
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000200b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 14	[188]	JMP      	1	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_16;
  }

  // 15	[188]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 16	[188]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 17	[188]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_17: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 18	[189]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_18: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 190 - 197
static
CallInfo *magic_implementation_18(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
  }

  // 0	[192]	GETTABUP 	1 0 0	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[192]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[192]	CALL     	1 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x050200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[192]	TFORPREP 	1 7	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000380cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_11;
  }

  // 4	[193]	GETTABUP 	7 0 1	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 5	[193]	MOVE     	8 6
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00060400);
    setobjs2s(L, ra, RB(i));
  }

  // 6	[193]	CALL     	7 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x020203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[193]	EQK      	7 2 1	; "table"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000283bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 8	[193]	JMP      	2	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_11;
  }

  // 9	[194]	LOADFALSE	7
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000385);
    setbfvalue(s2v(ra));
  }

  // 10	[194]	RETURN   	7 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000283c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 11	[192]	TFORCALL 	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020000cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 12	[192]	TFORLOOP 	1 9	; to 5
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000480cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_04; /* jump back */
    }
  }

  // 13	[196]	CLOSE    	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000000b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 14	[197]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 198 - 201
static
CallInfo *magic_implementation_19(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
  }

  // 0	[200]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[200]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[200]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[200]	EQK      	1 1 0	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[200]	JMP      	8	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_13;
  }

  // 5	[200]	GETTABUP 	1 0 2	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[200]	GETFIELD 	1 1 3	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[200]	GETTABUP 	2 0 4	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[200]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[200]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[200]	LOADK    	3 5	; "^vec3: "
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00028183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[200]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_15
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[200]	JMP      	2	; to 16
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_15;
  }

  // 13	[200]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 14	[200]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 15	[200]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 16	[201]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_16: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 202 - 205
static
CallInfo *magic_implementation_20(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
  }

  // 0	[204]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[204]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[204]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[204]	EQK      	1 1 0	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[204]	JMP      	8	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_13;
  }

  // 5	[204]	GETTABUP 	1 0 2	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[204]	GETFIELD 	1 1 3	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[204]	GETTABUP 	2 0 4	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[204]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[204]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[204]	LOADK    	3 5	; "^vec2: "
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00028183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[204]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_15
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[204]	JMP      	2	; to 16
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_15;
  }

  // 13	[204]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 14	[204]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 15	[204]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 16	[205]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_16: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 206 - 209
static
CallInfo *magic_implementation_21(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
  }

  // 0	[208]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[208]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[208]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[208]	EQK      	1 1 0	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[208]	JMP      	8	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_13;
  }

  // 5	[208]	GETTABUP 	1 0 2	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[208]	GETFIELD 	1 1 3	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[208]	GETTABUP 	2 0 4	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[208]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[208]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[208]	LOADK    	3 5	; "^color: "
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00028183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[208]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_15
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[208]	JMP      	2	; to 16
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_15;
  }

  // 13	[208]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 14	[208]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 15	[208]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 16	[209]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_16: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 210 - 213
static
CallInfo *magic_implementation_22(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
  }

  // 0	[212]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[212]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[212]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[212]	EQK      	1 1 0	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_13
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[212]	JMP      	8	; to 14
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_13;
  }

  // 5	[212]	GETTABUP 	1 0 2	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[212]	GETFIELD 	1 1 3	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[212]	GETTABUP 	2 0 4	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[212]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[212]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[212]	LOADK    	3 5	; "^transform: "
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00028183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[212]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_15
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[212]	JMP      	2	; to 16
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_15;
  }

  // 13	[212]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 14	[212]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 15	[212]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 16	[213]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_16: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 214 - 217
static
CallInfo *magic_implementation_23(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[216]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[216]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[216]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[216]	EQK      	1 1 1	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[216]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[216]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[216]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[216]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[217]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 218 - 221
static
CallInfo *magic_implementation_24(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[220]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[220]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[220]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[220]	EQK      	1 1 1	; "boolean"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[220]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[220]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[220]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[220]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[221]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 222 - 225
static
CallInfo *magic_implementation_25(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[224]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[224]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[224]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[224]	EQK      	1 1 1	; "table"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[224]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[224]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[224]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[224]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[225]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 226 - 229
static
CallInfo *magic_implementation_26(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[228]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[228]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[228]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[228]	EQK      	1 1 1	; "function"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[228]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[228]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[228]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[228]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[229]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 230 - 233
static
CallInfo *magic_implementation_27(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[232]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[232]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[232]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[232]	EQK      	1 1 1	; "userdata"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[232]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[232]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[232]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[232]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[233]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 234 - 237
static
CallInfo *magic_implementation_28(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[236]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[236]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[236]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[236]	EQK      	1 1 1	; "thread"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[236]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[236]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[236]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[236]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[237]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 238 - 241
static
CallInfo *magic_implementation_29(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[240]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[240]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[240]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[240]	EQK      	1 1 1	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[240]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[240]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[240]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[240]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[241]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 242 - 245
static
CallInfo *magic_implementation_30(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
  }

  // 0	[244]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[244]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[244]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[244]	EQK      	1 1 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[244]	JMP      	3	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_08;
  }

  // 5	[244]	LEN      	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000000b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 6	[244]	EQI      	1 1 1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_09
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x008080bd);
    int cond;
    int im = GETARG_sB(i);
    if (ttisinteger(s2v(ra)))
      cond = (ivalue(s2v(ra)) == im);
    else if (ttisfloat(s2v(ra)))
      cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));
    else
      cond = 0;  /* other types cannot be equal to a number */
    docondjump();
  }

  // 7	[244]	JMP      	1	; to 10
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_09;
  }

  // 8	[244]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 9	[244]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 10	[244]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_10: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 11	[245]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 246 - 250
static
CallInfo *magic_implementation_31(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
  }

  // 0	[249]	GETTABUP 	1 0 0	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[249]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[249]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[249]	GETTABUP 	2 0 1	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[249]	GETFIELD 	2 2 2	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0202010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[249]	LOADK    	3 3	; "^message: "
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[249]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[249]	EQ       	1 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000280b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 8	[249]	JMP      	1	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_10;
  }

  // 9	[249]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 10	[249]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 11	[249]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 12	[250]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 251 - 255
static
CallInfo *magic_implementation_32(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
  }

  // 0	[253]	GETTABUP 	1 0 2	; _ENV "pcall"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[253]	CLOSURE  	2 0	; 0x7fe077109450
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0000014f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 2	[253]	CALL     	1 2 3	; 1 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x030200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[253]	SETTABUP 	0 1 2	; _ENV "e"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0201000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 4	[253]	SETTABUP 	0 0 1	; _ENV "s"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 5	[254]	GETTABUP 	1 0 0	; _ENV "s"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[254]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 7	[255]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 253 - 253
static
CallInfo *magic_implementation_33(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
  }

  // 0	[253]	GETTABUP 	0 0 0	; item "__name"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[253]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 2	[253]	JMP      	3	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_06;
  }

  // 3	[253]	GETTABUP 	0 1 1	; _ENV "error"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0101000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[253]	LOADK    	1 2	; "Force error"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[253]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_05: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[253]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 256 - 260
static
CallInfo *magic_implementation_34(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
  }

  // 0	[259]	GETTABUP 	1 0 0	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[259]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[259]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[259]	GETTABUP 	2 0 1	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[259]	GETFIELD 	2 2 2	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0202010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[259]	LOADK    	3 3	; "^directory: "
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[259]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[259]	EQ       	1 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000280b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 8	[259]	JMP      	1	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_10;
  }

  // 9	[259]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 10	[259]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 11	[259]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 12	[260]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 261 - 265
static
CallInfo *magic_implementation_35(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
  }

  // 0	[264]	GETTABUP 	1 0 0	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[264]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[264]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[264]	GETTABUP 	2 0 1	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[264]	GETFIELD 	2 2 2	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0202010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[264]	LOADK    	3 3	; "^lock: "
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[264]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[264]	EQ       	1 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000280b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 8	[264]	JMP      	1	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_10;
  }

  // 9	[264]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 10	[264]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 11	[264]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 12	[265]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 266 - 269
static
CallInfo *magic_implementation_36(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
  }

  // 0	[268]	GETTABUP 	1 0 0	; _ENV "getmetatable"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[268]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[268]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[268]	GETFIELD 	1 1 1	; "__metatable"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0101008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[268]	EQK      	1 2 0	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_07
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000200bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 5	[268]	JMP      	1	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_07;
  }

  // 6	[268]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 7	[268]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 8	[268]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 9	[269]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 270 - 274
static
CallInfo *magic_implementation_37(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
  }

  // 0	[273]	GETTABUP 	1 0 0	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[273]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[273]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[273]	GETTABUP 	2 0 1	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[273]	GETFIELD 	2 2 2	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0202010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[273]	LOADK    	3 3	; "^LUABOX: "
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[273]	CALL     	2 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x02020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[273]	EQ       	1 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000280b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 8	[273]	JMP      	1	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_10;
  }

  // 9	[273]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 10	[273]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 11	[273]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 12	[274]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 275 - 278
static
CallInfo *magic_implementation_38(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
  }

  // 0	[277]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 1	[277]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_01: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 2	[278]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 279 - 282
static
CallInfo *magic_implementation_39(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
  }

  // 0	[281]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[281]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[281]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[281]	EQK      	1 1 1	; "thread"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000180bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[281]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[281]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 6	[281]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 7	[281]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[282]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_08: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 283 - 286
static
CallInfo *magic_implementation_40(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
  }

  // 0	[285]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[285]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[285]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[285]	EQK      	1 1 0	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[285]	JMP      	6	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_11;
  }

  // 5	[285]	GETTABUP 	1 0 2	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[285]	GETFIELD 	1 1 3	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[285]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[285]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[285]	EQ       	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000080b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 10	[285]	JMP      	1	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_12;
  }

  // 11	[285]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 12	[285]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 13	[285]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 14	[286]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 287 - 290
static
CallInfo *magic_implementation_41(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
  }

  // 0	[289]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[289]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[289]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[289]	EQK      	1 1 0	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[289]	JMP      	6	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_11;
  }

  // 5	[289]	GETTABUP 	1 0 2	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[289]	GETFIELD 	1 1 3	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[289]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[289]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[289]	EQ       	1 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000000b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 10	[289]	JMP      	1	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_12;
  }

  // 11	[289]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 12	[289]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 13	[289]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 14	[290]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 291 - 294
static
CallInfo *magic_implementation_42(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
  }

  // 0	[293]	GETTABUP 	1 0 0	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[293]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[293]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[293]	EQK      	1 1 0	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_11
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000100bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 4	[293]	JMP      	6	; to 12
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_11;
  }

  // 5	[293]	GETTABUP 	1 0 2	; _ENV "math"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[293]	GETFIELD 	1 1 3	; "floor"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[293]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[293]	CALL     	1 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x020200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[293]	EQ       	1 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000000b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 10	[293]	JMP      	1	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_12;
  }

  // 11	[293]	LFALSESKIP	1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000086);
    setbfvalue(s2v(ra));
    goto AOT_SKIP1;
  }

  // 12	[293]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 13	[293]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 14	[294]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 303 - 315
static
CallInfo *magic_implementation_43(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
  }

  // 0	[305]	LOADK    	1 0	; "^%s*var%s+([^%s]+)%s*:%s*([^%s]+)%s*=%s*([^%s]+)%s*$"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[306]	LOADK    	1 1	; "^%s*var%s+([^%s]+)%s*:%s*([^%s]+)%s*=%s*(.-)%s*$"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[307]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 3	[307]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 4	[308]	SELF     	3 0 2k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[308]	LOADK    	5 3	; "[^\r\n]+"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00018283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[308]	CALL     	3 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x050301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 7	[308]	TFORPREP 	3 20	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000a01cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_28;
  }

  // 8	[309]	SELF     	8 7 4k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x04078414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 9	[309]	MOVE     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00010500);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[309]	CALL     	8 3 4	; 2 in 3 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x04030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 11	[310]	TEST     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_28
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000442);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 12	[310]	JMP      	15	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x80000738);
    updatetrap(ci);
    goto label_28;
  }

  // 13	[310]	TEST     	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_28
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x000004c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 14	[310]	JMP      	13	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_28;
  }

  // 15	[310]	TEST     	10 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_28
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000542);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 16	[310]	JMP      	11	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x80000538);
    updatetrap(ci);
    goto label_28;
  }

  // 17	[311]	GETTABUP 	11 0 5	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0500058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 18	[311]	GETFIELD 	11 11 6	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x060b058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[311]	MOVE     	12 2
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00020600);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[311]	NEWTABLE 	13 0 4	; 4
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x04000693);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 21	[311]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 22	[311]	MOVE     	14 8
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00080700);
    setobjs2s(L, ra, RB(i));
  }

  // 23	[311]	MOVE     	15 9
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00090780);
    setobjs2s(L, ra, RB(i));
  }

  // 24	[311]	MOVE     	16 10
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x000a0800);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[311]	MOVE     	17 7
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00070880);
    setobjs2s(L, ra, RB(i));
  }

  // 26	[311]	SETLIST  	13 4 0
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x000406ce);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 27	[311]	CALL     	11 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x010305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 28	[308]	TFORCALL 	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x010001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 29	[308]	TFORLOOP 	3 22	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x000b01cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_08; /* jump back */
    }
  }

  // 30	[313]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 31	[314]	RETURN   	2 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_31: {
    aot_vmfetch(0x00028146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 32	[315]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_32: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 316 - 330
static
CallInfo *magic_implementation_44(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
  }

  // 0	[318]	LOADK    	1 0	; "%s*([^%s]+)%s*:%s*([^%s]+)%s*=%s*([^%s]+)%s*"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[319]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 2	[319]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 3	[320]	SELF     	3 0 1k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x01008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[320]	LOADK    	5 2	; "[^\r\n]+"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[320]	CALL     	3 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x050301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[320]	TFORPREP 	3 26	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000d01cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_33;
  }

  // 7	[321]	SELF     	8 7 3k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x03078414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[321]	MOVE     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010500);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[321]	CALL     	8 3 4	; 2 in 3 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x04030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[322]	TEST     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_33
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000442);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 11	[322]	JMP      	21	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000a38);
    updatetrap(ci);
    goto label_33;
  }

  // 12	[322]	TEST     	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_33
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000004c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 13	[322]	JMP      	19	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x80000938);
    updatetrap(ci);
    goto label_33;
  }

  // 14	[322]	TEST     	10 0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_33
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000542);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 15	[322]	JMP      	17	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000838);
    updatetrap(ci);
    goto label_33;
  }

  // 16	[324]	GETTABUP 	11 0 4	; _ENV "deffind"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0400058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[324]	MOVE     	12 7
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00070600);
    setobjs2s(L, ra, RB(i));
  }

  // 18	[324]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[324]	GETI     	11 11 1
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x010b058d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 20	[324]	TEST     	11 1
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_33
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x000085c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 21	[324]	JMP      	11	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x80000538);
    updatetrap(ci);
    goto label_33;
  }

  // 22	[325]	GETTABUP 	11 0 5	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0500058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 23	[325]	GETFIELD 	11 11 6	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x060b058e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 24	[325]	MOVE     	12 2
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00020600);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[325]	NEWTABLE 	13 0 4	; 4
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x04000693);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 26	[325]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 27	[325]	MOVE     	14 8
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00080700);
    setobjs2s(L, ra, RB(i));
  }

  // 28	[325]	MOVE     	15 9
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00090780);
    setobjs2s(L, ra, RB(i));
  }

  // 29	[325]	MOVE     	16 10
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x000a0800);
    setobjs2s(L, ra, RB(i));
  }

  // 30	[325]	MOVE     	17 7
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00070880);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[325]	SETLIST  	13 4 0
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000406ce);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 32	[325]	CALL     	11 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x010305c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 33	[320]	TFORCALL 	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x010001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 34	[320]	TFORLOOP 	3 28	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x000e01cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_07; /* jump back */
    }
  }

  // 35	[328]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 36	[329]	RETURN   	2 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_36: {
    aot_vmfetch(0x00028146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 37	[330]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_37: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 331 - 342
static
CallInfo *magic_implementation_45(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
  }

  // 0	[333]	LOADK    	1 0	; "^%s*function%s+([^%s]+)%s*%(([^%s]*)%)%s*$"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[334]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 2	[334]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 3	[335]	SELF     	3 0 1k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x01008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[335]	LOADK    	5 2	; "[^\r\n]+"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[335]	CALL     	3 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x050301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[335]	TFORPREP 	3 17	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000881cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_24;
  }

  // 7	[336]	SELF     	8 7 3k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x03078414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[336]	MOVE     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010500);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[336]	CALL     	8 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x03030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[337]	TEST     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000442);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 11	[337]	JMP      	12	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_24;
  }

  // 12	[337]	TEST     	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000004c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 13	[337]	JMP      	10	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_24;
  }

  // 14	[338]	GETTABUP 	10 0 4	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0400050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 15	[338]	GETFIELD 	10 10 5	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x050a050e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 16	[338]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[338]	NEWTABLE 	12 0 3	; 3
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x03000613);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 18	[338]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 19	[338]	MOVE     	13 8
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00080680);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[338]	MOVE     	14 9
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00090700);
    setobjs2s(L, ra, RB(i));
  }

  // 21	[338]	MOVE     	15 7
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00070780);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[338]	SETLIST  	12 3 0
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0003064e);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 23	[338]	CALL     	10 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x01030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[335]	TFORCALL 	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x010001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 25	[335]	TFORLOOP 	3 19	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x000981cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_07; /* jump back */
    }
  }

  // 26	[340]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 27	[341]	RETURN   	2 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_27: {
    aot_vmfetch(0x00028146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 28	[342]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_28: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 343 - 356
static
CallInfo *magic_implementation_46(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
  }

  // 0	[345]	LOADK    	1 0	; "%s*([^%s]+)%s*=%s*([^%s]+)%s*"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[346]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 2	[346]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 3	[347]	SELF     	3 0 1k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x01008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[347]	LOADK    	5 2	; "[^\r\n]+"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[347]	CALL     	3 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x050301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[347]	TFORPREP 	3 29	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000e81cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_36;
  }

  // 7	[348]	SELF     	8 7 3k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x03078414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[348]	MOVE     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010500);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[348]	CALL     	8 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x03030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[349]	TEST     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_36
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000442);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 11	[349]	JMP      	24	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80000bb8);
    updatetrap(ci);
    goto label_36;
  }

  // 12	[349]	TEST     	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_36
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000004c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 13	[349]	JMP      	22	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x80000ab8);
    updatetrap(ci);
    goto label_36;
  }

  // 14	[350]	GETTABUP 	10 0 4	; _ENV "deffind"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0400050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 15	[350]	MOVE     	11 7
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00070580);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[350]	CALL     	10 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x02020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 17	[350]	GETI     	10 10 1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x010a050d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 18	[350]	TEST     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_36
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00008542);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 19	[350]	JMP      	16	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x800007b8);
    updatetrap(ci);
    goto label_36;
  }

  // 20	[350]	GETTABUP 	10 0 5	; _ENV "assign"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0500050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 21	[350]	MOVE     	11 7
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00070580);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[350]	CALL     	10 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x02020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 23	[350]	GETI     	10 10 1
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x010a050d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 24	[350]	TEST     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_36
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00008542);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 25	[350]	JMP      	10	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_36;
  }

  // 26	[351]	GETTABUP 	10 0 6	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x0600050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 27	[351]	GETFIELD 	10 10 7	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x070a050e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 28	[351]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 29	[351]	NEWTABLE 	12 0 3	; 3
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x03000613);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 30	[351]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 31	[351]	MOVE     	13 8
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x00080680);
    setobjs2s(L, ra, RB(i));
  }

  // 32	[351]	MOVE     	14 9
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x00090700);
    setobjs2s(L, ra, RB(i));
  }

  // 33	[351]	MOVE     	15 7
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x00070780);
    setobjs2s(L, ra, RB(i));
  }

  // 34	[351]	SETLIST  	12 3 0
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x0003064e);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 35	[351]	CALL     	10 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x01030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 36	[347]	TFORCALL 	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x010001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 37	[347]	TFORLOOP 	3 31	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x000f81cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_07; /* jump back */
    }
  }

  // 38	[354]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 39	[355]	RETURN   	2 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_39: {
    aot_vmfetch(0x00028146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 40	[356]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_40: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 357 - 368
static
CallInfo *magic_implementation_47(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
  }

  // 0	[359]	LOADK    	1 0	; "%s*=%s*"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[360]	NEWTABLE 	2 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000113);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 2	[360]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 3	[361]	SELF     	3 0 1k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x01008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 4	[361]	LOADK    	5 2	; "[^\r\n]+"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[361]	CALL     	3 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x050301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[361]	TFORPREP 	3 17	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x000881cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_24;
  }

  // 7	[362]	SELF     	8 7 3k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x03078414);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[362]	MOVE     	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010500);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[362]	CALL     	8 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x03030444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[363]	TEST     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000442);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 11	[363]	JMP      	12	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_24;
  }

  // 12	[363]	TEST     	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x000004c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 13	[363]	JMP      	10	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_24;
  }

  // 14	[364]	GETTABUP 	10 0 4	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0400050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 15	[364]	GETFIELD 	10 10 5	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x050a050e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 16	[364]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[364]	NEWTABLE 	12 0 3	; 3
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x03000613);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 18	[364]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 19	[364]	MOVE     	13 8
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00080680);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[364]	MOVE     	14 9
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00090700);
    setobjs2s(L, ra, RB(i));
  }

  // 21	[364]	MOVE     	15 7
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00070780);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[364]	SETLIST  	12 3 0
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0003064e);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 23	[364]	CALL     	10 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x01030544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[361]	TFORCALL 	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x010001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 25	[361]	TFORLOOP 	3 19	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x000981cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_07; /* jump back */
    }
  }

  // 26	[366]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 27	[367]	RETURN   	2 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_27: {
    aot_vmfetch(0x00028146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 28	[368]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_28: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 369 - 394
static
CallInfo *magic_implementation_48(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
  }

  // 0	[370]	GETTABUP 	1 0 0	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[370]	GETTABUP 	2 0 1	; _ENV "dead"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[370]	CALL     	1 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x050200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[370]	TFORPREP 	1 48	; to 53
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x001800cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_52;
  }

  // 4	[371]	LOADK    	7 2	; "'DEADVALUESTRTYPECHECK-"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[371]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 6	[371]	LOADK    	9 3	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[371]	CONCAT   	7 3
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000303b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 8	[376]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 9	[377]	LOADK    	9 4	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00020483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 10	[378]	LOADI    	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80000501);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 11	[378]	LEN      	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000005b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 12	[378]	LOADI    	12 1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x80000601);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 13	[378]	FORPREP  	10 37	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0012854a);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_52; /* skip the loop */
  }

  // 14	[379]	SELF     	14 0 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x05008714);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[379]	MOVE     	16 13
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000d0800);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[379]	MOVE     	17 13
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x000d0880);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[379]	CALL     	14 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x02040744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[380]	SELF     	15 7 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x05078794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[380]	MOVE     	17 8
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00080880);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[380]	MOVE     	18 8
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00080900);
    setobjs2s(L, ra, RB(i));
  }

  // 21	[380]	CALL     	15 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x020407c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 22	[380]	EQ       	14 15 0
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_49
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000f0739);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 23	[380]	JMP      	25	; to 50
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x80000c38);
    updatetrap(ci);
    goto label_49;
  }

  // 24	[381]	MOVE     	15 8
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00080780);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[381]	ADDI     	8 8 1
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80080415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 26	[381]	MMBINI   	8 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x0680042f);
    Instruction pi = 0x80080415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 27	[382]	MOVE     	15 9
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00090780);
    setobjs2s(L, ra, RB(i));
  }

  // 28	[382]	MOVE     	16 14
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x000e0800);
    setobjs2s(L, ra, RB(i));
  }

  // 29	[382]	CONCAT   	15 2
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x000207b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 30	[382]	MOVE     	9 15
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x000f0480);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[383]	EQ       	9 7 0
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000704b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 32	[383]	JMP      	18	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x800008b8);
    updatetrap(ci);
    goto label_51;
  }

  // 33	[384]	SELF     	15 0 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x05008794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 34	[384]	LOADI    	17 1
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x80000881);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 35	[384]	LEN      	18 7
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x00070934);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 36	[384]	SUB      	18 13 18
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x120d0923);
    op_arith(L, l_subi, luai_numsub);
  }

  // 37	[384]	MMBIN    	13 18 7	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x071206ae);
    Instruction pi = 0x120d0923; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 38	[384]	CALL     	15 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x020407c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 39	[384]	MOVE     	16 6
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00060800);
    setobjs2s(L, ra, RB(i));
  }

  // 40	[384]	SELF     	17 0 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x05008894);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 41	[384]	ADDI     	19 13 1
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x800d0995);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 42	[384]	MMBINI   	13 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x068006af);
    Instruction pi = 0x800d0995;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 43	[384]	LEN      	20 0
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x00000a34);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 44	[384]	CALL     	17 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x020408c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 45	[384]	CONCAT   	15 3
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000307b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 46	[384]	MOVE     	0 15
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_52
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x000f0000);
    setobjs2s(L, ra, RB(i));
  }

  // 47	[385]	JMP      	4	; to 53
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_52;
  }

  // 48	[387]	JMP      	2	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_51;
  }

  // 49	[388]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 50	[389]	LOADK    	9 4	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x00020483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 51	[378]	FORLOOP  	10 38	; to 15
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00130549);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_14; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_14; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 52	[370]	TFORCALL 	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x020000cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 53	[370]	TFORLOOP 	1 50	; to 5
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x001900cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_04; /* jump back */
    }
  }

  // 54	[392]	CLOSE    	1
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x000000b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 55	[393]	RETURN   	0 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_55: {
    aot_vmfetch(0x00028046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 56	[394]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_56: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 395 - 416
static
CallInfo *magic_implementation_49(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
  }

  // 0	[398]	NEWTABLE 	1 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000093);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 1	[398]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 2	[399]	LOADI    	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x7fff8101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 3	[400]	SETTABUP 	0 0 0	; _ENV "ogstr"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0000000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 4	[401]	GETFIELD 	3 0 1	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[401]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_10
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 6	[401]	JMP      	3	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_10;
  }

  // 7	[401]	GETTABUP 	3 0 2	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0200018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[401]	LOADK    	4 3	; "string.gsub is not a found function, Are you sure you provided a string?"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00018203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[401]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[402]	SELF     	3 0 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x01008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[402]	LOADK    	5 4	; "'[^']-'"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00020283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 12	[406]	CLOSURE  	6 0	; 0x7fe07710bc50
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0000034f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 13	[402]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[406]	SELF     	3 3 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x01038194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[406]	LOADK    	5 5	; "\"[^\"]-\""
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00028283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 16	[410]	CLOSURE  	6 1	; 0x7fe07710bdc0
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0000834f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 17	[402]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[410]	SELF     	3 3 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x01038194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[410]	LOADK    	5 6	; "%[%[.-%]%]"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00030283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 20	[414]	CLOSURE  	6 2	; 0x7fe07710bfd0
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0001034f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 21	[402]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 22	[414]	MOVE     	0 3
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00030000);
    setobjs2s(L, ra, RB(i));
  }

  // 23	[415]	SELF     	3 0 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x01008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 24	[415]	LOADK    	5 7	; "//.-\n"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00038283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 25	[415]	LOADK    	6 8	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00040303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 26	[415]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 27	[415]	SELF     	3 3 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x01038194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 28	[415]	LOADK    	5 9	; "/%*.-%*/"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00048283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 29	[415]	LOADK    	6 8	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00040303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 30	[415]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 31	[415]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 32	[415]	RETURN   	3 3 0	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_32: {
    aot_vmfetch(0x000381c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 33	[416]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_33: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 402 - 406
static
CallInfo *magic_implementation_50(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
  }

  // 0	[403]	GETUPVAL 	1 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[403]	GETUPVAL 	3 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 2	[403]	ADDI     	3 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80030195);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 3	[403]	MMBINI   	3 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x068001af);
    Instruction pi = 0x80030195;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 4	[403]	SETUPVAL 	3 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0000018a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 5	[404]	GETUPVAL 	2 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[404]	GETUPVAL 	1 1	; dead
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[404]	SETTABLE 	1 2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00020090);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 8	[405]	LOADK    	1 0	; "'DEADVALUESTRTYPECHECK-"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[405]	GETUPVAL 	2 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 10	[405]	LOADK    	3 1	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00008183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[405]	CONCAT   	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000300b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 12	[405]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 13	[406]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 406 - 410
static
CallInfo *magic_implementation_51(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
  }

  // 0	[407]	GETUPVAL 	1 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[407]	GETUPVAL 	3 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 2	[407]	ADDI     	3 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80030195);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 3	[407]	MMBINI   	3 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x068001af);
    Instruction pi = 0x80030195;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 4	[407]	SETUPVAL 	3 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0000018a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 5	[408]	GETUPVAL 	2 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[408]	GETUPVAL 	1 1	; dead
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[408]	SETTABLE 	1 2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00020090);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 8	[409]	LOADK    	1 0	; "'DEADVALUESTRTYPECHECK-"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[409]	GETUPVAL 	2 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 10	[409]	LOADK    	3 1	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00008183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[409]	CONCAT   	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000300b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 12	[409]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 13	[410]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 410 - 414
static
CallInfo *magic_implementation_52(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
  }

  // 0	[411]	GETUPVAL 	1 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[411]	GETUPVAL 	3 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 2	[411]	ADDI     	3 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80030195);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 3	[411]	MMBINI   	3 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x068001af);
    Instruction pi = 0x80030195;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 4	[411]	SETUPVAL 	3 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0000018a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 5	[412]	GETUPVAL 	2 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[412]	GETUPVAL 	1 1	; dead
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[412]	SETTABLE 	1 2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00020090);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 8	[413]	LOADK    	1 0	; "'DEADVALUESTRTYPECHECK-"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[413]	GETUPVAL 	2 0	; i
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 10	[413]	LOADK    	3 1	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00008183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[413]	CONCAT   	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000300b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 12	[413]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 13	[414]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 420 - 441
static
CallInfo *magic_implementation_53(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
  }

  // 0	[421]	GETTABUP 	5 0 1	; _ENV "loadenv"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0100028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[421]	MOVE     	6 3
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00030300);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[421]	LOADK    	7 2	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 3	[421]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 4	[421]	CONCAT   	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000203b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 5	[421]	CALL     	5 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x030302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[421]	SETTABUP 	0 0 6	; _ENV "err"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0600000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 7	[421]	MOVE     	1 5
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00050080);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[422]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_16
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 9	[422]	JMP      	6	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_16;
  }

  // 10	[423]	GETTABUP 	5 0 3	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0300028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 11	[423]	LOADK    	6 4	; "Check error: "
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00020303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 12	[423]	GETTABUP 	7 0 0	; _ENV "err"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0000038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[423]	CONCAT   	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00020335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 14	[423]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 15	[423]	CALL     	5 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x010302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[425]	GETTABUP 	5 0 5	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0500028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[427]	CLOSURE  	6 0	; 0x7fe07710c530
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0000034f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 18	[430]	CLOSURE  	7 1	; 0x7fe07710c5c0
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x000083cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 19	[425]	CALL     	5 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x010302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[431]	GETTABUP 	5 0 6	; _ENV "types"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0600028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 21	[431]	GETTABLE 	5 5 0
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0005028c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 22	[431]	TEST     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_60
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000002c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 23	[431]	JMP      	36	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x800011b8);
    updatetrap(ci);
    goto label_60;
  }

  // 24	[432]	GETTABUP 	5 0 6	; _ENV "types"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0600028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 25	[432]	GETTABLE 	5 5 0
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x0005028c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 26	[432]	MOVE     	6 1
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00010300);
    setobjs2s(L, ra, RB(i));
  }

  // 27	[432]	CALL     	5 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x020202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 28	[432]	TEST     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_33
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x000002c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 29	[432]	JMP      	3	; to 34
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_33;
  }

  // 30	[433]	LOADTRUE 	5
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00000287);
    setbtvalue(s2v(ra));
  }

  // 31	[433]	RETURN   	5 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_72
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000282c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 32	[434]	JMP      	39	; to 73
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x80001338);
    updatetrap(ci);
    goto label_72;
  }

  // 33	[435]	GETTABUP 	5 0 7	; _ENV "typeof"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x0700028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 34	[435]	MOVE     	6 1
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00010300);
    setobjs2s(L, ra, RB(i));
  }

  // 35	[435]	CALL     	5 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x020202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 36	[435]	EQK      	5 8 0	; "function"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_40
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x000802bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 37	[435]	JMP      	2	; to 41
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_40;
  }

  // 38	[435]	LOADTRUE 	5
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00000287);
    setbtvalue(s2v(ra));
  }

  // 39	[435]	RETURN   	5 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x000282c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 40	[436]	GETTABUP 	5 0 3	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x0300028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 41	[436]	GETTABUP 	6 0 9	; _ENV "core"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x0900030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 42	[436]	GETFIELD 	6 6 10	; "error"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0a06030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 43	[436]	GETFIELD 	6 6 11	; "strerror"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0b06030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 44	[436]	LOADI    	7 111
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x80370381);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 45	[436]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 46	[436]	SELF     	6 6 12k	; "format"
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x0c068314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 47	[436]	MOVE     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00000400);
    setobjs2s(L, ra, RB(i));
  }

  // 48	[436]	GETTABUP 	9 0 13	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x0d00048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 49	[436]	GETTABUP 	10 0 7	; _ENV "typeof"
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x0700050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 50	[436]	MOVE     	11 1
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x00010580);
    setobjs2s(L, ra, RB(i));
  }

  // 51	[436]	CALL     	10 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 52	[436]	CALL     	9 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x020004c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 53	[436]	LOADK    	10 14	; " (and it's descendents)"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00070503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 54	[436]	CONCAT   	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x000204b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 55	[436]	MOVE     	10 2
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x00020500);
    setobjs2s(L, ra, RB(i));
  }

  // 56	[436]	CALL     	6 5 2	; 4 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x02050344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 57	[436]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 58	[436]	CALL     	5 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_72
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x010302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 59	[438]	JMP      	12	; to 73
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x800005b8);
    updatetrap(ci);
    goto label_72;
  }

  // 60	[439]	GETTABUP 	5 0 3	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x0300028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 61	[439]	GETTABUP 	6 0 9	; _ENV "core"
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x0900030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 62	[439]	GETFIELD 	6 6 10	; "error"
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x0a06030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 63	[439]	GETFIELD 	6 6 11	; "strerror"
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x0b06030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 64	[439]	LOADI    	7 112
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x80378381);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 65	[439]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 66	[439]	SELF     	6 6 12k	; "format"
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x0c068314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 67	[439]	MOVE     	8 0
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x00000400);
    setobjs2s(L, ra, RB(i));
  }

  // 68	[439]	CALL     	6 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x02030344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 69	[439]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 70	[439]	LOADK    	8 15	; "Use `cobaltpre -types` to see all types"
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x00078403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 71	[439]	CALL     	5 4 1	; 3 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_71: {
    aot_vmfetch(0x010402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 72	[441]	RETURN   	5 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_72: {
    aot_vmfetch(0x000182c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 425 - 427
static
CallInfo *magic_implementation_54(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[426]	GETUPVAL 	0 0	; value
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[426]	CALL     	0 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x02010044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 2	[426]	SETUPVAL 	0 0	; value
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x0000000a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 3	[427]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 427 - 430
static
CallInfo *magic_implementation_55(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
  }

  // 0	[429]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 1	[429]	RETURN1  	1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_01: {
    aot_vmfetch(0x000200c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 2	[430]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 444 - 483
static
CallInfo *magic_implementation_56(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
    case 132: goto label_132;
    case 133: goto label_133;
  }

  // 0	[445]	GETTABUP 	1 0 2	; _ENV "clean"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[445]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[445]	CALL     	1 2 3	; 1 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x030200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[445]	SETTABUP 	0 1 2	; _ENV "newdead"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0201000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 4	[445]	SETTABUP 	0 0 1	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 5	[446]	GETTABUP 	1 0 1	; _ENV "newdead"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0100008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[446]	SETTABUP 	0 3 1	; _ENV "dead"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0103000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 7	[447]	GETTABUP 	1 0 4	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0400008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[447]	GETTABUP 	2 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0000010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 9	[447]	SELF     	2 2 5k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x05028114);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 10	[447]	LOADK    	4 6	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00030203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[447]	CALL     	2 3 0	; 2 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00030144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[447]	CALL     	1 0 5	; all in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x050000c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 13	[447]	TFORPREP 	1 114	; to 129
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x003900cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_128;
  }

  // 14	[448]	GETTABUP 	7 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0000038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 15	[448]	SELF     	7 7 5k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x05078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 16	[448]	LOADK    	9 6	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00030483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 17	[448]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[448]	GETTABLE 	7 7 5
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0507038c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[448]	TEST     	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000083c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 20	[448]	JMP      	1	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_22;
  }

  // 21	[448]	LOADK    	7 7	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00038383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 22	[448]	SETTABUP 	0 0 7	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0700000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 23	[449]	GETTABUP 	7 0 8	; _ENV "deffind"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x0800038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 24	[449]	GETTABUP 	8 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0000040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 25	[449]	CALL     	7 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x020203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 26	[450]	GETTABUP 	8 0 9	; _ENV "assign"
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x0900040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 27	[450]	GETTABUP 	9 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0000048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 28	[450]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 29	[451]	GETTABUP 	9 0 10	; _ENV "allassign"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0a00048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 30	[451]	GETTABUP 	10 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x0000050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 31	[451]	CALL     	9 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x020204c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[452]	GETTABUP 	10 0 11	; _ENV "findfunctions"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x0b00050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 33	[452]	GETTABUP 	11 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x0000058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 34	[452]	CALL     	10 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x02020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 35	[453]	GETTABUP 	11 0 12	; _ENV "findall"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x0c00058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 36	[453]	GETTABUP 	12 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x0000060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 37	[453]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 38	[455]	NEWTABLE 	12 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00000613);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 39	[455]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 40	[456]	NEWTABLE 	13 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00000693);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 41	[456]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 42	[457]	GETTABUP 	14 0 4	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0400070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[457]	MOVE     	15 7
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x00070780);
    setobjs2s(L, ra, RB(i));
  }

  // 44	[457]	CALL     	14 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x05020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 45	[457]	TFORPREP 	14 31	; to 78
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000f874b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_77;
  }

  // 46	[458]	GETTABUP 	20 0 13	; _ENV "check"
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x0d000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 47	[458]	GETI     	21 19 2
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x02130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 48	[458]	GETI     	22 19 3
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x03130b0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 49	[458]	GETI     	23 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x01130b8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 50	[458]	MOVE     	24 13
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x000d0c00);
    setobjs2s(L, ra, RB(i));
  }

  // 51	[458]	GETI     	25 19 4
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x04130c8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 52	[458]	CALL     	20 6 1	; 5 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x01060a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 53	[459]	GETTABUP 	20 0 16	; _ENV "loadenv"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x10000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 54	[459]	MOVE     	21 13
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x000d0a80);
    setobjs2s(L, ra, RB(i));
  }

  // 55	[459]	LOADK    	22 17	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x00088b03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 56	[459]	GETI     	23 19 3
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x03130b8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 57	[459]	CONCAT   	22 2
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00020b35);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 58	[459]	CALL     	20 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x03030a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 59	[459]	SETTABUP 	0 15 21	; _ENV "err"
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x150f000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 60	[459]	SETTABUP 	0 14 20	; _ENV "value"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x140e000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 61	[460]	GETTABUP 	20 0 14	; _ENV "value"
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x0e000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 62	[460]	TEST     	20 1
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_69
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x00008a42);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 63	[460]	JMP      	5	; to 70
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_69;
  }

  // 64	[461]	GETTABUP 	20 0 18	; _ENV "typerror"
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x12000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 65	[461]	LOADK    	21 19	; "Check error: "
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x00098a83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 66	[461]	GETTABUP 	22 0 15	; _ENV "err"
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x0f000b0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 67	[461]	CONCAT   	21 2
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x00020ab5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 68	[461]	CALL     	20 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x01020a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 69	[463]	GETI     	20 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x01130a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 70	[463]	GETI     	21 19 2
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x02130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 71	[463]	SETTABLE 	12 20 21
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x15140610);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 72	[464]	GETTABUP 	20 0 20	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x14000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 73	[466]	CLOSURE  	21 0	; 0x7fe07710cee0
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x00000acf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 74	[466]	CLOSURE  	22 1	; 0x7fe077105ca0
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x00008b4f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 75	[464]	CALL     	20 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x01030a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 76	[468]	CLOSE    	18
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x00000936);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 77	[457]	TFORCALL 	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x0200074c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 78	[457]	TFORLOOP 	14 33	; to 47
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x0010874d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_46; /* jump back */
    }
  }

  // 79	[468]	CLOSE    	14
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x00000736);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 80	[469]	GETTABUP 	14 0 4	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x0400070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 81	[469]	MOVE     	15 9
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x00090780);
    setobjs2s(L, ra, RB(i));
  }

  // 82	[469]	CALL     	14 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x05020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 83	[469]	TFORPREP 	14 20	; to 105
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x000a074b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_104;
  }

  // 84	[470]	GETI     	20 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x01130a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 85	[470]	GETTABLE 	20 12 20
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x140c0a0c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 86	[470]	TEST     	20 0
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_97
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x00000a42);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 87	[470]	JMP      	9	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_97;
  }

  // 88	[471]	GETTABUP 	20 0 13	; _ENV "check"
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x0d000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 89	[471]	GETI     	21 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x01130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 90	[471]	GETTABLE 	21 12 21
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x150c0a8c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 91	[471]	GETI     	22 19 2
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x02130b0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 92	[471]	GETI     	23 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x01130b8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 93	[471]	MOVE     	24 13
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x000d0c00);
    setobjs2s(L, ra, RB(i));
  }

  // 94	[471]	GETI     	25 19 3
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x03130c8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 95	[471]	CALL     	20 6 1	; 5 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_104
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x01060a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 96	[472]	JMP      	7	; to 105
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_104;
  }

  // 97	[472]	GETI     	20 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x01130a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 98	[472]	GETTABLE 	20 13 20
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x140d0a0c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 99	[472]	TEST     	20 1
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_104
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x00008a42);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 100	[472]	JMP      	3	; to 105
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_104;
  }

  // 101	[473]	GETI     	20 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x01130a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 102	[473]	GETI     	21 19 2
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x02130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 103	[473]	SETTABLE 	13 20 21
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x15140690);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 104	[469]	TFORCALL 	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x0200074c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 105	[469]	TFORLOOP 	14 22	; to 85
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x000b074d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_84; /* jump back */
    }
  }

  // 106	[475]	CLOSE    	14
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x00000736);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 107	[476]	GETTABUP 	14 0 4	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x0400070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 108	[476]	MOVE     	15 8
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x00080780);
    setobjs2s(L, ra, RB(i));
  }

  // 109	[476]	CALL     	14 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x05020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 110	[476]	TFORPREP 	14 13	; to 125
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x0006874b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_124;
  }

  // 111	[477]	GETTABUP 	20 0 13	; _ENV "check"
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x0d000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 112	[477]	GETI     	21 19 2
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x02130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 113	[477]	GETI     	22 19 3
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x03130b0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 114	[477]	GETI     	23 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x01130b8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 115	[477]	MOVE     	24 13
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x000d0c00);
    setobjs2s(L, ra, RB(i));
  }

  // 116	[477]	GETI     	25 19 4
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x04130c8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 117	[477]	CALL     	20 6 1	; 5 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x01060a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 118	[478]	GETI     	20 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x01130a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 119	[478]	GETI     	21 19 3
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x03130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 120	[478]	SETTABLE 	13 20 21
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x15140690);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 121	[479]	GETI     	20 19 1
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x01130a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 122	[479]	GETI     	21 19 2
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x02130a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 123	[479]	SETTABLE 	12 20 21
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x15140610);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 124	[476]	TFORCALL 	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x0200074c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 125	[476]	TFORLOOP 	14 15	; to 112
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x0007874d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_111; /* jump back */
    }
  }

  // 126	[480]	CLOSE    	14
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x00000736);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 127	[481]	CLOSE    	7
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x000003b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 128	[447]	TFORCALL 	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x020000cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 129	[447]	TFORLOOP 	1 116	; to 15
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x003a00cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_14; /* jump back */
    }
  }

  // 130	[481]	CLOSE    	1
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_132
  label_130: {
    aot_vmfetch(0x000000b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 131	[482]	LOADTRUE 	1
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_133
  label_131: {
    aot_vmfetch(0x00000087);
    setbtvalue(s2v(ra));
  }

  // 132	[482]	RETURN   	1 2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 133)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_132: {
    aot_vmfetch(0x000280c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 133	[483]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 134)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_133: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 464 - 466
static
CallInfo *magic_implementation_57(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
  }

  // 0	[465]	GETUPVAL 	0 1	; def
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00010009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[465]	GETI     	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0100008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[465]	GETUPVAL 	0 0	; knownValues
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[465]	GETTABUP 	2 2 0	; _ENV "value"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0002010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[465]	CALL     	2 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02010144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[465]	SETTABLE 	0 1 2
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_05: {
    aot_vmfetch(0x02010010);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 6	[466]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 466 - 466
static
CallInfo *magic_implementation_58(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
  }

  // 0	[466]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_00: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 484 - 490
static
CallInfo *magic_implementation_59(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
  }

  // 0	[486]	GETTABUP 	0 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[486]	LOADK    	1 1	; "All valid checkable types:"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[486]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[487]	GETTABUP 	0 0 2	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0200000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[487]	GETTABUP 	1 0 3	; _ENV "alltypes"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0300008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 5	[487]	CALL     	0 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x05020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[487]	TFORPREP 	0 5	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0002804b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_12;
  }

  // 7	[488]	GETTABUP 	6 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0000030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[488]	LOADK    	7 4	; "  "
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00020383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[488]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[488]	CONCAT   	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x000203b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 11	[488]	CALL     	6 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x01020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 12	[487]	TFORCALL 	0 2
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0200004c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 13	[487]	TFORLOOP 	0 7	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0003804d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_07; /* jump back */
    }
  }

  // 14	[489]	CLOSE    	0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_14: {
    aot_vmfetch(0x00000036);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 15	[490]	RETURN   	0 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_15: {
    aot_vmfetch(0x00018046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 524 - 539
static
CallInfo *magic_implementation_60(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
  }

  // 0	[526]	LOADK    	3 0	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[527]	LEN      	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00010234);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 2	[528]	LOADI    	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000281);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 3	[529]	LEN      	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00000334);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 4	[529]	LE       	5 6 0
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_32
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000602bb);
    op_order(L, l_lei, LEnum, lessequalothers);
  }

  // 5	[529]	JMP      	26	; to 33
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x80000cb8);
    updatetrap(ci);
    goto label_32;
  }

  // 6	[530]	SELF     	6 0 1k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x01008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[530]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[530]	ADD      	9 5 4
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x040504a2);
    op_arith(L, l_addi, luai_numadd);
  }

  // 9	[530]	MMBIN    	5 4 6	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x060402ae);
    Instruction pi = 0x040504a2; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 10	[530]	ADDI     	9 9 -1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x7e090495);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 11	[530]	MMBINI   	9 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x078004af);
    Instruction pi = 0x7e090495;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 12	[530]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 13	[530]	EQ       	6 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00010339);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 14	[530]	JMP      	7	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_22;
  }

  // 15	[531]	MOVE     	6 3
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00030300);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[531]	MOVE     	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00020380);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[531]	CONCAT   	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00020335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 18	[531]	MOVE     	3 6
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00060180);
    setobjs2s(L, ra, RB(i));
  }

  // 19	[532]	ADD      	5 5 4
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x040502a2);
    op_arith(L, l_addi, luai_numadd);
  }

  // 20	[532]	MMBIN    	5 4 6	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_03
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x060402ae);
    Instruction pi = 0x040502a2; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 21	[533]	JMP      	-19	; to 4
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x7ffff638);
    updatetrap(ci);
    goto label_03;
  }

  // 22	[534]	MOVE     	6 3
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00030300);
    setobjs2s(L, ra, RB(i));
  }

  // 23	[534]	SELF     	7 0 1k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x01008394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 24	[534]	MOVE     	9 5
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00050480);
    setobjs2s(L, ra, RB(i));
  }

  // 25	[534]	MOVE     	10 5
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00050500);
    setobjs2s(L, ra, RB(i));
  }

  // 26	[534]	CALL     	7 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x020403c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 27	[534]	CONCAT   	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00020335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 28	[534]	MOVE     	3 6
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00060180);
    setobjs2s(L, ra, RB(i));
  }

  // 29	[535]	ADDI     	5 5 1
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x80050295);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 30	[535]	MMBINI   	5 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_03
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x068002af);
    Instruction pi = 0x80050295;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 31	[537]	JMP      	-29	; to 4
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x7ffff138);
    updatetrap(ci);
    goto label_03;
  }

  // 32	[538]	RETURN1  	3
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_32: {
    aot_vmfetch(0x000201c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 33	[539]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_33: {
    aot_vmfetch(0x00010347);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 541 - 552
static
CallInfo *magic_implementation_61(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
  }

  // 0	[542]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_03
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 1	[542]	JMP      	1	; to 4
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_03;
  }

  // 2	[542]	LOADI    	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 3	[543]	LEN      	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000101b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 4	[544]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 5	[545]	LEN      	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x000002b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 6	[545]	LE       	4 5 0
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_26
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0005023b);
    op_order(L, l_lei, LEnum, lessequalothers);
  }

  // 7	[545]	JMP      	18	; to 27
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x800008b8);
    updatetrap(ci);
    goto label_26;
  }

  // 8	[546]	SELF     	5 0 0k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 9	[546]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[546]	ADD      	8 4 3
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x03040422);
    op_arith(L, l_addi, luai_numadd);
  }

  // 11	[546]	MMBIN    	4 3 6	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0603022e);
    Instruction pi = 0x03040422; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 12	[546]	ADDI     	8 8 -1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x7e080415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 13	[546]	MMBINI   	8 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0780042f);
    Instruction pi = 0x7e080415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 14	[546]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 15	[546]	EQ       	5 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000102b9);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 16	[546]	JMP      	6	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_23;
  }

  // 17	[547]	MOVE     	5 4
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00040280);
    setobjs2s(L, ra, RB(i));
  }

  // 18	[547]	ADD      	6 4 3
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x03040322);
    op_arith(L, l_addi, luai_numadd);
  }

  // 19	[547]	MMBIN    	4 3 6	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0603022e);
    Instruction pi = 0x03040322; /* original arith. expression */
    TValue *rb = vRB(i);
    TMS tm = (TMS)GETARG_C(i);
    StkId result = RA(pi);
    lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
    Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));
  }

  // 20	[547]	ADDI     	6 6 -1
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x7e060315);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 21	[547]	MMBINI   	6 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0780032f);
    Instruction pi = 0x7e060315;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 22	[547]	RETURN   	5 3 0	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000302c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 23	[549]	ADDI     	4 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x80040215);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 24	[549]	MMBINI   	4 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_05
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0680022f);
    Instruction pi = 0x80040215;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 25	[550]	JMP      	-21	; to 6
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x7ffff538);
    updatetrap(ci);
    goto label_05;
  }

  // 26	[551]	LOADNIL  	5 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00000288);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 27	[551]	RETURN1  	5
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_27: {
    aot_vmfetch(0x000202c8);
    if (l_unlikely(L->hookmask)) {
      L->top = ra + 1;
      savepc(ci);
      luaD_poscall(L, ci, 1);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres = ci->nresults;
      L->ci = ci->previous;  /* back to caller */
      if (nres == 0)
        L->top = base - 1;  /* asked for no results */
      else {
        setobjs2s(L, base - 1, ra);  /* at least this result */
        L->top = base;
        for (; l_unlikely(nres > 1); nres--)
          setnilvalue(s2v(L->top++));
      }
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 28	[552]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_28: {
    aot_vmfetch(0x000102c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 554 - 624
static
CallInfo *magic_implementation_62(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
    case 132: goto label_132;
    case 133: goto label_133;
    case 134: goto label_134;
    case 135: goto label_135;
    case 136: goto label_136;
    case 137: goto label_137;
    case 138: goto label_138;
    case 139: goto label_139;
    case 140: goto label_140;
    case 141: goto label_141;
    case 142: goto label_142;
    case 143: goto label_143;
    case 144: goto label_144;
    case 145: goto label_145;
    case 146: goto label_146;
    case 147: goto label_147;
    case 148: goto label_148;
    case 149: goto label_149;
    case 150: goto label_150;
    case 151: goto label_151;
    case 152: goto label_152;
    case 153: goto label_153;
    case 154: goto label_154;
    case 155: goto label_155;
    case 156: goto label_156;
    case 157: goto label_157;
    case 158: goto label_158;
    case 159: goto label_159;
    case 160: goto label_160;
    case 161: goto label_161;
    case 162: goto label_162;
    case 163: goto label_163;
    case 164: goto label_164;
    case 165: goto label_165;
    case 166: goto label_166;
    case 167: goto label_167;
    case 168: goto label_168;
    case 169: goto label_169;
    case 170: goto label_170;
    case 171: goto label_171;
    case 172: goto label_172;
  }

  // 0	[555]	GETTABUP 	1 0 2	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0200008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[555]	GETFIELD 	1 1 3	; "clean"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 2	[555]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 3	[555]	CALL     	1 2 3	; 1 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x030200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[555]	SETTABUP 	0 1 2	; _ENV "dead"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0201000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 5	[555]	SETTABUP 	0 0 1	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0100000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 6	[557]	GETTABUP 	1 0 0	; _ENV "cleanedCode"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[557]	SELF     	1 1 5k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x05018094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[557]	LOADK    	3 6	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00030183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[557]	CALL     	1 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x020300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[557]	SETTABUP 	0 4 1	; _ENV "lines"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0104000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 11	[560]	GETTABUP 	1 0 7	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0700008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[560]	GETTABUP 	2 0 4	; _ENV "lines"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[560]	CALL     	1 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x050200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[560]	TFORPREP 	1 148	; to 164
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x004a00cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_163;
  }

  // 15	[561]	GETTABUP 	7 0 2	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x0200038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 16	[561]	GETFIELD 	7 7 9	; "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0907038e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 17	[561]	MOVE     	8 6
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00060400);
    setobjs2s(L, ra, RB(i));
  }

  // 18	[561]	GETTABUP 	9 0 1	; _ENV "dead"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0100048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 19	[561]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[561]	SETTABUP 	0 8 7	; _ENV "vclean"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0708000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 21	[563]	GETTABUP 	7 0 8	; _ENV "vclean"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0800038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 22	[563]	SELF     	7 7 10k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0a078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 23	[563]	LOADK    	9 11	; "@[a-zA-Z0-9_]+"
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00058483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 24	[563]	CALL     	7 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x050303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 25	[563]	TFORPREP 	7 10	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x000503cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_36;
  }

  // 26	[564]	SELF     	12 6 12k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x0c068614);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 27	[564]	MOVE     	14 11
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000b0700);
    setobjs2s(L, ra, RB(i));
  }

  // 28	[564]	LOADK    	15 13	; "ipairs("
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00068783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 29	[564]	SELF     	16 11 14k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0e0b8814);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 30	[564]	LOADI    	18 2
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x80008901);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 31	[564]	CALL     	16 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x02030844);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[564]	LOADK    	17 15	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x00078883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 33	[564]	CONCAT   	15 3
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x000307b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 34	[564]	CALL     	12 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x02040644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 35	[564]	MOVE     	6 12
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x000c0300);
    setobjs2s(L, ra, RB(i));
  }

  // 36	[563]	TFORCALL 	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x010003cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 37	[563]	TFORLOOP 	7 12	; to 27
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x000603cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_26; /* jump back */
    }
  }

  // 38	[565]	CLOSE    	7
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x000003b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 39	[566]	GETTABUP 	7 0 8	; _ENV "vclean"
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x0800038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 40	[566]	SELF     	7 7 10k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x0a078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 41	[566]	LOADK    	9 16	; "$[a-zA-Z0-9_]+"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x00080483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 42	[566]	CALL     	7 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x050303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 43	[566]	TFORPREP 	7 10	; to 55
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x000503cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_54;
  }

  // 44	[567]	SELF     	12 6 12k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x0c068614);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 45	[567]	MOVE     	14 11
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000b0700);
    setobjs2s(L, ra, RB(i));
  }

  // 46	[567]	LOADK    	15 17	; "pairs("
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x00088783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 47	[567]	SELF     	16 11 14k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x0e0b8814);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 48	[567]	LOADI    	18 2
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x80008901);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 49	[567]	CALL     	16 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x02030844);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 50	[567]	LOADK    	17 15	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x00078883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 51	[567]	CONCAT   	15 3
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x000307b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 52	[567]	CALL     	12 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x02040644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 53	[567]	MOVE     	6 12
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x000c0300);
    setobjs2s(L, ra, RB(i));
  }

  // 54	[566]	TFORCALL 	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x010003cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 55	[566]	TFORLOOP 	7 12	; to 45
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x000603cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_44; /* jump back */
    }
  }

  // 56	[568]	CLOSE    	7
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x000003b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 57	[571]	SELF     	7 6 10k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x0a068394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 58	[571]	LOADK    	9 18	; "[a-zA-Z0-9_]+~[^%s]+"
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00090483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 59	[571]	CALL     	7 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x050303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 60	[571]	TFORPREP 	7 28	; to 90
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x000e03cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_89;
  }

  // 61	[578]	SELF     	12 11 14k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x0e0b8614);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 62	[578]	LOADI    	14 1
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x80000701);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 63	[578]	SELF     	15 11 20k	; "find"
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x140b8794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 64	[578]	LOADK    	17 21	; "~"
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x000a8883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 65	[578]	CALL     	15 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x020307c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 66	[578]	ADDI     	15 15 -1
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x7e0f0795);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 67	[578]	MMBINI   	15 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x078007af);
    Instruction pi = 0x7e0f0795;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 68	[578]	CALL     	12 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x02040644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 69	[578]	SETTABUP 	0 19 12	; _ENV "arg1"
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x0c13000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 70	[579]	SELF     	12 11 14k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x0e0b8614);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 71	[579]	SELF     	14 11 20k	; "find"
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x140b8714);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 72	[579]	LOADK    	16 21	; "~"
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x000a8803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 73	[579]	CALL     	14 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x02030744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 74	[579]	ADDI     	14 14 1
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x800e0715);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 75	[579]	MMBINI   	14 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x0680072f);
    Instruction pi = 0x800e0715;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 76	[579]	CALL     	12 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x02030644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 77	[579]	SETTABUP 	0 22 12	; _ENV "arg2"
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x0c16000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 78	[580]	GETTABUP 	12 0 12	; _ENV "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x0c00060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 79	[580]	MOVE     	13 6
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x00060680);
    setobjs2s(L, ra, RB(i));
  }

  // 80	[580]	MOVE     	14 11
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x000b0700);
    setobjs2s(L, ra, RB(i));
  }

  // 81	[580]	LOADK    	15 23	; "global(\""
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x000b8783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 82	[580]	GETTABUP 	16 0 19	; _ENV "arg1"
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x1300080b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 83	[580]	LOADK    	17 24	; "\", "
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x000c0883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 84	[580]	GETTABUP 	18 0 22	; _ENV "arg2"
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x1600090b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 85	[580]	LOADK    	19 15	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x00078983);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 86	[580]	CONCAT   	15 5
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x000507b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 87	[580]	CALL     	12 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x02040644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 88	[580]	MOVE     	6 12
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x000c0300);
    setobjs2s(L, ra, RB(i));
  }

  // 89	[571]	TFORCALL 	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x010003cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 90	[571]	TFORLOOP 	7 30	; to 62
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x000f03cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_61; /* jump back */
    }
  }

  // 91	[581]	CLOSE    	7
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x000003b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 92	[594]	SELF     	7 6 10k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x0a068394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 93	[594]	LOADK    	9 25	; "f'(.-)'"
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x000c8483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 94	[594]	CALL     	7 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x050303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 95	[594]	TFORPREP 	7 33	; to 130
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x001083cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_129;
  }

  // 96	[596]	GETTABUP 	12 0 2	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x0200060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 97	[596]	GETFIELD 	12 12 9	; "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x090c060e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 98	[596]	SELF     	13 6 12k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x0c068694);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 99	[596]	LOADK    	15 25	; "f'(.-)'"
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x000c8783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 100	[596]	LOADK    	16 26	; "string.format('"
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x000d0803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 101	[596]	MOVE     	17 11
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x000b0880);
    setobjs2s(L, ra, RB(i));
  }

  // 102	[596]	LOADK    	18 27	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x000d8903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 103	[596]	CONCAT   	16 3
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x00030835);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 104	[596]	CALL     	13 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x020406c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 105	[596]	GETTABUP 	14 0 1	; _ENV "dead"
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x0100070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 106	[596]	CALL     	12 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x02030644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 107	[596]	MOVE     	6 12
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x000c0300);
    setobjs2s(L, ra, RB(i));
  }

  // 108	[598]	SELF     	12 6 10k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x0a068614);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 109	[598]	LOADK    	14 28	; "{(.-)}"
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x000e0703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 110	[598]	CALL     	12 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x05030644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 111	[598]	TFORPREP 	12 10	; to 123
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x0005064b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_122;
  }

  // 112	[600]	MOVE     	17 6
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x00060880);
    setobjs2s(L, ra, RB(i));
  }

  // 113	[600]	LOADK    	18 29	; ", "
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x000e8903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 114	[600]	MOVE     	19 16
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x00100980);
    setobjs2s(L, ra, RB(i));
  }

  // 115	[600]	CONCAT   	17 3
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x000308b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 116	[600]	MOVE     	6 17
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x00110300);
    setobjs2s(L, ra, RB(i));
  }

  // 117	[602]	SELF     	17 6 12k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x0c068894);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 118	[602]	LOADK    	19 28	; "{(.-)}"
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x000e0983);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 119	[602]	LOADK    	20 30	; "%%s"
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x000f0a03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 120	[602]	CALL     	17 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x020408c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 121	[602]	MOVE     	6 17
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x00110300);
    setobjs2s(L, ra, RB(i));
  }

  // 122	[598]	TFORCALL 	12 1
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x0100064c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 123	[598]	TFORLOOP 	12 12	; to 113
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x0006064d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_112; /* jump back */
    }
  }

  // 124	[603]	CLOSE    	12
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x00000636);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 125	[606]	MOVE     	12 6
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x00060600);
    setobjs2s(L, ra, RB(i));
  }

  // 126	[606]	LOADK    	13 15	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x00078683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 127	[606]	CONCAT   	12 2
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x00020635);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 128	[606]	MOVE     	6 12
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x000c0300);
    setobjs2s(L, ra, RB(i));
  }

  // 129	[594]	TFORCALL 	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x010003cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 130	[594]	TFORLOOP 	7 35	; to 97
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_132
  label_130: {
    aot_vmfetch(0x001183cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_96; /* jump back */
    }
  }

  // 131	[607]	CLOSE    	7
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_133
  label_131: {
    aot_vmfetch(0x000003b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 132	[609]	SELF     	7 6 10k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 133)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_134
  label_132: {
    aot_vmfetch(0x0a068394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 133	[609]	LOADK    	9 31	; "f[[(.*)]]"
  #undef  AOT_PC
  #define AOT_PC (code + 134)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_135
  label_133: {
    aot_vmfetch(0x000f8483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 134	[609]	CALL     	7 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 135)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_136
  label_134: {
    aot_vmfetch(0x050303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 135	[609]	TFORPREP 	7 18	; to 155
  #undef  AOT_PC
  #define AOT_PC (code + 136)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_137
  label_135: {
    aot_vmfetch(0x000903cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_154;
  }

  // 136	[610]	GETTABUP 	12 0 32	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 137)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_138
  label_136: {
    aot_vmfetch(0x2000060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 137	[610]	LOADK    	13 33	; "\027[1;31mPreprocessor error:\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 138)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_139
  label_137: {
    aot_vmfetch(0x00108683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 138	[610]	CALL     	12 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 139)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_140
  label_138: {
    aot_vmfetch(0x01020644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 139	[611]	GETTABUP 	12 0 32	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 140)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_141
  label_139: {
    aot_vmfetch(0x2000060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 140	[611]	LOADK    	13 34	; "\027[1;31mError with the 'f[[' preprocessor command.\027[0m\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 141)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_142
  label_140: {
    aot_vmfetch(0x00110683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 141	[611]	CALL     	12 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 142)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_143
  label_141: {
    aot_vmfetch(0x01020644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 142	[612]	GETTABUP 	12 0 35	; _ENV "errorin"
  #undef  AOT_PC
  #define AOT_PC (code + 143)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_144
  label_142: {
    aot_vmfetch(0x2300060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 143	[612]	TEST     	12 0
  #undef  AOT_PC
  #define AOT_PC (code + 144)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_148
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_145
  label_143: {
    aot_vmfetch(0x00000642);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 144	[612]	JMP      	3	; to 149
  #undef  AOT_PC
  #define AOT_PC (code + 145)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_146
  label_144: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_148;
  }

  // 145	[613]	GETTABUP 	12 0 32	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 146)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_147
  label_145: {
    aot_vmfetch(0x2000060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 146	[613]	LOADK    	13 36	; "\027[1;31mMultiline formatted strings are not supported.\027[0m\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 147)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_148
  label_146: {
    aot_vmfetch(0x00120683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 147	[613]	CALL     	12 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 148)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_149
  label_147: {
    aot_vmfetch(0x01020644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 148	[615]	GETTABUP 	12 0 32	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 149)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_150
  label_148: {
    aot_vmfetch(0x2000060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 149	[615]	LOADK    	13 37	; "\027[1;31mStopping preprocessor.\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 150)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_151
  label_149: {
    aot_vmfetch(0x00128683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 150	[615]	CALL     	12 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 151)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_152
  label_150: {
    aot_vmfetch(0x01020644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 151	[616]	GETTABUP 	12 0 38	; _ENV "os"
  #undef  AOT_PC
  #define AOT_PC (code + 152)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_153
  label_151: {
    aot_vmfetch(0x2600060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 152	[616]	GETFIELD 	12 12 39	; "exit"
  #undef  AOT_PC
  #define AOT_PC (code + 153)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_154
  label_152: {
    aot_vmfetch(0x270c060e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 153	[616]	CALL     	12 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 154)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_155
  label_153: {
    aot_vmfetch(0x01010644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 154	[609]	TFORCALL 	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 155)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_156
  label_154: {
    aot_vmfetch(0x010003cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 155	[609]	TFORLOOP 	7 20	; to 137
  #undef  AOT_PC
  #define AOT_PC (code + 156)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_157
  label_155: {
    aot_vmfetch(0x000a03cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_136; /* jump back */
    }
  }

  // 156	[617]	CLOSE    	7
  #undef  AOT_PC
  #define AOT_PC (code + 157)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_158
  label_156: {
    aot_vmfetch(0x000003b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 157	[619]	GETTABUP 	7 0 4	; _ENV "lines"
  #undef  AOT_PC
  #define AOT_PC (code + 158)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_159
  label_157: {
    aot_vmfetch(0x0400038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 158	[619]	GETTABUP 	8 0 2	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 159)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_160
  label_158: {
    aot_vmfetch(0x0200040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 159	[619]	GETFIELD 	8 8 9	; "revive"
  #undef  AOT_PC
  #define AOT_PC (code + 160)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_161
  label_159: {
    aot_vmfetch(0x0908040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 160	[619]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 161)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_162
  label_160: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 161	[619]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 162)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_163
  label_161: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 162	[619]	SETTABLE 	7 5 8
  #undef  AOT_PC
  #define AOT_PC (code + 163)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_164
  label_162: {
    aot_vmfetch(0x08050390);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 163	[560]	TFORCALL 	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 164)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_165
  label_163: {
    aot_vmfetch(0x020000cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 164	[560]	TFORLOOP 	1 150	; to 16
  #undef  AOT_PC
  #define AOT_PC (code + 165)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_166
  label_164: {
    aot_vmfetch(0x004b00cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_15; /* jump back */
    }
  }

  // 165	[620]	CLOSE    	1
  #undef  AOT_PC
  #define AOT_PC (code + 166)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_167
  label_165: {
    aot_vmfetch(0x000000b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 166	[623]	GETTABUP 	1 0 40	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 167)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_168
  label_166: {
    aot_vmfetch(0x2800008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 167	[623]	GETFIELD 	1 1 41	; "concat"
  #undef  AOT_PC
  #define AOT_PC (code + 168)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_169
  label_167: {
    aot_vmfetch(0x2901008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 168	[623]	GETTABUP 	2 0 4	; _ENV "lines"
  #undef  AOT_PC
  #define AOT_PC (code + 169)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_170
  label_168: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 169	[623]	LOADK    	3 6	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 170)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_171
  label_169: {
    aot_vmfetch(0x00030183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 170	[623]	TAILCALL 	1 3 0	; 2 in
  #undef  AOT_PC
  #define AOT_PC (code + 171)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_172
  label_170: {
    aot_vmfetch(0x000380c5);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b);  /* prepare call frame */
    return ci;
  }

  // 171	[623]	RETURN   	1 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 172)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_171: {
    aot_vmfetch(0x000080c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 172	[624]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 173)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_172: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 626 - 1195
static
CallInfo *magic_implementation_63(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
    case 132: goto label_132;
    case 133: goto label_133;
    case 134: goto label_134;
    case 135: goto label_135;
    case 136: goto label_136;
    case 137: goto label_137;
    case 138: goto label_138;
    case 139: goto label_139;
    case 140: goto label_140;
    case 141: goto label_141;
    case 142: goto label_142;
    case 143: goto label_143;
    case 144: goto label_144;
    case 145: goto label_145;
    case 146: goto label_146;
    case 147: goto label_147;
    case 148: goto label_148;
    case 149: goto label_149;
    case 150: goto label_150;
    case 151: goto label_151;
    case 152: goto label_152;
    case 153: goto label_153;
    case 154: goto label_154;
    case 155: goto label_155;
    case 156: goto label_156;
    case 157: goto label_157;
    case 158: goto label_158;
    case 159: goto label_159;
    case 160: goto label_160;
    case 161: goto label_161;
    case 162: goto label_162;
    case 163: goto label_163;
    case 164: goto label_164;
    case 165: goto label_165;
    case 166: goto label_166;
    case 167: goto label_167;
    case 168: goto label_168;
    case 169: goto label_169;
    case 170: goto label_170;
    case 171: goto label_171;
    case 172: goto label_172;
    case 173: goto label_173;
    case 174: goto label_174;
    case 175: goto label_175;
    case 176: goto label_176;
    case 177: goto label_177;
    case 178: goto label_178;
    case 179: goto label_179;
    case 180: goto label_180;
    case 181: goto label_181;
    case 182: goto label_182;
    case 183: goto label_183;
    case 184: goto label_184;
    case 185: goto label_185;
    case 186: goto label_186;
    case 187: goto label_187;
    case 188: goto label_188;
    case 189: goto label_189;
    case 190: goto label_190;
    case 191: goto label_191;
    case 192: goto label_192;
    case 193: goto label_193;
    case 194: goto label_194;
    case 195: goto label_195;
    case 196: goto label_196;
    case 197: goto label_197;
    case 198: goto label_198;
    case 199: goto label_199;
    case 200: goto label_200;
    case 201: goto label_201;
    case 202: goto label_202;
    case 203: goto label_203;
    case 204: goto label_204;
    case 205: goto label_205;
    case 206: goto label_206;
    case 207: goto label_207;
    case 208: goto label_208;
    case 209: goto label_209;
    case 210: goto label_210;
    case 211: goto label_211;
    case 212: goto label_212;
    case 213: goto label_213;
    case 214: goto label_214;
    case 215: goto label_215;
    case 216: goto label_216;
    case 217: goto label_217;
    case 218: goto label_218;
    case 219: goto label_219;
    case 220: goto label_220;
    case 221: goto label_221;
    case 222: goto label_222;
    case 223: goto label_223;
    case 224: goto label_224;
    case 225: goto label_225;
    case 226: goto label_226;
    case 227: goto label_227;
    case 228: goto label_228;
    case 229: goto label_229;
    case 230: goto label_230;
    case 231: goto label_231;
    case 232: goto label_232;
    case 233: goto label_233;
    case 234: goto label_234;
    case 235: goto label_235;
    case 236: goto label_236;
    case 237: goto label_237;
    case 238: goto label_238;
    case 239: goto label_239;
    case 240: goto label_240;
    case 241: goto label_241;
    case 242: goto label_242;
    case 243: goto label_243;
    case 244: goto label_244;
    case 245: goto label_245;
    case 246: goto label_246;
    case 247: goto label_247;
    case 248: goto label_248;
    case 249: goto label_249;
    case 250: goto label_250;
    case 251: goto label_251;
    case 252: goto label_252;
    case 253: goto label_253;
    case 254: goto label_254;
    case 255: goto label_255;
    case 256: goto label_256;
    case 257: goto label_257;
    case 258: goto label_258;
    case 259: goto label_259;
    case 260: goto label_260;
    case 261: goto label_261;
    case 262: goto label_262;
    case 263: goto label_263;
    case 264: goto label_264;
    case 265: goto label_265;
    case 266: goto label_266;
    case 267: goto label_267;
    case 268: goto label_268;
    case 269: goto label_269;
    case 270: goto label_270;
    case 271: goto label_271;
    case 272: goto label_272;
    case 273: goto label_273;
    case 274: goto label_274;
    case 275: goto label_275;
    case 276: goto label_276;
    case 277: goto label_277;
    case 278: goto label_278;
    case 279: goto label_279;
    case 280: goto label_280;
    case 281: goto label_281;
    case 282: goto label_282;
    case 283: goto label_283;
    case 284: goto label_284;
    case 285: goto label_285;
    case 286: goto label_286;
    case 287: goto label_287;
    case 288: goto label_288;
    case 289: goto label_289;
    case 290: goto label_290;
    case 291: goto label_291;
    case 292: goto label_292;
    case 293: goto label_293;
    case 294: goto label_294;
    case 295: goto label_295;
    case 296: goto label_296;
    case 297: goto label_297;
    case 298: goto label_298;
    case 299: goto label_299;
    case 300: goto label_300;
    case 301: goto label_301;
    case 302: goto label_302;
    case 303: goto label_303;
    case 304: goto label_304;
    case 305: goto label_305;
    case 306: goto label_306;
    case 307: goto label_307;
    case 308: goto label_308;
    case 309: goto label_309;
    case 310: goto label_310;
    case 311: goto label_311;
    case 312: goto label_312;
    case 313: goto label_313;
    case 314: goto label_314;
    case 315: goto label_315;
    case 316: goto label_316;
    case 317: goto label_317;
    case 318: goto label_318;
    case 319: goto label_319;
    case 320: goto label_320;
    case 321: goto label_321;
    case 322: goto label_322;
    case 323: goto label_323;
    case 324: goto label_324;
    case 325: goto label_325;
    case 326: goto label_326;
    case 327: goto label_327;
    case 328: goto label_328;
    case 329: goto label_329;
    case 330: goto label_330;
    case 331: goto label_331;
    case 332: goto label_332;
    case 333: goto label_333;
    case 334: goto label_334;
    case 335: goto label_335;
    case 336: goto label_336;
    case 337: goto label_337;
    case 338: goto label_338;
    case 339: goto label_339;
    case 340: goto label_340;
    case 341: goto label_341;
    case 342: goto label_342;
    case 343: goto label_343;
    case 344: goto label_344;
    case 345: goto label_345;
    case 346: goto label_346;
  }

  // 0	[626]	VARARGPREP	4
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000251);
    ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));
    if (l_unlikely(trap)) {  /* previous "Protect" updated trap */
      luaD_hookcall(L, ci);
      L->oldpc = 1;  /* next opcode will be seen as a "new" line */
    }
    updatebase(ci);  /* function has new base after adjustment */
  }

  // 1	[630]	EQK      	3 0 0	; "-types"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_07
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x000001bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 2	[630]	JMP      	4	; to 8
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_07;
  }

  // 3	[631]	GETTABUP 	4 0 1	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0100020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[631]	GETFIELD 	4 4 2	; "all"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0204020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[631]	CALL     	4 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x01010244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[632]	RETURN   	4 1 5	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x05018246);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 7	[633]	NEWTABLE 	4 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000213);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 8	[633]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 9	[633]	VARARG   	5 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000002d0);
    int n = GETARG_C(i) - 1;  /* required results */
    Protect(luaT_getvarargs(L, ci, ra, n));
  }

  // 10	[633]	SETLIST  	4 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0000024e);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 11	[633]	NEWTABLE 	5 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000293);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 12	[633]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 13	[633]	EQ       	4 5 0
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_18
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00050239);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 14	[633]	JMP      	3	; to 19
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_18;
  }

  // 15	[634]	GETTABUP 	4 0 3	; _ENV "error"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x0300020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 16	[634]	LOADK    	5 4	; "No arguments or invalid flags provided."
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00020283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 17	[634]	CALL     	4 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x01020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[638]	GETTABUP 	4 0 5	; _ENV "macros"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0500020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 19	[638]	CALL     	4 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x01010244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[641]	LOADNIL  	4 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00000208);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 21	[642]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_25
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 22	[642]	JMP      	2	; to 26
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_25;
  }

  // 23	[642]	MOVE     	5 0
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_26
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00000280);
    setobjs2s(L, ra, RB(i));
  }

  // 24	[642]	JMP      	1	; to 27
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_26;
  }

  // 25	[642]	LOADNIL  	5 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00000288);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 26	[643]	EQK      	1 6 0	; "file"
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_56
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x000600bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 27	[643]	JMP      	28	; to 57
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x80000db8);
    updatetrap(ci);
    goto label_56;
  }

  // 28	[644]	GETTABUP 	6 0 7	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x0700030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 29	[644]	GETFIELD 	6 6 8	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0806030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 30	[644]	MOVE     	7 0
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00000380);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[644]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[645]	TEST     	6 1
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_41
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x00008342);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 33	[645]	JMP      	7	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_41;
  }

  // 34	[646]	GETTABUP 	7 0 3	; _ENV "error"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x0300038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 35	[646]	GETTABUP 	8 0 9	; _ENV "core"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x0900040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 36	[646]	GETFIELD 	8 8 3	; "error"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x0308040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 37	[646]	GETFIELD 	8 8 10	; "strerror"
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x0a08040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 38	[646]	LOADI    	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x80008481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 39	[646]	CALL     	8 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 40	[646]	CALL     	7 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x010003c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 41	[648]	SELF     	7 6 11k	; "read"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x0b068394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 42	[648]	LOADK    	9 12	; "*all"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x00060483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 43	[648]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 44	[648]	MOVE     	4 7
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x00070200);
    setobjs2s(L, ra, RB(i));
  }

  // 45	[649]	SELF     	7 6 13k	; "close"
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x0d068394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 46	[649]	CALL     	7 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x010203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 47	[650]	TEST     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_56
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00008242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 48	[650]	JMP      	7	; to 57
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_56;
  }

  // 49	[651]	GETTABUP 	7 0 3	; _ENV "error"
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x0300038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 50	[651]	GETTABUP 	8 0 9	; _ENV "core"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0900040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 51	[651]	GETFIELD 	8 8 3	; "error"
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x0308040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 52	[651]	GETFIELD 	8 8 10	; "strerror"
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x0a08040e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 53	[651]	LOADI    	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x80008481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 54	[651]	CALL     	8 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x00020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 55	[651]	CALL     	7 0 1	; all in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x010003c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 56	[656]	TEST     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_59
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x00008242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 57	[656]	JMP      	1	; to 60
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_59;
  }

  // 58	[656]	MOVE     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00000200);
    setobjs2s(L, ra, RB(i));
  }

  // 59	[657]	GETTABUP 	6 0 1	; _ENV "typechecker"
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x0100030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 60	[657]	GETFIELD 	6 6 14	; "check"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x0e06030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 61	[657]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 62	[657]	CALL     	6 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x01020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 63	[658]	GETTABUP 	6 0 15	; _ENV "ext"
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x0f00030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 64	[658]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 65	[658]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 66	[658]	MOVE     	4 6
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x00060200);
    setobjs2s(L, ra, RB(i));
  }

  // 67	[661]	NEWTABLE 	6 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x00000313);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 68	[661]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 69	[662]	SELF     	7 4 16k	; "gmatch"
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x10048394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 70	[662]	LOADK    	9 17	; "[^\r\n]+"
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x00088483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 71	[662]	CALL     	7 3 5	; 2 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x050303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 72	[662]	TFORPREP 	7 4	; to 78
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x000203cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_77;
  }

  // 73	[663]	LEN      	12 6
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x00060634);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 74	[663]	ADDI     	12 12 1
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x800c0615);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 75	[663]	MMBINI   	12 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x0680062f);
    Instruction pi = 0x800c0615;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 76	[663]	SETTABLE 	6 12 11
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x0b0c0310);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 77	[662]	TFORCALL 	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x010003cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 78	[662]	TFORLOOP 	7 6	; to 74
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x000303cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_73; /* jump back */
    }
  }

  // 79	[664]	CLOSE    	7
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x000003b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 80	[673]	CLOSURE  	7 0	; 0x7fe07710e830
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x000003cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 81	[666]	SETTABUP 	0 18 7	; _ENV "getname"
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x0712000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 82	[676]	NEWTABLE 	7 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x00000393);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 83	[676]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 84	[677]	GETTABUP 	8 0 19	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x1300040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 85	[677]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 86	[677]	CALL     	8 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x05020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 87	[677]	TFORPREP 	8 34	; to 123
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x0011044b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_122;
  }

  // 88	[678]	SELF     	14 13 20k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x140d8714);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 89	[678]	LOADI    	16 1
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x80000801);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 90	[678]	LOADI    	17 1
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x80000881);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 91	[678]	CALL     	14 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x02040744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 92	[679]	LOADI    	15 1
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x80000781);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 93	[681]	EQK      	14 21 1	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_97
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x0015873c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 94	[681]	JMP      	2	; to 98
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_97;
  }

  // 95	[681]	EQK      	14 22 0	; "\t"
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_106
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x0016073c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 96	[681]	JMP      	9	; to 107
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_106;
  }

  // 97	[682]	MOVE     	16 15
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x000f0800);
    setobjs2s(L, ra, RB(i));
  }

  // 98	[682]	ADDI     	15 15 1
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x800f0795);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 99	[682]	MMBINI   	15 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x068007af);
    Instruction pi = 0x800f0795;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 100	[683]	SELF     	16 13 20k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x140d8814);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 101	[683]	MOVE     	18 15
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x000f0900);
    setobjs2s(L, ra, RB(i));
  }

  // 102	[683]	MOVE     	19 15
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x000f0980);
    setobjs2s(L, ra, RB(i));
  }

  // 103	[683]	CALL     	16 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x02040844);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 104	[683]	MOVE     	14 16
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_93
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x00100700);
    setobjs2s(L, ra, RB(i));
  }

  // 105	[684]	JMP      	-13	; to 94
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x7ffff938);
    updatetrap(ci);
    goto label_93;
  }

  // 106	[686]	EQK      	14 23 0	; "#"
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_122
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x0017073c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 107	[686]	JMP      	14	; to 123
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x800006b8);
    updatetrap(ci);
    goto label_122;
  }

  // 108	[687]	SELF     	16 13 20k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x140d8814);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 109	[687]	MOVE     	18 15
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x000f0900);
    setobjs2s(L, ra, RB(i));
  }

  // 110	[687]	LEN      	19 13
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x000d09b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 111	[687]	CALL     	16 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x02040844);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 112	[687]	MOVE     	13 16
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x00100680);
    setobjs2s(L, ra, RB(i));
  }

  // 113	[689]	GETTABUP 	16 0 24	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x1800080b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 114	[689]	GETFIELD 	16 16 25	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x1910080e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 115	[689]	MOVE     	17 7
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x00070880);
    setobjs2s(L, ra, RB(i));
  }

  // 116	[689]	NEWTABLE 	18 0 2	; 2
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x02000913);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 117	[689]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 118	[689]	MOVE     	19 12
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x000c0980);
    setobjs2s(L, ra, RB(i));
  }

  // 119	[689]	MOVE     	20 13
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x000d0a00);
    setobjs2s(L, ra, RB(i));
  }

  // 120	[689]	SETLIST  	18 2 0
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x0002094e);
        int n = GETARG_B(i);
        unsigned int last = GETARG_C(i);
        Table *h = hvalue(s2v(ra));
        if (n == 0)
          n = cast_int(L->top - ra) - 1;  /* get up to the top */
        else
          L->top = ci->top;  /* correct top in case of emergency GC */
        last += n;
        if (last > luaH_realasize(h))  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          setobj2t(L, &h->array[last - 1], val);
          last--;
          luaC_barrierback(L, obj2gco(h), val);
        }
  }

  // 121	[689]	CALL     	16 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x01030844);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 122	[677]	TFORCALL 	8 2
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x0200044c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 123	[677]	TFORLOOP 	8 36	; to 89
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x0012044d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_88; /* jump back */
    }
  }

  // 124	[691]	CLOSE    	8
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x00000436);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 125	[694]	NEWTABLE 	8 3 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x00030413);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 126	[694]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 127	[695]	SETFIELD 	8 26 27k	; "cobalt" true
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x1b1a8412);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 128	[696]	SETFIELD 	8 28 29k	; "cobaltversion" "23"
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x1d1c8412);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 129	[697]	SETFIELD 	8 30 31k	; "edition" "standard"
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x1f1e8412);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 130	[698]	SETFIELD 	8 32 33k	; "cplusplus" false
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_132
  label_130: {
    aot_vmfetch(0x21208412);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 131	[701]	GETTABUP 	9 0 24	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_133
  label_131: {
    aot_vmfetch(0x1800048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 132	[701]	GETFIELD 	9 9 35	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 133)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_134
  label_132: {
    aot_vmfetch(0x2309048e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 133	[701]	VARARG   	10 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 134)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_135
  label_133: {
    aot_vmfetch(0x00000550);
    int n = GETARG_C(i) - 1;  /* required results */
    Protect(luaT_getvarargs(L, ci, ra, n));
  }

  // 134	[701]	CALL     	9 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 135)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_136
  label_134: {
    aot_vmfetch(0x020004c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 135	[701]	SETTABUP 	0 34 9	; _ENV "envitems"
  #undef  AOT_PC
  #define AOT_PC (code + 136)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_137
  label_135: {
    aot_vmfetch(0x0922000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 136	[702]	NEWTABLE 	9 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 137)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_138
  label_136: {
    aot_vmfetch(0x00000493);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 137	[702]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 138)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_139
  label_137: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 138	[702]	SETTABUP 	0 36 9	; _ENV "inenv"
  #undef  AOT_PC
  #define AOT_PC (code + 139)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_140
  label_138: {
    aot_vmfetch(0x0924000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 139	[703]	GETTABUP 	9 0 19	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 140)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_141
  label_139: {
    aot_vmfetch(0x1300048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 140	[703]	GETTABUP 	10 0 34	; _ENV "envitems"
  #undef  AOT_PC
  #define AOT_PC (code + 141)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_142
  label_140: {
    aot_vmfetch(0x2200050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 141	[703]	CALL     	9 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 142)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_143
  label_141: {
    aot_vmfetch(0x050204c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 142	[703]	TFORPREP 	9 22	; to 166
  #undef  AOT_PC
  #define AOT_PC (code + 143)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_144
  label_142: {
    aot_vmfetch(0x000b04cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_165;
  }

  // 143	[704]	GETTABUP 	15 0 37	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 144)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_145
  label_143: {
    aot_vmfetch(0x2500078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 144	[704]	MOVE     	16 14
  #undef  AOT_PC
  #define AOT_PC (code + 145)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_146
  label_144: {
    aot_vmfetch(0x000e0800);
    setobjs2s(L, ra, RB(i));
  }

  // 145	[704]	CALL     	15 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 146)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_147
  label_145: {
    aot_vmfetch(0x020207c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 146	[704]	EQK      	15 38 0	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 147)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_149
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_148
  label_146: {
    aot_vmfetch(0x002607bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 147	[704]	JMP      	1	; to 150
  #undef  AOT_PC
  #define AOT_PC (code + 148)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_167
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_149
  label_147: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_149;
  }

  // 148	[705]	JMP      	18	; to 168
  #undef  AOT_PC
  #define AOT_PC (code + 149)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_150
  label_148: {
    aot_vmfetch(0x800008b8);
    updatetrap(ci);
    goto label_167;
  }

  // 149	[707]	SELF     	15 14 39k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 150)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_151
  label_149: {
    aot_vmfetch(0x270e8794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 150	[707]	LOADK    	17 40	; "-"
  #undef  AOT_PC
  #define AOT_PC (code + 151)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_152
  label_150: {
    aot_vmfetch(0x00140883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 151	[707]	LOADK    	18 41	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 152)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_153
  label_151: {
    aot_vmfetch(0x00148903);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 152	[707]	CALL     	15 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 153)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_154
  label_152: {
    aot_vmfetch(0x020407c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 153	[707]	SELF     	15 15 42k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 154)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_155
  label_153: {
    aot_vmfetch(0x2a0f8794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 154	[707]	LOADK    	17 43	; "="
  #undef  AOT_PC
  #define AOT_PC (code + 155)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_156
  label_154: {
    aot_vmfetch(0x00158883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 155	[707]	CALL     	15 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 156)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_157
  label_155: {
    aot_vmfetch(0x020307c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 156	[708]	GETTABUP 	16 0 36	; _ENV "inenv"
  #undef  AOT_PC
  #define AOT_PC (code + 157)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_158
  label_156: {
    aot_vmfetch(0x2400080b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 157	[708]	GETI     	17 15 1
  #undef  AOT_PC
  #define AOT_PC (code + 158)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_159
  label_157: {
    aot_vmfetch(0x010f088d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 158	[708]	GETTABUP 	18 0 44	; _ENV "loadstring"
  #undef  AOT_PC
  #define AOT_PC (code + 159)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_160
  label_158: {
    aot_vmfetch(0x2c00090b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 159	[708]	LOADK    	19 45	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 160)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_161
  label_159: {
    aot_vmfetch(0x00168983);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 160	[708]	GETI     	20 15 2
  #undef  AOT_PC
  #define AOT_PC (code + 161)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_162
  label_160: {
    aot_vmfetch(0x020f0a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 161	[708]	CONCAT   	19 2
  #undef  AOT_PC
  #define AOT_PC (code + 162)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_163
  label_161: {
    aot_vmfetch(0x000209b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 162	[708]	CALL     	18 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 163)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_164
  label_162: {
    aot_vmfetch(0x02020944);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 163	[708]	CALL     	18 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 164)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_165
  label_163: {
    aot_vmfetch(0x02010944);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 164	[708]	SETTABLE 	16 17 18
  #undef  AOT_PC
  #define AOT_PC (code + 165)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_166
  label_164: {
    aot_vmfetch(0x12110810);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 165	[703]	TFORCALL 	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 166)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_167
  label_165: {
    aot_vmfetch(0x020004cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 166	[703]	TFORLOOP 	9 24	; to 144
  #undef  AOT_PC
  #define AOT_PC (code + 167)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_168
  label_166: {
    aot_vmfetch(0x000c04cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_143; /* jump back */
    }
  }

  // 167	[709]	CLOSE    	9
  #undef  AOT_PC
  #define AOT_PC (code + 168)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_169
  label_167: {
    aot_vmfetch(0x000004b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 168	[712]	GETTABUP 	9 0 19	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 169)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_170
  label_168: {
    aot_vmfetch(0x1300048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 169	[712]	GETTABUP 	10 0 36	; _ENV "inenv"
  #undef  AOT_PC
  #define AOT_PC (code + 170)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_171
  label_169: {
    aot_vmfetch(0x2400050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 170	[712]	CALL     	9 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 171)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_172
  label_170: {
    aot_vmfetch(0x050204c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 171	[712]	TFORPREP 	9 11	; to 184
  #undef  AOT_PC
  #define AOT_PC (code + 172)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_173
  label_171: {
    aot_vmfetch(0x000584cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_183;
  }

  // 172	[713]	GETTABUP 	15 0 37	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 173)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_174
  label_172: {
    aot_vmfetch(0x2500078b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 173	[713]	MOVE     	16 14
  #undef  AOT_PC
  #define AOT_PC (code + 174)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_175
  label_173: {
    aot_vmfetch(0x000e0800);
    setobjs2s(L, ra, RB(i));
  }

  // 174	[713]	CALL     	15 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 175)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_176
  label_174: {
    aot_vmfetch(0x020207c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 175	[713]	EQK      	15 46 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 176)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_182
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_177
  label_175: {
    aot_vmfetch(0x002e07bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 176	[713]	JMP      	5	; to 183
  #undef  AOT_PC
  #define AOT_PC (code + 177)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_178
  label_176: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_182;
  }

  // 177	[713]	LOADK    	15 47	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 178)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_179
  label_177: {
    aot_vmfetch(0x00178783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 178	[713]	MOVE     	16 14
  #undef  AOT_PC
  #define AOT_PC (code + 179)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_180
  label_178: {
    aot_vmfetch(0x000e0800);
    setobjs2s(L, ra, RB(i));
  }

  // 179	[713]	LOADK    	17 47	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 180)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_181
  label_179: {
    aot_vmfetch(0x00178883);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 180	[713]	CONCAT   	15 3
  #undef  AOT_PC
  #define AOT_PC (code + 181)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_182
  label_180: {
    aot_vmfetch(0x000307b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 181	[713]	MOVE     	14 15
  #undef  AOT_PC
  #define AOT_PC (code + 182)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_183
  label_181: {
    aot_vmfetch(0x000f0700);
    setobjs2s(L, ra, RB(i));
  }

  // 182	[714]	SETTABLE 	8 13 14
  #undef  AOT_PC
  #define AOT_PC (code + 183)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_184
  label_182: {
    aot_vmfetch(0x0e0d0410);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 183	[712]	TFORCALL 	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 184)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_185
  label_183: {
    aot_vmfetch(0x020004cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 184	[712]	TFORLOOP 	9 13	; to 173
  #undef  AOT_PC
  #define AOT_PC (code + 185)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_186
  label_184: {
    aot_vmfetch(0x000684cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_172; /* jump back */
    }
  }

  // 185	[715]	CLOSE    	9
  #undef  AOT_PC
  #define AOT_PC (code + 186)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_187
  label_185: {
    aot_vmfetch(0x000004b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 186	[716]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 187)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_188
  label_186: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 187	[717]	NEWTABLE 	10 0 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 188)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_189
  label_187: {
    aot_vmfetch(0x00000513);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 188	[717]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 189)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_190
  label_188: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 189	[718]	LOADTRUE 	11
  #undef  AOT_PC
  #define AOT_PC (code + 190)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_191
  label_189: {
    aot_vmfetch(0x00000587);
    setbtvalue(s2v(ra));
  }

  // 190	[719]	LOADFALSE	12
  #undef  AOT_PC
  #define AOT_PC (code + 191)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_192
  label_190: {
    aot_vmfetch(0x00000605);
    setbfvalue(s2v(ra));
  }

  // 191	[749]	CLOSURE  	13 1	; 0x7fe07710ec30
  #undef  AOT_PC
  #define AOT_PC (code + 192)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_193
  label_191: {
    aot_vmfetch(0x000086cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 192	[721]	SETTABUP 	0 48 13	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 193)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_194
  label_192: {
    aot_vmfetch(0x0d30000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 193	[750]	GETTABUP 	13 0 49	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 194)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_195
  label_193: {
    aot_vmfetch(0x3100068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 194	[750]	MOVE     	14 6
  #undef  AOT_PC
  #define AOT_PC (code + 195)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_196
  label_194: {
    aot_vmfetch(0x00060700);
    setobjs2s(L, ra, RB(i));
  }

  // 195	[750]	CALL     	13 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 196)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_197
  label_195: {
    aot_vmfetch(0x050206c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 196	[750]	TFORPREP 	13 107	; to 305
  #undef  AOT_PC
  #define AOT_PC (code + 197)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_198
  label_196: {
    aot_vmfetch(0x003586cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_304;
  }

  // 197	[754]	LOADI    	19 1
  #undef  AOT_PC
  #define AOT_PC (code + 198)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_199
  label_197: {
    aot_vmfetch(0x80000981);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 198	[754]	LEN      	20 18
  #undef  AOT_PC
  #define AOT_PC (code + 199)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_200
  label_198: {
    aot_vmfetch(0x00120a34);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 199	[754]	LOADI    	21 1
  #undef  AOT_PC
  #define AOT_PC (code + 200)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_201
  label_199: {
    aot_vmfetch(0x80000a81);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 200	[754]	FORPREP  	19 26	; to 228
  #undef  AOT_PC
  #define AOT_PC (code + 201)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_202
  label_200: {
    aot_vmfetch(0x000d09ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_228; /* skip the loop */
  }

  // 201	[755]	SELF     	23 18 20k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 202)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_203
  label_201: {
    aot_vmfetch(0x14128b94);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 202	[755]	MOVE     	25 22
  #undef  AOT_PC
  #define AOT_PC (code + 203)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_204
  label_202: {
    aot_vmfetch(0x00160c80);
    setobjs2s(L, ra, RB(i));
  }

  // 203	[755]	MOVE     	26 22
  #undef  AOT_PC
  #define AOT_PC (code + 204)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_205
  label_203: {
    aot_vmfetch(0x00160d00);
    setobjs2s(L, ra, RB(i));
  }

  // 204	[755]	CALL     	23 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 205)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_206
  label_204: {
    aot_vmfetch(0x02040bc4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 205	[756]	EQK      	23 50 0	; "/"
  #undef  AOT_PC
  #define AOT_PC (code + 206)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_216
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_207
  label_205: {
    aot_vmfetch(0x00320bbc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 206	[756]	JMP      	9	; to 217
  #undef  AOT_PC
  #define AOT_PC (code + 207)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_208
  label_206: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_216;
  }

  // 207	[756]	SELF     	24 18 20k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 208)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_209
  label_207: {
    aot_vmfetch(0x14128c14);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 208	[756]	ADDI     	26 22 1
  #undef  AOT_PC
  #define AOT_PC (code + 209)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_210
  label_208: {
    aot_vmfetch(0x80160d15);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 209	[756]	MMBINI   	22 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 210)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_211
  label_209: {
    aot_vmfetch(0x06800b2f);
    Instruction pi = 0x80160d15;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 210	[756]	ADDI     	27 22 1
  #undef  AOT_PC
  #define AOT_PC (code + 211)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_212
  label_210: {
    aot_vmfetch(0x80160d95);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 211	[756]	MMBINI   	22 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 212)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_213
  label_211: {
    aot_vmfetch(0x06800b2f);
    Instruction pi = 0x80160d95;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 212	[756]	CALL     	24 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 213)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_214
  label_212: {
    aot_vmfetch(0x02040c44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 213	[756]	EQK      	24 51 0	; "*"
  #undef  AOT_PC
  #define AOT_PC (code + 214)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_216
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_215
  label_213: {
    aot_vmfetch(0x00330c3c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 214	[756]	JMP      	1	; to 217
  #undef  AOT_PC
  #define AOT_PC (code + 215)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_216
  label_214: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_216;
  }

  // 215	[757]	LOADTRUE 	12
  #undef  AOT_PC
  #define AOT_PC (code + 216)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_217
  label_215: {
    aot_vmfetch(0x00000607);
    setbtvalue(s2v(ra));
  }

  // 216	[759]	EQK      	23 51 0	; "*"
  #undef  AOT_PC
  #define AOT_PC (code + 217)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_227
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_218
  label_216: {
    aot_vmfetch(0x00330bbc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 217	[759]	JMP      	9	; to 228
  #undef  AOT_PC
  #define AOT_PC (code + 218)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_219
  label_217: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_227;
  }

  // 218	[759]	SELF     	24 18 20k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 219)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_220
  label_218: {
    aot_vmfetch(0x14128c14);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 219	[759]	ADDI     	26 22 1
  #undef  AOT_PC
  #define AOT_PC (code + 220)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_221
  label_219: {
    aot_vmfetch(0x80160d15);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 220	[759]	MMBINI   	22 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 221)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_222
  label_220: {
    aot_vmfetch(0x06800b2f);
    Instruction pi = 0x80160d15;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 221	[759]	ADDI     	27 22 1
  #undef  AOT_PC
  #define AOT_PC (code + 222)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_223
  label_221: {
    aot_vmfetch(0x80160d95);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 222	[759]	MMBINI   	22 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 223)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_224
  label_222: {
    aot_vmfetch(0x06800b2f);
    Instruction pi = 0x80160d95;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 223	[759]	CALL     	24 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 224)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_225
  label_223: {
    aot_vmfetch(0x02040c44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 224	[759]	EQK      	24 50 0	; "/"
  #undef  AOT_PC
  #define AOT_PC (code + 225)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_227
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_226
  label_224: {
    aot_vmfetch(0x00320c3c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 225	[759]	JMP      	1	; to 228
  #undef  AOT_PC
  #define AOT_PC (code + 226)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_227
  label_225: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_227;
  }

  // 226	[760]	LOADFALSE	12
  #undef  AOT_PC
  #define AOT_PC (code + 227)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_228
  label_226: {
    aot_vmfetch(0x00000605);
    setbfvalue(s2v(ra));
  }

  // 227	[754]	FORLOOP  	19 27	; to 202
  #undef  AOT_PC
  #define AOT_PC (code + 228)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_229
  label_227: {
    aot_vmfetch(0x000d89c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_201; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_201; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 228	[763]	TEST     	12 0
  #undef  AOT_PC
  #define AOT_PC (code + 229)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_231
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_230
  label_228: {
    aot_vmfetch(0x00000642);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 229	[763]	JMP      	1	; to 232
  #undef  AOT_PC
  #define AOT_PC (code + 230)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_304
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_231
  label_229: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_231;
  }

  // 230	[764]	JMP      	73	; to 305
  #undef  AOT_PC
  #define AOT_PC (code + 231)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_232
  label_230: {
    aot_vmfetch(0x80002438);
    updatetrap(ci);
    goto label_304;
  }

  // 231	[766]	LOADFALSE	19
  #undef  AOT_PC
  #define AOT_PC (code + 232)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_233
  label_231: {
    aot_vmfetch(0x00000985);
    setbfvalue(s2v(ra));
  }

  // 232	[767]	GETTABUP 	20 0 49	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 233)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_234
  label_232: {
    aot_vmfetch(0x31000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 233	[767]	MOVE     	21 7
  #undef  AOT_PC
  #define AOT_PC (code + 234)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_235
  label_233: {
    aot_vmfetch(0x00070a80);
    setobjs2s(L, ra, RB(i));
  }

  // 234	[767]	CALL     	20 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 235)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_236
  label_234: {
    aot_vmfetch(0x05020a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 235	[767]	TFORPREP 	20 6	; to 243
  #undef  AOT_PC
  #define AOT_PC (code + 236)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_237
  label_235: {
    aot_vmfetch(0x00030a4b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_242;
  }

  // 236	[768]	GETI     	26 25 1
  #undef  AOT_PC
  #define AOT_PC (code + 237)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_238
  label_236: {
    aot_vmfetch(0x01190d0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 237	[768]	EQ       	26 17 0
  #undef  AOT_PC
  #define AOT_PC (code + 238)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_242
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_239
  label_237: {
    aot_vmfetch(0x00110d39);
    int cond;
    TValue *rb = vRB(i);
    Protect(cond = luaV_equalobj(L, s2v(ra), rb));
    docondjump();
  }

  // 238	[768]	JMP      	3	; to 243
  #undef  AOT_PC
  #define AOT_PC (code + 239)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_240
  label_238: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_242;
  }

  // 239	[769]	MOVE     	18 25
  #undef  AOT_PC
  #define AOT_PC (code + 240)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_241
  label_239: {
    aot_vmfetch(0x00190900);
    setobjs2s(L, ra, RB(i));
  }

  // 240	[770]	LOADTRUE 	19
  #undef  AOT_PC
  #define AOT_PC (code + 241)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_244
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_242
  label_240: {
    aot_vmfetch(0x00000987);
    setbtvalue(s2v(ra));
  }

  // 241	[771]	JMP      	2	; to 245
  #undef  AOT_PC
  #define AOT_PC (code + 242)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_243
  label_241: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_244;
  }

  // 242	[767]	TFORCALL 	20 2
  #undef  AOT_PC
  #define AOT_PC (code + 243)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_244
  label_242: {
    aot_vmfetch(0x02000a4c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 243	[767]	TFORLOOP 	20 8	; to 237
  #undef  AOT_PC
  #define AOT_PC (code + 244)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_245
  label_243: {
    aot_vmfetch(0x00040a4d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_236; /* jump back */
    }
  }

  // 244	[773]	CLOSE    	20
  #undef  AOT_PC
  #define AOT_PC (code + 245)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_246
  label_244: {
    aot_vmfetch(0x00000a36);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 245	[774]	TEST     	19 1
  #undef  AOT_PC
  #define AOT_PC (code + 246)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_251
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_247
  label_245: {
    aot_vmfetch(0x000089c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 246	[774]	JMP      	4	; to 252
  #undef  AOT_PC
  #define AOT_PC (code + 247)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_248
  label_246: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_251;
  }

  // 247	[775]	TEST     	11 1
  #undef  AOT_PC
  #define AOT_PC (code + 248)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_304
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_249
  label_247: {
    aot_vmfetch(0x000085c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 248	[775]	JMP      	55	; to 305
  #undef  AOT_PC
  #define AOT_PC (code + 249)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_250
  label_248: {
    aot_vmfetch(0x80001b38);
    updatetrap(ci);
    goto label_304;
  }

  // 249	[776]	SETTABLE 	9 17 52k	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 250)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_304
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_251
  label_249: {
    aot_vmfetch(0x34118490);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 250	[778]	JMP      	53	; to 305
  #undef  AOT_PC
  #define AOT_PC (code + 251)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_252
  label_250: {
    aot_vmfetch(0x80001a38);
    updatetrap(ci);
    goto label_304;
  }

  // 251	[790]	CLOSURE  	20 2	; 0x7fe07710ee70
  #undef  AOT_PC
  #define AOT_PC (code + 252)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_253
  label_251: {
    aot_vmfetch(0x00010a4f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 252	[782]	SETTABUP 	0 53 20	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 253)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_254
  label_252: {
    aot_vmfetch(0x1435000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 253	[793]	GETI     	20 18 2
  #undef  AOT_PC
  #define AOT_PC (code + 254)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_255
  label_253: {
    aot_vmfetch(0x02120a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 254	[793]	SELF     	20 20 20k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 255)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_256
  label_254: {
    aot_vmfetch(0x14148a14);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 255	[793]	LOADI    	22 2
  #undef  AOT_PC
  #define AOT_PC (code + 256)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_257
  label_255: {
    aot_vmfetch(0x80008b01);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 256	[793]	LOADI    	23 2
  #undef  AOT_PC
  #define AOT_PC (code + 257)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_258
  label_256: {
    aot_vmfetch(0x80008b81);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 257	[793]	CALL     	20 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 258)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_259
  label_257: {
    aot_vmfetch(0x02040a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 258	[793]	EQK      	20 54 0	; "!"
  #undef  AOT_PC
  #define AOT_PC (code + 259)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_263
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_260
  label_258: {
    aot_vmfetch(0x00360a3c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 259	[793]	JMP      	3	; to 264
  #undef  AOT_PC
  #define AOT_PC (code + 260)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_261
  label_259: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_263;
  }

  // 260	[794]	GETI     	20 18 1
  #undef  AOT_PC
  #define AOT_PC (code + 261)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_262
  label_260: {
    aot_vmfetch(0x01120a0d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 261	[794]	SETTABLE 	9 20 52k	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 262)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_263
  label_261: {
    aot_vmfetch(0x34148490);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 262	[795]	RETURN   	20 1 5	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 263)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_264
  label_262: {
    aot_vmfetch(0x05018a46);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 263	[798]	GETTABUP 	20 0 55	; _ENV "switch"
  #undef  AOT_PC
  #define AOT_PC (code + 264)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_265
  label_263: {
    aot_vmfetch(0x37000a0b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 264	[798]	GETI     	21 18 2
  #undef  AOT_PC
  #define AOT_PC (code + 265)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_266
  label_264: {
    aot_vmfetch(0x02120a8d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 265	[798]	SELF     	21 21 56k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 266)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_267
  label_265: {
    aot_vmfetch(0x38158a94);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 266	[798]	LOADK    	23 57	; "%S+"
  #undef  AOT_PC
  #define AOT_PC (code + 267)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_268
  label_266: {
    aot_vmfetch(0x001c8b83);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 267	[798]	CALL     	21 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 268)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_269
  label_267: {
    aot_vmfetch(0x02030ac4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 268	[798]	NEWTABLE 	22 5 0	; 0
  #undef  AOT_PC
  #define AOT_PC (code + 269)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_270
  label_268: {
    aot_vmfetch(0x00050b13);
    int b = GETARG_B(i);  /* log2(hash size) + 1 */
    int c = GETARG_C(i);  /* array size */
    Table *t;
    if (b > 0)
      b = 1 << (b - 1);  /* size is 2^(b - 1) */
    lua_assert((!TESTARG_k(i)) == (GETARG_Ax(0x00000052) == 0));
    if (TESTARG_k(i))
      c += GETARG_Ax(0x00000052) * (MAXARG_C + 1);
    /* skip extra argument */
    L->top = ra + 1;  /* correct top in case of emergency GC */
    t = luaH_new(L);  /* memory allocation */
    sethvalue2s(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, c, b);  /* idem */
    checkGC(L, ra + 1);
    goto AOT_SKIP1;
  }

  // 269	[798]	EXTRAARG 	0
  #undef  AOT_PC
  #define AOT_PC (code + 270)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_271
  label_269: {
    aot_vmfetch(0x00000052);
    lua_assert(0);
  }

  // 270	[813]	CLOSURE  	23 3	; 0x7fe07710e430
  #undef  AOT_PC
  #define AOT_PC (code + 271)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_272
  label_270: {
    aot_vmfetch(0x00018bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 271	[813]	SETFIELD 	22 58 23	; "#open"
  #undef  AOT_PC
  #define AOT_PC (code + 272)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_273
  label_271: {
    aot_vmfetch(0x173a0b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 272	[861]	CLOSURE  	23 4	; 0x7fe07710fad0
  #undef  AOT_PC
  #define AOT_PC (code + 273)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_274
  label_272: {
    aot_vmfetch(0x00020bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 273	[861]	SETFIELD 	22 59 23	; "#define"
  #undef  AOT_PC
  #define AOT_PC (code + 274)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_275
  label_273: {
    aot_vmfetch(0x173b0b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 274	[909]	CLOSURE  	23 5	; 0x7fe07710cfc0
  #undef  AOT_PC
  #define AOT_PC (code + 275)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_276
  label_274: {
    aot_vmfetch(0x00028bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 275	[909]	SETFIELD 	22 60 23	; "##line"
  #undef  AOT_PC
  #define AOT_PC (code + 276)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_277
  label_275: {
    aot_vmfetch(0x173c0b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 276	[959]	CLOSURE  	23 6	; 0x7fe0771108a0
  #undef  AOT_PC
  #define AOT_PC (code + 277)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_278
  label_276: {
    aot_vmfetch(0x00030bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 277	[959]	SETFIELD 	22 61 23	; "##include"
  #undef  AOT_PC
  #define AOT_PC (code + 278)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_279
  label_277: {
    aot_vmfetch(0x173d0b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 278	[996]	CLOSURE  	23 7	; 0x7fe077111080
  #undef  AOT_PC
  #define AOT_PC (code + 279)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_280
  label_278: {
    aot_vmfetch(0x00038bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 279	[996]	SETFIELD 	22 62 23	; "#if"
  #undef  AOT_PC
  #define AOT_PC (code + 280)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_281
  label_279: {
    aot_vmfetch(0x173e0b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 280	[1033]	CLOSURE  	23 8	; 0x7fe0771119d0
  #undef  AOT_PC
  #define AOT_PC (code + 281)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_282
  label_280: {
    aot_vmfetch(0x00040bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 281	[1033]	SETFIELD 	22 63 23	; "#ifdef"
  #undef  AOT_PC
  #define AOT_PC (code + 282)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_283
  label_281: {
    aot_vmfetch(0x173f0b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 282	[1070]	CLOSURE  	23 9	; 0x7fe077112270
  #undef  AOT_PC
  #define AOT_PC (code + 283)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_284
  label_282: {
    aot_vmfetch(0x00048bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 283	[1070]	SETFIELD 	22 64 23	; "#ifndef"
  #undef  AOT_PC
  #define AOT_PC (code + 284)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_285
  label_283: {
    aot_vmfetch(0x17400b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 284	[1110]	CLOSURE  	23 10	; 0x7fe077112a10
  #undef  AOT_PC
  #define AOT_PC (code + 285)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_286
  label_284: {
    aot_vmfetch(0x00050bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 285	[1110]	SETFIELD 	22 65 23	; "#elif"
  #undef  AOT_PC
  #define AOT_PC (code + 286)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_287
  label_285: {
    aot_vmfetch(0x17410b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 286	[1114]	CLOSURE  	23 11	; 0x7fe077113380
  #undef  AOT_PC
  #define AOT_PC (code + 287)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_288
  label_286: {
    aot_vmfetch(0x00058bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 287	[1114]	SETFIELD 	22 66 23	; "#else"
  #undef  AOT_PC
  #define AOT_PC (code + 288)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_289
  label_287: {
    aot_vmfetch(0x17420b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 288	[1119]	CLOSURE  	23 12	; 0x7fe077113410
  #undef  AOT_PC
  #define AOT_PC (code + 289)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_290
  label_288: {
    aot_vmfetch(0x00060bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 289	[1119]	SETFIELD 	22 67 23	; "#endif"
  #undef  AOT_PC
  #define AOT_PC (code + 290)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_291
  label_289: {
    aot_vmfetch(0x17430b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 290	[1129]	CLOSURE  	23 13	; 0x7fe0771134a0
  #undef  AOT_PC
  #define AOT_PC (code + 291)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_292
  label_290: {
    aot_vmfetch(0x00068bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 291	[1129]	SETFIELD 	22 68 23	; "#undef"
  #undef  AOT_PC
  #define AOT_PC (code + 292)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_293
  label_291: {
    aot_vmfetch(0x17440b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 292	[1135]	CLOSURE  	23 14	; 0x7fe077113630
  #undef  AOT_PC
  #define AOT_PC (code + 293)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_294
  label_292: {
    aot_vmfetch(0x00070bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 293	[1135]	SETFIELD 	22 69 23	; "#error"
  #undef  AOT_PC
  #define AOT_PC (code + 294)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_295
  label_293: {
    aot_vmfetch(0x17450b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 294	[1140]	CLOSURE  	23 15	; 0x7fe0771138c0
  #undef  AOT_PC
  #define AOT_PC (code + 295)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_296
  label_294: {
    aot_vmfetch(0x00078bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 295	[1140]	SETFIELD 	22 70 23	; "#warning"
  #undef  AOT_PC
  #define AOT_PC (code + 296)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_297
  label_295: {
    aot_vmfetch(0x17460b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 296	[1143]	CLOSURE  	23 16	; 0x7fe077113be0
  #undef  AOT_PC
  #define AOT_PC (code + 297)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_298
  label_296: {
    aot_vmfetch(0x00080bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 297	[1143]	SETFIELD 	22 71 23	; "#config"
  #undef  AOT_PC
  #define AOT_PC (code + 298)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_299
  label_297: {
    aot_vmfetch(0x17470b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 298	[1147]	CLOSURE  	23 17	; 0x7fe077113cb0
  #undef  AOT_PC
  #define AOT_PC (code + 299)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_300
  label_298: {
    aot_vmfetch(0x00088bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 299	[1147]	SETFIELD 	22 72 23	; "#ext"
  #undef  AOT_PC
  #define AOT_PC (code + 300)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_301
  label_299: {
    aot_vmfetch(0x17480b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 300	[1167]	CLOSURE  	23 18	; 0x7fe077113e00
  #undef  AOT_PC
  #define AOT_PC (code + 301)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_302
  label_300: {
    aot_vmfetch(0x00090bcf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 301	[1167]	SETFIELD 	22 73 23	; "default"
  #undef  AOT_PC
  #define AOT_PC (code + 302)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_303
  label_301: {
    aot_vmfetch(0x17490b12);
    const TValue *slot;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 302	[798]	CALL     	20 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 303)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_304
  label_302: {
    aot_vmfetch(0x01030a44);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 303	[1170]	CLOSE    	17
  #undef  AOT_PC
  #define AOT_PC (code + 304)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_305
  label_303: {
    aot_vmfetch(0x000008b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 304	[750]	TFORCALL 	13 2
  #undef  AOT_PC
  #define AOT_PC (code + 305)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_306
  label_304: {
    aot_vmfetch(0x020006cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 305	[750]	TFORLOOP 	13 109	; to 198
  #undef  AOT_PC
  #define AOT_PC (code + 306)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_307
  label_305: {
    aot_vmfetch(0x003686cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_197; /* jump back */
    }
  }

  // 306	[1173]	LEN      	13 10
  #undef  AOT_PC
  #define AOT_PC (code + 307)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_308
  label_306: {
    aot_vmfetch(0x000a06b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 307	[1173]	GTI      	13 0 0
  #undef  AOT_PC
  #define AOT_PC (code + 308)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_312
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_309
  label_307: {
    aot_vmfetch(0x007f06c0);
    op_orderI(L, l_gti, luai_numgt, 1, TM_LT);
  }

  // 308	[1173]	JMP      	3	; to 313
  #undef  AOT_PC
  #define AOT_PC (code + 309)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_310
  label_308: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_312;
  }

  // 309	[1174]	GETTABUP 	13 0 74	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 310)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_311
  label_309: {
    aot_vmfetch(0x4a00068b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 310	[1174]	LOADK    	14 75	; "Missing #endif(s)"
  #undef  AOT_PC
  #define AOT_PC (code + 311)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_312
  label_310: {
    aot_vmfetch(0x00258703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 311	[1174]	CALL     	13 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 312)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_313
  label_311: {
    aot_vmfetch(0x010206c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 312	[1176]	LOADNIL  	6 1	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 313)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_314
  label_312: {
    aot_vmfetch(0x00010308);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 313	[1178]	LOADNIL  	0 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 314)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_315
  label_313: {
    aot_vmfetch(0x00000008);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 314	[1179]	LOADK    	13 76	; "/* Preprocessed with the built in Cobalt preprocessor */\n\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 315)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_316
  label_314: {
    aot_vmfetch(0x00260683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 315	[1180]	GETTABUP 	14 0 77	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 316)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_317
  label_315: {
    aot_vmfetch(0x4d00070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 316	[1180]	MOVE     	15 9
  #undef  AOT_PC
  #define AOT_PC (code + 317)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_318
  label_316: {
    aot_vmfetch(0x00090780);
    setobjs2s(L, ra, RB(i));
  }

  // 317	[1180]	CALL     	14 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 318)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_319
  label_317: {
    aot_vmfetch(0x05020744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 318	[1180]	TFORPREP 	14 8	; to 328
  #undef  AOT_PC
  #define AOT_PC (code + 319)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_320
  label_318: {
    aot_vmfetch(0x0004074b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_327;
  }

  // 319	[1181]	EQK      	19 78 0	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 320)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_322
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_321
  label_319: {
    aot_vmfetch(0x004e09bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 320	[1181]	JMP      	1	; to 323
  #undef  AOT_PC
  #define AOT_PC (code + 321)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_327
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_322
  label_320: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_322;
  }

  // 321	[1182]	JMP      	5	; to 328
  #undef  AOT_PC
  #define AOT_PC (code + 322)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_323
  label_321: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_327;
  }

  // 322	[1184]	MOVE     	20 13
  #undef  AOT_PC
  #define AOT_PC (code + 323)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_324
  label_322: {
    aot_vmfetch(0x000d0a00);
    setobjs2s(L, ra, RB(i));
  }

  // 323	[1184]	MOVE     	21 19
  #undef  AOT_PC
  #define AOT_PC (code + 324)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_325
  label_323: {
    aot_vmfetch(0x00130a80);
    setobjs2s(L, ra, RB(i));
  }

  // 324	[1184]	LOADK    	22 79	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 325)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_326
  label_324: {
    aot_vmfetch(0x00278b03);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 325	[1184]	CONCAT   	20 3
  #undef  AOT_PC
  #define AOT_PC (code + 326)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_327
  label_325: {
    aot_vmfetch(0x00030a35);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 326	[1184]	MOVE     	13 20
  #undef  AOT_PC
  #define AOT_PC (code + 327)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_328
  label_326: {
    aot_vmfetch(0x00140680);
    setobjs2s(L, ra, RB(i));
  }

  // 327	[1180]	TFORCALL 	14 2
  #undef  AOT_PC
  #define AOT_PC (code + 328)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_329
  label_327: {
    aot_vmfetch(0x0200074c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 328	[1180]	TFORLOOP 	14 10	; to 320
  #undef  AOT_PC
  #define AOT_PC (code + 329)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_330
  label_328: {
    aot_vmfetch(0x0005074d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_319; /* jump back */
    }
  }

  // 329	[1185]	CLOSE    	14
  #undef  AOT_PC
  #define AOT_PC (code + 330)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_331
  label_329: {
    aot_vmfetch(0x00000736);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 330	[1186]	LOADNIL  	9 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 331)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_332
  label_330: {
    aot_vmfetch(0x00000488);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 331	[1187]	TEST     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 332)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_343
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_333
  label_331: {
    aot_vmfetch(0x00000142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 332	[1187]	JMP      	10	; to 344
  #undef  AOT_PC
  #define AOT_PC (code + 333)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_334
  label_332: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_343;
  }

  // 333	[1189]	GETTABUP 	14 0 80	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 334)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_335
  label_333: {
    aot_vmfetch(0x5000070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 334	[1189]	GETFIELD 	14 14 81	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 335)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_336
  label_334: {
    aot_vmfetch(0x510e070e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 335	[1189]	MOVE     	15 3
  #undef  AOT_PC
  #define AOT_PC (code + 336)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_337
  label_335: {
    aot_vmfetch(0x00030780);
    setobjs2s(L, ra, RB(i));
  }

  // 336	[1189]	LOADK    	16 82	; "w"
  #undef  AOT_PC
  #define AOT_PC (code + 337)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_338
  label_336: {
    aot_vmfetch(0x00290803);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 337	[1189]	CALL     	14 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 338)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_339
  label_337: {
    aot_vmfetch(0x02030744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 338	[1190]	SELF     	15 14 83k	; "write"
  #undef  AOT_PC
  #define AOT_PC (code + 339)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_340
  label_338: {
    aot_vmfetch(0x530e8794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 339	[1190]	MOVE     	17 13
  #undef  AOT_PC
  #define AOT_PC (code + 340)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_341
  label_339: {
    aot_vmfetch(0x000d0880);
    setobjs2s(L, ra, RB(i));
  }

  // 340	[1190]	CALL     	15 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 341)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_342
  label_340: {
    aot_vmfetch(0x010307c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 341	[1191]	SELF     	15 14 84k	; "close"
  #undef  AOT_PC
  #define AOT_PC (code + 342)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_343
  label_341: {
    aot_vmfetch(0x540e8794);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 342	[1191]	CALL     	15 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 343)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_344
  label_342: {
    aot_vmfetch(0x010207c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 343	[1193]	GETTABUP 	14 0 85	; _ENV "collectgarbage"
  #undef  AOT_PC
  #define AOT_PC (code + 344)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_345
  label_343: {
    aot_vmfetch(0x5500070b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 344	[1193]	CALL     	14 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 345)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_346
  label_344: {
    aot_vmfetch(0x01010744);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 345	[1194]	RETURN   	13 2 5	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 346)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_345: {
    aot_vmfetch(0x050286c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 346	[1195]	RETURN   	14 1 5	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 347)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_346: {
    aot_vmfetch(0x05018746);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 666 - 673
static
CallInfo *magic_implementation_64(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
  }

  // 0	[667]	GETUPVAL 	0 0	; ogstr
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[667]	TEST     	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_12
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 2	[667]	JMP      	9	; to 13
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000438);
    updatetrap(ci);
    goto label_12;
  }

  // 3	[669]	GETTABUP 	0 1 0	; _ENV "filex"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0001000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[669]	GETFIELD 	0 0 1	; "join"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100000e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 5	[669]	GETTABUP 	1 1 2	; _ENV "filesystem"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0201008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[669]	GETFIELD 	1 1 3	; "currentdir"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 7	[669]	CALL     	1 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x020100c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[669]	GETUPVAL 	2 0	; ogstr
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 9	[669]	TAILCALL 	0 3 0	; 2 in
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00030045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b);  /* prepare call frame */
    return ci;
  }

  // 10	[669]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_22
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 11	[670]	JMP      	10	; to 23
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_22;
  }

  // 12	[671]	GETTABUP 	0 1 4	; _ENV "debug"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0401000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[671]	GETFIELD 	0 0 5	; "getinfo"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0500000e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 14	[671]	LOADI    	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80008081);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 15	[671]	LOADK    	2 6	; "S"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00030103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 16	[671]	CALL     	0 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x02030044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 17	[671]	GETFIELD 	0 0 7	; "source"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0700000e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 18	[671]	SELF     	0 0 8k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x08008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[671]	LOADI    	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x80008101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 20	[671]	TAILCALL 	0 3 0	; 2 in
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00030045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b);  /* prepare call frame */
    return ci;
  }

  // 21	[671]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_21: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 22	[673]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_22: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 721 - 749
static
CallInfo *magic_implementation_65(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
  }

  // 0	[722]	LOADK    	1 0	; "{"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 1	[723]	GETTABUP 	2 0 1	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0100010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 2	[723]	GETUPVAL 	3 1	; env
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[723]	CALL     	2 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x05020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 4	[723]	TFORPREP 	2 26	; to 32
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000d014b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_31;
  }

  // 5	[724]	GETTABUP 	8 0 2	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[724]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 7	[724]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[724]	EQK      	8 3 0	; "number"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_16
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0003043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 9	[724]	JMP      	6	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_16;
  }

  // 10	[725]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 11	[725]	MOVE     	9 7
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00070480);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[725]	LOADK    	10 4	; ","
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00020503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[725]	CONCAT   	8 3
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00030435);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 14	[725]	MOVE     	1 8
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_31
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00080080);
    setobjs2s(L, ra, RB(i));
  }

  // 15	[726]	JMP      	15	; to 32
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000738);
    updatetrap(ci);
    goto label_31;
  }

  // 16	[726]	GETTABUP 	8 0 2	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0200040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[726]	MOVE     	9 6
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00060480);
    setobjs2s(L, ra, RB(i));
  }

  // 18	[726]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[726]	EQK      	8 5 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_31
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0005043c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 20	[726]	JMP      	10	; to 32
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x800004b8);
    updatetrap(ci);
    goto label_31;
  }

  // 21	[727]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[727]	LOADK    	9 6	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x00030483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 23	[727]	MOVE     	10 6
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00060500);
    setobjs2s(L, ra, RB(i));
  }

  // 24	[727]	LOADK    	11 7	; "\": "
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00038583);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 25	[727]	GETTABUP 	12 0 8	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x0800060b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 26	[727]	MOVE     	13 7
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00070680);
    setobjs2s(L, ra, RB(i));
  }

  // 27	[727]	CALL     	12 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x02020644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 28	[727]	LOADK    	13 4	; ","
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00020683);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 29	[727]	CONCAT   	8 6
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00060435);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 30	[727]	MOVE     	1 8
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00080080);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[723]	TFORCALL 	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x0200014c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 32	[723]	TFORLOOP 	2 28	; to 6
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x000e014d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_05; /* jump back */
    }
  }

  // 33	[729]	CLOSE    	2
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x00000136);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 34	[730]	MOVE     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00010100);
    setobjs2s(L, ra, RB(i));
  }

  // 35	[730]	LOADK    	3 9	; "}"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x00048183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 36	[730]	CONCAT   	2 2
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00020135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 37	[730]	MOVE     	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00020080);
    setobjs2s(L, ra, RB(i));
  }

  // 38	[731]	GETTABUP 	2 0 10	; _ENV "loadstring"
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x0a00010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 39	[732]	LOADK    	3 11	; "// Cobalt execution environment: Ignore.\n            env = "
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00058183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 40	[732]	MOVE     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00010200);
    setobjs2s(L, ra, RB(i));
  }

  // 41	[748]	LOADK    	5 12	; ";\n            for (i, v in pairs(env)){\n                _ENV[i] = v\n            }\n            core = import(\"core\")\n            function defined(val){\n                // check if it is in env, if it return the value\n                if (env[val] != null && env[val] != false) {\n                    return env[val]\n                }else{\n                    if (jit == null){\n                        return macros(val)\n                    }else{\n                        warn(val..\" is not defined and C macros are not supported on the JIT compiler\")\n                    }\n                }\n            }"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x00060283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 42	[748]	MOVE     	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x00000300);
    setobjs2s(L, ra, RB(i));
  }

  // 43	[748]	CONCAT   	3 4
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x000401b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 44	[731]	TAILCALL 	2 2 0	; 1 in
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x00028145);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b);  /* prepare call frame */
    return ci;
  }

  // 45	[748]	RETURN   	2 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_45: {
    aot_vmfetch(0x00008146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 46	[749]	RETURN   	2 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_46: {
    aot_vmfetch(0x00018146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 782 - 790
static
CallInfo *magic_implementation_66(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
  }

  // 0	[783]	GETTABUP 	1 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[783]	LOADK    	2 1	; "\027[1;31mPreprocessor error:\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[783]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[784]	GETTABUP 	1 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 4	[784]	LOADK    	2 2	; "\027[1;31mError with the '"
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[784]	GETUPVAL 	3 1	; v
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[784]	GETI     	3 3 2
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0203018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 7	[784]	LOADK    	4 3	; "' preprocessor command.\027[0m\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00018203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 8	[784]	CONCAT   	2 3
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00030135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 9	[784]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 10	[785]	TEST     	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_18
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00000042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 11	[785]	JMP      	6	; to 19
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_18;
  }

  // 12	[786]	GETTABUP 	1 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[786]	LOADK    	2 4	; "\027[1;31m"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00020103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 14	[786]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 15	[786]	LOADK    	4 5	; "\027[0m\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00028203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 16	[786]	CONCAT   	2 3
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00030135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 17	[786]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[788]	GETTABUP 	1 0 0	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 19	[788]	LOADK    	2 6	; "\027[1;31mStopping preprocessor.\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00030103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 20	[788]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 21	[789]	GETTABUP 	1 0 7	; _ENV "os"
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x0700008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 22	[789]	GETFIELD 	1 1 8	; "exit"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0801008e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 23	[789]	CALL     	1 1 1	; 0 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_23: {
    aot_vmfetch(0x010100c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[790]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_24: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 799 - 813
static
CallInfo *magic_implementation_67(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
  }

  // 0	[804]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[804]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[804]	SELF     	0 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[804]	LOADK    	2 1	; "#open "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[804]	LOADK    	3 2	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[804]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[805]	GETUPVAL 	1 1	; env
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[805]	GETTABLE 	1 1 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0001008c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[806]	EQK      	1 3 0	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_16
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x000300bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 9	[806]	JMP      	6	; to 17
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_16;
  }

  // 10	[807]	GETTABUP 	2 2 4	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0402010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 11	[807]	LOADK    	3 5	; "Macro '"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00028183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 12	[807]	MOVE     	4 0
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00000200);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[807]	LOADK    	5 6	; "' is not defined"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00030283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 14	[807]	CONCAT   	3 3
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x000301b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 15	[807]	CALL     	2 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x01020144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[809]	GETUPVAL 	2 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 17	[809]	GETI     	3 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0102018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 18	[809]	GETUPVAL 	2 3	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x00030109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 19	[809]	LOADK    	4 7	; "var "
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00038203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 20	[809]	GETTABUP 	5 2 8	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x0802028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 21	[809]	MOVE     	6 0
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00000300);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[809]	CALL     	5 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x020202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 23	[809]	LOADK    	6 9	; " = "
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00048303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 24	[809]	GETTABUP 	7 2 10	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0a02038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 25	[809]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 26	[809]	CALL     	7 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x020203c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 27	[809]	EQK      	7 11 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000b03bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 28	[809]	JMP      	13	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_42;
  }

  // 29	[809]	GETUPVAL 	7 4	; str
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00040389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 30	[809]	SELF     	7 7 12k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x0c078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 31	[809]	LOADI    	9 1
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x80000481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 32	[809]	LOADI    	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x80000501);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 33	[809]	CALL     	7 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x020403c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 34	[809]	EQK      	7 13 0	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x000d03bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 35	[809]	JMP      	6	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_42;
  }

  // 36	[809]	GETUPVAL 	7 4	; str
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00040389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 37	[809]	SELF     	7 7 12k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x0c078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 38	[809]	LOADI    	9 -1
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x7fff0481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 39	[809]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 40	[809]	EQK      	7 13 1	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_55
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x000d83bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 41	[809]	JMP      	13	; to 56
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_55;
  }

  // 42	[809]	GETUPVAL 	7 4	; str
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x00040389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 43	[809]	SELF     	7 7 12k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0c078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 44	[809]	LOADI    	9 1
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x80000481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 45	[809]	LOADI    	10 1
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x80000501);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 46	[809]	CALL     	7 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x020403c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 47	[809]	EQK      	7 14 0	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_60
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x000e03bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 48	[809]	JMP      	11	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x80000538);
    updatetrap(ci);
    goto label_60;
  }

  // 49	[809]	GETUPVAL 	7 4	; str
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00040389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 50	[809]	SELF     	7 7 12k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0c078394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 51	[809]	LOADI    	9 -1
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x7fff0481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 52	[809]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 53	[809]	EQK      	7 14 0	; "'"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_60
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x000e03bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 54	[809]	JMP      	5	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_60;
  }

  // 55	[809]	LOADK    	7 13	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x00068383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 56	[809]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 57	[809]	LOADK    	9 13	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00068483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 58	[809]	CONCAT   	7 3
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_64
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x000303b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 59	[809]	JMP      	4	; to 65
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_64;
  }

  // 60	[809]	GETTABUP 	8 2 8	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x0802040b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 61	[809]	MOVE     	9 1
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x00010480);
    setobjs2s(L, ra, RB(i));
  }

  // 62	[809]	CALL     	8 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x02020444);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 63	[809]	MOVE     	7 8
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x00080380);
    setobjs2s(L, ra, RB(i));
  }

  // 64	[809]	CONCAT   	4 4
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x00040235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 65	[809]	SETTABLE 	2 3 4
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x04030110);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 66	[812]	LOADNIL  	2 1	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x00010108);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 67	[812]	MOVE     	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x00030080);
    setobjs2s(L, ra, RB(i));
  }

  // 68	[812]	MOVE     	0 2
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_68: {
    aot_vmfetch(0x00020000);
    setobjs2s(L, ra, RB(i));
  }

  // 69	[813]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_69: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 814 - 861
static
CallInfo *magic_implementation_68(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
    case 117: goto label_117;
    case 118: goto label_118;
    case 119: goto label_119;
    case 120: goto label_120;
    case 121: goto label_121;
    case 122: goto label_122;
    case 123: goto label_123;
    case 124: goto label_124;
    case 125: goto label_125;
    case 126: goto label_126;
    case 127: goto label_127;
    case 128: goto label_128;
    case 129: goto label_129;
    case 130: goto label_130;
    case 131: goto label_131;
  }

  // 0	[816]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[816]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[816]	SELF     	0 0 0k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[816]	LOADK    	2 1	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[816]	CALL     	0 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02030044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[818]	GETI     	1 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 6	[819]	GETTABUP 	2 1 2	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0201010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[819]	GETFIELD 	2 2 3	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0302010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 8	[819]	MOVE     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010180);
    setobjs2s(L, ra, RB(i));
  }

  // 9	[819]	LOADI    	4 -1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x7fff0201);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 10	[819]	CALL     	2 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x02030144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 11	[819]	EQK      	2 4 0	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_88
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0004013c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 12	[819]	JMP      	75	; to 89
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x80002538);
    updatetrap(ci);
    goto label_88;
  }

  // 13	[826]	GETTABUP 	2 1 2	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0201010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 14	[826]	GETFIELD 	2 2 0	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0002010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[826]	GETUPVAL 	3 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 16	[826]	GETI     	3 3 2
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0203018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 17	[826]	LOADK    	4 1	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00008203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 18	[826]	CALL     	2 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x02030144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 19	[827]	GETI     	3 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0202018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 20	[827]	SELF     	3 3 0k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00038194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 21	[827]	LOADK    	5 5	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00028283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 22	[827]	CALL     	3 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x020301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 23	[827]	GETI     	3 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x0103018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 24	[828]	GETI     	4 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0202020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 25	[828]	SELF     	4 4 0k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00048214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 26	[828]	LOADK    	6 5	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00028303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 27	[828]	CALL     	4 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x02030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 28	[828]	GETI     	4 4 2
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x0204020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 29	[828]	SELF     	4 4 6k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x06048214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 30	[828]	LOADK    	6 7	; "%)"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00038303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 31	[828]	LOADK    	7 8	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x00040383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 32	[828]	CALL     	4 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x02040244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 33	[828]	SELF     	4 4 0k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x00048214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 34	[828]	LOADK    	6 9	; ","
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x00048303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 35	[828]	CALL     	4 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x02030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 36	[829]	GETI     	5 2 3
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x0302028d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 37	[830]	LOADI    	6 4
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x80018301);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 38	[830]	LEN      	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x000203b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 39	[830]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 40	[830]	FORPREP  	6 5	; to 47
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x0002834a);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_47; /* skip the loop */
  }

  // 41	[831]	MOVE     	10 5
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x00050500);
    setobjs2s(L, ra, RB(i));
  }

  // 42	[831]	LOADK    	11 1	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x00008583);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 43	[831]	GETTABLE 	12 2 9
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0902060c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 44	[831]	CONCAT   	10 3
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x00030535);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 45	[831]	MOVE     	5 10
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000a0280);
    setobjs2s(L, ra, RB(i));
  }

  // 46	[830]	FORLOOP  	6 6	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x00030349);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_41; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_41; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 47	[833]	GETTABUP 	6 1 10	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x0a01030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 48	[833]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 49	[833]	CALL     	6 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x05020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 50	[833]	TFORPREP 	6 5	; to 57
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0002834b);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_56;
  }

  // 51	[834]	SELF     	12 11 6k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x060b8614);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 52	[834]	LOADK    	14 1	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x00008703);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 53	[834]	LOADK    	15 8	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00040783);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 54	[834]	CALL     	12 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x02040644);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 55	[834]	SETTABLE 	4 10 12
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x0c0a0210);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 56	[833]	TFORCALL 	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x0200034c);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 57	[833]	TFORLOOP 	6 7	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x0003834d);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_51; /* jump back */
    }
  }

  // 58	[835]	CLOSE    	6
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00000336);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 59	[837]	LOADK    	6 11	; "function("
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x00058303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 60	[837]	GETTABUP 	7 1 12	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x0c01038b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 61	[837]	GETFIELD 	7 7 13	; "concat"
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x0d07038e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 62	[837]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 63	[837]	LOADK    	9 9	; ","
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x00048483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 64	[837]	CALL     	7 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x020303c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 65	[837]	LOADK    	8 14	; "){ return "
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x00070403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 66	[837]	MOVE     	9 5
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x00050480);
    setobjs2s(L, ra, RB(i));
  }

  // 67	[837]	LOADK    	10 15	; "; }"
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x00078503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 68	[837]	CONCAT   	6 5
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x00050335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 69	[838]	LOADK    	7 16	; "var "
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x00080383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 70	[838]	MOVE     	8 3
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x00030400);
    setobjs2s(L, ra, RB(i));
  }

  // 71	[838]	LOADK    	9 17	; " = "
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x00088483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 72	[838]	MOVE     	10 6
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x00060500);
    setobjs2s(L, ra, RB(i));
  }

  // 73	[838]	CONCAT   	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x000403b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 74	[841]	GETUPVAL 	8 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x00000409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 75	[841]	GETI     	9 8 1
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x0108048d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 76	[841]	GETUPVAL 	8 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x00020409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 77	[841]	SETTABLE 	8 9 7
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x07090410);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 78	[842]	GETUPVAL 	8 3	; env
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x00030409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 79	[842]	SETTABLE 	8 1 6
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x06010410);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 80	[845]	LOADNIL  	8 5	; 6 out
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x00050408);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 81	[845]	MOVE     	5 13
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x000d0280);
    setobjs2s(L, ra, RB(i));
  }

  // 82	[845]	MOVE     	4 12
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x000c0200);
    setobjs2s(L, ra, RB(i));
  }

  // 83	[845]	MOVE     	7 11
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x000b0380);
    setobjs2s(L, ra, RB(i));
  }

  // 84	[845]	MOVE     	6 10
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x000a0300);
    setobjs2s(L, ra, RB(i));
  }

  // 85	[845]	MOVE     	3 9
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x00090180);
    setobjs2s(L, ra, RB(i));
  }

  // 86	[845]	MOVE     	2 8
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_131
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x00080100);
    setobjs2s(L, ra, RB(i));
  }

  // 87	[846]	JMP      	43	; to 132
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x80001538);
    updatetrap(ci);
    goto label_131;
  }

  // 88	[848]	LOADNIL  	2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x00000108);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 89	[849]	GETTABUP 	3 1 18	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x1201018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 90	[849]	LOADK    	4 19	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x00098203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 91	[849]	GETI     	5 0 3
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x0300028d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 92	[849]	CONCAT   	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x00020235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 93	[849]	TEST     	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_96
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x00008242);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 94	[849]	JMP      	1	; to 97
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_96;
  }

  // 95	[849]	LOADK    	4 20	; "false"
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x000a0203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 96	[849]	CALL     	3 2 3	; 1 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x030201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 97	[850]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_103
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 98	[850]	JMP      	4	; to 104
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_103;
  }

  // 99	[851]	GETTABUP 	5 1 21	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x1501028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 100	[851]	MOVE     	6 4
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x00040300);
    setobjs2s(L, ra, RB(i));
  }

  // 101	[851]	CALL     	5 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_106
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x010202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 102	[852]	JMP      	3	; to 107
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_106;
  }

  // 103	[853]	MOVE     	5 3
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x00030280);
    setobjs2s(L, ra, RB(i));
  }

  // 104	[853]	CALL     	5 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x020102c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 105	[853]	MOVE     	2 5
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x00050100);
    setobjs2s(L, ra, RB(i));
  }

  // 106	[856]	GETUPVAL 	5 3	; env
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x00030289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 107	[856]	SETTABLE 	5 1 2
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x02010290);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 108	[858]	GETUPVAL 	5 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x00000289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 109	[858]	GETI     	6 5 1
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x0105030d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 110	[858]	GETUPVAL 	5 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x00020289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 111	[858]	LOADK    	7 16	; "var "
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x00080383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 112	[858]	MOVE     	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x00010400);
    setobjs2s(L, ra, RB(i));
  }

  // 113	[858]	LOADK    	9 17	; " = "
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x00088483);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 114	[858]	GETTABUP 	10 1 22	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x1601050b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 115	[858]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_117
  label_115: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 116	[858]	CALL     	10 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_118
  label_116: {
    aot_vmfetch(0x02020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 117	[858]	EQK      	10 2 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 118)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_124
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_119
  label_117: {
    aot_vmfetch(0x0002053c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 118	[858]	JMP      	5	; to 125
  #undef  AOT_PC
  #define AOT_PC (code + 119)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_120
  label_118: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_124;
  }

  // 119	[858]	LOADK    	10 23	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 120)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_121
  label_119: {
    aot_vmfetch(0x000b8503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 120	[858]	MOVE     	11 2
  #undef  AOT_PC
  #define AOT_PC (code + 121)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_122
  label_120: {
    aot_vmfetch(0x00020580);
    setobjs2s(L, ra, RB(i));
  }

  // 121	[858]	LOADK    	12 23	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 122)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_123
  label_121: {
    aot_vmfetch(0x000b8603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 122	[858]	CONCAT   	10 3
  #undef  AOT_PC
  #define AOT_PC (code + 123)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_128
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_124
  label_122: {
    aot_vmfetch(0x00030535);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 123	[858]	JMP      	4	; to 129
  #undef  AOT_PC
  #define AOT_PC (code + 124)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_125
  label_123: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_128;
  }

  // 124	[858]	GETTABUP 	11 1 24	; _ENV "tostring"
  #undef  AOT_PC
  #define AOT_PC (code + 125)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_126
  label_124: {
    aot_vmfetch(0x1801058b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 125	[858]	MOVE     	12 2
  #undef  AOT_PC
  #define AOT_PC (code + 126)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_127
  label_125: {
    aot_vmfetch(0x00020600);
    setobjs2s(L, ra, RB(i));
  }

  // 126	[858]	CALL     	11 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 127)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_128
  label_126: {
    aot_vmfetch(0x020205c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 127	[858]	MOVE     	10 11
  #undef  AOT_PC
  #define AOT_PC (code + 128)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_129
  label_127: {
    aot_vmfetch(0x000b0500);
    setobjs2s(L, ra, RB(i));
  }

  // 128	[858]	CONCAT   	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 129)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_130
  label_128: {
    aot_vmfetch(0x000403b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 129	[858]	SETTABLE 	5 6 7
  #undef  AOT_PC
  #define AOT_PC (code + 130)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_131
  label_129: {
    aot_vmfetch(0x07060290);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 130	[859]	RETURN   	5 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 131)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_130: {
    aot_vmfetch(0x000182c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 131	[861]	RETURN   	2 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 132)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_131: {
    aot_vmfetch(0x00018146);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 862 - 909
static
CallInfo *magic_implementation_69(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
  }

  // 0	[868]	GETTABUP 	0 0 0	; _ENV "warn"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[868]	LOADK    	1 1	; "Using #line is not recommended, Use import() instead"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[868]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[869]	GETUPVAL 	0 1	; v
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00010009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[869]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 5	[869]	SELF     	0 0 2k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 6	[869]	LOADK    	2 3	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[869]	CALL     	0 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x02030044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[870]	GETI     	1 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0200008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 9	[871]	LOADNIL  	2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000108);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 10	[872]	GETI     	3 0 3
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0300018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 11	[872]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_17
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 12	[872]	JMP      	4	; to 18
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_17;
  }

  // 13	[873]	GETTABUP 	3 0 4	; _ENV "getname"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0400018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 14	[873]	CALL     	3 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x020101c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 15	[873]	MOVE     	2 3
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00030100);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[874]	JMP      	7	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_24;
  }

  // 17	[875]	GETTABUP 	3 0 5	; _ENV "string"
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0500018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 18	[875]	GETFIELD 	3 3 6	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0603018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[875]	GETI     	4 0 3
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x0300020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 20	[875]	LOADI    	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x80008281);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 21	[875]	LOADI    	6 -2
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x7ffe8301);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 22	[875]	CALL     	3 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x020401c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 23	[875]	MOVE     	2 3
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00030100);
    setobjs2s(L, ra, RB(i));
  }

  // 24	[877]	GETTABUP 	3 0 7	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x0700018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 25	[877]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 26	[877]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 27	[878]	GETTABUP 	3 0 8	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0800018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 28	[878]	GETFIELD 	3 3 9	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x0903018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 29	[878]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 30	[878]	CALL     	3 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x020201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 31	[879]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_57
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 32	[879]	JMP      	24	; to 58
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x80000bb8);
    updatetrap(ci);
    goto label_57;
  }

  // 33	[880]	GETTABUP 	4 0 4	; _ENV "getname"
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x0400020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 34	[880]	CALL     	4 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x02010244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 35	[881]	SELF     	5 4 10k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x0a048294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 36	[881]	LOADK    	7 11	; "(.*/)"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00058383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 37	[881]	CALL     	5 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x020302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 38	[882]	EQK      	5 12 0	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_41
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x000c02bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 39	[882]	JMP      	1	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_41;
  }

  // 40	[883]	LOADK    	5 13	; "./"
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x00068283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 41	[885]	GETTABUP 	6 0 8	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x0800030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 42	[885]	GETFIELD 	6 6 9	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0906030e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 43	[885]	MOVE     	7 5
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x00050380);
    setobjs2s(L, ra, RB(i));
  }

  // 44	[885]	MOVE     	8 2
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x00020400);
    setobjs2s(L, ra, RB(i));
  }

  // 45	[885]	CONCAT   	7 2
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x000203b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 46	[885]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 47	[885]	MOVE     	3 6
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00060180);
    setobjs2s(L, ra, RB(i));
  }

  // 48	[886]	TEST     	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_57
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x000081c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 49	[886]	JMP      	7	; to 58
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_57;
  }

  // 50	[887]	GETTABUP 	6 0 14	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0e00030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 51	[887]	LOADK    	7 15	; "File '"
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00078383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 52	[887]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 53	[887]	MOVE     	9 2
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00020480);
    setobjs2s(L, ra, RB(i));
  }

  // 54	[887]	LOADK    	10 16	; "' not found"
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x00080503);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 55	[887]	CONCAT   	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x000403b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 56	[887]	CALL     	6 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x01020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 57	[891]	SELF     	4 3 17k	; "read"
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x11038214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 58	[891]	LOADK    	6 18	; "*all"
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00090303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 59	[891]	CALL     	4 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x02030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 60	[892]	SELF     	5 3 19k	; "close"
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x13038294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 61	[892]	CALL     	5 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x010202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 62	[894]	GETTABUP 	5 0 20	; _ENV "process"
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x1400028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 63	[894]	MOVE     	6 4
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x00040300);
    setobjs2s(L, ra, RB(i));
  }

  // 64	[894]	LOADNIL  	7 1	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x00010388);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 65	[894]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 66	[894]	MOVE     	4 5
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x00050200);
    setobjs2s(L, ra, RB(i));
  }

  // 67	[896]	SELF     	5 4 2k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x02048294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 68	[896]	LOADK    	7 21	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x000a8383);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 69	[896]	CALL     	5 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x020302c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 70	[896]	MOVE     	0 5
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x00050000);
    setobjs2s(L, ra, RB(i));
  }

  // 71	[897]	LOADK    	5 22	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x000b0283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 72	[898]	GETTABUP 	6 0 23	; _ENV "tonumber"
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x1700030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 73	[898]	MOVE     	7 1
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x00010380);
    setobjs2s(L, ra, RB(i));
  }

  // 74	[898]	CALL     	6 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x02020344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 75	[898]	LEN      	7 0
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x000003b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 76	[898]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 77	[898]	FORPREP  	6 5	; to 84
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x0002834a);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_84; /* skip the loop */
  }

  // 78	[899]	MOVE     	10 5
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x00050500);
    setobjs2s(L, ra, RB(i));
  }

  // 79	[899]	GETTABLE 	11 0 9
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x0900058c);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = vRC(i);
    lua_Unsigned n;
    if (ttisinteger(rc)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))
        : luaV_fastget(L, rb, rc, slot, luaH_get)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 80	[899]	LOADK    	12 21	; "\n"
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x000a8603);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 81	[899]	CONCAT   	10 3
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x00030535);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 82	[899]	MOVE     	5 10
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x000a0280);
    setobjs2s(L, ra, RB(i));
  }

  // 83	[898]	FORLOOP  	6 6	; to 79
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x00030349);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_78; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_78; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 84	[901]	GETUPVAL 	6 1	; v
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x00010309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 85	[901]	GETI     	7 6 1
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x0106038d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 86	[901]	GETUPVAL 	6 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x00020309);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 87	[901]	SETTABLE 	6 7 5
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x05070310);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 88	[904]	LOADNIL  	3 2	; 3 out
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x00020188);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 89	[907]	LOADNIL  	0 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x00000008);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 90	[908]	LOADNIL  	6 1	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x00010308);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 91	[908]	MOVE     	1 7
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x00070080);
    setobjs2s(L, ra, RB(i));
  }

  // 92	[908]	SETTABUP 	0 24 6	; _ENV "file"
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_92: {
    aot_vmfetch(0x0618000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 93	[909]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_93: {
    aot_vmfetch(0x00010347);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 910 - 959
static
CallInfo *magic_implementation_70(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
    case 70: goto label_70;
    case 71: goto label_71;
    case 72: goto label_72;
    case 73: goto label_73;
    case 74: goto label_74;
    case 75: goto label_75;
    case 76: goto label_76;
    case 77: goto label_77;
    case 78: goto label_78;
    case 79: goto label_79;
    case 80: goto label_80;
    case 81: goto label_81;
    case 82: goto label_82;
    case 83: goto label_83;
    case 84: goto label_84;
    case 85: goto label_85;
    case 86: goto label_86;
    case 87: goto label_87;
    case 88: goto label_88;
    case 89: goto label_89;
    case 90: goto label_90;
    case 91: goto label_91;
    case 92: goto label_92;
    case 93: goto label_93;
    case 94: goto label_94;
    case 95: goto label_95;
    case 96: goto label_96;
    case 97: goto label_97;
    case 98: goto label_98;
    case 99: goto label_99;
    case 100: goto label_100;
    case 101: goto label_101;
    case 102: goto label_102;
    case 103: goto label_103;
    case 104: goto label_104;
    case 105: goto label_105;
    case 106: goto label_106;
    case 107: goto label_107;
    case 108: goto label_108;
    case 109: goto label_109;
    case 110: goto label_110;
    case 111: goto label_111;
    case 112: goto label_112;
    case 113: goto label_113;
    case 114: goto label_114;
    case 115: goto label_115;
    case 116: goto label_116;
  }

  // 0	[911]	GETTABUP 	0 0 0	; _ENV "warn"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[911]	LOADK    	1 1	; "Using #include is not recommended, Use import() instead"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[911]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[913]	GETUPVAL 	0 1	; v
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00010009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[913]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 5	[913]	SELF     	0 0 2k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 6	[913]	LOADK    	2 3	; "#include \""
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[913]	LOADK    	3 4	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00020183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 8	[913]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[914]	MOVE     	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000080);
    setobjs2s(L, ra, RB(i));
  }

  // 10	[917]	LOADI    	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80000101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 11	[917]	LEN      	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x000001b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 12	[917]	LOADI    	4 1
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x80000201);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 13	[917]	FORPREP  	2 13	; to 28
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0006814a);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_28; /* skip the loop */
  }

  // 14	[918]	SELF     	6 0 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x05008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[918]	MOVE     	8 5
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00050400);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[918]	MOVE     	9 5
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00050480);
    setobjs2s(L, ra, RB(i));
  }

  // 17	[918]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[919]	EQK      	6 6 0	; "\""
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_27
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0006033c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 19	[919]	JMP      	7	; to 28
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_27;
  }

  // 20	[920]	SELF     	7 0 5k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x05008394);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 21	[920]	LOADI    	9 1
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x80000481);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 22	[920]	ADDI     	10 5 -1
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x7e050515);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 23	[920]	MMBINI   	5 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x078002af);
    Instruction pi = 0x7e050515;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 24	[920]	CALL     	7 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x020403c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 25	[920]	MOVE     	0 7
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_28
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x00070000);
    setobjs2s(L, ra, RB(i));
  }

  // 26	[921]	JMP      	1	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_28;
  }

  // 27	[917]	FORLOOP  	2 14	; to 15
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x00070149);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_14; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_14; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 28	[925]	LOADNIL  	2 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00000108);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 29	[926]	GETTABUP 	3 0 7	; _ENV "pairs"
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x0700018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 30	[926]	GETTABUP 	4 0 8	; _ENV "package"
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x0800020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 31	[926]	GETFIELD 	4 4 9	; "searchers"
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x0904020e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 32	[926]	CALL     	3 2 5	; 1 in 4 out
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x050201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 33	[926]	TFORPREP 	3 26	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x000d01cb);
    /* create to-be-closed upvalue (if needed) */
    halfProtect(luaF_newtbcupval(L, ra + 3));
    goto label_60;
  }

  // 34	[927]	GETTABUP 	9 0 10	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x0a00048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 35	[927]	GETFIELD 	9 9 11	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x0b09048e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 36	[927]	MOVE     	10 8
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x00080500);
    setobjs2s(L, ra, RB(i));
  }

  // 37	[927]	MOVE     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00000580);
    setobjs2s(L, ra, RB(i));
  }

  // 38	[927]	CALL     	10 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 39	[927]	CALL     	9 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x020004c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 40	[927]	LEN      	9 9
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x000904b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 41	[927]	EQI      	9 2 0
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_60
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x008104bd);
    int cond;
    int im = GETARG_sB(i);
    if (ttisinteger(s2v(ra)))
      cond = (ivalue(s2v(ra)) == im);
    else if (ttisfloat(s2v(ra)))
      cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));
    else
      cond = 0;  /* other types cannot be equal to a number */
    docondjump();
  }

  // 42	[927]	JMP      	17	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x80000838);
    updatetrap(ci);
    goto label_60;
  }

  // 43	[927]	GETTABUP 	9 0 10	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0a00048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 44	[927]	GETFIELD 	9 9 11	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x0b09048e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 45	[927]	MOVE     	10 8
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x00080500);
    setobjs2s(L, ra, RB(i));
  }

  // 46	[927]	MOVE     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x00000580);
    setobjs2s(L, ra, RB(i));
  }

  // 47	[927]	CALL     	10 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 48	[927]	CALL     	9 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x020004c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 49	[927]	GETI     	9 9 1
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x0109048d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 50	[927]	EQK      	9 12 1	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_60
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x000c84bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 51	[927]	JMP      	8	; to 61
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x800003b8);
    updatetrap(ci);
    goto label_60;
  }

  // 52	[928]	GETTABUP 	9 0 10	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x0a00048b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 53	[928]	GETFIELD 	9 9 11	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x0b09048e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 54	[928]	MOVE     	10 8
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x00080500);
    setobjs2s(L, ra, RB(i));
  }

  // 55	[928]	MOVE     	11 0
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x00000580);
    setobjs2s(L, ra, RB(i));
  }

  // 56	[928]	CALL     	10 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x00020544);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 57	[928]	CALL     	9 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x020004c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 58	[928]	MOVE     	2 9
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_62
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00090100);
    setobjs2s(L, ra, RB(i));
  }

  // 59	[929]	JMP      	2	; to 63
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x800000b8);
    updatetrap(ci);
    goto label_62;
  }

  // 60	[926]	TFORCALL 	3 2
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x020001cc);
    /* 'ra' has the iterator function, 'ra + 1' has the state,
       'ra + 2' has the control variable, and 'ra + 3' has the
       to-be-closed variable. The call will use the stack after
       these values (starting at 'ra + 4')
    */
    /* push function, state, and control variable */
    memcpy(ra + 4, ra, 3 * sizeof(*ra));
    L->top = ra + 4 + 3;
    ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */
    updatestack(ci);  /* stack may have changed */
  }

  // 61	[926]	TFORLOOP 	3 28	; to 35
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x000e01cd);
    if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */
      setobjs2s(L, ra + 2, ra + 4);  /* save control variable */
      goto label_34; /* jump back */
    }
  }

  // 62	[931]	CLOSE    	3
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x000001b6);
Protect(luaF_close(L, ra, LUA_OK, 1));
  }

  // 63	[932]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_88
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 64	[932]	JMP      	23	; to 89
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x80000b38);
    updatetrap(ci);
    goto label_88;
  }

  // 65	[933]	GETTABUP 	3 0 13	; _ENV "getname"
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x0d00018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 66	[933]	CALL     	3 1 2	; 0 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x020101c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 67	[934]	SELF     	4 3 14k	; "match"
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x0e038214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 68	[934]	LOADK    	6 15	; "(.*/)"
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_70
  label_68: {
    aot_vmfetch(0x00078303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 69	[934]	CALL     	4 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_71
  label_69: {
    aot_vmfetch(0x02030244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 70	[935]	EQK      	4 12 0	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 71)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_73
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_72
  label_70: {
    aot_vmfetch(0x000c023c);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 71	[935]	JMP      	1	; to 74
  #undef  AOT_PC
  #define AOT_PC (code + 72)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_73
  label_71: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_73;
  }

  // 72	[936]	LOADK    	4 16	; "./"
  #undef  AOT_PC
  #define AOT_PC (code + 73)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_74
  label_72: {
    aot_vmfetch(0x00080203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 73	[939]	GETTABUP 	5 0 17	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 74)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_75
  label_73: {
    aot_vmfetch(0x1100028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 74	[939]	GETFIELD 	5 5 18	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 75)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_76
  label_74: {
    aot_vmfetch(0x1205028e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 75	[939]	MOVE     	6 4
  #undef  AOT_PC
  #define AOT_PC (code + 76)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_77
  label_75: {
    aot_vmfetch(0x00040300);
    setobjs2s(L, ra, RB(i));
  }

  // 76	[939]	MOVE     	7 0
  #undef  AOT_PC
  #define AOT_PC (code + 77)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_78
  label_76: {
    aot_vmfetch(0x00000380);
    setobjs2s(L, ra, RB(i));
  }

  // 77	[939]	CONCAT   	6 2
  #undef  AOT_PC
  #define AOT_PC (code + 78)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_79
  label_77: {
    aot_vmfetch(0x00020335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 78	[939]	CALL     	5 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 79)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_80
  label_78: {
    aot_vmfetch(0x020202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 79	[939]	MOVE     	2 5
  #undef  AOT_PC
  #define AOT_PC (code + 80)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_81
  label_79: {
    aot_vmfetch(0x00050100);
    setobjs2s(L, ra, RB(i));
  }

  // 80	[940]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 81)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_88
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_82
  label_80: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 81	[940]	JMP      	6	; to 89
  #undef  AOT_PC
  #define AOT_PC (code + 82)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_83
  label_81: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_88;
  }

  // 82	[941]	GETTABUP 	5 0 19	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 83)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_84
  label_82: {
    aot_vmfetch(0x1300028b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 83	[941]	LOADK    	6 20	; "File '"
  #undef  AOT_PC
  #define AOT_PC (code + 84)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_85
  label_83: {
    aot_vmfetch(0x000a0303);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 84	[941]	MOVE     	7 0
  #undef  AOT_PC
  #define AOT_PC (code + 85)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_86
  label_84: {
    aot_vmfetch(0x00000380);
    setobjs2s(L, ra, RB(i));
  }

  // 85	[941]	LOADK    	8 21	; "' not found"
  #undef  AOT_PC
  #define AOT_PC (code + 86)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_87
  label_85: {
    aot_vmfetch(0x000a8403);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 86	[941]	CONCAT   	6 3
  #undef  AOT_PC
  #define AOT_PC (code + 87)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_88
  label_86: {
    aot_vmfetch(0x00030335);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 87	[941]	CALL     	5 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 88)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_89
  label_87: {
    aot_vmfetch(0x010202c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 88	[944]	GETTABUP 	3 0 22	; _ENV "type"
  #undef  AOT_PC
  #define AOT_PC (code + 89)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_90
  label_88: {
    aot_vmfetch(0x1600018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 89	[944]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 90)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_91
  label_89: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 90	[944]	CALL     	3 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 91)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_92
  label_90: {
    aot_vmfetch(0x020201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 91	[944]	EQK      	3 23 0	; "string"
  #undef  AOT_PC
  #define AOT_PC (code + 92)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_99
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_93
  label_91: {
    aot_vmfetch(0x001701bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 92	[944]	JMP      	6	; to 100
  #undef  AOT_PC
  #define AOT_PC (code + 93)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_94
  label_92: {
    aot_vmfetch(0x800002b8);
    updatetrap(ci);
    goto label_99;
  }

  // 93	[945]	GETTABUP 	3 0 17	; _ENV "io"
  #undef  AOT_PC
  #define AOT_PC (code + 94)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_95
  label_93: {
    aot_vmfetch(0x1100018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 94	[945]	GETFIELD 	3 3 18	; "open"
  #undef  AOT_PC
  #define AOT_PC (code + 95)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_96
  label_94: {
    aot_vmfetch(0x1203018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 95	[945]	GETI     	4 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 96)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_97
  label_95: {
    aot_vmfetch(0x0202020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 96	[945]	CALL     	3 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 97)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_98
  label_96: {
    aot_vmfetch(0x020201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 97	[945]	MOVE     	0 3
  #undef  AOT_PC
  #define AOT_PC (code + 98)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_100
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_99
  label_97: {
    aot_vmfetch(0x00030000);
    setobjs2s(L, ra, RB(i));
  }

  // 98	[946]	JMP      	1	; to 101
  #undef  AOT_PC
  #define AOT_PC (code + 99)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_100
  label_98: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_100;
  }

  // 99	[947]	MOVE     	0 2
  #undef  AOT_PC
  #define AOT_PC (code + 100)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_101
  label_99: {
    aot_vmfetch(0x00020000);
    setobjs2s(L, ra, RB(i));
  }

  // 100	[949]	SELF     	3 0 24k	; "read"
  #undef  AOT_PC
  #define AOT_PC (code + 101)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_102
  label_100: {
    aot_vmfetch(0x18008194);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 101	[949]	LOADK    	5 25	; "*all"
  #undef  AOT_PC
  #define AOT_PC (code + 102)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_103
  label_101: {
    aot_vmfetch(0x000c8283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 102	[949]	CALL     	3 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 103)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_104
  label_102: {
    aot_vmfetch(0x020301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 103	[950]	SELF     	4 0 26k	; "close"
  #undef  AOT_PC
  #define AOT_PC (code + 104)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_105
  label_103: {
    aot_vmfetch(0x1a008214);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 104	[950]	CALL     	4 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 105)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_106
  label_104: {
    aot_vmfetch(0x01020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 105	[954]	GETUPVAL 	4 1	; v
  #undef  AOT_PC
  #define AOT_PC (code + 106)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_107
  label_105: {
    aot_vmfetch(0x00010209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 106	[954]	GETI     	5 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 107)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_108
  label_106: {
    aot_vmfetch(0x0104028d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 107	[954]	GETUPVAL 	4 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 108)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_109
  label_107: {
    aot_vmfetch(0x00020209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 108	[954]	GETTABUP 	6 0 28	; _ENV "process"
  #undef  AOT_PC
  #define AOT_PC (code + 109)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_110
  label_108: {
    aot_vmfetch(0x1c00030b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 109	[954]	MOVE     	7 3
  #undef  AOT_PC
  #define AOT_PC (code + 110)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_111
  label_109: {
    aot_vmfetch(0x00030380);
    setobjs2s(L, ra, RB(i));
  }

  // 110	[954]	LOADNIL  	8 1	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 111)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_112
  label_110: {
    aot_vmfetch(0x00010408);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 111	[954]	CALL     	6 4 3	; 3 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 112)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_113
  label_111: {
    aot_vmfetch(0x03040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 112	[954]	SETTABUP 	0 27 7	; _ENV "newincludes"
  #undef  AOT_PC
  #define AOT_PC (code + 113)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_114
  label_112: {
    aot_vmfetch(0x071b000f);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = KB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rb);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      luaV_finishfastset(L, upval, slot, rc);
    }
    else
      Protect(luaV_finishset(L, upval, rb, rc, slot));
  }

  // 113	[954]	SETTABLE 	4 5 6
  #undef  AOT_PC
  #define AOT_PC (code + 114)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_115
  label_113: {
    aot_vmfetch(0x06050210);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 114	[956]	LOADNIL  	0 0	; 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 115)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_116
  label_114: {
    aot_vmfetch(0x00000008);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 115	[957]	LOADNIL  	2 1	; 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 116)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_115: {
    aot_vmfetch(0x00010108);
    int b = GETARG_B(i);
    do {
      setnilvalue(s2v(ra++));
    } while (b--);
  }

  // 116	[959]	RETURN   	4 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 117)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_116: {
    aot_vmfetch(0x00018246);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 960 - 996
static
CallInfo *magic_implementation_71(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
  }

  // 0	[965]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[965]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[965]	SELF     	0 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[965]	LOADK    	2 1	; "#if "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[965]	LOADK    	3 2	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[965]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[967]	LOADI    	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000081);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 7	[967]	LEN      	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000134);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 8	[967]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 9	[967]	FORPREP  	1 13	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_24; /* skip the loop */
  }

  // 10	[968]	SELF     	5 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x03008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[968]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[968]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[968]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[969]	EQK      	5 4 0	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x000402bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 15	[969]	JMP      	7	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_23;
  }

  // 16	[970]	SELF     	6 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 17	[970]	ADDI     	8 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x80040415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 18	[970]	MMBINI   	4 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0680022f);
    Instruction pi = 0x80040415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 19	[970]	LEN      	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000004b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 20	[970]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 21	[970]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[971]	JMP      	1	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_24;
  }

  // 23	[967]	FORLOOP  	1 14	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_10; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_10; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 24	[974]	LEN      	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x000000b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 25	[974]	LOADI    	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80000101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 26	[974]	LOADI    	3 -1
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x7fff0181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 27	[974]	FORPREP  	1 13	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_42; /* skip the loop */
  }

  // 28	[975]	SELF     	5 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x03008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 29	[975]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 30	[975]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[975]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[976]	EQK      	5 5 0	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_41
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x000502bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 33	[976]	JMP      	7	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_41;
  }

  // 34	[977]	SELF     	6 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 35	[977]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 36	[977]	ADDI     	9 4 -1
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x7e040495);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 37	[977]	MMBINI   	4 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x0780022f);
    Instruction pi = 0x7e040495;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 38	[977]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 39	[977]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 40	[978]	JMP      	1	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_42;
  }

  // 41	[974]	FORLOOP  	1 14	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_28; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_28; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 42	[982]	GETTABUP 	1 1 6	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0601008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[984]	CLOSURE  	2 0	; 0x7fe077111220
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0000014f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 44	[986]	CLOSURE  	3 1	; 0x7fe077111780
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x000081cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 45	[982]	CALL     	1 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x030300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 46	[987]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 47	[987]	JMP      	3	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_51;
  }

  // 48	[988]	GETTABUP 	3 1 7	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x0701018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 49	[988]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 50	[988]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 51	[991]	GETUPVAL 	3 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 52	[991]	GETI     	4 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x0103020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 53	[991]	GETUPVAL 	3 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00020189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 54	[991]	SETTABLE 	3 4 8k	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x08048190);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 55	[992]	GETTABUP 	3 1 9	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x0901018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 56	[992]	GETFIELD 	3 3 10	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x0a03018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 57	[992]	GETUPVAL 	4 3	; activeifs
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00030209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 58	[992]	MOVE     	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00020280);
    setobjs2s(L, ra, RB(i));
  }

  // 59	[992]	CALL     	3 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x010301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 60	[995]	SETUPVAL 	2 4	; run
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_60: {
    aot_vmfetch(0x0004010a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 61	[996]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_61: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 982 - 984
static
CallInfo *magic_implementation_72(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
  }

  // 0	[983]	GETTABUP 	0 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[983]	LOADK    	1 1	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[983]	GETUPVAL 	2 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[983]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 4	[983]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[983]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_20
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 6	[983]	JMP      	13	; to 21
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_20;
  }

  // 7	[983]	GETTABUP 	0 0 2	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0200000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[983]	LOADK    	1 3	; "Failed to check condition\n"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00018083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[983]	GETTABUP 	2 0 4	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 10	[983]	GETFIELD 	2 2 5	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0502010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[983]	GETTABUP 	3 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[983]	LOADK    	4 1	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00008203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[983]	GETUPVAL 	5 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00010289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 14	[983]	CONCAT   	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00020235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 15	[983]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[983]	CALL     	2 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x02000144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 17	[983]	GETI     	2 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0202010d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 18	[983]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 19	[983]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[983]	TAILCALL 	0 1 0	; 0 in
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00010045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b);  /* prepare call frame */
    return ci;
  }

  // 21	[983]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_21: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 22	[984]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_22: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 984 - 986
static
CallInfo *magic_implementation_73(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[985]	GETTABUP 	1 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[985]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[985]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[986]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 997 - 1033
static
CallInfo *magic_implementation_74(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
  }

  // 0	[1002]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1002]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[1002]	SELF     	0 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[1002]	LOADK    	2 1	; "#if "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1002]	LOADK    	3 2	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[1002]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[1004]	LOADI    	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000081);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 7	[1004]	LEN      	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000134);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 8	[1004]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 9	[1004]	FORPREP  	1 13	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_24; /* skip the loop */
  }

  // 10	[1005]	SELF     	5 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x03008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[1005]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[1005]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[1005]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[1006]	EQK      	5 4 0	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x000402bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 15	[1006]	JMP      	7	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_23;
  }

  // 16	[1007]	SELF     	6 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 17	[1007]	ADDI     	8 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x80040415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 18	[1007]	MMBINI   	4 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0680022f);
    Instruction pi = 0x80040415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 19	[1007]	LEN      	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000004b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 20	[1007]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 21	[1007]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[1008]	JMP      	1	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_24;
  }

  // 23	[1004]	FORLOOP  	1 14	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_10; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_10; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 24	[1011]	LEN      	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x000000b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 25	[1011]	LOADI    	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80000101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 26	[1011]	LOADI    	3 -1
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x7fff0181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 27	[1011]	FORPREP  	1 13	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_42; /* skip the loop */
  }

  // 28	[1012]	SELF     	5 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x03008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 29	[1012]	GETUPVAL 	7 1	; i
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00010389);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 30	[1012]	GETUPVAL 	8 1	; i
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00010409);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 31	[1012]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[1013]	EQK      	5 5 0	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_41
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x000502bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 33	[1013]	JMP      	7	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_41;
  }

  // 34	[1014]	SELF     	6 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 35	[1014]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 36	[1014]	ADDI     	9 4 -1
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x7e040495);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 37	[1014]	MMBINI   	4 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x0780022f);
    Instruction pi = 0x7e040495;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 38	[1014]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 39	[1014]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 40	[1015]	JMP      	1	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_42;
  }

  // 41	[1011]	FORLOOP  	1 14	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_28; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_28; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 42	[1019]	GETTABUP 	1 2 6	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0602008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[1021]	CLOSURE  	2 0	; 0x7fe077111a60
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0000014f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 44	[1023]	CLOSURE  	3 1	; 0x7fe077112060
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x000081cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 45	[1019]	CALL     	1 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x030300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 46	[1024]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 47	[1024]	JMP      	3	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_51;
  }

  // 48	[1025]	GETTABUP 	3 2 7	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x0702018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 49	[1025]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 50	[1025]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 51	[1028]	GETUPVAL 	3 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 52	[1028]	GETI     	4 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x0103020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 53	[1028]	GETUPVAL 	3 3	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00030189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 54	[1028]	SETTABLE 	3 4 8k	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x08048190);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 55	[1029]	GETTABUP 	3 2 9	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x0902018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 56	[1029]	GETFIELD 	3 3 10	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x0a03018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 57	[1029]	GETUPVAL 	4 4	; activeifs
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00040209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 58	[1029]	MOVE     	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00020280);
    setobjs2s(L, ra, RB(i));
  }

  // 59	[1029]	CALL     	3 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x010301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 60	[1032]	SETUPVAL 	2 5	; run
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_60: {
    aot_vmfetch(0x0005010a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 61	[1033]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_61: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1019 - 1021
static
CallInfo *magic_implementation_75(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
  }

  // 0	[1020]	GETTABUP 	0 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1020]	LOADK    	1 1	; "return defined(\""
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[1020]	GETUPVAL 	2 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[1020]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_06
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 4	[1020]	JMP      	1	; to 7
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_06;
  }

  // 5	[1020]	LOADK    	2 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 6	[1020]	LOADK    	3 3	; "\")"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[1020]	CONCAT   	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000300b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 8	[1020]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[1020]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_30
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 10	[1020]	JMP      	19	; to 31
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x80000938);
    updatetrap(ci);
    goto label_30;
  }

  // 11	[1020]	GETTABUP 	0 0 4	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0400000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[1020]	LOADK    	1 5	; "Failed to check condition\n"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00028083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[1020]	GETTABUP 	2 0 6	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0600010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 14	[1020]	GETFIELD 	2 2 7	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x0702010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 15	[1020]	GETTABUP 	3 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 16	[1020]	LOADK    	4 8	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00040203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 17	[1020]	GETUPVAL 	5 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x00010289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 18	[1020]	TEST     	5 1
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_21
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x000082c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 19	[1020]	JMP      	1	; to 22
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_21;
  }

  // 20	[1020]	LOADK    	5 2	; "null"
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00010283);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 21	[1020]	CONCAT   	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00020235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 22	[1020]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 23	[1020]	CALL     	2 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x02000144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 24	[1020]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_27
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 25	[1020]	JMP      	1	; to 28
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_27;
  }

  // 26	[1020]	LOADK    	2 9	; "Failed to error"
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00048103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 27	[1020]	GETI     	2 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0202010d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 28	[1020]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 29	[1020]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 30	[1020]	TAILCALL 	0 1 0	; 0 in
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00010045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b);  /* prepare call frame */
    return ci;
  }

  // 31	[1020]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_31: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 32	[1021]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_32: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1021 - 1023
static
CallInfo *magic_implementation_76(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1022]	GETTABUP 	1 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1022]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1022]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1023]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1034 - 1070
static
CallInfo *magic_implementation_77(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
  }

  // 0	[1039]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1039]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[1039]	SELF     	0 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[1039]	LOADK    	2 1	; "#if "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1039]	LOADK    	3 2	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[1039]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[1041]	LOADI    	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000081);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 7	[1041]	LEN      	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000134);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 8	[1041]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 9	[1041]	FORPREP  	1 13	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_24; /* skip the loop */
  }

  // 10	[1042]	SELF     	5 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x03008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[1042]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[1042]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 13	[1042]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[1043]	EQK      	5 4 0	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_23
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x000402bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 15	[1043]	JMP      	7	; to 24
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_23;
  }

  // 16	[1044]	SELF     	6 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 17	[1044]	ADDI     	8 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x80040415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 18	[1044]	MMBINI   	4 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0680022f);
    Instruction pi = 0x80040415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 19	[1044]	LEN      	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000004b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 20	[1044]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 21	[1044]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_24
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 22	[1045]	JMP      	1	; to 25
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_24;
  }

  // 23	[1041]	FORLOOP  	1 14	; to 11
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_10; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_10; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 24	[1048]	LEN      	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x000000b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 25	[1048]	LOADI    	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80000101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 26	[1048]	LOADI    	3 -1
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x7fff0181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 27	[1048]	FORPREP  	1 13	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_42; /* skip the loop */
  }

  // 28	[1049]	SELF     	5 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x03008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 29	[1049]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 30	[1049]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 31	[1049]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 32	[1050]	EQK      	5 5 0	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_41
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x000502bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 33	[1050]	JMP      	7	; to 42
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_41;
  }

  // 34	[1051]	SELF     	6 0 3k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x03008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 35	[1051]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 36	[1051]	ADDI     	9 4 -1
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x7e040495);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 37	[1051]	MMBINI   	4 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x0780022f);
    Instruction pi = 0x7e040495;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 38	[1051]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 39	[1051]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_42
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 40	[1052]	JMP      	1	; to 43
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_42;
  }

  // 41	[1048]	FORLOOP  	1 14	; to 29
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_28; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_28; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 42	[1056]	GETTABUP 	1 1 6	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x0601008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 43	[1058]	CLOSURE  	2 0	; 0x7fe0771123c0
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x0000014f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 44	[1060]	CLOSURE  	3 1	; 0x7fe077112840
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x000081cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 45	[1056]	CALL     	1 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x030300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 46	[1061]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_51
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 47	[1061]	JMP      	3	; to 52
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_51;
  }

  // 48	[1062]	GETTABUP 	3 1 7	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x0701018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 49	[1062]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 50	[1062]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 51	[1065]	GETUPVAL 	3 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x00000189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 52	[1065]	GETI     	4 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x0103020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 53	[1065]	GETUPVAL 	3 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x00020189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 54	[1065]	SETTABLE 	3 4 8k	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x08048190);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 55	[1066]	GETTABUP 	3 1 9	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x0901018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 56	[1066]	GETFIELD 	3 3 10	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x0a03018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 57	[1066]	GETUPVAL 	4 3	; activeifs
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00030209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 58	[1066]	MOVE     	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x00020280);
    setobjs2s(L, ra, RB(i));
  }

  // 59	[1066]	CALL     	3 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x010301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 60	[1069]	SETUPVAL 	2 4	; run
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_60: {
    aot_vmfetch(0x0004010a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 61	[1070]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_61: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1056 - 1058
static
CallInfo *magic_implementation_78(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
  }

  // 0	[1057]	GETTABUP 	0 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1057]	LOADK    	1 1	; "return !defined(\""
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[1057]	GETUPVAL 	2 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[1057]	LOADK    	3 2	; "\")"
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1057]	CONCAT   	1 3
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x000300b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 5	[1057]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[1057]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_21
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 7	[1057]	JMP      	13	; to 22
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_21;
  }

  // 8	[1057]	GETTABUP 	0 0 3	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x0300000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 9	[1057]	LOADK    	1 4	; "Failed to check condition\n"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00020083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 10	[1057]	GETTABUP 	2 0 5	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0500010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 11	[1057]	GETFIELD 	2 2 6	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0602010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 12	[1057]	GETTABUP 	3 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 13	[1057]	LOADK    	4 7	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00038203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 14	[1057]	GETUPVAL 	5 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00010289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 15	[1057]	CONCAT   	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00020235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 16	[1057]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 17	[1057]	CALL     	2 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x02000144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[1057]	GETI     	2 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0202010d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 19	[1057]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 20	[1057]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 21	[1057]	TAILCALL 	0 1 0	; 0 in
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x00010045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b);  /* prepare call frame */
    return ci;
  }

  // 22	[1057]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_22: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 23	[1058]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_23: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1058 - 1060
static
CallInfo *magic_implementation_79(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1059]	GETTABUP 	1 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1059]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1059]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1060]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1071 - 1110
static
CallInfo *magic_implementation_80(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
    case 31: goto label_31;
    case 32: goto label_32;
    case 33: goto label_33;
    case 34: goto label_34;
    case 35: goto label_35;
    case 36: goto label_36;
    case 37: goto label_37;
    case 38: goto label_38;
    case 39: goto label_39;
    case 40: goto label_40;
    case 41: goto label_41;
    case 42: goto label_42;
    case 43: goto label_43;
    case 44: goto label_44;
    case 45: goto label_45;
    case 46: goto label_46;
    case 47: goto label_47;
    case 48: goto label_48;
    case 49: goto label_49;
    case 50: goto label_50;
    case 51: goto label_51;
    case 52: goto label_52;
    case 53: goto label_53;
    case 54: goto label_54;
    case 55: goto label_55;
    case 56: goto label_56;
    case 57: goto label_57;
    case 58: goto label_58;
    case 59: goto label_59;
    case 60: goto label_60;
    case 61: goto label_61;
    case 62: goto label_62;
    case 63: goto label_63;
    case 64: goto label_64;
    case 65: goto label_65;
    case 66: goto label_66;
    case 67: goto label_67;
    case 68: goto label_68;
    case 69: goto label_69;
  }

  // 0	[1074]	GETUPVAL 	0 0	; run
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1074]	TEST     	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 2	[1074]	JMP      	5	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_08;
  }

  // 3	[1075]	GETUPVAL 	0 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00020009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[1075]	GETI     	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 5	[1075]	GETUPVAL 	0 1	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[1075]	SETTABLE 	0 1 0k	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00018010);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 7	[1076]	RETURN   	0 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00018046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[1079]	GETUPVAL 	0 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00020009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 9	[1079]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 10	[1079]	SELF     	0 0 1k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x01008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[1079]	LOADK    	2 2	; "#elif "
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00010103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 12	[1079]	LOADK    	3 3	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00018183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[1079]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 14	[1081]	LOADI    	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x80000081);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 15	[1081]	LEN      	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000134);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 16	[1081]	LOADI    	3 1
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x80000181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 17	[1081]	FORPREP  	1 13	; to 32
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_32; /* skip the loop */
  }

  // 18	[1082]	SELF     	5 0 4k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x04008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 19	[1082]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 20	[1082]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 21	[1082]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 22	[1083]	EQK      	5 5 0	; "("
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_31
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x000502bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 23	[1083]	JMP      	7	; to 32
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_31;
  }

  // 24	[1084]	SELF     	6 0 4k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x04008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 25	[1084]	ADDI     	8 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x80040415);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 26	[1084]	MMBINI   	4 1 6 0	; __add
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x0680022f);
    Instruction pi = 0x80040415;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 27	[1084]	LEN      	9 0
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x000004b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 28	[1084]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 29	[1084]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_32
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_31
  label_29: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 30	[1085]	JMP      	1	; to 33
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_32
  label_30: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_32;
  }

  // 31	[1081]	FORLOOP  	1 14	; to 19
  #undef  AOT_PC
  #define AOT_PC (code + 32)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_33
  label_31: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_18; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_18; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 32	[1088]	LEN      	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 33)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_34
  label_32: {
    aot_vmfetch(0x000000b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 33	[1088]	LOADI    	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 34)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_35
  label_33: {
    aot_vmfetch(0x80000101);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 34	[1088]	LOADI    	3 -1
  #undef  AOT_PC
  #define AOT_PC (code + 35)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_36
  label_34: {
    aot_vmfetch(0x7fff0181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 35	[1088]	FORPREP  	1 13	; to 50
  #undef  AOT_PC
  #define AOT_PC (code + 36)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_37
  label_35: {
    aot_vmfetch(0x000680ca);
    savestate(L, ci);  /* in case of errors */
    if (forprep(L, ra))
      goto label_50; /* skip the loop */
  }

  // 36	[1089]	SELF     	5 0 4k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 37)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_38
  label_36: {
    aot_vmfetch(0x04008294);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 37	[1089]	MOVE     	7 4
  #undef  AOT_PC
  #define AOT_PC (code + 38)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_39
  label_37: {
    aot_vmfetch(0x00040380);
    setobjs2s(L, ra, RB(i));
  }

  // 38	[1089]	MOVE     	8 4
  #undef  AOT_PC
  #define AOT_PC (code + 39)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_40
  label_38: {
    aot_vmfetch(0x00040400);
    setobjs2s(L, ra, RB(i));
  }

  // 39	[1089]	CALL     	5 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 40)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_41
  label_39: {
    aot_vmfetch(0x020402c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 40	[1090]	EQK      	5 6 0	; ")"
  #undef  AOT_PC
  #define AOT_PC (code + 41)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_49
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_42
  label_40: {
    aot_vmfetch(0x000602bc);
    TValue *rb = KB(i);
    /* basic types do not use '__eq'; we can use raw equality */
    int cond = luaV_equalobj(NULL, s2v(ra), rb);
    docondjump();
  }

  // 41	[1090]	JMP      	7	; to 50
  #undef  AOT_PC
  #define AOT_PC (code + 42)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_43
  label_41: {
    aot_vmfetch(0x80000338);
    updatetrap(ci);
    goto label_49;
  }

  // 42	[1091]	SELF     	6 0 4k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 43)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_44
  label_42: {
    aot_vmfetch(0x04008314);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 43	[1091]	LOADI    	8 1
  #undef  AOT_PC
  #define AOT_PC (code + 44)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_45
  label_43: {
    aot_vmfetch(0x80000401);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 44	[1091]	ADDI     	9 4 -1
  #undef  AOT_PC
  #define AOT_PC (code + 45)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_46
  label_44: {
    aot_vmfetch(0x7e040495);
    op_arithI(L, l_addi, luai_numadd);
  }

  // 45	[1091]	MMBINI   	4 1 7 0	; __sub
  #undef  AOT_PC
  #define AOT_PC (code + 46)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_47
  label_45: {
    aot_vmfetch(0x0780022f);
    Instruction pi = 0x7e040495;  /* original arith. expression */
    int imm = GETARG_sB(i);
    TMS tm = (TMS)GETARG_C(i);
    int flip = GETARG_k(i);
    StkId result = RA(pi);
    Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));
  }

  // 46	[1091]	CALL     	6 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 47)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_48
  label_46: {
    aot_vmfetch(0x02040344);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 47	[1091]	MOVE     	0 6
  #undef  AOT_PC
  #define AOT_PC (code + 48)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_50
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_49
  label_47: {
    aot_vmfetch(0x00060000);
    setobjs2s(L, ra, RB(i));
  }

  // 48	[1092]	JMP      	1	; to 51
  #undef  AOT_PC
  #define AOT_PC (code + 49)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_50
  label_48: {
    aot_vmfetch(0x80000038);
    updatetrap(ci);
    goto label_50;
  }

  // 49	[1088]	FORLOOP  	1 14	; to 37
  #undef  AOT_PC
  #define AOT_PC (code + 50)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_51
  label_49: {
    aot_vmfetch(0x000700c9);
    if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */
      lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
      if (count > 0) {  /* still more iterations? */
        lua_Integer step = ivalue(s2v(ra + 2));
        lua_Integer idx = ivalue(s2v(ra));  /* internal index */
        chgivalue(s2v(ra + 1), count - 1);  /* update counter */
        idx = intop(+, idx, step);  /* add step to index */
        chgivalue(s2v(ra), idx);  /* update internal index */
        setivalue(s2v(ra + 3), idx);  /* and control variable */
        goto label_36; /* jump back */
      }
    }
    else if (floatforloop(ra)) /* float loop */
      goto label_36; /* jump back */
    updatetrap(ci);  /* allows a signal to break the loop */
  }

  // 50	[1096]	GETTABUP 	1 3 7	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 51)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_52
  label_50: {
    aot_vmfetch(0x0703008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 51	[1098]	CLOSURE  	2 0	; 0x7fe077112e60
  #undef  AOT_PC
  #define AOT_PC (code + 52)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_53
  label_51: {
    aot_vmfetch(0x0000014f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 52	[1100]	CLOSURE  	3 1	; 0x7fe077112f70
  #undef  AOT_PC
  #define AOT_PC (code + 53)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_54
  label_52: {
    aot_vmfetch(0x000081cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 53	[1096]	CALL     	1 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 54)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_55
  label_53: {
    aot_vmfetch(0x030300c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 54	[1101]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 55)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_59
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_56
  label_54: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 55	[1101]	JMP      	3	; to 60
  #undef  AOT_PC
  #define AOT_PC (code + 56)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_57
  label_55: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_59;
  }

  // 56	[1102]	GETTABUP 	3 3 8	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 57)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_58
  label_56: {
    aot_vmfetch(0x0803018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 57	[1102]	MOVE     	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 58)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_59
  label_57: {
    aot_vmfetch(0x00020200);
    setobjs2s(L, ra, RB(i));
  }

  // 58	[1102]	CALL     	3 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 59)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_60
  label_58: {
    aot_vmfetch(0x010201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 59	[1105]	GETUPVAL 	3 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 60)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_61
  label_59: {
    aot_vmfetch(0x00020189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 60	[1105]	GETI     	4 3 1
  #undef  AOT_PC
  #define AOT_PC (code + 61)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_62
  label_60: {
    aot_vmfetch(0x0103020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 61	[1105]	GETUPVAL 	3 1	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 62)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_63
  label_61: {
    aot_vmfetch(0x00010189);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 62	[1105]	SETTABLE 	3 4 0k	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 63)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_64
  label_62: {
    aot_vmfetch(0x00048190);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 63	[1106]	GETTABUP 	3 3 9	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 64)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_65
  label_63: {
    aot_vmfetch(0x0903018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 64	[1106]	GETFIELD 	3 3 10	; "insert"
  #undef  AOT_PC
  #define AOT_PC (code + 65)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_66
  label_64: {
    aot_vmfetch(0x0a03018e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 65	[1106]	GETUPVAL 	4 4	; activeifs
  #undef  AOT_PC
  #define AOT_PC (code + 66)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_67
  label_65: {
    aot_vmfetch(0x00040209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 66	[1106]	MOVE     	5 2
  #undef  AOT_PC
  #define AOT_PC (code + 67)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_68
  label_66: {
    aot_vmfetch(0x00020280);
    setobjs2s(L, ra, RB(i));
  }

  // 67	[1106]	CALL     	3 3 1	; 2 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 68)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_69
  label_67: {
    aot_vmfetch(0x010301c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 68	[1109]	SETUPVAL 	2 0	; run
  #undef  AOT_PC
  #define AOT_PC (code + 69)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_68: {
    aot_vmfetch(0x0000010a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 69	[1110]	RETURN   	3 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 70)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_69: {
    aot_vmfetch(0x000181c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1096 - 1098
static
CallInfo *magic_implementation_81(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
  }

  // 0	[1097]	GETTABUP 	0 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1097]	LOADK    	1 1	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[1097]	GETUPVAL 	2 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00010109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[1097]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 4	[1097]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[1097]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_20
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 6	[1097]	JMP      	13	; to 21
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x80000638);
    updatetrap(ci);
    goto label_20;
  }

  // 7	[1097]	GETTABUP 	0 0 2	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x0200000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 8	[1097]	LOADK    	1 3	; "Failed to check condition\n"
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00018083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 9	[1097]	GETTABUP 	2 0 4	; _ENV "table"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0400010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 10	[1097]	GETFIELD 	2 2 5	; "pack"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0502010e);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[1097]	GETTABUP 	3 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x0000018b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 12	[1097]	LOADK    	4 1	; "return "
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00008203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[1097]	GETUPVAL 	5 1	; condition
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00010289);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 14	[1097]	CONCAT   	4 2
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00020235);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 15	[1097]	CALL     	3 2 0	; 1 in all out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x000201c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[1097]	CALL     	2 0 2	; all in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x02000144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 17	[1097]	GETI     	2 2 2
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x0202010d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 18	[1097]	CONCAT   	1 2
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x000200b5);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 19	[1097]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[1097]	TAILCALL 	0 1 0	; 0 in
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00010045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b);  /* prepare call frame */
    return ci;
  }

  // 21	[1097]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_21: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 22	[1098]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_22: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1098 - 1100
static
CallInfo *magic_implementation_82(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1099]	GETTABUP 	1 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1099]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1099]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1100]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1111 - 1114
static
CallInfo *magic_implementation_83(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
  }

  // 0	[1112]	GETUPVAL 	0 0	; run
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1112]	NOT      	0 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000033);
    TValue *rb = vRB(i);
    if (l_isfalse(rb))
      setbtvalue(s2v(ra));
    else
      setbfvalue(s2v(ra));
  }

  // 2	[1112]	SETUPVAL 	0 0	; run
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x0000000a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 3	[1113]	GETUPVAL 	0 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00020009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[1113]	GETI     	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0100008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 5	[1113]	GETUPVAL 	0 1	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[1113]	SETTABLE 	0 1 0k	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_06: {
    aot_vmfetch(0x00018010);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 7	[1114]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_07: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1115 - 1119
static
CallInfo *magic_implementation_84(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
  }

  // 0	[1116]	GETUPVAL 	0 0	; activeifs
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1116]	LEN      	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x000000b4);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 2	[1116]	GETUPVAL 	0 0	; activeifs
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 3	[1116]	SETTABLE 	0 1 0k	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00018010);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 4	[1117]	GETUPVAL 	0 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00020009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 5	[1117]	GETI     	1 0 1
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0100008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 6	[1117]	GETUPVAL 	0 1	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[1117]	SETTABLE 	0 1 0k	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00018010);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 8	[1118]	LOADTRUE 	0
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000007);
    setbtvalue(s2v(ra));
  }

  // 9	[1118]	SETUPVAL 	0 3	; run
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x0003000a);
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, s2v(ra));
    luaC_barrier(L, uv, s2v(ra));
  }

  // 10	[1119]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_10: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1120 - 1129
static
CallInfo *magic_implementation_85(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
  }

  // 0	[1122]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1122]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[1122]	SELF     	0 0 0k	; "split"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[1122]	LOADK    	2 1	; " "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1122]	CALL     	0 3 2	; 2 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x02030044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 5	[1124]	GETI     	1 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0200008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 6	[1126]	GETUPVAL 	2 1	; env
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 7	[1126]	SETTABLE 	2 1 2k	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x02018110);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 8	[1128]	GETUPVAL 	2 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00000109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 9	[1128]	GETI     	3 2 1
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0102018d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 10	[1128]	GETUPVAL 	2 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00020109);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 11	[1128]	SETTABLE 	2 3 2k	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_11: {
    aot_vmfetch(0x02038110);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 12	[1129]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x00010147);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1130 - 1135
static
CallInfo *magic_implementation_86(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
  }

  // 0	[1131]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1131]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[1131]	SELF     	0 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[1131]	LOADK    	2 1	; "#error "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1131]	LOADK    	3 2	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[1131]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[1132]	GETTABUP 	1 1 3	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[1132]	LOADK    	2 4	; "\027[1;31mRaised error:\027[0m"
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00020103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 8	[1132]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[1133]	GETTABUP 	1 1 3	; _ENV "print"
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0301008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 10	[1133]	LOADK    	2 5	; "\027[1;31m"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x00028103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 11	[1133]	MOVE     	3 0
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00000180);
    setobjs2s(L, ra, RB(i));
  }

  // 12	[1133]	LOADK    	4 6	; "\027[0m\n\n"
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00030203);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 13	[1133]	CONCAT   	2 3
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x00030135);
    int n = GETARG_B(i);  /* number of elements to concatenate */
    L->top = ra + n;  /* mark the end of concat operands */
    ProtectNT(luaV_concat(L, n));
    checkGC(L, L->top); /* 'luaV_concat' ensures correct top */
  }

  // 14	[1133]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 15	[1134]	MOVE     	1 0
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x00000080);
    setobjs2s(L, ra, RB(i));
  }

  // 16	[1134]	LOADK    	2 7	; "Ending preprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x00038103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 17	[1134]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_17: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 18	[1135]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_18: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1136 - 1140
static
CallInfo *magic_implementation_87(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
  }

  // 0	[1137]	GETUPVAL 	0 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000009);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1137]	GETI     	0 0 2
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x0200000d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 2	[1137]	SELF     	0 0 0k	; "gsub"
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x00008014);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 3	[1137]	LOADK    	2 1	; "#warning "
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008103);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 4	[1137]	LOADK    	3 2	; ""
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x00010183);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 5	[1137]	CALL     	0 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x02040044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 6	[1138]	GETTABUP 	1 1 3	; _ENV "warn"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x0301008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 7	[1138]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 8	[1138]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 9	[1139]	GETUPVAL 	1 0	; v
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 10	[1139]	GETI     	2 1 1
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x0101010d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 11	[1139]	GETUPVAL 	1 2	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 12	[1139]	SETTABLE 	1 2 4k	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_12: {
    aot_vmfetch(0x04028090);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 13	[1140]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_13: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1141 - 1143
static
CallInfo *magic_implementation_88(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1142]	GETTABUP 	0 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1142]	LOADK    	1 1	; "Config is not supported"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[1142]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1143]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1144 - 1147
static
CallInfo *magic_implementation_89(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1146]	GETTABUP 	0 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1146]	LOADK    	1 1	; "Extensions are not supported"
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00008083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 2	[1146]	CALL     	0 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x01020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1147]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1148 - 1167
static
CallInfo *magic_implementation_90(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
    case 11: goto label_11;
    case 12: goto label_12;
    case 13: goto label_13;
    case 14: goto label_14;
    case 15: goto label_15;
    case 16: goto label_16;
    case 17: goto label_17;
    case 18: goto label_18;
    case 19: goto label_19;
    case 20: goto label_20;
    case 21: goto label_21;
    case 22: goto label_22;
    case 23: goto label_23;
    case 24: goto label_24;
    case 25: goto label_25;
    case 26: goto label_26;
    case 27: goto label_27;
    case 28: goto label_28;
    case 29: goto label_29;
    case 30: goto label_30;
  }

  // 0	[1149]	GETUPVAL 	1 0	; run
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x00000089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 1	[1149]	TEST     	1 1
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x000080c2);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 2	[1149]	JMP      	5	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x80000238);
    updatetrap(ci);
    goto label_08;
  }

  // 3	[1150]	GETUPVAL 	1 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 4	[1150]	GETI     	2 1 1
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x0101010d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 5	[1150]	GETUPVAL 	1 1	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 6	[1150]	SETTABLE 	1 2 0k	; nil
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00028090);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 7	[1151]	RETURN   	1 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x000180c6);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 8	[1155]	GETUPVAL 	1 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00020089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 9	[1155]	GETI     	1 1 2
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_11
  label_09: {
    aot_vmfetch(0x0201008d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 10	[1155]	SELF     	1 1 1k	; "sub"
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_12
  label_10: {
    aot_vmfetch(0x01018094);
    const TValue *slot;
    TValue *rb = vRB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobj2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, rb, rc, ra, slot));
  }

  // 11	[1155]	LOADI    	3 2
  #undef  AOT_PC
  #define AOT_PC (code + 12)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_13
  label_11: {
    aot_vmfetch(0x80008181);
    lua_Integer b = GETARG_sBx(i);
    setivalue(s2v(ra), b);
  }

  // 12	[1155]	GETUPVAL 	4 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 13)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_14
  label_12: {
    aot_vmfetch(0x00020209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 13	[1155]	GETI     	4 4 2
  #undef  AOT_PC
  #define AOT_PC (code + 14)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_15
  label_13: {
    aot_vmfetch(0x0204020d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 14	[1155]	LEN      	4 4
  #undef  AOT_PC
  #define AOT_PC (code + 15)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_16
  label_14: {
    aot_vmfetch(0x00040234);
    Protect(luaV_objlen(L, ra, vRB(i)));
  }

  // 15	[1155]	CALL     	1 4 2	; 3 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 16)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_17
  label_15: {
    aot_vmfetch(0x020400c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 16	[1157]	GETTABUP 	2 3 2	; _ENV "xpcall"
  #undef  AOT_PC
  #define AOT_PC (code + 17)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_18
  label_16: {
    aot_vmfetch(0x0203010b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 17	[1159]	CLOSURE  	3 0	; 0x7fe077113f90
  #undef  AOT_PC
  #define AOT_PC (code + 18)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_19
  label_17: {
    aot_vmfetch(0x000001cf);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 18	[1161]	CLOSURE  	4 1	; 0x7fe077114100
  #undef  AOT_PC
  #define AOT_PC (code + 19)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_20
  label_18: {
    aot_vmfetch(0x0000824f);
    Proto *p = cl->p->p[GETARG_Bx(i)];
    halfProtect(pushclosure(L, p, cl->upvals, base, ra));
    checkGC(L, ra + 1);
  }

  // 19	[1157]	CALL     	2 3 3	; 2 in 2 out
  #undef  AOT_PC
  #define AOT_PC (code + 20)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_21
  label_19: {
    aot_vmfetch(0x03030144);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 20	[1162]	TEST     	2 1
  #undef  AOT_PC
  #define AOT_PC (code + 21)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_26
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_22
  label_20: {
    aot_vmfetch(0x00008142);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 21	[1162]	JMP      	4	; to 27
  #undef  AOT_PC
  #define AOT_PC (code + 22)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_23
  label_21: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_26;
  }

  // 22	[1163]	GETTABUP 	4 3 3	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 23)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_24
  label_22: {
    aot_vmfetch(0x0303020b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 23	[1163]	MOVE     	5 3
  #undef  AOT_PC
  #define AOT_PC (code + 24)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_25
  label_23: {
    aot_vmfetch(0x00030280);
    setobjs2s(L, ra, RB(i));
  }

  // 24	[1163]	CALL     	4 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 25)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_30
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_26
  label_24: {
    aot_vmfetch(0x01020244);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 25	[1164]	JMP      	4	; to 31
  #undef  AOT_PC
  #define AOT_PC (code + 26)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_27
  label_25: {
    aot_vmfetch(0x800001b8);
    updatetrap(ci);
    goto label_30;
  }

  // 26	[1165]	GETUPVAL 	4 2	; v
  #undef  AOT_PC
  #define AOT_PC (code + 27)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_28
  label_26: {
    aot_vmfetch(0x00020209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 27	[1165]	GETI     	5 4 1
  #undef  AOT_PC
  #define AOT_PC (code + 28)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_29
  label_27: {
    aot_vmfetch(0x0104028d);
    const TValue *slot;
    TValue *rb = vRB(i);
    int c = GETARG_C(i);
    if (luaV_fastgeti(L, rb, c, slot)) {
      setobj2s(L, ra, slot);
    }
    else {
      TValue key;
      setivalue(&key, c);
      Protect(luaV_finishget(L, rb, &key, ra, slot));
    }
  }

  // 28	[1165]	GETUPVAL 	4 1	; newlines
  #undef  AOT_PC
  #define AOT_PC (code + 29)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_30
  label_28: {
    aot_vmfetch(0x00010209);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 29	[1165]	SETTABLE 	4 5 3
  #undef  AOT_PC
  #define AOT_PC (code + 30)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_29: {
    aot_vmfetch(0x03050210);
    const TValue *slot;
    TValue *rb = vRB(i);  /* key (table is in 'ra') */
    TValue *rc = RKC(i);  /* value */
    lua_Unsigned n;
    if (ttisinteger(rb)  /* fast track for integers? */
        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))
        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {
      luaV_finishfastset(L, s2v(ra), slot, rc);
    }
    else
      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
  }

  // 30	[1167]	RETURN   	4 1 0	; 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 31)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_30: {
    aot_vmfetch(0x00018246);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1157 - 1159
static
CallInfo *magic_implementation_91(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
    case 4: goto label_04;
    case 5: goto label_05;
    case 6: goto label_06;
    case 7: goto label_07;
    case 8: goto label_08;
    case 9: goto label_09;
    case 10: goto label_10;
  }

  // 0	[1158]	GETTABUP 	0 0 0	; _ENV "envload"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1158]	GETUPVAL 	1 1	; code
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00010089);
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }

  // 2	[1158]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_04
  label_02: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1158]	TEST     	0 1
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #define AOT_NEXT_JUMP label_08
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_05
  label_03: {
    aot_vmfetch(0x00008042);
    int cond = !l_isfalse(s2v(ra));
    docondjump();
  }

  // 4	[1158]	JMP      	3	; to 9
  #undef  AOT_PC
  #define AOT_PC (code + 5)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_06
  label_04: {
    aot_vmfetch(0x80000138);
    updatetrap(ci);
    goto label_08;
  }

  // 5	[1158]	GETTABUP 	0 0 1	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 6)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_07
  label_05: {
    aot_vmfetch(0x0100000b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 6	[1158]	LOADK    	1 2	; "Failed to load preprocessor command"
  #undef  AOT_PC
  #define AOT_PC (code + 7)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_08
  label_06: {
    aot_vmfetch(0x00010083);
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }

  // 7	[1158]	CALL     	0 2 2	; 1 in 1 out
  #undef  AOT_PC
  #define AOT_PC (code + 8)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_09
  label_07: {
    aot_vmfetch(0x02020044);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 8	[1158]	TAILCALL 	0 1 0	; 0 in
  #undef  AOT_PC
  #define AOT_PC (code + 9)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_10
  label_08: {
    aot_vmfetch(0x00010045);
    int b = GETARG_B(i);  /* number of arguments + 1 (function) */
    int nparams1 = GETARG_C(i);
    /* delta is virtual 'func' - real 'func' (vararg functions) */
    int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
    if (b != 0)
      L->top = ra + b;
    else  /* previous instruction set top */
      b = cast_int(L->top - ra);
    savepc(ci);  /* several calls here can raise errors */
    if (TESTARG_k(i)) {
      luaF_closeupval(L, base);  /* close upvalues from current call */
      lua_assert(L->tbclist < base);  /* no pending tbc variables */
      lua_assert(base == ci->func + 1);
    }
    while (!ttisfunction(s2v(ra))) {  /* not a function? */
      luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */
      b++;  /* there is now one extra argument */
      checkstackGCp(L, 1, ra);
    }
    if (!ttisLclosure(s2v(ra))) {  /* C function? */
      luaD_precall(L, ra, LUA_MULTRET);  /* call it */
      updatetrap(ci);
      updatestack(ci);  /* stack may have been relocated */
      ci->func -= delta;  /* restore 'func' (if vararg) */
      luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */
      updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
    }
    ci->func -= delta;  /* restore 'func' (if vararg) */
    luaD_pretailcall(L, ci, ra, b);  /* prepare call frame */
    return ci;
  }

  // 9	[1158]	RETURN   	0 0 0	; all out
  #undef  AOT_PC
  #define AOT_PC (code + 10)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_09: {
    aot_vmfetch(0x00000046);
    int n = GETARG_B(i) - 1;  /* number of results */
    int nparams1 = GETARG_C(i);
    if (n < 0)  /* not fixed? */
      n = cast_int(L->top - ra);  /* get what is available */
    savepc(ci);
    if (TESTARG_k(i)) {  /* may there be open upvalues? */
      if (L->top < ci->top)
        L->top = ci->top;
      luaF_close(L, base, CLOSEKTOP, 1);
      updatetrap(ci);
      updatestack(ci);
    }
    if (nparams1)  /* vararg function? */
      ci->func -= ci->u.l.nextraargs + nparams1;
    L->top = ra + n;  /* set call for 'luaD_poscall' */
    luaD_poscall(L, ci, n);
    updatetrap(ci);  /* 'luaD_poscall' can change hooks */
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

  // 10	[1159]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 11)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_10: {
    aot_vmfetch(0x00010047);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

// source = @init.cobalt
// lines: 1159 - 1161
static
CallInfo *magic_implementation_92(lua_State *L, CallInfo *ci)
{
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  trap = L->hookmask;
  cl = clLvalue(s2v(ci->func));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (l_unlikely(trap)) {
    if (pc == cl->p->code) {  /* first instruction (not resuming)? */
      if (cl->p->is_vararg)
        trap = 0;  /* hooks will start after VARARGPREP instruction */
      else  /* check 'call' hook */
        luaD_hookcall(L, ci);
    }
    ci->u.l.trap = 1;  /* assume trap is on, for now */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  Instruction *code = cl->p->code;
  Instruction i;
  StkId ra;

  switch (pc - code) {
    case 0: goto label_00;
    case 1: goto label_01;
    case 2: goto label_02;
    case 3: goto label_03;
  }

  // 0	[1160]	GETTABUP 	1 0 0	; _ENV "errorpreprocessor"
  #undef  AOT_PC
  #define AOT_PC (code + 1)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_02
  label_00: {
    aot_vmfetch(0x0000008b);
    const TValue *slot;
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = KC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
      setobj2s(L, ra, slot);
    }
    else
      Protect(luaV_finishget(L, upval, rc, ra, slot));
  }

  // 1	[1160]	MOVE     	2 0
  #undef  AOT_PC
  #define AOT_PC (code + 2)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  #define AOT_SKIP1 label_03
  label_01: {
    aot_vmfetch(0x00000100);
    setobjs2s(L, ra, RB(i));
  }

  // 2	[1160]	CALL     	1 2 1	; 1 in 0 out
  #undef  AOT_PC
  #define AOT_PC (code + 3)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_02: {
    aot_vmfetch(0x010200c4);
    CallInfo *newci;
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0)  /* fixed number of arguments? */
        L->top = ra + b;  /* top signals number of arguments */
    /* else previous instruction set top */
    savepc(L);  /* in case of errors */
    if ((newci = luaD_precall(L, ra, nresults)) == NULL)
        updatetrap(ci);  /* C call; nothing else to be done */
    else {
        ci = newci;
        ci->callstatus = 0;  /* call re-uses 'luaV_execute' */
        return ci;
    }
  }

  // 3	[1161]	RETURN0  	
  #undef  AOT_PC
  #define AOT_PC (code + 4)
  #undef  AOT_NEXT_JUMP
  #undef  AOT_SKIP1
  label_03: {
    aot_vmfetch(0x000100c7);
    if (l_unlikely(L->hookmask)) {
      L->top = ra;
      savepc(ci);
      luaD_poscall(L, ci, 0);  /* no hurry... */
      trap = 1;
    }
    else {  /* do the 'poscall' here */
      int nres;
      L->ci = ci->previous;  /* back to caller */
      L->top = base - 1;
      for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        setnilvalue(s2v(L->top++));  /* all results are nil */
    }
    if (ci->callstatus & CIST_FRESH)
        return NULL;  /* end this frame */
    else {
        ci = ci->previous;
        return ci;
    }
  }

}

static AotCompiledFunction AOT_FUNCTIONS[] = {
  magic_implementation_00,
  magic_implementation_01,
  magic_implementation_02,
  magic_implementation_03,
  magic_implementation_04,
  magic_implementation_05,
  magic_implementation_06,
  magic_implementation_07,
  magic_implementation_08,
  magic_implementation_09,
  magic_implementation_10,
  magic_implementation_11,
  magic_implementation_12,
  magic_implementation_13,
  magic_implementation_14,
  magic_implementation_15,
  magic_implementation_16,
  magic_implementation_17,
  magic_implementation_18,
  magic_implementation_19,
  magic_implementation_20,
  magic_implementation_21,
  magic_implementation_22,
  magic_implementation_23,
  magic_implementation_24,
  magic_implementation_25,
  magic_implementation_26,
  magic_implementation_27,
  magic_implementation_28,
  magic_implementation_29,
  magic_implementation_30,
  magic_implementation_31,
  magic_implementation_32,
  magic_implementation_33,
  magic_implementation_34,
  magic_implementation_35,
  magic_implementation_36,
  magic_implementation_37,
  magic_implementation_38,
  magic_implementation_39,
  magic_implementation_40,
  magic_implementation_41,
  magic_implementation_42,
  magic_implementation_43,
  magic_implementation_44,
  magic_implementation_45,
  magic_implementation_46,
  magic_implementation_47,
  magic_implementation_48,
  magic_implementation_49,
  magic_implementation_50,
  magic_implementation_51,
  magic_implementation_52,
  magic_implementation_53,
  magic_implementation_54,
  magic_implementation_55,
  magic_implementation_56,
  magic_implementation_57,
  magic_implementation_58,
  magic_implementation_59,
  magic_implementation_60,
  magic_implementation_61,
  magic_implementation_62,
  magic_implementation_63,
  magic_implementation_64,
  magic_implementation_65,
  magic_implementation_66,
  magic_implementation_67,
  magic_implementation_68,
  magic_implementation_69,
  magic_implementation_70,
  magic_implementation_71,
  magic_implementation_72,
  magic_implementation_73,
  magic_implementation_74,
  magic_implementation_75,
  magic_implementation_76,
  magic_implementation_77,
  magic_implementation_78,
  magic_implementation_79,
  magic_implementation_80,
  magic_implementation_81,
  magic_implementation_82,
  magic_implementation_83,
  magic_implementation_84,
  magic_implementation_85,
  magic_implementation_86,
  magic_implementation_87,
  magic_implementation_88,
  magic_implementation_89,
  magic_implementation_90,
  magic_implementation_91,
  magic_implementation_92,
  NULL
};

static const char AOT_MODULE_SOURCE_CODE[] = {
   47,  47,  32,  66, 117, 105, 108, 116,  32, 105, 110,  32, 112, 114, 101, 112,
  114, 111,  99, 101, 115, 115, 111, 114,  32, 102, 111, 114,  32,  99, 111,  98,
   97, 108, 116,  10,  47,  47,  32,  84, 104, 101,  32, 112, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 101, 114,  32, 105, 115,  32, 110, 111, 116,  32,  97,
  112,  97, 114, 116,  32, 111, 102,  32, 116, 104, 101,  32,  99, 111, 109, 112,
  105, 108, 101, 114,  10,  47,  47,  32,  97, 110, 100,  32, 110, 101, 101, 100,
  115,  32, 116, 111,  32,  98, 101,  32,  98, 117, 105, 108, 116,  32, 117, 115,
  105, 110, 103,  32,  96,  99, 109,  97, 107, 101,  32,  46,  32,  38,  38,  32,
  109,  97, 107, 101,  96,  32,  97, 110, 100,  10,  47,  47,  32, 117, 115, 101,
  100,  32,  98, 101, 102, 111, 114, 101,  32,  99, 111, 109, 112, 105, 108, 105,
  110, 103,  32, 116, 104, 101,  32, 115, 111, 117, 114,  99, 101,  32,  99, 111,
  100, 101,  10,  10,  47,  47,  32,  84, 104, 101,  32, 112, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 111, 114,  32, 114, 101, 112, 108,  97,  99, 101, 115,
   32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32, 100, 105,
  114, 101,  99, 116, 105, 118, 101, 115,  32, 119, 105, 116, 104,  10,  47,  47,
   32,  99, 111,  98,  97, 108, 116,  32,  99, 111, 100, 101,  32, 100, 101, 112,
  101, 110, 100, 105, 110, 103,  32, 111, 110,  32, 115, 121, 115, 116, 101, 109,
   32,  97, 110, 100,  32, 111, 116, 104, 101, 114,  32, 102,  97,  99, 116, 111,
  114, 115,  10,  10,  47,  42,  32,  68, 101, 112, 101, 110, 100, 101, 110,  99,
  105, 101, 115,  10,  32,  32,  32,  47,  47,  32, 115, 119, 105, 116,  99, 104,
   32,  40,  73, 110, 115, 116,  97, 108, 108, 101, 100,  32, 119, 105, 116, 104,
   32,  96, 109,  97, 107, 101,  32, 115, 101, 116, 117, 112,  96,  41,  10,  32,
   32,  32,  47,  47,  32, 102, 105, 108, 101, 120,  32,  40,  73, 110, 115, 116,
   97, 108, 108, 101, 100,  32, 119, 105, 116, 104,  32,  96, 109,  97, 107, 101,
   32, 115, 101, 116, 117, 112,  96,  41,  10,  32,  32,  32,  47,  47,  32,  99,
  111, 114, 101,  32,  47,  47,  32,  80, 114, 101, 108, 111,  97, 100, 101, 100,
   44,  32, 110, 101, 101, 100, 101, 100,  32, 116, 111,  32, 103, 101, 116,  32,
   67,  32, 109,  97,  99, 114, 111, 115,  46,  32,  74,  73,  84,  32,  80, 111,
  114, 116, 101, 100,  32,  38,  32,  73, 110, 116, 101, 114, 112, 114, 101, 116,
  101, 114,  32,  67, 111, 114, 101,  46,  10,  32,  32,  32,  47,  47,  32, 102,
  102, 105,  32,  47,  47,  32,  80, 114, 101, 108, 111,  97, 100, 101, 100,  44,
   32, 110, 101, 101, 100, 101, 100,  32, 116, 111,  32, 103, 101, 116,  32,  67,
   32, 109,  97,  99, 114, 111, 115,  46,  32,  74,  73,  84,  32,  80, 111, 114,
  116, 101, 100,  32,  38,  32,  73, 110, 116, 101, 114, 112, 114, 101, 116, 101,
  114,  32,  67, 111, 114, 101,  46,  10,  32,  32,  32,  47,  47,  32,  98,  97,
  115, 101,  32, 108, 105,  98, 114,  97, 114, 105, 101, 115,  32,  47,  47,  32,
   74,  73,  84,  32,  38,  32,  73, 110, 116, 101, 114, 112, 114, 101, 116, 101,
  114,  32, 100, 101, 115, 105, 103, 110, 101, 100,  32, 112, 114, 101, 108, 111,
   97, 100, 101, 100,  32, 108, 105,  98, 114,  97, 114, 105, 101, 115,  10,  42,
   47,  10,  10,  47,  42,  32,  78, 111, 116, 101, 115,  10,  32,  32,  32,  32,
   45,  32,  84, 104, 101,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,
  111, 114,  32, 105, 115,  32, 110, 111, 116,  32,  97, 112,  97, 114, 116,  32,
  111, 102,  32, 116, 104, 101,  32,  99, 111, 109, 112, 105, 108, 101, 114,  10,
   32,  32,  32,  32,  45,  32,  85, 115, 105, 110, 103,  32,  67,  32,  77,  97,
   99, 114, 111, 115,  32, 114, 101, 113, 117, 105, 114, 101,  32,  71,  67,  67,
   32, 116, 111,  32,  98, 101,  32, 105, 110, 115, 116,  97, 108, 108, 101, 100,
   32,  40,  65, 115,  32, 111, 102,  32, 116, 104, 101,  32,  96,  99, 111, 114,
  101,  96,  32, 108, 105,  98, 114,  97, 114, 121,  32, 100, 101, 112, 101, 110,
  100, 101, 110,  99, 121,  41,  10,  32,  32,  32,  32,  45,  32,  67,  32,  77,
   97,  99, 114, 111, 115,  32, 119, 105, 108, 108,  32,  78,  79,  84,  32, 119,
  111, 114, 107,  32, 111, 110,  32, 116, 104, 101,  32,  74,  73,  84,  32,  99,
  111, 109, 112, 105, 108, 101, 114,  10,  42,  47,  10,  10,  47,  42,  32,  84,
   79,  68,  79,  58,  10,  32,  32,  32,  32,  45,  32,  65,  99, 116, 117,  97,
  108, 108, 121,  32, 115, 117,  98, 115, 116, 105, 116, 117, 116, 101,  32, 109,
   97,  99, 114, 111, 115,  32,  38,  32, 100, 101, 102, 105, 110, 105, 116, 105,
  111, 110, 115,  10,  42,  47,  10,  10,  47,  42,  32,  83, 117, 112, 112, 111,
  114, 116, 115,  10,  32,  32,  32,  47,  47,  32,  69, 110,  97,  98, 108, 101,
  100,  58,  10,  32,  32,  32,  32,  47,  47,  32,  35, 111, 112, 101, 110,  32,
   40, 110,  97, 109, 101,  41,  58,  32,  67, 104, 101,  99, 107, 115,  32, 105,
  102,  32,  97,  32,  77,  97,  99, 114, 111,  32, 105, 115,  32, 100, 101, 102,
  105, 110, 101, 100,  32,  97, 110, 100,  32, 111, 112, 101, 110, 115,  32, 105,
  116,  32, 115, 111,  32, 116, 104,  97, 116,  32, 116, 104, 101,  32, 112, 114,
  111, 103, 114,  97, 109,  32,  99,  97, 110,  32, 117, 115, 101,  32, 105, 116,
   10,  32,  32,  32,  32,  47,  47,  32,  35, 100, 101, 102, 105, 110, 101,  32,
   40, 110,  97, 109, 101,  41,  32,  40, 118,  97, 108, 117, 101,  32,  60, 111,
  112, 116, 105, 111, 110,  97, 108,  62,  41,  58,  32,  83, 101, 116, 115,  32,
   97,  32, 109,  97,  99, 114, 111,  10,  32,  32,  32,  32,  47,  47,  32,  35,
  100, 101, 102, 105, 110, 101,  32,  40, 108,  97, 109,  98, 100,  97, 110,  97,
  109, 101,  41,  40,  97, 114, 103, 115,  41,  32,  40, 102, 117, 110,  99, 116,
  105, 111, 110,  41,  58,  32,  83, 101, 116, 115,  32,  97,  32, 109,  97,  99,
  114, 111,  32, 116, 111,  32,  97,  32, 108,  97, 109,  98, 100,  97,  32, 102,
  117, 110,  99, 116, 105, 111, 110,  10,  32,  32,  32,  32,  47,  47,  32,  35,
  117, 110, 100, 101, 102,  32,  40, 110,  97, 109, 101,  41,  58,  32,  82, 101,
  109, 111, 118, 101, 115,  32,  97,  32, 109,  97,  99, 114, 111,  10,  32,  32,
   32,  32,  47,  47,  32,  35, 105, 102, 100, 101, 102,  32,  40, 110,  97, 109,
  101,  41,  58,  32,  73, 102,  32, 109,  97,  99, 114, 111,  32, 105, 115,  32,
  100, 101, 102, 105, 110, 101, 100,  44,  32,  67, 111, 110, 100, 105, 116, 105,
  111, 110,  32, 109, 117, 115, 116,  32,  98, 101,  32, 119, 114,  97, 112, 112,
  101, 100,  32, 105, 110,  32,  40,  41,  10,  32,  32,  32,  32,  47,  47,  32,
   35, 105, 102, 110, 100, 101, 102,  32,  40, 110,  97, 109, 101,  41,  58,  32,
   73, 102,  32, 109,  97,  99, 114, 111,  32, 105, 115,  32, 110, 111, 116,  32,
  100, 101, 102, 105, 110, 101, 100,  44,  32,  67, 111, 110, 100, 105, 116, 105,
  111, 110,  32, 109, 117, 115, 116,  32,  98, 101,  32, 119, 114,  97, 112, 112,
  101, 100,  32, 105, 110,  32,  40,  41,  10,  32,  32,  32,  32,  47,  47,  32,
   35, 101, 108, 105, 102,  32,  40, 110,  97, 109, 101,  41,  58,  32,  69, 108,
  115, 101,  32, 105, 102,  32, 109,  97,  99, 114, 111,  32, 105, 115,  32, 100,
  101, 102, 105, 110, 101, 100,  44,  32,  67, 111, 110, 100, 105, 116, 105, 111,
  110,  32, 109, 117, 115, 116,  32,  98, 101,  32, 119, 114,  97, 112, 112, 101,
  100,  32, 105, 110,  32,  40,  41,  10,  32,  32,  32,  32,  47,  47,  32,  35,
  101, 108, 115, 101,  58,  32,  69, 108, 115, 101,  44,  32, 110, 111,  32,  99,
  111, 110, 100, 105, 116, 105, 111, 110,  10,  32,  32,  32,  32,  47,  47,  32,
   35, 101, 110, 100, 105, 102,  58,  32,  69, 110, 100,  32, 105, 102,  10,  32,
   32,  32,  32,  47,  47,  32,  35, 101, 114, 114, 111, 114,  32,  40, 109, 101,
  115, 115,  97, 103, 101,  41,  58,  32,  82,  97, 105, 115, 101, 115,  32,  97,
  110,  32, 101, 114, 114, 111, 114,  10,  32,  32,  32,  32,  47,  47,  32,  35,
  119,  97, 114, 110, 105, 110, 103,  32,  40, 109, 101, 115, 115,  97, 103, 101,
   41,  58,  32,  82,  97, 105, 115, 101, 115,  32,  97,  32, 119,  97, 114, 110,
  105, 110, 103,  10,  10,  32,  32,  32,  47,  47,  32,  68, 105, 115,  97,  98,
  108, 101, 100,  58,  10,  32,  32,  32,  32,  47,  47,  32,  35, 105, 110,  99,
  108, 117, 100, 101,  32,  34, 102, 105, 108, 101,  46,  99, 111,  98,  97, 108,
  116,  34,  58,  32,  73, 110,  99, 108, 117, 100, 101, 115,  32,  97,  32, 102,
  105, 108, 101,  32,  40,  67, 121,  99, 108, 105,  99,  32, 100, 101, 112, 101,
  110, 100, 101, 110,  99, 105, 101, 115,  32, 119, 105, 108, 108,  32, 108, 101,
   97, 118, 101,  32, 116, 104, 101,  32, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  32, 105, 110,  32,  97, 110,  32, 105, 110, 102, 105, 110,
  105, 116, 101,  32, 108, 111, 111, 112,  41,  32,  40,  78,  97, 109, 101,  32,
  109, 117, 115, 116,  32,  98, 101,  32, 105, 110,  32,  34,  34,  41,  10,  32,
   32,  32,  32,  47,  47,  32,  35, 108, 105, 110, 101,  32,  40, 108, 105, 110,
  101,  41,  32,  34, 102, 105, 108, 101,  46,  99, 111,  98,  97, 108, 116,  32,
   60, 111, 112, 116, 105, 111, 110,  97, 108,  62,  34,  58,  32,  83, 101, 116,
  115,  32, 116, 104, 101,  32, 108, 105, 110, 101,  32, 110, 117, 109,  98, 101,
  114,  32,  97, 110, 100,  32, 102, 105, 108, 101,  32, 110,  97, 109, 101,  32,
  102, 111, 114,  32, 116, 104, 101,  32, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  32,  40,  67, 121,  99, 108, 105,  99,  32, 100, 101, 112,
  101, 110, 100, 101, 110,  99, 105, 101, 115,  32, 119, 105, 108, 108,  32, 108,
  101,  97, 118, 101,  32, 116, 104, 101,  32, 112, 114, 101, 112, 114, 111,  99,
  101, 115, 115, 111, 114,  32, 105, 110,  32,  97, 110,  32, 105, 110, 102, 105,
  110, 105, 116, 101,  32, 108, 111, 111, 112,  41,  32,  40,  78,  97, 109, 101,
   32, 109, 117, 115, 116,  32,  98, 101,  32, 105, 110,  32,  34,  34,  41,  10,
   10,  10,  32,  32,  32,  32,  47,  47,  32,  69, 118, 101, 114, 121, 116, 104,
  105, 110, 103,  32, 101, 108, 115, 101,  32, 116, 104,  97, 116,  32, 115, 116,
   97, 114, 116, 115,  32, 119, 105, 116, 104,  32,  97,  32,  35,  32, 119, 105,
  108, 108,  32,  98, 101,  32, 101, 120, 101,  99, 117, 116, 101, 100,  32,  97,
  115,  32,  97,  32,  99, 111,  98,  97, 108, 116,  32, 115, 111, 117, 114,  99,
  101,  32, 108, 105, 110, 101,  10,  32,  32,  32,  32,  47,  47,  32,  67,  32,
   77,  97,  99, 114, 111, 115,  32,  97, 114, 101,  32, 115, 117, 112, 112, 111,
  114, 116, 101, 100,  32, 105, 102,  32,  71,  67,  67,  32, 105, 115,  32, 105,
  110, 115, 116,  97, 108, 108, 101, 100,  44,  32, 105, 102,  32, 110, 111, 116,
   44,  32, 116, 104, 101, 121,  32, 119, 105, 108, 108,  32,  98, 101,  32, 105,
  103, 110, 111, 114, 101, 100,  46,  10,  32,  32,  32,  32,  47,  47,  32,  99,
  111,  98,  97, 108, 116,  32,  97, 110, 100,  32,  99, 111,  98,  97, 108, 116,
  118, 101, 114, 115, 105, 111, 110,  32,  97, 114, 101,  32, 105, 110,  99, 108,
  117, 100, 101, 100,  32, 109,  97,  99, 114, 111, 115,  10,  42,  47,  10,  10,
  115, 119, 105, 116,  99, 104,  32,  61,  32, 105, 109, 112, 111, 114, 116,  40,
   34, 115, 119, 105, 116,  99, 104,  34,  41,  32,  47,  47,  32,  83, 119, 105,
  116,  99, 104,  32, 108, 105,  98, 114,  97, 114, 121,  32, 102, 111, 114,  32,
   99, 111,  98,  97, 108, 116,  10, 102, 105, 108, 101, 115, 121, 115, 116, 101,
  109,  32,  61,  32, 102, 105, 108, 101,  32, 124, 124,  32, 105, 109, 112, 111,
  114, 116,  40,  34, 102, 105, 108, 101,  34,  41,  32,  47,  47,  32,  70, 105,
  108, 101,  32, 108, 105,  98, 114,  97, 114, 121,  32, 102, 111, 114,  32,  99,
  111,  98,  97, 108, 116,  10, 102, 105, 108, 101, 120,  32,  61,  32, 105, 109,
  112, 111, 114, 116,  40,  34, 101, 120, 116,  46, 102, 105, 108, 101,  34,  41,
   32,  47,  47,  32,  69, 120, 116, 101, 110, 100, 101, 100,  32,  70, 105, 108,
  101,  32, 108, 105,  98, 114,  97, 114, 121,  32, 102, 111, 114,  32,  99, 111,
   98,  97, 108, 116,  10,  99, 111, 114, 101,  32,  61,  32,  99, 111, 114, 101,
   32, 124, 124,  32, 105, 109, 112, 111, 114, 116,  40,  34,  99, 111, 114, 101,
   34,  41,  32,  47,  47,  32,  67, 111, 114, 101,  32, 108, 105,  98, 114,  97,
  114, 121,  32, 102, 111, 114,  32,  99, 111,  98,  97, 108, 116,  10,  10, 109,
   97,  99, 114, 111, 115,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,
   40,  41, 123, 125,  32,  47,  47,  32,  99, 111, 114, 101,  46, 109,  97,  99,
  114, 111, 115,  10,  10,  47,  42,  10,  32,  32,  67, 111,  98,  97, 108, 116,
   32,  84, 121, 112, 101,  99, 104, 101,  99, 107, 101, 114,  46,  32,  10,  32,
   32,  84, 104, 105, 115,  32, 105, 115,  32,  97,  32, 116, 121, 112, 101,  99,
  104, 101,  99, 107, 101, 114,  32, 102, 111, 114,  32, 116, 104, 101,  32,  67,
  111,  98,  97, 108, 116,  32, 108,  97, 110, 103, 117,  97, 103, 101,  46,  32,
   73, 116,  32, 105, 115,  32, 119, 114, 105, 116, 116, 101, 110,  32, 105, 110,
   32,  67, 111,  98,  97, 108, 116,  46,  10,  32,  32,  73, 110, 116, 101, 103,
  114,  97, 116, 101, 100,  32, 105, 110, 116, 111,  32, 116, 104, 101,  32, 112,
  114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46,  10,  42,  47,  10,
   10,  47,  42,  32,  84,  79,  68,  79,  58,  10,  32,  45,  32,  65, 108, 108,
  111, 119,  32,  99, 117, 115, 116, 111, 109,  32, 116, 121, 112, 101, 115,  10,
   32,  45,  32,  70, 117, 110,  99, 116, 105, 111, 110, 115,  32,  99,  97, 110,
   32, 104,  97, 118, 101,  32,  97, 114, 103, 117, 109, 101, 110, 116, 115,  32,
  116, 111,  32,  98, 101,  32, 116, 121, 112, 101,  99, 104, 101,  99, 107, 101,
  100,  10,  32,  45,  32,  71, 101, 110, 101, 114, 105,  99, 115,  10,  32,  45,
   32,  70, 105, 120,  32, 105, 115, 115, 117, 101,  32, 119, 104, 101, 114, 101,
   32, 116, 121, 112, 101,  32,  99,  97, 110,  32,  98, 101,  32,  99, 104,  97,
  110, 103, 101, 100,  32,  97, 102, 116, 101, 114,  32, 100, 101, 102, 105, 110,
  105, 116, 111, 110,  10,  42,  47,  10,  10,  47,  42,  32,  83,  89,  83,  84,
   69,  77,  58,  10,  32,  84, 104, 101,  32, 115, 121, 115, 116, 101, 109,  32,
  114, 101, 109, 111, 118, 101, 115,  32,  97, 108, 108,  32,  99, 111, 109, 109,
  101, 110, 116, 115,  32,  97, 110, 100,  32,  99, 108, 101,  97, 114, 115,  32,
  115, 116, 114, 105, 110, 103, 115,  32,  97, 110, 100,  32, 115,  97, 118, 101,
  115,  32, 105, 116,  32, 116, 111,  32,  97,  32, 116,  97,  98, 108, 101,  32,
  111, 102,  32,  34, 100, 101,  97, 100,  34,  32, 115, 116, 114, 105, 110, 103,
  115,  44,  32,  10,  32, 116, 104, 101, 110,  32, 105, 116,  32, 108, 111, 111,
  107, 115,  32, 102, 111, 114,  32, 100, 101, 102, 105, 110, 105, 116, 105, 111,
  110, 115,  32,  96, 118,  97, 114,  32, 120,  58,  32, 121,  32,  61,  32, 122,
   96,  32, 116, 111,  32, 115, 116, 111, 114, 101,  32, 105, 110,  32,  97,  32,
   99,  97,  99, 104, 101,  32,  97, 110, 100,  32,  97, 115, 115, 105, 103, 110,
  109, 101, 110, 116, 115,  32,  96, 120,  58,  32, 121,  32,  61,  32, 122,  96,
   32,  97, 110, 100,  32, 101, 118, 101, 110,  32,  10,  32, 110, 111, 114, 109,
   97, 108,  32,  97, 115, 115, 105, 103, 110, 109, 101, 110, 116, 115,  32,  96,
   97,  32,  61,  32, 122,  96,  32, 112,  97, 116, 116, 101, 114, 110, 115,  44,
   32,  97, 110, 100,  32, 116, 104, 101, 110,  32, 105, 116,  32,  99, 104, 101,
   99, 107, 115,  32, 116, 104, 101,  32, 116, 121, 112, 101, 115,  32, 111, 102,
   32, 116, 104, 101,  32, 118,  97, 108, 117, 101, 115,  32, 119, 105, 116, 104,
   32,  10,  32, 116, 104, 101,  32,  34, 100, 101,  97, 100,  34,  32, 115, 116,
  114, 105, 110, 103, 115,  32, 114, 101,  98, 111, 114, 110,  46,  10,  10,  32,
   73, 116,  32, 105, 115,  32, 115, 105, 109, 112, 108, 101,  32,  97, 110, 100,
   32, 115, 104, 111, 114, 116,  44,  32, 105, 116,  32, 105, 115,  32, 105, 110,
   32,  66,  69,  84,  65,  32,  98, 117, 116,  32, 105, 115, 115, 117, 101, 115,
   32, 119, 105, 108, 108,  32,  98, 101,  32, 114,  97, 114, 101,  32, 105, 116,
   32, 104,  97, 115,  32,  98, 101, 101, 110,  32, 116, 101, 115, 116, 101, 100,
   32, 111, 110,  32, 101, 118, 101, 110,  32, 116, 104, 105, 115,  32,  10,  32,
  102, 105, 108, 101,  32,  97, 110, 100,  32, 105, 116,  32, 119, 111, 114, 107,
  115,  32, 102, 105, 110, 101,  46,  10,  10,  32,  73, 102,  32, 121, 111, 117,
   32, 100, 111,  32, 110, 111, 116,  32, 117, 115, 101,  32, 116, 104, 101,  32,
  116, 121, 112, 101,  99, 104, 101,  99, 107, 101, 114,  32, 116, 121, 112, 101,
   32,  97, 110, 110, 111, 116,  97, 116, 105, 111, 110, 115,  32,  97, 114, 101,
   32, 115, 117, 112, 112, 111, 114, 116, 101, 100,  32,  98, 121,  32, 116, 104,
  101,  32, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 114,  32,  98, 117,
  116,  32, 119, 111, 110, 116,  10,  32, 104,  97, 118, 101,  32,  97, 110, 121,
   32, 118,  97, 108, 117, 101,  46,  32,  66, 117, 116,  32, 116, 104, 101,  32,
  115,  97, 109, 101,  32,  99,  97, 110, 110, 111, 116,  32,  98, 101,  32, 115,
   97, 105, 100,  32, 102, 111, 114,  32, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  32, 100, 105, 114, 101,  99, 116, 105, 118, 101, 115,  44,
   32, 116, 104, 101, 121,  32,  97, 114, 101,  32, 110, 111, 116,  32, 115, 117,
  112, 112, 111, 114, 116, 101, 100,  32,  10,  32, 105, 110,  32, 116, 104, 101,
   32, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 114,  46,  10,  10,  32,
   73, 102,  32, 116, 104, 101,  32, 116, 121, 112, 101,  99, 104, 101,  99, 107,
  101, 114,  32, 102,  97, 105, 108, 115,  32, 116, 111,  32,  99, 104, 101,  99,
  107,  32, 105, 116,  32, 119, 105, 108, 108,  32, 105, 103, 110, 111, 114, 101,
   46,  10,  42,  47,  10,  10,  47,  47,  32,  71,  76,  79,  66,  65,  76,  83,
   10, 100, 101,  97, 100,  32,  61,  32, 123, 125,  10,  10,  47,  47,  32,  69,
   82,  82,  79,  82,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 116, 121,
  112, 101, 114, 114, 111, 114,  40, 101, 114, 114, 111, 114, 105, 110,  44,  32,
  108, 105, 110, 101,  44,  32, 110, 111, 116, 101,  41, 123,  10,  32,  32, 112,
  114, 105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49, 109,  84,
  121, 112, 101,  99, 104, 101,  99, 107, 101, 114,  32, 101, 114, 114, 111, 114,
   58,  92,  50,  55,  91,  48, 109,  34,  41,  10,  32,  32, 105, 102,  32,  40,
  101, 114, 114, 111, 114, 105, 110,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32, 112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49,
  109,  34,  46,  46, 101, 114, 114, 111, 114, 105, 110,  46,  46,  34,  92,  50,
   55,  91,  48, 109,  92, 110,  92, 110,  34,  41,  10,  32,  32, 125,  10,  32,
   32, 112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49,
  109,  83, 110, 105, 112, 112, 101, 116,  58,  92,  50,  55,  91,  48, 109,  34,
   41,  10,  32,  32, 112, 114, 105, 110, 116,  40, 114, 101, 118, 105, 118, 101,
   40, 108, 105, 110, 101,  41,  41,  10,  32,  32, 105, 102,  32,  40, 110, 111,
  116, 101,  41, 123,  10,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,  34,
   92, 110,  92,  50,  55,  91,  49,  59,  51,  49, 109,  84, 121, 112, 101,  99,
  104, 101,  99, 107, 101, 114,  32, 112, 114, 111, 118, 105, 100, 101, 100,  32,
  110, 111, 116, 101,  58,  92,  50,  55,  91,  48, 109,  34,  41,  10,  32,  32,
   32,  32, 112, 114, 105, 110, 116,  40,  34,  92, 110,  92,  50,  55,  91,  49,
   59,  51,  49, 109,  34,  46,  46, 110, 111, 116, 101,  46,  46,  34,  92,  50,
   55,  91,  48, 109,  34,  41,  10,  32,  32, 125,  10,  32,  32, 112, 114, 105,
  110, 116,  40,  34,  92, 110,  92,  50,  55,  91,  49,  59,  51,  49, 109,  83,
  116, 111, 112, 112, 105, 110, 103,  32,  84, 121, 112, 101,  99, 104, 101,  99,
  107, 101, 114,  46,  92,  50,  55,  91,  48, 109,  34,  41,  10,  32,  32, 111,
  115,  46, 101, 120, 105, 116,  40,  41,  10, 125,  10,  47,  47,  32,  76,  79,
   65,  68,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 116,  97,  98, 108,
  101, 116, 111, 115, 116, 114, 105, 110, 103,  40, 116,  98, 108,  41, 123,  10,
   32,  32,  47,  47,  32,  67, 111, 110, 118, 101, 114, 116, 115,  32,  97,  32,
  116,  97,  98, 108, 101,  32, 116, 111,  32,  97,  32, 115, 116, 114, 105, 110,
  103,  10,  32,  32, 118,  97, 114,  32, 114, 101, 115, 117, 108, 116,  32,  61,
   32,  34, 123,  34,  10,  32,  32, 102, 111, 114,  32,  40, 105,  44,  32, 118,
   32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 116,  98, 108,  41,  41,  32,
  123,  10,  32,  32,  32,  32, 105, 102,  32,  40,  33, 118,  41, 123,  10,  32,
   32,  32,  32,  32,  32, 118,  32,  61,  32,  34, 110, 117, 108, 108,  34,  10,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 118,  32,  61,  32,  40, 108,
  111,  97, 100, 115, 116, 114, 105, 110, 103,  40,  34, 114, 101, 116, 117, 114,
  110,  32,  34,  46,  46,  40, 118,  32, 124, 124,  32,  34, 110, 117, 108, 108,
   34,  41,  41,  32, 124, 124,  32, 108, 111,  97, 100, 101, 110, 118,  40,  34,
  114, 101, 116, 117, 114, 110,  32,  34,  46,  46,  40, 118,  32, 124, 124,  32,
   34, 110, 117, 108, 108,  34,  41,  41,  41,  10,  32,  32,  32,  32, 120, 112,
   99,  97, 108, 108,  40, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,
   10,  32,  32,  32,  32,  32,  32, 118,  32,  61,  32, 118,  40,  41,  10,  32,
   32,  32,  32, 125,  44,  32,  10,  32,  32,  32,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32, 118,  32,  61,
   32, 108, 111,  97, 100, 101, 110, 118,  40,  34, 114, 101, 116, 117, 114, 110,
   32,  34,  46,  46,  40, 118,  32, 124, 124,  32,  34, 110, 117, 108, 108,  34,
   41,  41,  10,  32,  32,  32,  32,  32,  32, 120, 112,  99,  97, 108, 108,  40,
  102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 118,  32,  61,  32, 118,  40,  41,  10,  32,  32,  32,  32,
   32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40, 101, 114, 114,  41, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 116, 121, 112, 101, 114, 114, 111, 114,  40,  34,  69, 114, 114, 111,
  114,  32,  99, 104, 101,  99, 107, 105, 110, 103,  32, 118,  97, 108, 117, 101,
   58,  32,  34,  46,  46, 101, 114, 114,  41,  10,  32,  32,  32,  32,  32,  32,
  125,  41,  10,  32,  32,  32,  32, 125,  41,  10,  10,  32,  32,  32,  32, 105,
  102,  32,  40, 116, 121, 112, 101,  40, 118,  41,  32,  61,  61,  32,  34, 115,
  116, 114, 105, 110, 103,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
  114, 101, 115, 117, 108, 116,  32,  61,  32, 114, 101, 115, 117, 108, 116,  46,
   46, 105,  46,  46,  34,  32,  61,  32,  92,  34,  34,  46,  46, 118,  46,  46,
   34,  92,  34,  44,  34,  10,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,
   32, 105, 102,  32,  40, 116, 121, 112, 101,  40, 118,  41,  32,  61,  61,  32,
   34, 116,  97,  98, 108, 101,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32, 114, 101, 115, 117, 108, 116,  32,  61,  32, 114, 101, 115, 117, 108, 116,
   46,  46, 105,  46,  46,  34,  32,  61,  32,  34,  46,  46, 116,  97,  98, 108,
  101, 116, 111, 115, 116, 114, 105, 110, 103,  40, 118,  41,  46,  46,  34,  44,
   32,  34,  10,  32,  32,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,
   32,  32,  32,  32,  32,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32, 114,
  101, 115, 117, 108, 116,  46,  46, 105,  46,  46,  34,  32,  61,  32,  34,  46,
   46,  40, 118,  32, 124, 124,  32,  34, 110, 117, 108, 108,  34,  41,  46,  46,
   34,  44,  34,  10,  32,  32,  32,  32, 125,  10,  32,  32, 125,  10,  32,  32,
  114, 101, 115, 117, 108, 116,  32,  61,  32, 114, 101, 115, 117, 108, 116,  46,
   46,  34, 125,  34,  10,  32,  32, 114, 101, 116, 117, 114, 110,  32, 114, 101,
  115, 117, 108, 116,  10, 125,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32,
  108, 111,  97, 100, 101, 110, 118,  40, 101, 110, 118,  44,  32, 115, 116, 114,
   41, 123,  10,  32,  32,  47,  47,  32,  85, 115, 101, 115,  32, 108, 111,  97,
  100, 115, 116, 114, 105, 110, 103,  44,  32,  98, 117, 116,  32, 116, 104, 101,
   32, 101, 110, 118, 105, 111, 117, 114, 109, 101, 110, 116,  32,  99,  97, 110,
   32,  98, 101,  32, 112, 114, 111, 118, 105, 100, 101, 100,  46,  32, 101, 110,
  118,  32, 105, 115,  32,  97,  32, 116,  97,  98, 108, 101,  46,  10,  32,  32,
  101, 110, 118, 115, 116, 114,  32,  61,  32, 116,  97,  98, 108, 101, 116, 111,
  115, 116, 114, 105, 110, 103,  40, 101, 110, 118,  41,  10,  32,  32, 115, 116,
  114,  32,  61,  32,  91,  91,  10,  32,  32,  32,  32, 101, 110, 118,  32,  61,
   32,  93,  93,  46,  46, 101, 110, 118, 115, 116, 114,  46,  46,  91,  91,  10,
   32,  32,  32,  32, 102, 111, 114,  32,  40, 105,  44,  32, 118,  32, 105, 110,
   32, 112,  97, 105, 114, 115,  40, 101, 110, 118,  41,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  95,  71,  91, 105,  93,  32,  61,  32, 118,  10,  32,
   32,  32,  32, 125,  10,  10,  32,  32,  93,  93,  46,  46, 115, 116, 114,  10,
   10,  32,  32, 114, 101, 116, 117, 114, 110,  32, 108, 111,  97, 100, 115, 116,
  114, 105, 110, 103,  40, 114, 101, 118, 105, 118, 101,  40, 115, 116, 114,  41,
   41,  59,  10, 125,  10,  10,  47,  47,  32,  84,  89,  80,  69,  83,  10, 116,
  121, 112, 101, 115,  32,  61,  32, 123,  10,  32,  32,  34, 115, 116, 114, 105,
  110, 103,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116,
  101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99,
  107,  32, 105, 102,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97,  32, 115,
  116, 114, 105, 110, 103,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34,
  115, 116, 114, 105, 110, 103,  34,  10,  32,  32, 125,  44,  10,  32,  32,  34,
  112, 111, 115,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105,
  116, 101, 109,  41, 123,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32, 109,  97, 116, 104,  46,  97,  98, 115,  40, 105, 116, 101, 109,  41,  32,
   61,  61,  32, 105, 116, 101, 109,  10,  32,  32, 125,  44,  10,  32,  32,  34,
  110, 101, 103,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105,
  116, 101, 109,  41, 123,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32, 109,  97, 116, 104,  46,  97,  98, 115,  40, 105, 116, 101, 109,  41,  32,
   33,  61,  32, 105, 116, 101, 109,  10,  32,  32, 125,  44,  10,  32,  32,  34,
  112, 111, 115, 105, 110, 116,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32, 114, 101, 116,
  117, 114, 110,  32, 109,  97, 116, 104,  46,  97,  98, 115,  40, 105, 116, 101,
  109,  41,  32,  61,  61,  32, 105, 116, 101, 109,  32,  38,  38,  32, 109,  97,
  116, 104,  46, 102, 108, 111, 111, 114,  40, 105, 116, 101, 109,  41,  32,  61,
   61,  32, 105, 116, 101, 109,  10,  32,  32, 125,  44,  10,  32,  32,  34, 110,
  101, 103, 105, 110, 116,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,
   40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32, 114, 101, 116, 117,
  114, 110,  32, 109,  97, 116, 104,  46,  97,  98, 115,  40, 105, 116, 101, 109,
   41,  32,  33,  61,  32, 105, 116, 101, 109,  32,  38,  38,  32, 109,  97, 116,
  104,  46, 102, 108, 111, 111, 114,  40, 105, 116, 101, 109,  41,  32,  61,  61,
   32, 105, 116, 101, 109,  10,  32,  32, 125,  44,  10,  32,  32,  34, 112, 111,
  105, 110, 116, 101, 114,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,
   40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67,
  104, 101,  99, 107,  32, 105, 102,  32, 116, 104, 101,  32, 105, 116, 101, 109,
   32, 105, 115,  32,  97,  32, 115, 116, 114, 105, 110, 103,  32, 119, 104, 105,
   99, 104,  32, 105, 115,  32, 112,  97, 114, 115, 101, 100,  32, 108, 105, 107,
  101,  32,  97,  32, 112, 111, 105, 110, 116, 101, 114,  10,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,
   41,  32,  61,  61,  32,  34, 115, 116, 114, 105, 110, 103,  34,  32,  38,  38,
   32, 105, 116, 101, 109,  45,  62, 109,  97, 116,  99, 104,  40,  34,  94,  37,
  115,  42,  37,  42,  37, 115,  42,  36,  34,  41,  10,  32,  32, 125,  44,  10,
   32,  32,  34,  97, 114, 114,  97, 121,  34,  58,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,
   47,  32,  77,  97, 107, 101,  32, 115, 117, 114, 101,  32, 116, 104,  97, 116,
   32,  97, 108, 108,  32, 116, 104, 101,  32, 105, 110, 100, 101, 120, 101, 115,
   32,  97, 114, 101,  32, 105, 110, 116, 101, 103, 101, 114, 115,  10,  32,  32,
   32,  32, 102, 111, 114,  32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,
   97, 105, 114, 115,  40, 105, 116, 101, 109,  41,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40, 105,  41,  32,
   33,  61,  32,  34, 110, 117, 109,  98, 101, 114,  34,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97,
  108, 115, 101,  10,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
  125,  10,  32,  32, 125,  44,  10,  32,  32,  34, 116, 101, 114, 109, 105, 110,
   97, 116, 105, 110, 103,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,
   40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67,
  104, 101,  99, 107, 115,  32, 105, 102,  32, 116, 104, 101,  32, 105, 110, 112,
  117, 116, 116, 101, 100,  32, 118,  97, 108, 117, 101,  32, 105, 115,  32,  97,
   32, 116, 101, 114, 109, 105, 110,  97, 116, 105, 110, 103,  32, 110, 117, 109,
   98, 101, 114,  32,  40,  48,  46,  53,  44,  32,  48,  46,  50,  53,  44,  32,
   48,  46,  49,  50,  53,  44,  32, 101, 116,  99,  41,  32,  98, 117, 116,  32,
  110, 111, 116,  32,  40,  46,  51,  51,  51,  46,  46,  44,  32,  46,  54,  54,
   54,  46,  46,  44,  32, 101, 116,  99,  41,  10,  32,  32,  32,  32, 114, 101,
  116, 117, 114, 110,  32, 109,  97, 116, 104,  46, 102, 108, 111, 111, 114,  40,
  105, 116, 101, 109,  41,  32,  33,  61,  32, 105, 116, 101, 109,  32,  38,  38,
   32, 109,  97, 116, 104,  46, 102, 108, 111, 111, 114,  40, 105, 116, 101, 109,
   32,  42,  32,  50,  41,  32,  61,  61,  32, 105, 116, 101, 109,  32,  42,  32,
   50,  10,  32,  32, 125,  44,  10,  32,  32,  34, 110, 111, 110, 116, 101, 114,
  109, 105, 110,  97, 116, 105, 110, 103,  34,  58,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,
   47,  32,  67, 104, 101,  99, 107, 115,  32, 105, 102,  32, 116, 104, 101,  32,
  105, 110, 112, 117, 116, 116, 101, 100,  32, 118,  97, 108, 117, 101,  32, 105,
  115,  32,  97,  32, 110, 111, 110, 116, 101, 114, 109, 105, 110,  97, 116, 105,
  110, 103,  32, 110, 117, 109,  98, 101, 114,  32,  40,  46,  51,  51,  51,  46,
   46,  44,  32,  46,  54,  54,  54,  46,  46,  44,  32, 101, 116,  99,  41,  10,
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 109,  97, 116, 104,  46,
  102, 108, 111, 111, 114,  40, 105, 116, 101, 109,  41,  32,  33,  61,  32, 105,
  116, 101, 109,  32,  38,  38,  32, 109,  97, 116, 104,  46, 102, 108, 111, 111,
  114,  40, 105, 116, 101, 109,  32,  42,  32,  50,  41,  32,  33,  61,  32, 105,
  116, 101, 109,  32,  42,  32,  50,  10,  32,  32, 125,  44,  10,  32,  32,  34,
  109,  97, 116, 114, 105, 120,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,
   67, 104, 101,  99, 107,  32, 105, 102,  32,  97, 108, 108,  32, 116, 104, 101,
   32, 118,  97, 108, 117, 101, 115,  32,  97, 114, 101,  32,  97,  32, 116,  97,
   98, 108, 101,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105,  44,  32,
  118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 105, 116, 101, 109,  41,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 116, 121,
  112, 101,  40, 118,  41,  32,  33,  61,  32,  34, 116,  97,  98, 108, 101,  34,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117,
  114, 110,  32, 102,  97, 108, 115, 101,  10,  32,  32,  32,  32,  32,  32, 125,
   10,  32,  32,  32,  32, 125,  10,  32,  32, 125,  44,  10,  32,  32,  34,  86,
  101,  99, 116, 111, 114,  51,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,
   85, 115, 101, 115,  32, 116, 104, 101,  32,  96,  86, 101,  99, 116, 111, 114,
   51,  96,  32,  99, 108,  97, 115, 115,  32,  97, 110, 100,  32,  99, 104, 101,
   99, 107,  32, 105, 102,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 105,
  116, 101, 109,  41,  32,  61,  61,  32,  34, 118, 101,  99,  51,  58,  32,  60,
  112, 111, 105, 110, 116, 101, 114,  62,  34,  10,  32,  32,  32,  32, 114, 101,
  116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,
   61,  61,  32,  34, 117, 115, 101, 114, 100,  97, 116,  97,  34,  32,  38,  38,
   32, 115, 116, 114, 105, 110, 103,  46, 109,  97, 116,  99, 104,  40, 116, 111,
  115, 116, 114, 105, 110, 103,  40, 105, 116, 101, 109,  41,  44,  32,  34,  94,
  118, 101,  99,  51,  58,  32,  34,  41,  10,  32,  32, 125,  44,  10,  32,  32,
   34,  86, 101,  99, 116, 111, 114,  50,  34,  58,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,
   47,  32,  85, 115, 101, 115,  32, 116, 104, 101,  32,  96,  86, 101,  99, 116,
  111, 114,  50,  96,  32,  99, 108,  97, 115, 115,  32,  97, 110, 100,  32,  99,
  104, 101,  99, 107,  32, 105, 102,  32, 116, 111, 115, 116, 114, 105, 110, 103,
   40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34, 118, 101,  99,  50,  58,
   32,  60, 112, 111, 105, 110, 116, 101, 114,  62,  34,  10,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,
   41,  32,  61,  61,  32,  34, 117, 115, 101, 114, 100,  97, 116,  97,  34,  32,
   38,  38,  32, 115, 116, 114, 105, 110, 103,  46, 109,  97, 116,  99, 104,  40,
  116, 111, 115, 116, 114, 105, 110, 103,  40, 105, 116, 101, 109,  41,  44,  32,
   34,  94, 118, 101,  99,  50,  58,  32,  34,  41,  10,  32,  32, 125,  44,  10,
   32,  32,  34,  67, 111, 108, 111, 114,  34,  58,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,
   47,  32,  85, 115, 101, 115,  32, 116, 104, 101,  32,  96,  67, 111, 108, 111,
  114,  96,  32,  99, 108,  97, 115, 115,  32,  97, 110, 100,  32,  99, 104, 101,
   99, 107,  32, 105, 102,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 105,
  116, 101, 109,  41,  32,  61,  61,  32,  34,  99, 111, 108, 111, 114,  58,  32,
   60, 112, 111, 105, 110, 116, 101, 114,  62,  34,  10,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,
   32,  61,  61,  32,  34, 117, 115, 101, 114, 100,  97, 116,  97,  34,  32,  38,
   38,  32, 115, 116, 114, 105, 110, 103,  46, 109,  97, 116,  99, 104,  40, 116,
  111, 115, 116, 114, 105, 110, 103,  40, 105, 116, 101, 109,  41,  44,  32,  34,
   94,  99, 111, 108, 111, 114,  58,  32,  34,  41,  10,  32,  32, 125,  44,  10,
   32,  32,  34,  84, 114,  97, 110, 115, 102, 111, 114, 109,  34,  58,  32, 102,
  117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,
   32,  32,  32,  47,  47,  32,  85, 115, 101, 115,  32, 116, 104, 101,  32,  96,
   84, 114,  97, 110, 115, 102, 111, 114, 109,  96,  32,  99, 108,  97, 115, 115,
   32,  97, 110, 100,  32,  99, 104, 101,  99, 107,  32, 105, 102,  32, 116, 111,
  115, 116, 114, 105, 110, 103,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,
   34, 116, 114,  97, 110, 115, 102, 111, 114, 109,  58,  32,  60, 112, 111, 105,
  110, 116, 101, 114,  62,  34,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114,
  110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,
   34, 117, 115, 101, 114, 100,  97, 116,  97,  34,  32,  38,  38,  32, 115, 116,
  114, 105, 110, 103,  46, 109,  97, 116,  99, 104,  40, 116, 111, 115, 116, 114,
  105, 110, 103,  40, 105, 116, 101, 109,  41,  44,  32,  34,  94, 116, 114,  97,
  110, 115, 102, 111, 114, 109,  58,  32,  34,  41,  10,  32,  32, 125,  44,  10,
   32,  32,  34, 110, 117, 109,  98, 101, 114,  34,  58,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,
   47,  47,  32,  67, 104, 101,  99, 107,  32, 105, 102,  32, 105, 116, 101, 109,
   32, 105, 115,  32,  97,  32, 110, 117, 109,  98, 101, 114,  10,  32,  32,  32,
   32, 114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101,
  109,  41,  32,  61,  61,  32,  34, 110, 117, 109,  98, 101, 114,  34,  10,  32,
   32, 125,  44,  10,  32,  32,  34,  98, 111, 111, 108, 101,  97, 110,  34,  58,
   32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,
   10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99, 107,  32, 105, 102,
   32, 105, 116, 101, 109,  32, 105, 115,  32,  97,  32,  98, 111, 111, 108, 101,
   97, 110,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 121,
  112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34,  98, 111, 111,
  108, 101,  97, 110,  34,  10,  32,  32, 125,  44,  10,  32,  32,  34, 116,  97,
   98, 108, 101,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105,
  116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,
   99, 107,  32, 105, 102,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97,  32,
  116,  97,  98, 108, 101,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34,
  116,  97,  98, 108, 101,  34,  10,  32,  32, 125,  44,  10,  32,  32,  34, 102,
  117, 110,  99, 116, 105, 111, 110,  34,  58,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,
   32,  67, 104, 101,  99, 107,  32, 105, 102,  32, 105, 116, 101, 109,  32, 105,
  115,  32,  97,  32, 102, 117, 110,  99, 116, 105, 111, 110,  10,  32,  32,  32,
   32, 114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101,
  109,  41,  32,  61,  61,  32,  34, 102, 117, 110,  99, 116, 105, 111, 110,  34,
   10,  32,  32, 125,  44,  10,  32,  32,  34, 117, 115, 101, 114, 100,  97, 116,
   97,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101,
  109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99, 107,
   32, 105, 102,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97,  32, 117, 115,
  101, 114, 100,  97, 116,  97,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114,
  110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,
   34, 117, 115, 101, 114, 100,  97, 116,  97,  34,  10,  32,  32, 125,  44,  10,
   32,  32,  34, 116, 104, 114, 101,  97, 100,  34,  58,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,
   47,  47,  32,  67, 104, 101,  99, 107,  32, 105, 102,  32, 105, 116, 101, 109,
   32, 105, 115,  32,  97,  32, 116, 104, 114, 101,  97, 100,  10,  32,  32,  32,
   32, 114, 101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101,
  109,  41,  32,  61,  61,  32,  34, 116, 104, 114, 101,  97, 100,  34,  10,  32,
   32, 125,  44,  10,  32,  32,  34, 110, 117, 108, 108,  34,  58,  32, 102, 117,
  110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,
   32,  32,  47,  47,  32,  67, 104, 101,  99, 107,  32, 105, 102,  32, 105, 116,
  101, 109,  32, 105, 115,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,
   32,  61,  61,  32,  34, 110, 117, 108, 108,  34,  10,  32,  32, 125,  44,  10,
   32,  32,  34,  99, 104,  97, 114,  34,  58,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,
   32,  67, 104, 101,  99, 107,  32, 105, 102,  32, 116, 104, 101,  32, 105, 116,
  101, 109,  32, 105, 115,  32,  97,  32, 115, 116, 114, 105, 110, 103,  32,  97,
  110, 100,  32,  49,  32,  99, 104,  97, 114,  97,  99, 116, 101, 114,  32, 108,
  111, 110, 103,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116,
  121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34, 115, 116,
  114, 105, 110, 103,  34,  32,  38,  38,  32,  35, 105, 116, 101, 109,  32,  61,
   61,  32,  49,  59,  10,  32,  32, 125,  44,  10,  32,  32,  34, 109, 115, 103,
   34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,
   41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99, 107,  32,
  105, 102,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 105, 116, 101, 109,
   41,  32,  61,  61,  32,  34, 109, 101, 115, 115,  97, 103, 101,  58,  32,  60,
  112, 111, 105, 110, 116, 101, 114,  62,  34,  10,  32,  32,  32,  32,  47,  47,
   32, 109, 101, 115, 115,  97, 103, 101, 115,  32,  97, 114, 101,  32, 117, 115,
  101, 100,  32, 105, 110,  32, 116, 104, 101,  32,  77, 101, 115, 115,  97, 103,
  101,  32, 108, 105,  98, 114,  97, 114, 121,  32, 102, 111, 114,  32,  99, 111,
  109, 109, 117, 110, 105,  99,  97, 116, 105, 111, 110,  32,  98, 101, 116, 119,
  101, 101, 110,  32, 116, 104, 114, 101,  97, 100, 115,  10,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40,
  105, 116, 101, 109,  41,  32,  61,  61,  32, 115, 116, 114, 105, 110, 103,  46,
  109,  97, 116,  99, 104,  40,  34,  94, 109, 101, 115, 115,  97, 103, 101,  58,
   32,  34,  41,  10,  32,  32, 125,  44,  10,  32,  32,  34,  99, 111, 109, 112,
  108, 101, 120,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105,
  116, 101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  84, 114, 121,
   32, 116, 111,  32, 103, 101, 116,  32, 105, 116, 101, 109,  46,  95,  95, 110,
   97, 109, 101,  44,  32, 105, 102,  32, 105, 116,  32, 105, 115,  32,  34,  99,
  111, 109, 112, 108, 101, 120,  32, 110, 117, 109,  98, 101, 114,  34,  32, 116,
  104, 101, 110,  32, 105, 116,  32, 105, 115,  32,  97,  32,  99, 111, 109, 112,
  108, 101, 120,  32, 110, 117, 109,  98, 101, 114,  10,  32,  32,  32,  32, 115,
   44,  32, 101,  32,  61,  32, 112,  99,  97, 108, 108,  40, 102, 117, 110,  99,
  116, 105, 111, 110,  40,  41, 123,  32, 105, 102,  32,  40,  33, 105, 116, 101,
  109,  46,  95,  95, 110,  97, 109, 101,  41, 123, 101, 114, 114, 111, 114,  40,
   34,  70, 111, 114,  99, 101,  32, 101, 114, 114, 111, 114,  34,  41, 125,  32,
  125,  41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 115,  10,
   32,  32, 125,  44,  10,  32,  32,  34, 100, 105, 114, 101,  99, 116, 111, 114,
  121,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101,
  109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  70, 111, 114,  32,  96,
  102, 105, 108, 101,  96,  32, 100, 105, 114, 101,  99, 116, 111, 114, 121,  32,
  116, 121, 112, 101,  10,  32,  32,  32,  32,  47,  47,  32, 114, 101, 116, 117,
  114, 110,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 105, 116, 101, 109,
   41,  32,  61,  61,  32,  34, 100, 105, 114, 101,  99, 116, 111, 114, 121,  58,
   32,  60, 112, 111, 105, 110, 116, 101, 114,  62,  34,  10,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40,
  105, 116, 101, 109,  41,  32,  61,  61,  32, 115, 116, 114, 105, 110, 103,  46,
  109,  97, 116,  99, 104,  40,  34,  94, 100, 105, 114, 101,  99, 116, 111, 114,
  121,  58,  32,  34,  41,  10,  32,  32, 125,  44,  10,  32,  32,  34, 108, 111,
   99, 107,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116,
  101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  70, 111, 114,  32,
   96, 102, 105, 108, 101,  96,  32, 108, 111,  99, 107,  32, 116, 121, 112, 101,
   10,  32,  32,  32,  32,  47,  47,  32, 114, 101, 116, 117, 114, 110,  32, 116,
  111, 115, 116, 114, 105, 110, 103,  40, 105, 116, 101, 109,  41,  32,  61,  61,
   32,  34, 108, 111,  99, 107,  58,  32,  60, 112, 111, 105, 110, 116, 101, 114,
   62,  34,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 111,
  115, 116, 114, 105, 110, 103,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,
  115, 116, 114, 105, 110, 103,  46, 109,  97, 116,  99, 104,  40,  34,  94, 108,
  111,  99, 107,  58,  32,  34,  41,  10,  32,  32, 125,  44,  10,  32,  32,  34,
  112, 114, 111, 116, 101,  99, 116, 101, 100,  34,  58,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,  10,  32,  32,  32,  32,
   47,  47,  32, 114, 101, 116, 117, 114, 110,  32, 103, 101, 116, 109, 101, 116,
   97, 116,  97,  98, 108, 101,  40, 105, 116, 101, 109,  41,  46,  95,  95, 109,
  101, 116,  97, 116,  97,  98, 108, 101,  32,  33,  61,  32, 110, 105, 108,  10,
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 103, 101, 116, 109, 101,
  116,  97, 116,  97,  98, 108, 101,  40, 105, 116, 101, 109,  41,  46,  95,  95,
  109, 101, 116,  97, 116,  97,  98, 108, 101,  32,  33,  61,  32, 110, 117, 108,
  108,  10,  32,  32, 125,  44,  10,  32,  32,  34,  95,  76,  85,  65,  66,  79,
   88,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101,
  109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99, 107,
   32, 105, 102,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40, 105, 116, 101,
  109,  41,  32,  61,  61,  32,  34,  76,  85,  65,  66,  79,  88,  58,  32,  60,
  112, 111, 105, 110, 116, 101, 114,  62,  34,  10,  32,  32,  32,  32,  47,  47,
   32, 116, 104, 105, 115,  32, 115, 104, 111, 117, 108, 100, 110, 116,  32,  98,
  101,  32, 117, 115, 101, 100,  32, 102, 111, 114,  32,  97, 118, 101, 114,  97,
  103, 101,  32,  99, 111, 100, 101,  44,  32,  76,  85,  65,  66,  79,  88,  32,
  105, 115,  32, 105, 110, 116, 101, 114, 110,  97, 108,  10,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  32, 116, 111, 115, 116, 114, 105, 110, 103,  40,
  105, 116, 101, 109,  41,  32,  61,  61,  32, 115, 116, 114, 105, 110, 103,  46,
  109,  97, 116,  99, 104,  40,  34,  94,  76,  85,  65,  66,  79,  88,  58,  32,
   34,  41,  10,  32,  32, 125,  44,  10,  32,  32,  34,  97, 110, 121,  34,  58,
   32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,  41, 123,
   10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99, 107,  32, 105, 102,
   32, 105, 116, 101, 109,  32, 105, 115,  32,  97, 110, 121,  32, 116, 121, 112,
  101,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 114, 117,
  101,  10,  32,  32, 125,  44,  10,  32,  32,  34, 116, 104, 114, 101,  97, 100,
   34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101, 109,
   41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99, 107,  32,
  105, 102,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97,  32, 116, 104, 114,
  101,  97, 100,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116,
  121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34, 116, 104,
  114, 101,  97, 100,  34,  10,  32,  32, 125,  44,  10,  32,  32,  34, 105, 110,
  116,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101,
  109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99, 107,
   32, 105, 102,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97, 110,  32, 105,
  110, 116, 101, 103, 101, 114,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114,
  110,  32, 116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,
   34, 110, 117, 109,  98, 101, 114,  34,  32,  38,  38,  32, 109,  97, 116, 104,
   46, 102, 108, 111, 111, 114,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,
  105, 116, 101, 109,  10,  32,  32, 125,  44,  10,  32,  32,  34, 102, 108, 111,
   97, 116,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116,
  101, 109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99,
  107,  32, 105, 102,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97,  32, 102,
  108, 111,  97, 116,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,
  116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34, 110,
  117, 109,  98, 101, 114,  34,  32,  38,  38,  32, 109,  97, 116, 104,  46, 102,
  108, 111, 111, 114,  40, 105, 116, 101, 109,  41,  32,  33,  61,  32, 105, 116,
  101, 109,  10,  32,  32, 125,  44,  10,  32,  32,  34, 100, 111, 117,  98, 108,
  101,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 105, 116, 101,
  109,  41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99, 107,
   32, 105, 102,  32, 105, 116, 101, 109,  32, 105, 115,  32,  97,  32, 100, 111,
  117,  98, 108, 101,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,
  116, 121, 112, 101,  40, 105, 116, 101, 109,  41,  32,  61,  61,  32,  34, 110,
  117, 109,  98, 101, 114,  34,  32,  38,  38,  32, 109,  97, 116, 104,  46, 102,
  108, 111, 111, 114,  40, 105, 116, 101, 109,  41,  32,  33,  61,  32, 105, 116,
  101, 109,  10,  32,  32, 125,  44,  10, 125,  59,  10,  97, 108, 108, 116, 121,
  112, 101, 115,  32,  61,  32,  91,  93,  10,  10, 102, 111, 114,  32,  40, 105,
   44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 116, 121, 112,
  101, 115,  41,  41,  32, 123,  10,  32,  32, 116,  97,  98, 108, 101,  46, 105,
  110, 115, 101, 114, 116,  40,  97, 108, 108, 116, 121, 112, 101, 115,  44,  32,
  105,  41,  10, 125,  10,  10,  47,  47,  32,  80,  65,  82,  83,  69,  82,  10,
  102, 117, 110,  99, 116, 105, 111, 110,  32, 100, 101, 102, 102, 105, 110, 100,
   40, 115, 116, 114,  41,  32, 123,  10,  32,  32,  32,  32,  47,  47,  32,  84,
   97, 107, 101, 115,  32, 105, 110,  32,  99, 111, 100, 101,  32,  97, 110, 100,
   32, 108, 111, 111, 107, 115,  32, 102, 111, 114,  32, 100, 101, 102, 105, 110,
  105, 116, 105, 111, 110, 115,  32, 119, 105, 116, 104,  32,  97, 110, 110, 111,
  116,  97, 116, 105, 111, 110, 115,  10,  32,  32,  32,  32, 118,  97, 114,  32,
  112,  97, 116, 116, 101, 114, 110,  32,  61,  32,  34,  94,  37, 115,  42, 118,
   97, 114,  37, 115,  43,  40,  91,  94,  37, 115,  93,  43,  41,  37, 115,  42,
   58,  37, 115,  42,  40,  91,  94,  37, 115,  93,  43,  41,  37, 115,  42,  61,
   37, 115,  42,  40,  91,  94,  37, 115,  93,  43,  41,  37, 115,  42,  36,  34,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 112,  97, 116, 116, 101, 114,
  110,  32,  61,  32,  34,  94,  37, 115,  42, 118,  97, 114,  37, 115,  43,  40,
   91,  94,  37, 115,  93,  43,  41,  37, 115,  42,  58,  37, 115,  42,  40,  91,
   94,  37, 115,  93,  43,  41,  37, 115,  42,  61,  37, 115,  42,  40,  46,  45,
   41,  37, 115,  42,  36,  34,  59,  10,  32,  32,  32,  32, 118,  97, 114,  32,
  114, 101, 115, 117, 108, 116,  32,  61,  32, 123, 125,  59,  10,  32,  32,  32,
   32, 102, 111, 114,  40,  32, 108, 105, 110, 101,  32, 105, 110,  32, 115, 116,
  114,  45,  62, 103, 109,  97, 116,  99, 104,  40,  34,  91,  94,  92, 114,  92,
  110,  93,  43,  34,  41,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32, 118,  97, 114, 116,  44,  32, 107, 101, 121,  44,  32, 118,
   97, 108, 117, 101,  32,  61,  32, 108, 105, 110, 101,  45,  62, 109,  97, 116,
   99, 104,  40, 112,  97, 116, 116, 101, 114, 110,  41,  59,  10,  32,  32,  32,
   32,  32,  32, 105, 102,  40,  32, 118,  97, 114, 116,  32,  38,  38,  32, 107,
  101, 121,  32,  38,  38,  32, 118,  97, 108, 117, 101,  32,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105, 110,
  115, 101, 114, 116,  40, 114, 101, 115, 117, 108, 116,  44,  32, 123, 118,  97,
  114, 116,  44,  32, 107, 101, 121,  44,  32, 118,  97, 108, 117, 101,  44,  32,
  108, 105, 110, 101, 125,  41,  59,  10,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,
   32, 114, 101, 115, 117, 108, 116,  59,  10, 125,  10, 102, 117, 110,  99, 116,
  105, 111, 110,  32,  97, 115, 115, 105, 103, 110,  40, 115, 116, 114,  41,  32,
  123,  10,  32,  32,  32,  32,  47,  47,  32,  84,  97, 107, 101, 115,  32, 105,
  110,  32,  99, 111, 100, 101,  32, 108, 111, 111, 107, 115,  32, 102, 111, 114,
   32,  97, 115, 115, 105, 103, 110, 109, 101, 110, 116, 115,  32, 119, 105, 116,
  104,  32,  97, 110, 110, 111, 116,  97, 116, 105, 111, 110, 115,  10,  32,  32,
   32,  32, 118,  97, 114,  32, 112,  97, 116, 116, 101, 114, 110,  32,  61,  32,
   34,  37, 115,  42,  40,  91,  94,  37, 115,  93,  43,  41,  37, 115,  42,  58,
   37, 115,  42,  40,  91,  94,  37, 115,  93,  43,  41,  37, 115,  42,  61,  37,
  115,  42,  40,  91,  94,  37, 115,  93,  43,  41,  37, 115,  42,  34,  59,  10,
   32,  32,  32,  32, 118,  97, 114,  32, 114, 101, 115, 117, 108, 116,  32,  61,
   32, 123, 125,  59,  10,  32,  32,  32,  32, 102, 111, 114,  40,  32, 108, 105,
  110, 101,  32, 105, 110,  32, 115, 116, 114,  45,  62, 103, 109,  97, 116,  99,
  104,  40,  34,  91,  94,  92, 114,  92, 110,  93,  43,  34,  41,  32,  41,  32,
  123,  10,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 118,  97, 114, 116,
   44,  32, 107, 101, 121,  44,  32, 118,  97, 108, 117, 101,  32,  61,  32, 108,
  105, 110, 101,  45,  62, 109,  97, 116,  99, 104,  40, 112,  97, 116, 116, 101,
  114, 110,  41,  59,  10,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32, 118,
   97, 114, 116,  32,  38,  38,  32, 107, 101, 121,  32,  38,  38,  32, 118,  97,
  108, 117, 101,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32,  86, 101, 114, 105, 102, 121,  32, 118,  97, 114,  44,  32, 107,
  101, 121,  44,  32, 118,  97, 108, 117, 101,  32,  97, 114, 101,  32, 110, 111,
  116,  32, 101, 108, 105, 103, 105,  98, 108, 101,  32, 102, 111, 114,  32, 100,
  101, 102,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  40,  32,  33,
   32, 100, 101, 102, 102, 105, 110, 100,  40, 108, 105, 110, 101,  41,  91,  49,
   93,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40, 114,
  101, 115, 117, 108, 116,  44,  32, 123, 118,  97, 114, 116,  44,  32, 107, 101,
  121,  44,  32, 118,  97, 108, 117, 101,  44,  32, 108, 105, 110, 101, 125,  41,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 114, 101,
  116, 117, 114, 110,  32, 114, 101, 115, 117, 108, 116,  59,  10, 125,  10, 102,
  117, 110,  99, 116, 105, 111, 110,  32, 102, 105, 110, 100, 102, 117, 110,  99,
  116, 105, 111, 110, 115,  40, 115, 116, 114,  41, 123,  10,  32,  32,  47,  47,
   32,  76, 111, 111, 107, 115,  32, 102, 111, 114,  32,  96, 102, 117, 110,  99,
  116, 105, 111, 110,  32, 120,  40,  60,  63,  62,  41,  96,  32,  97, 110, 100,
   32, 114, 101, 116, 117, 114, 110, 115,  32,  97,  32, 116,  97,  98, 108, 101,
   32, 111, 102,  32,  97, 108, 108,  32, 116, 104, 101,  32, 102, 117, 110,  99,
  116, 105, 111, 110, 115,  32,  97, 110, 100,  32, 115, 111, 117, 114,  99, 101,
   32,  99, 111, 100, 101,  10,  32,  32, 118,  97, 114,  32, 112,  97, 116, 116,
  101, 114, 110,  32,  61,  32,  34,  94,  37, 115,  42, 102, 117, 110,  99, 116,
  105, 111, 110,  37, 115,  43,  40,  91,  94,  37, 115,  93,  43,  41,  37, 115,
   42,  37,  40,  40,  91,  94,  37, 115,  93,  42,  41,  37,  41,  37, 115,  42,
   36,  34,  59,  10,  32,  32, 118,  97, 114,  32, 114, 101, 115, 117, 108, 116,
   32,  61,  32, 123, 125,  59,  10,  32,  32, 102, 111, 114,  40,  32, 108, 105,
  110, 101,  32, 105, 110,  32, 115, 116, 114,  45,  62, 103, 109,  97, 116,  99,
  104,  40,  34,  91,  94,  92, 114,  92, 110,  93,  43,  34,  41,  32,  41,  32,
  123,  10,  32,  32,  32,  32, 118,  97, 114,  32, 107, 101, 121,  44,  32, 118,
   97, 108, 117, 101,  32,  61,  32, 108, 105, 110, 101,  45,  62, 109,  97, 116,
   99, 104,  40, 112,  97, 116, 116, 101, 114, 110,  41,  59,  10,  32,  32,  32,
   32, 105, 102,  40,  32, 107, 101, 121,  32,  38,  38,  32, 118,  97, 108, 117,
  101,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108,
  101,  46, 105, 110, 115, 101, 114, 116,  40, 114, 101, 115, 117, 108, 116,  44,
   32, 123, 107, 101, 121,  44,  32, 118,  97, 108, 117, 101,  44,  32, 108, 105,
  110, 101, 125,  41,  59,  10,  32,  32,  32,  32, 125,  10,  32,  32, 125,  10,
   32,  32, 114, 101, 116, 117, 114, 110,  32, 114, 101, 115, 117, 108, 116,  59,
   10, 125,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32,  97, 108, 108,  97,
  115, 115, 105, 103, 110,  40, 115, 116, 114,  41, 123,  10,  32,  32,  47,  47,
   32,  85, 115, 101, 100,  32, 116, 111,  32, 108, 111, 111, 107,  32, 102, 111,
  114,  32, 116, 121, 112, 101, 108, 101, 115, 115,  32,  97, 115, 115, 105, 103,
  110, 109, 101, 110, 116, 115,  10,  32,  32, 118,  97, 114,  32, 112,  97, 116,
  116, 101, 114, 110,  32,  61,  32,  34,  37, 115,  42,  40,  91,  94,  37, 115,
   93,  43,  41,  37, 115,  42,  61,  37, 115,  42,  40,  91,  94,  37, 115,  93,
   43,  41,  37, 115,  42,  34,  59,  10,  32,  32, 118,  97, 114,  32, 114, 101,
  115, 117, 108, 116,  32,  61,  32, 123, 125,  59,  10,  32,  32, 102, 111, 114,
   40,  32, 108, 105, 110, 101,  32, 105, 110,  32, 115, 116, 114,  45,  62, 103,
  109,  97, 116,  99, 104,  40,  34,  91,  94,  92, 114,  92, 110,  93,  43,  34,
   41,  32,  41,  32, 123,  10,  32,  32,  32,  32, 118,  97, 114,  32, 107, 101,
  121,  44,  32, 118,  97, 108, 117, 101,  32,  61,  32, 108, 105, 110, 101,  45,
   62, 109,  97, 116,  99, 104,  40, 112,  97, 116, 116, 101, 114, 110,  41,  59,
   10,  32,  32,  32,  32, 105, 102,  40,  32, 107, 101, 121,  32,  38,  38,  32,
  118,  97, 108, 117, 101,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
  105, 102,  32,  40,  33,  32, 100, 101, 102, 102, 105, 110, 100,  40, 108, 105,
  110, 101,  41,  91,  49,  93,  32,  38,  38,  32,  33,  32,  97, 115, 115, 105,
  103, 110,  40, 108, 105, 110, 101,  41,  91,  49,  93,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105, 110, 115,
  101, 114, 116,  40, 114, 101, 115, 117, 108, 116,  44,  32, 123, 107, 101, 121,
   44,  32, 118,  97, 108, 117, 101,  44,  32, 108, 105, 110, 101, 125,  41,  59,
   10,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  32,
   32, 125,  10,  32,  32, 114, 101, 116, 117, 114, 110,  32, 114, 101, 115, 117,
  108, 116,  59,  10, 125,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 102,
  105, 110, 100,  97, 108, 108,  40, 115, 116, 114,  41, 123,  10,  32,  32,  47,
   47,  32,  85, 115, 101, 100,  32, 116, 111,  32, 108, 111, 111, 107,  32, 102,
  111, 114,  32,  37, 115,  61,  37, 115,  10,  32,  32, 118,  97, 114,  32, 112,
   97, 116, 116, 101, 114, 110,  32,  61,  32,  34,  37, 115,  42,  61,  37, 115,
   42,  34,  59,  10,  32,  32, 118,  97, 114,  32, 114, 101, 115, 117, 108, 116,
   32,  61,  32, 123, 125,  59,  10,  32,  32, 102, 111, 114,  40,  32, 108, 105,
  110, 101,  32, 105, 110,  32, 115, 116, 114,  45,  62, 103, 109,  97, 116,  99,
  104,  40,  34,  91,  94,  92, 114,  92, 110,  93,  43,  34,  41,  32,  41,  32,
  123,  10,  32,  32,  32,  32, 118,  97, 114,  32, 107, 101, 121,  44,  32, 118,
   97, 108, 117, 101,  32,  61,  32, 108, 105, 110, 101,  45,  62, 109,  97, 116,
   99, 104,  40, 112,  97, 116, 116, 101, 114, 110,  41,  59,  10,  32,  32,  32,
   32, 105, 102,  40,  32, 107, 101, 121,  32,  38,  38,  32, 118,  97, 108, 117,
  101,  32,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32, 116,  97,  98, 108,
  101,  46, 105, 110, 115, 101, 114, 116,  40, 114, 101, 115, 117, 108, 116,  44,
   32, 123, 107, 101, 121,  44,  32, 118,  97, 108, 117, 101,  44,  32, 108, 105,
  110, 101, 125,  41,  59,  10,  32,  32,  32,  32, 125,  10,  32,  32, 125,  10,
   32,  32, 114, 101, 116, 117, 114, 110,  32, 114, 101, 115, 117, 108, 116,  59,
   10, 125,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 114, 101, 118, 105,
  118, 101,  40, 115, 116, 114,  41, 123,  10,  32,  32, 102, 111, 114,  32,  40,
  105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 100, 101,
   97, 100,  41,  41, 123,  10,  32,  32,  32,  32, 118,  97, 114,  32, 105, 110,
  100, 101, 120,  32,  61,  32,  34,  39,  68,  69,  65,  68,  86,  65,  76,  85,
   69,  83,  84,  82,  84,  89,  80,  69,  67,  72,  69,  67,  75,  45,  34,  46,
   46,  40, 105,  41,  46,  46,  34,  39,  34,  10,  10,  32,  32,  32,  32,  47,
   47,  32,  71, 111,  32,  99, 104,  97, 114,  97,  99, 116, 101, 114,  32,  98,
  121,  32,  99, 104,  97, 114,  97,  99, 116, 101, 114,  32,  97, 110, 100,  32,
  108, 111, 111, 107,  32, 102, 111, 114,  32, 105, 110, 100, 101, 120,  10,  32,
   32,  32,  32,  47,  47,  32,  73,  32, 119,  97, 110, 116,  32, 116, 111,  32,
  117, 115, 101,  32,  45,  62, 103, 115, 117,  98,  32,  98, 117, 116,  32, 116,
  104,  97, 116,  32, 100, 111, 101, 115, 110, 116,  32, 119, 111, 114, 107,  32,
  102, 111, 114,  32, 115, 117, 109,  32, 114, 101,  97, 115, 111, 110,  32, 115,
  111,  32,  73,  32,  97, 109,  32, 117, 115, 105, 110, 103,  32,  97,  32,  10,
   32,  32,  32,  32,  47,  47,  32, 109,  97, 110, 117,  97, 108,  32, 109, 101,
  116, 104, 111, 100,  10,  32,  32,  32,  32, 118,  97, 114,  32,  99, 105,  32,
   61,  32,  49,  59,  10,  32,  32,  32,  32, 118,  97, 114,  32,  99, 115, 111,
  102,  97, 114,  32,  61,  32,  34,  34,  59,  10,  32,  32,  32,  32, 102, 111,
  114,  32,  40, 105, 105,  32,  61,  32,  49,  44,  32,  35, 115, 116, 114,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  99, 104,  97,
  114,  32,  61,  32, 115, 116, 114,  45,  62, 115, 117,  98,  40, 105, 105,  44,
   32, 105, 105,  41,  59,  10,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,
   99, 104,  97, 114,  32,  61,  61,  32, 105, 110, 100, 101, 120,  45,  62, 115,
  117,  98,  40,  99, 105,  44,  32,  99, 105,  41,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  99, 105,  43,  43,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  99, 115, 111, 102,  97, 114,  32,  61,  32,  99, 115, 111,
  102,  97, 114,  46,  46,  99, 104,  97, 114,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 102,  32,  40,  99, 115, 111, 102,  97, 114,  32,  61,  61,
   32, 105, 110, 100, 101, 120,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 115, 116, 114,  32,  61,  32, 115, 116, 114,  45,  62, 115,
  117,  98,  40,  49,  44,  32, 105, 105,  32,  45,  32,  35, 105, 110, 100, 101,
  120,  41,  46,  46, 118,  46,  46, 115, 116, 114,  45,  62, 115, 117,  98,  40,
  105, 105,  32,  43,  32,  49,  44,  32,  35, 115, 116, 114,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32, 125,
   32, 101, 108, 115, 101,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   99, 105,  32,  61,  32,  49,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   99, 115, 111, 102,  97, 114,  32,  61,  32,  34,  34,  59,  10,  32,  32,  32,
   32,  32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  32,  32, 125,  10,  32,
   32, 114, 101, 116, 117, 114, 110,  32, 115, 116, 114,  10, 125,  10, 102, 117,
  110,  99, 116, 105, 111, 110,  32,  99, 108, 101,  97, 110,  40, 115, 116, 114,
   41,  32, 123,  10,  32,  32,  47,  47,  32,  84,  97, 107, 101, 115,  32, 105,
  110,  32,  99, 111, 100, 101,  32,  97, 110, 100,  32, 114, 101, 109, 111, 118,
  101, 115,  32,  99, 111, 109, 109, 101, 110, 116, 115,  44,  32, 115, 116, 114,
  105, 110, 103, 115,  46,  10,  32,  32,  47,  47,  32,  82, 101, 109, 111, 118,
  101,  32, 115, 116, 114, 105, 110, 103, 115,  32,  97, 110, 100,  32,  97, 100,
  100,  32, 105, 116,  32, 116, 111,  32,  34, 100, 101,  97, 100,  34,  32, 116,
   97,  98, 108, 101,  10,  32,  32, 118,  97, 114,  32, 100, 101,  97, 100,  32,
   61,  32, 123, 125,  59,  10,  32,  32, 118,  97, 114,  32, 105,  32,  61,  32,
   48,  59,  10,  32,  32, 111, 103, 115, 116, 114,  32,  61,  32, 115, 116, 114,
   59,  10,  32,  32, 105, 102,  32,  40,  33, 115, 116, 114,  91,  34, 103, 115,
  117,  98,  34,  93,  41,  32, 116, 121, 112, 101, 114, 114, 111, 114,  40,  34,
  115, 116, 114, 105, 110, 103,  46, 103, 115, 117,  98,  32, 105, 115,  32, 110,
  111, 116,  32,  97,  32, 102, 111, 117, 110, 100,  32, 102, 117, 110,  99, 116,
  105, 111, 110,  44,  32,  65, 114, 101,  32, 121, 111, 117,  32, 115, 117, 114,
  101,  32, 121, 111, 117,  32, 112, 114, 111, 118, 105, 100, 101, 100,  32,  97,
   32, 115, 116, 114, 105, 110, 103,  63,  34,  41,  10,  32,  32, 115, 116, 114,
   32,  61,  32, 115, 116, 114,  45,  62, 103, 115, 117,  98,  40,  34,  39,  91,
   94,  39,  93,  45,  39,  34,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,
   40, 109,  97, 116,  99, 104,  41, 123,  10,  32,  32,  32,  32, 105,  43,  43,
   59,  10,  32,  32,  32,  32, 100, 101,  97, 100,  91, 105,  93,  32,  61,  32,
  109,  97, 116,  99, 104,  59,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114,
  110,  32,  34,  39,  68,  69,  65,  68,  86,  65,  76,  85,  69,  83,  84,  82,
   84,  89,  80,  69,  67,  72,  69,  67,  75,  45,  34,  46,  46,  40, 105,  41,
   46,  46,  34,  39,  34,  59,  10,  32,  32, 125,  41,  45,  62, 103, 115, 117,
   98,  40,  39,  34,  91,  94,  34,  93,  45,  34,  39,  44,  32, 102, 117, 110,
   99, 116, 105, 111, 110,  40, 109,  97, 116,  99, 104,  41, 123,  10,  32,  32,
   32,  32, 105,  43,  43,  59,  10,  32,  32,  32,  32, 100, 101,  97, 100,  91,
  105,  93,  32,  61,  32, 109,  97, 116,  99, 104,  59,  10,  32,  32,  32,  32,
  114, 101, 116, 117, 114, 110,  32,  34,  39,  68,  69,  65,  68,  86,  65,  76,
   85,  69,  83,  84,  82,  84,  89,  80,  69,  67,  72,  69,  67,  75,  45,  34,
   46,  46,  40, 105,  41,  46,  46,  34,  39,  34,  59,  10,  32,  32, 125,  41,
   45,  62, 103, 115, 117,  98,  40,  39,  37,  91,  37,  91,  46,  45,  37,  93,
   37,  93,  39,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 109,  97,
  116,  99, 104,  41, 123,  10,  32,  32,  32,  32, 105,  43,  43,  59,  10,  32,
   32,  32,  32, 100, 101,  97, 100,  91, 105,  93,  32,  61,  32, 109,  97, 116,
   99, 104,  59,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  34,
   39,  68,  69,  65,  68,  86,  65,  76,  85,  69,  83,  84,  82,  84,  89,  80,
   69,  67,  72,  69,  67,  75,  45,  34,  46,  46,  40, 105,  41,  46,  46,  34,
   39,  34,  59,  10,  32,  32, 125,  41,  59,  10,  32,  32, 114, 101, 116, 117,
  114, 110,  32, 115, 116, 114,  45,  62, 103, 115, 117,  98,  40,  39,  47,  47,
   46,  45,  92, 110,  39,  44,  32,  39,  92, 110,  39,  41,  45,  62, 103, 115,
  117,  98,  40,  39,  47,  37,  42,  46,  45,  37,  42,  47,  39,  44,  32,  39,
   92, 110,  39,  41,  44,  32, 100, 101,  97, 100,  59,  10, 125,  10,  10,  47,
   47,  32,  67,  72,  69,  67,  75,  69,  82,  10, 116, 121, 112, 101, 111, 102,
   32,  61,  32, 116, 121, 112, 101,  59,  10, 102, 117, 110,  99, 116, 105, 111,
  110,  32,  99, 104, 101,  99, 107,  40, 116, 121, 112, 101,  44,  32, 118,  97,
  108, 117, 101,  44,  32, 118, 110,  97, 109, 101,  44,  32, 107, 110, 111, 119,
  110,  86,  97, 108, 117, 101, 115,  44,  32, 108, 105, 110, 101,  41,  32, 123,
   10,  32,  32, 118,  97, 108, 117, 101,  44,  32, 101, 114, 114,  32,  61,  32,
  108, 111,  97, 100, 101, 110, 118,  40, 107, 110, 111, 119, 110,  86,  97, 108,
  117, 101, 115,  44,  32,  34, 114, 101, 116, 117, 114, 110,  32,  34,  32,  46,
   46,  32, 118,  97, 108, 117, 101,  41,  10,  32,  32, 105, 102,  32,  40,  33,
  118,  97, 108, 117, 101,  41, 123,  10,  32,  32,  32,  32, 116, 121, 112, 101,
  114, 114, 111, 114,  40,  34,  67, 104, 101,  99, 107,  32, 101, 114, 114, 111,
  114,  58,  32,  34,  46,  46, 101, 114, 114,  44,  32, 108, 105, 110, 101,  41,
   10,  32,  32, 125,  10,  32,  32, 120, 112,  99,  97, 108, 108,  40, 102, 117,
  110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32, 118,  97,
  108, 117, 101,  32,  61,  32, 118,  97, 108, 117, 101,  40,  41,  59,  10,  32,
   32, 125,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 101, 114, 114,
   41, 123,  10,  32,  32,  32,  32,  47,  47,  32,  73, 103, 110, 111, 114, 101,
   32,  97, 110, 100,  32, 114, 101, 116, 117, 114, 110,  32, 116, 114, 117, 101,
   10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 114, 117, 101,
   59,  10,  32,  32, 125,  41,  10,  32,  32, 105, 102,  40,  32, 116, 121, 112,
  101, 115,  91, 116, 121, 112, 101,  93,  32,  41,  32, 123,  10,  32,  32,  32,
   32, 105, 102,  32,  40, 116, 121, 112, 101, 115,  91, 116, 121, 112, 101,  93,
   40, 118,  97, 108, 117, 101,  41,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32, 114, 101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  59,  10,  32,  32,
   32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,  32,  32,  32,  32,  32,
   32, 105, 102,  32,  40, 116, 121, 112, 101, 111, 102,  40, 118,  97, 108, 117,
  101,  41,  32,  61,  61,  32,  34, 102, 117, 110,  99, 116, 105, 111, 110,  34,
   41,  32, 114, 101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  59,  32,  47,
   47,  32,  73, 103, 110, 111, 114, 101,  32, 102, 111, 114,  32, 110, 111, 119,
   10,  32,  32,  32,  32,  32,  32, 116, 121, 112, 101, 114, 114, 111, 114,  40,
   99, 111, 114, 101,  46, 101, 114, 114, 111, 114,  46, 115, 116, 114, 101, 114,
  114, 111, 114,  40,  49,  49,  49,  41,  45,  62, 102, 111, 114, 109,  97, 116,
   40, 116, 121, 112, 101,  44,  32,  40, 116, 111, 115, 116, 114, 105, 110, 103,
   40, 116, 121, 112, 101, 111, 102,  40, 118,  97, 108, 117, 101,  41,  41,  46,
   46,  34,  32,  40,  97, 110, 100,  32, 105, 116,  39, 115,  32, 100, 101, 115,
   99, 101, 110, 100, 101, 110, 116, 115,  41,  34,  41,  44,  32, 118, 110,  97,
  109, 101,  41,  44,  32, 108, 105, 110, 101,  41,  59,  10,  32,  32,  32,  32,
  125,  10,  32,  32, 125,  32, 101, 108, 115, 101,  32, 123,  10,  32,  32,  32,
   32, 116, 121, 112, 101, 114, 114, 111, 114,  40,  99, 111, 114, 101,  46, 101,
  114, 114, 111, 114,  46, 115, 116, 114, 101, 114, 114, 111, 114,  40,  49,  49,
   50,  41,  45,  62, 102, 111, 114, 109,  97, 116,  40, 116, 121, 112, 101,  41,
   44,  32, 108, 105, 110, 101,  44,  32,  34,  85, 115, 101,  32,  96,  99, 111,
   98,  97, 108, 116, 112, 114, 101,  32,  45, 116, 121, 112, 101, 115,  96,  32,
  116, 111,  32, 115, 101, 101,  32,  97, 108, 108,  32, 116, 121, 112, 101, 115,
   34,  41,  59,  10,  32,  32, 125,  10, 125,  10,  10,  47,  47,  32,  77,  65,
   73,  78,  10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 116, 121, 112, 101,
   99, 104, 101,  99, 107,  40,  99, 111, 100, 101,  41, 123,  10,  32,  32,  99,
  108, 101,  97, 110, 101, 100,  67, 111, 100, 101,  44,  32, 110, 101, 119, 100,
  101,  97, 100,  32,  61,  32,  99, 108, 101,  97, 110,  40,  99, 111, 100, 101,
   41,  59,  10,  32,  32, 100, 101,  97, 100,  32,  61,  32, 110, 101, 119, 100,
  101,  97, 100,  59,  10,  32,  32, 102, 111, 114,  32,  40, 105,  44,  32, 118,
   32, 105, 110,  32, 112,  97, 105, 114, 115,  40,  99, 108, 101,  97, 110, 101,
  100,  67, 111, 100, 101,  45,  62, 115, 112, 108, 105, 116,  40,  34,  92, 110,
   34,  41,  41,  41, 123,  10,  32,  32,  32,  32,  99, 108, 101,  97, 110, 101,
  100,  67, 111, 100, 101,  32,  61,  32,  99, 108, 101,  97, 110, 101, 100,  67,
  111, 100, 101,  45,  62, 115, 112, 108, 105, 116,  40,  34,  92, 110,  34,  41,
   91, 105,  93,  32, 124, 124,  32,  34,  34,  59,  10,  32,  32,  32,  32, 118,
   97, 114,  32, 100, 101, 102, 115,  32,  61,  32, 100, 101, 102, 102, 105, 110,
  100,  40,  99, 108, 101,  97, 110, 101, 100,  67, 111, 100, 101,  41,  59,  10,
   32,  32,  32,  32, 118,  97, 114,  32,  97, 115, 115, 105, 103, 110, 115,  32,
   61,  32,  97, 115, 115, 105, 103, 110,  40,  99, 108, 101,  97, 110, 101, 100,
   67, 111, 100, 101,  41,  59,  10,  32,  32,  32,  32, 118,  97, 114,  32,  97,
  108, 108,  97, 115, 115, 105, 103, 110, 115,  32,  61,  32,  97, 108, 108,  97,
  115, 115, 105, 103, 110,  40,  99, 108, 101,  97, 110, 101, 100,  67, 111, 100,
  101,  41,  59,  10,  32,  32,  32,  32, 118,  97, 114,  32, 102, 117, 110,  99,
  116, 105, 111, 110, 115,  32,  61,  32, 102, 105, 110, 100, 102, 117, 110,  99,
  116, 105, 111, 110, 115,  40,  99, 108, 101,  97, 110, 101, 100,  67, 111, 100,
  101,  41,  59,  10,  32,  32,  32,  32, 118,  97, 114,  32,  97, 108, 108,  32,
   61,  32, 102, 105, 110, 100,  97, 108, 108,  40,  99, 108, 101,  97, 110, 101,
  100,  67, 111, 100, 101,  41,  59,  10,  10,  32,  32,  32,  32, 118,  97, 114,
   32, 107, 110, 111, 119, 110,  84, 121, 112, 101, 115,  32,  61,  32, 123, 125,
   59,  10,  32,  32,  32,  32, 118,  97, 114,  32, 107, 110, 111, 119, 110,  86,
   97, 108, 117, 101, 115,  32,  61,  32, 123, 125,  59,  32,  10,  32,  32,  32,
   32, 102, 111, 114,  40,  32,  95,  44,  32, 100, 101, 102,  32, 105, 110,  32,
  112,  97, 105, 114, 115,  40, 100, 101, 102, 115,  41,  32,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  99, 104, 101,  99, 107,  40, 100, 101, 102,  91,
   50,  93,  44,  32, 100, 101, 102,  91,  51,  93,  44,  32, 100, 101, 102,  91,
   49,  93,  44,  32, 107, 110, 111, 119, 110,  86,  97, 108, 117, 101, 115,  44,
   32, 100, 101, 102,  91,  52,  93,  41,  10,  32,  32,  32,  32,  32,  32, 118,
   97, 108, 117, 101,  44,  32, 101, 114, 114,  32,  61,  32, 108, 111,  97, 100,
  101, 110, 118,  40, 107, 110, 111, 119, 110,  86,  97, 108, 117, 101, 115,  44,
   32,  34, 114, 101, 116, 117, 114, 110,  32,  34,  32,  46,  46,  32, 100, 101,
  102,  91,  51,  93,  41,  10,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,
   33, 118,  97, 108, 117, 101,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 116, 121, 112, 101, 114, 114, 111, 114,  40,  34,  67, 104, 101,  99, 107,
   32, 101, 114, 114, 111, 114,  58,  32,  34,  46,  46, 101, 114, 114,  41,  10,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32, 107, 110,
  111, 119, 110,  84, 121, 112, 101, 115,  91, 100, 101, 102,  91,  49,  93,  93,
   32,  61,  32, 100, 101, 102,  91,  50,  93,  59,  10,  32,  32,  32,  32,  32,
   32, 120, 112,  99,  97, 108, 108,  40, 102, 117, 110,  99, 116, 105, 111, 110,
   40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 107, 110, 111, 119,
  110,  86,  97, 108, 117, 101, 115,  91, 100, 101, 102,  91,  49,  93,  93,  32,
   61,  32, 118,  97, 108, 117, 101,  40,  41,  59,  10,  32,  32,  32,  32,  32,
   32, 125,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 101, 114, 114,
   41, 123, 125,  41,  10,  32,  32,  32,  32,  32,  32,  10,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32, 102, 111, 114,  40,  32,  95,  44,  32,  97, 108,
  108,  97, 115, 115, 105, 103, 110,  32, 105, 110,  32, 112,  97, 105, 114, 115,
   40,  97, 108, 108,  97, 115, 115, 105, 103, 110, 115,  41,  32,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 107, 110, 111, 119, 110,
   84, 121, 112, 101, 115,  91,  97, 108, 108,  97, 115, 115, 105, 103, 110,  91,
   49,  93,  93,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  99,
  104, 101,  99, 107,  40, 107, 110, 111, 119, 110,  84, 121, 112, 101, 115,  91,
   97, 108, 108,  97, 115, 115, 105, 103, 110,  91,  49,  93,  93,  44,  32,  97,
  108, 108,  97, 115, 115, 105, 103, 110,  91,  50,  93,  44,  32,  97, 108, 108,
   97, 115, 115, 105, 103, 110,  91,  49,  93,  44,  32, 107, 110, 111, 119, 110,
   86,  97, 108, 117, 101, 115,  44,  32,  97, 108, 108,  97, 115, 115, 105, 103,
  110,  91,  51,  93,  41,  59,  10,  32,  32,  32,  32,  32,  32, 125, 101, 108,
  115, 101,  32, 105, 102,  40,  33, 107, 110, 111, 119, 110,  86,  97, 108, 117,
  101, 115,  91,  97, 108, 108,  97, 115, 115, 105, 103, 110,  91,  49,  93,  93,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 107, 110, 111, 119,
  110,  86,  97, 108, 117, 101, 115,  91,  97, 108, 108,  97, 115, 115, 105, 103,
  110,  91,  49,  93,  93,  32,  61,  32,  97, 108, 108,  97, 115, 115, 105, 103,
  110,  91,  50,  93,  59,  10,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32, 102, 111, 114,  40,  32,  95,  44,  32,
   97, 115, 115, 105, 103, 110,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40,
   97, 115, 115, 105, 103, 110, 115,  41,  32,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  99, 104, 101,  99, 107,  40,  97, 115, 115, 105, 103, 110,  91,
   50,  93,  44,  32,  97, 115, 115, 105, 103, 110,  91,  51,  93,  44,  32,  97,
  115, 115, 105, 103, 110,  91,  49,  93,  44,  32, 107, 110, 111, 119, 110,  86,
   97, 108, 117, 101, 115,  44,  32,  97, 115, 115, 105, 103, 110,  91,  52,  93,
   41,  59,  10,  32,  32,  32,  32,  32,  32, 107, 110, 111, 119, 110,  86,  97,
  108, 117, 101, 115,  91,  97, 115, 115, 105, 103, 110,  91,  49,  93,  93,  32,
   61,  32,  97, 115, 115, 105, 103, 110,  91,  51,  93,  59,  10,  32,  32,  32,
   32,  32,  32, 107, 110, 111, 119, 110,  84, 121, 112, 101, 115,  91,  97, 115,
  115, 105, 103, 110,  91,  49,  93,  93,  32,  61,  32,  97, 115, 115, 105, 103,
  110,  91,  50,  93,  59,  10,  32,  32,  32,  32, 125,  10,  32,  32, 125,  10,
   32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  59,  10, 125,
   10, 102, 117, 110,  99, 116, 105, 111, 110,  32,  97, 108, 108,  40,  41, 123,
   10,  32,  32,  47,  47,  32,  80, 114, 105, 110, 116, 115,  32,  97, 108, 108,
   32, 116, 121, 112, 101, 115,  10,  32,  32, 112, 114, 105, 110, 116,  40,  34,
   65, 108, 108,  32, 118,  97, 108, 105, 100,  32,  99, 104, 101,  99, 107,  97,
   98, 108, 101,  32, 116, 121, 112, 101, 115,  58,  34,  41,  10,  32,  32, 102,
  111, 114,  32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114,
  115,  40,  97, 108, 108, 116, 121, 112, 101, 115,  41,  41,  32, 123,  10,  32,
   32,  32,  32, 112, 114, 105, 110, 116,  40,  34,  32,  32,  34,  46,  46, 118,
   41,  10,  32,  32, 125,  10, 125,  10,  10, 116, 121, 112, 101,  99, 104, 101,
   99, 107, 101, 114,  32,  61,  32, 123,  10,  32,  32,  34,  97, 108, 108,  34,
   58,  32,  97, 108, 108,  44,  10,  32,  32,  34,  99, 104, 101,  99, 107,  34,
   58,  32, 116, 121, 112, 101,  99, 104, 101,  99, 107,  44,  10,  32,  32,  34,
   99, 108, 101,  97, 110,  34,  58,  32,  99, 108, 101,  97, 110,  44,  10,  32,
   32,  34, 114, 101, 118, 105, 118, 101,  34,  58,  32, 114, 101, 118, 105, 118,
  101,  44,  10, 125,  10,  10,  47,  42,  10,  32,  32,  67, 111,  98,  97, 108,
  116,  32,  76,  97, 110, 103, 117,  97, 103, 101,  32,  69, 120, 116, 101, 110,
  115, 105, 111, 110,  46,  10,  32,  32,  84, 104, 105, 115,  32, 112, 114, 111,
  118, 105, 100, 101, 115,  32, 101, 120, 116, 101, 110, 115, 105, 111, 110, 115,
   32, 116, 111,  32, 116, 104, 101,  32, 115, 116,  97, 110, 100,  97, 114, 100,
   32,  67, 111,  98,  97, 108, 116,  32, 108,  97, 110, 103, 117,  97, 103, 101,
   46,  32,  10,  42,  47,  10,  10,  47,  42,  32,  69,  88,  84,  69,  78,  68,
   83,  58,  10,  45,  32, 102,  34, 123, 120, 125,  34,  32,  61,  32, 115, 116,
  114, 105, 110, 103,  46, 102, 111, 114, 109,  97, 116,  40,  34,  37, 115,  34,
   44,  32, 120,  41,  10,  45,  32,  36, 116,  97,  98, 108, 101,  32,  61,  32,
  112,  97, 105, 114, 115,  40, 116,  97,  98, 108, 101,  41,  10,  45,  32,  64,
  116,  97,  98, 108, 101,  32,  61,  32, 105, 112,  97, 105, 114, 115,  40, 116,
   97,  98, 108, 101,  41,  10,  45,  32, 120, 126, 121,  32,  61,  32,  95,  71,
   46, 120,  32,  61,  32, 121,  44,  32, 114, 101, 116, 117, 114, 110,  32, 121,
   10,  45,  32, 114, 101, 109, 111, 118, 101, 115,  32,  99, 111, 109, 109, 101,
  110, 116, 115,  10,  45,  32, 118,  97, 114,  32,  91, 120,  44,  32, 121,  44,
   32, 122,  93,  32,  61,  32, 116,  98, 108,  32,  40, 120,  44,  32, 121,  44,
   32, 122,  32,  97, 114, 101,  32, 116, 104, 101,  32, 107, 101, 121, 115,  32,
  111, 102,  32, 116,  98, 108,  41,  10,  42,  47,  10,  10,  47,  42,  32,  84,
   79,  68,  79,  58,  10,  45,  32,  70, 105, 120,  32, 116, 104, 101,  32, 110,
  101, 115, 116, 101, 100,  32, 115, 116, 114, 105, 110, 103,  32,  98, 117, 103,
   10,  45,  32,  83, 116, 114, 105, 110, 103, 115,  32, 116, 104,  97, 116,  32,
   97, 114, 101,  32, 111, 112, 116, 105, 109, 105, 122, 101, 100,  32, 116, 111,
   32,  98, 101,  32,  34,  44,  32,  39,  32, 115, 104, 111, 117, 108, 100,  32,
  110, 111, 116,  32, 108, 111, 115, 101,  32, 112, 111, 119, 101, 114,  10,  42,
   47,  10,  10,  47,  42,  32,  83,  89,  83,  84,  69,  77,  58,  10,  32,  84,
  104, 105, 115,  32, 117, 115, 101, 115,  32, 116, 104, 101,  32, 116, 121, 112,
  101,  99, 104, 101,  99, 107, 101, 114,  39, 115,  32, 100, 101,  97, 100,  32,
   38,  32,  97, 108, 105, 118, 101,  32, 115, 121, 115, 116, 101, 109,  32, 116,
  111,  32,  10,  32, 107, 105, 108, 108,  32,  97, 108, 108,  32, 110, 111, 110,
   32, 115, 121, 110, 116,  97, 120,  32, 115, 116,  97, 116, 101, 109, 101, 110,
  116, 115,  32,  97, 110, 100,  32, 119, 105, 108, 108,  32, 108, 111, 111, 107,
   32, 102, 111, 114,  32,  97,  32,  10,  32, 102,  34, 120,  32, 123, 115, 116,
  114, 105, 110, 103, 125,  32, 123, 115, 116, 114, 105, 110, 103,  50, 125,  34,
   32,  97, 110, 100,  32, 114, 101, 112, 108,  97,  99, 101,  32, 105, 116,  32,
  119, 105, 116, 104,  32, 115, 116, 114, 105, 110, 103,  46, 102, 111, 114, 109,
   97, 116,  40,  34, 120,  32,  37, 115,  34,  44,  32, 115, 116, 114, 105, 110,
  103,  44,  32, 115, 116, 114, 105, 110, 103,  50,  41,  46,  10,  42,  47,  10,
   10, 102, 117, 110,  99, 116, 105, 111, 110,  32, 103, 115, 117,  98,  40, 115,
  116, 114,  44,  32, 112,  97, 116, 116, 101, 114, 110,  44,  32, 114, 101, 112,
  108,  97,  99, 101,  41, 123,  10,  32,  32,  47,  47,  32,  82,  97, 119,  32,
   71,  83,  85,  66,  32, 102, 117, 110,  99, 116, 105, 111, 110,  10,  32,  32,
  118,  97, 114,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32,  34,  34,  10,
   32,  32, 118,  97, 114,  32, 112,  97, 116, 116, 101, 114, 110,  95, 108, 101,
  110,  32,  61,  32,  35, 112,  97, 116, 116, 101, 114, 110,  10,  32,  32, 118,
   97, 114,  32, 105,  32,  61,  32,  49,  10,  32,  32, 119, 104, 105, 108, 101,
   32,  40, 105,  32,  60,  61,  32,  35, 115, 116, 114,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32, 105, 102,  32,  40, 115, 116, 114,  45,  62, 115, 117,
   98,  40, 105,  44,  32, 105,  32,  43,  32, 112,  97, 116, 116, 101, 114, 110,
   95, 108, 101, 110,  32,  45,  32,  49,  41,  32,  61,  61,  32, 112,  97, 116,
  116, 101, 114, 110,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32, 114, 101, 115, 117, 108,
  116,  32,  46,  46,  32, 114, 101, 112, 108,  97,  99, 101,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  43,  32, 112,
   97, 116, 116, 101, 114, 110,  95, 108, 101, 110,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 125, 101, 108, 115, 101, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32, 114, 101, 115,
  117, 108, 116,  32,  46,  46,  32, 115, 116, 114,  45,  62, 115, 117,  98,  40,
  105,  44,  32, 105,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  105,  32,  61,  32, 105,  32,  43,  32,  49,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  32,  32, 114, 101, 116, 117,
  114, 110,  32, 114, 101, 115, 117, 108, 116,  10, 125,  10,  10, 102, 117, 110,
   99, 116, 105, 111, 110,  32, 102, 105, 110, 100,  40, 115, 116, 114,  44,  32,
  112,  97, 116, 116, 101, 114, 110,  44,  32, 105, 110, 105, 116,  41, 123,  10,
   32,  32, 105, 110, 105, 116,  32,  61,  32, 105, 110, 105, 116,  32, 124, 124,
   32,  49,  10,  32,  32, 118,  97, 114,  32, 112,  97, 116, 116, 101, 114, 110,
   95, 108, 101, 110,  32,  61,  32,  35, 112,  97, 116, 116, 101, 114, 110,  10,
   32,  32, 118,  97, 114,  32, 105,  32,  61,  32, 105, 110, 105, 116,  10,  32,
   32, 119, 104, 105, 108, 101,  32,  40, 105,  32,  60,  61,  32,  35, 115, 116,
  114,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 115,
  116, 114,  45,  62, 115, 117,  98,  40, 105,  44,  32, 105,  32,  43,  32, 112,
   97, 116, 116, 101, 114, 110,  95, 108, 101, 110,  32,  45,  32,  49,  41,  32,
   61,  61,  32, 112,  97, 116, 116, 101, 114, 110,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 105,
   44,  32, 105,  32,  43,  32, 112,  97, 116, 116, 101, 114, 110,  95, 108, 101,
  110,  32,  45,  32,  49,  10,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  43,  32,  49,  10,  32,  32,
  125,  10,  32,  32, 114, 101, 116, 117, 114, 110,  32, 110, 117, 108, 108,  10,
  125,  10,  10, 101, 120, 116,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  40, 115, 116, 114,  41, 123,  10,  32,  32,  99, 108, 101,  97, 110, 101,
  100,  67, 111, 100, 101,  44,  32, 100, 101,  97, 100,  32,  61,  32, 116, 121,
  112, 101,  99, 104, 101,  99, 107, 101, 114,  46,  99, 108, 101,  97, 110,  40,
  115, 116, 114,  41,  10,  32,  32,  10,  32,  32, 108, 105, 110, 101, 115,  32,
   61,  32,  99, 108, 101,  97, 110, 101, 100,  67, 111, 100, 101,  45,  62, 115,
  112, 108, 105, 116,  40,  34,  92, 110,  34,  41,  10,  10,  10,  32,  32, 102,
  111, 114,  32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114,
  115,  40, 108, 105, 110, 101, 115,  41,  41, 123,  10,  32,  32,  32,  32, 118,
   99, 108, 101,  97, 110,  32,  61,  32,  32, 116, 121, 112, 101,  99, 104, 101,
   99, 107, 101, 114,  46, 114, 101, 118, 105, 118, 101,  40, 118,  44,  32, 100,
  101,  97, 100,  41,  10,  32,  32,  32,  32,  47,  47,  32,  82, 101, 112, 108,
   97,  99, 101,  32,  36, 116,  97,  98, 108, 101,  32, 119, 105, 116, 104,  32,
  112,  97, 105, 114, 115,  40, 116,  97,  98, 108, 101,  41,  44,  32,  97, 110,
  100,  32,  36,  36, 116,  97,  98, 108, 101,  32, 119, 105, 116, 104,  32, 105,
  112,  97, 105, 114, 115,  40, 116,  97,  98, 108, 101,  41,  46,  32,  77,  97,
  107, 101,  32, 115, 117, 114, 101,  32, 116, 104, 101,  32,  36,  36,  32, 100,
  111, 101, 115, 110, 116,  32, 114, 101, 110, 100, 101, 114,  32,  97, 115,  32,
   36,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40, 109,  97, 116,  99, 104,
   32, 105, 110,  32, 118,  99, 108, 101,  97, 110,  45,  62, 103, 109,  97, 116,
   99, 104,  40,  34,  64,  91,  97,  45, 122,  65,  45,  90,  48,  45,  57,  95,
   93,  43,  34,  41,  41, 123,  10,  32,  32,  32,  32,  32,  32, 118,  32,  61,
   32, 118,  45,  62, 103, 115, 117,  98,  40, 109,  97, 116,  99, 104,  44,  32,
   34, 105, 112,  97, 105, 114, 115,  40,  34,  46,  46,  40, 109,  97, 116,  99,
  104,  45,  62, 115, 117,  98,  40,  50,  41,  41,  46,  46,  34,  41,  34,  41,
   10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40,
  109,  97, 116,  99, 104,  32, 105, 110,  32, 118,  99, 108, 101,  97, 110,  45,
   62, 103, 109,  97, 116,  99, 104,  40,  34,  36,  91,  97,  45, 122,  65,  45,
   90,  48,  45,  57,  95,  93,  43,  34,  41,  41, 123,  10,  32,  32,  32,  32,
   32,  32, 118,  32,  61,  32, 118,  45,  62, 103, 115, 117,  98,  40, 109,  97,
  116,  99, 104,  44,  32,  34, 112,  97, 105, 114, 115,  40,  34,  46,  46, 109,
   97, 116,  99, 104,  45,  62, 115, 117,  98,  40,  50,  41,  46,  46,  34,  41,
   34,  41,  10,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  47,  47,
   32, 120, 126, 121,  32,  40, 121,  32, 105, 115,  32,  97, 110, 121, 116, 104,
  105, 110, 103,  32, 117, 110, 116, 105, 108,  32, 119, 104, 105, 116, 101, 115,
  112,  97,  99, 101,  32,  40, 110, 111, 116,  32, 105, 110, 115, 105, 100, 101,
   32,  97,  32, 115, 116, 114, 105, 110, 103,  41,  41,  32, 119, 105, 108, 108,
   32,  97, 100, 100,  32, 116, 111,  32, 116, 104, 101,  32, 115, 116,  97, 114,
  116,  32,  95,  71,  46, 120,  61, 121,  59,  32,  97, 110, 100,  32, 116, 104,
  101, 110,  32, 119, 105, 108, 108,  32, 114, 101, 112, 108,  97,  99, 101,  32,
  116, 104, 101,  32, 120, 126, 121,  32, 119, 105, 116, 104,  32, 120,  10,  32,
   32,  32,  32, 102, 111, 114,  32,  40, 109,  97, 116,  99, 104,  32, 105, 110,
   32, 118,  45,  62, 103, 109,  97, 116,  99, 104,  40,  34,  91,  97,  45, 122,
   65,  45,  90,  48,  45,  57,  95,  93,  43, 126,  91,  94,  37, 115,  93,  43,
   34,  41,  41, 123,  10,  32,  32,  32,  32,  32,  32,  47,  42,  10,  32,  32,
   32,  32,  32,  32, 118,  32,  61,  32,  34,  95,  71,  91,  92,  34,  34,  46,
   46, 109,  97, 116,  99, 104,  45,  62, 115, 117,  98,  40,  49,  44,  32, 109,
   97, 116,  99, 104,  45,  62, 102, 105, 110, 100,  40,  34, 126,  34,  41,  45,
   49,  41,  46,  46,  34,  92,  34,  93,  32,  61,  32,  34,  46,  46, 109,  97,
  116,  99, 104,  45,  62, 115, 117,  98,  40, 109,  97, 116,  99, 104,  45,  62,
  102, 105, 110, 100,  40,  34, 126,  34,  41,  43,  49,  41,  46,  46,  34,  59,
   32,  34,  46,  46, 118,  10,  32,  32,  32,  32,  10,  32,  32,  32,  32,  32,
   32,  47,  47,  32, 114, 101, 112, 108,  97,  99, 101,  32, 109,  97, 116,  99,
  104,  32, 119, 105, 116, 104,  32, 116, 104, 101,  32, 102, 105, 114, 115, 116,
   32, 112,  97, 114, 116,  32, 111, 102,  32, 116, 104, 101,  32, 109,  97, 116,
   99, 104,  46,  32,  66, 117, 116,  32, 100, 111,  32, 110, 111, 116,  32, 117,
  115, 101,  32, 103, 115, 117,  98,  10,  32,  32,  32,  32,  32,  32, 118,  32,
   61,  32, 103, 115, 117,  98,  40, 118,  44,  32, 109,  97, 116,  99, 104,  44,
   32, 109,  97, 116,  99, 104,  45,  62, 115, 117,  98,  40,  49,  44,  32, 109,
   97, 116,  99, 104,  45,  62, 102, 105, 110, 100,  40,  34, 126,  34,  41,  45,
   49,  41,  41,  10,  32,  32,  32,  32,  32,  32,  42,  47,  10,  32,  32,  32,
   32,  32,  32,  97, 114, 103,  49,  32,  61,  32, 109,  97, 116,  99, 104,  45,
   62, 115, 117,  98,  40,  49,  44,  32, 109,  97, 116,  99, 104,  45,  62, 102,
  105, 110, 100,  40,  34, 126,  34,  41,  45,  49,  41,  10,  32,  32,  32,  32,
   32,  32,  97, 114, 103,  50,  32,  61,  32, 109,  97, 116,  99, 104,  45,  62,
  115, 117,  98,  40, 109,  97, 116,  99, 104,  45,  62, 102, 105, 110, 100,  40,
   34, 126,  34,  41,  43,  49,  41,  10,  32,  32,  32,  32,  32,  32, 118,  32,
   61,  32, 103, 115, 117,  98,  40, 118,  44,  32, 109,  97, 116,  99, 104,  44,
   32,  34, 103, 108, 111,  98,  97, 108,  40,  92,  34,  34,  46,  46,  97, 114,
  103,  49,  46,  46,  34,  92,  34,  44,  32,  34,  46,  46,  97, 114, 103,  50,
   46,  46,  34,  41,  34,  41,  10,  32,  32,  32,  32, 125,  10,  10,  32,  32,
   32,  32,  47,  47,  32, 116,  97,  98, 108, 101,  32,  91, 120,  44,  32, 121,
   44,  32, 122,  93,  32,  61,  32, 116,  98, 108,  10,  32,  32,  32,  32,  47,
   42,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40, 109,  97, 116,  99, 104,
   32, 105, 110,  32, 118,  45,  62, 103, 109,  97, 116,  99, 104,  40,  34,  40,
   91,  97,  45, 122,  65,  45,  90,  48,  45,  57,  95,  93,  43,  41,  37, 115,
   42,  37,  91,  40,  46,  45,  41,  37,  93,  37, 115,  42,  61,  34,  41,  41,
  123,  10,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40, 118,  41,
   10,  32,  32,  32,  32,  32,  32,  47,  47,  32, 114, 101, 112, 108,  97,  99,
  101,  32, 116, 104, 101,  32, 109,  97, 116,  99, 104,  32, 119, 105, 116, 104,
   32, 116, 104, 101,  32, 102, 105, 114, 115, 116,  32, 112,  97, 114, 116,  32,
  111, 102,  32, 116, 104, 101,  32, 109,  97, 116,  99, 104,  10,  32,  32,  32,
   32,  32,  32, 118,  32,  61,  32, 103, 115, 117,  98,  40, 118,  44,  32, 109,
   97, 116,  99, 104,  44,  32, 109,  97, 116,  99, 104,  45,  62, 115, 117,  98,
   40,  49,  44,  32, 102, 105, 110, 100,  40, 109,  97, 116,  99, 104,  44,  32,
   34,  91,  34,  41,  45,  49,  41,  41,  10,  32,  32,  32,  32,  32,  32,  47,
   47,  32, 114, 101, 112, 108,  97,  99, 101,  32, 116, 104, 101,  32, 109,  97,
  116,  99, 104,  32, 119, 105, 116, 104,  32, 116, 104, 101,  32, 116,  97,  98,
  108, 101,  46, 105, 110, 115, 101, 114, 116,  40, 116,  98, 108,  44,  32, 120,
   44,  32, 121,  44,  32, 122,  41,  10,  32,  32,  32,  32,  32,  32, 118,  32,
   61,  32, 103, 115, 117,  98,  40, 118,  44,  32, 109,  97, 116,  99, 104,  44,
   32,  34, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40,  34,
   46,  46, 109,  97, 116,  99, 104,  45,  62, 115, 117,  98,  40, 102, 105, 110,
  100,  40, 109,  97, 116,  99, 104,  44,  32,  34,  61,  34,  41,  43,  49,  41,
   46,  46,  34,  44,  32,  34,  46,  46, 109,  97, 116,  99, 104,  45,  62, 115,
  117,  98,  40, 102, 105, 110, 100,  40, 109,  97, 116,  99, 104,  44,  32,  34,
   91,  34,  41,  43,  49,  44,  32, 102, 105, 110, 100,  40, 109,  97, 116,  99,
  104,  44,  32,  34,  93,  34,  41,  45,  49,  41,  46,  46,  34,  41,  34,  41,
   10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  42,  47,  10,  10,  32,
   32,  32,  32, 102, 111, 114,  32,  40, 109,  97, 116,  99, 104,  32, 105, 110,
   32, 118,  45,  62, 103, 109,  97, 116,  99, 104,  40,  34, 102,  39,  40,  46,
   45,  41,  39,  34,  41,  41, 123,  10,  32,  32,  32,  32,  32,  32,  47,  47,
   32, 114, 101, 112, 108,  97,  99, 101,  32, 116, 104, 101,  32, 102,  39, 123,
  125,  39,  32, 119, 105, 116, 104,  32, 115, 116, 114, 105, 110, 103,  46, 102,
  111, 114, 109,  97, 116,  40,  34, 123, 125,  34,  44,  32,  46,  46,  46,  41,
   10,  32,  32,  32,  32,  32,  32, 118,  32,  61,  32, 116, 121, 112, 101,  99,
  104, 101,  99, 107, 101, 114,  46, 114, 101, 118, 105, 118, 101,  40, 118,  45,
   62, 103, 115, 117,  98,  40,  34, 102,  39,  40,  46,  45,  41,  39,  34,  44,
   32,  34, 115, 116, 114, 105, 110, 103,  46, 102, 111, 114, 109,  97, 116,  40,
   39,  34,  46,  46, 109,  97, 116,  99, 104,  46,  46,  34,  39,  34,  41,  44,
   32, 100, 101,  97, 100,  41,  10,  32,  32,  32,  32,  32,  32,  47,  47,  32,
  102, 105, 110, 100,  32,  97, 108, 108,  32, 123, 125,  32, 105, 110,  32, 116,
  104, 101,  32, 115, 116, 114, 105, 110, 103,  10,  32,  32,  32,  32,  32,  32,
  102, 111, 114,  32,  40, 105, 116,  32, 105, 110,  32, 118,  45,  62, 103, 109,
   97, 116,  99, 104,  40,  34, 123,  40,  46,  45,  41, 125,  34,  41,  41, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  70, 111, 114,  32,
  101,  97,  99, 104,  32, 123, 125,  32,  97, 100, 100,  32,  97,  32,  44,  32,
   97, 110, 100,  32, 116, 104, 101,  32, 118,  97, 108, 117, 101,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 118,  32,  61,  32, 118,  46,  46,  34,  44,  32,
   34,  46,  46, 105, 116,  10,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32,  97, 108, 115, 111,  32, 114, 101, 112, 108,  97,  99, 101,  32, 116, 104,
  101,  32, 123, 125,  32, 119, 105, 116, 104,  32,  37, 115,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 118,  32,  61,  32, 118,  45,  62, 103, 115, 117,  98,
   40,  34, 123,  40,  46,  45,  41, 125,  34,  44,  32,  34,  37,  37, 115,  34,
   41,  10,  32,  32,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  32,
   32,  47,  47,  32,  97, 100, 100,  32, 116, 104, 101,  32,  99, 108, 111, 115,
  105, 110, 103,  32,  98, 114,  97,  99, 107, 101, 116,  10,  32,  32,  32,  32,
   32,  32, 118,  32,  61,  32, 118,  46,  46,  34,  41,  34,  10,  32,  32,  32,
   32, 125,  10,  10,  32,  32,  32,  32, 102, 111, 114,  32,  40, 109,  97, 116,
   99, 104,  32, 105, 110,  32, 118,  45,  62, 103, 109,  97, 116,  99, 104,  40,
   34, 102,  91,  91,  40,  46,  42,  41,  93,  93,  34,  41,  41, 123,  10,  32,
   32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,
   49,  59,  51,  49, 109,  80, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111,
  114,  32, 101, 114, 114, 111, 114,  58,  92,  50,  55,  91,  48, 109,  34,  41,
   10,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,  34,  92,  50,
   55,  91,  49,  59,  51,  49, 109,  69, 114, 114, 111, 114,  32, 119, 105, 116,
  104,  32, 116, 104, 101,  32,  39, 102,  91,  91,  39,  32, 112, 114, 101, 112,
  114, 111,  99, 101, 115, 115, 111, 114,  32,  99, 111, 109, 109,  97, 110, 100,
   46,  92,  50,  55,  91,  48, 109,  92, 110,  92, 110,  34,  41,  10,  32,  32,
   32,  32,  32,  32, 105, 102,  32,  40, 101, 114, 114, 111, 114, 105, 110,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 105,
  110, 116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49, 109,  77, 117, 108,
  116, 105, 108, 105, 110, 101,  32, 102, 111, 114, 109,  97, 116, 116, 101, 100,
   32, 115, 116, 114, 105, 110, 103, 115,  32,  97, 114, 101,  32, 110, 111, 116,
   32, 115, 117, 112, 112, 111, 114, 116, 101, 100,  46,  92,  50,  55,  91,  48,
  109,  92, 110,  92, 110,  34,  41,  10,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,  34,  92,  50,  55,
   91,  49,  59,  51,  49, 109,  83, 116, 111, 112, 112, 105, 110, 103,  32, 112,
  114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46,  92,  50,  55,  91,
   48, 109,  34,  41,  10,  32,  32,  32,  32,  32,  32, 111, 115,  46, 101, 120,
  105, 116,  40,  41,  10,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,
  108, 105, 110, 101, 115,  91, 105,  93,  32,  61,  32, 116, 121, 112, 101,  99,
  104, 101,  99, 107, 101, 114,  46, 114, 101, 118, 105, 118, 101,  40, 118,  41,
   10,  32,  32, 125,  10,  10,  10,  32,  32, 114, 101, 116, 117, 114, 110,  32,
  116,  97,  98, 108, 101,  46,  99, 111, 110,  99,  97, 116,  40, 108, 105, 110,
  101, 115,  44,  34,  92, 110,  34,  41,  10, 125,  10,  10, 102, 117, 110,  99,
  116, 105, 111, 110,  32, 112, 114, 111,  99, 101, 115, 115,  40, 115, 116, 114,
   44,  32, 105, 116, 101, 109, 116, 121, 112, 101,  44,  32, 111, 117, 116,  44,
   32, 111, 117, 116, 102, 105, 108, 101,  44,  32,  46,  46,  46,  41, 123,  10,
   32,  32,  32,  32,  47,  47,  32,  48,  58,  32,  73, 110, 105, 116,  10,  32,
   32,  32,  32,  10,  32,  32,  32,  32,  47,  47,  47,  32,  67, 104, 101,  99,
  107,  32, 109, 111, 100, 101,  58,  10,  32,  32,  32,  32, 105, 102,  32,  40,
  111, 117, 116, 102, 105, 108, 101,  32,  61,  61,  32,  34,  45, 116, 121, 112,
  101, 115,  34,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 116, 121,
  112, 101,  99, 104, 101,  99, 107, 101, 114,  46,  97, 108, 108,  40,  41,  32,
   47,  47,  32,  80, 114, 105, 110, 116,  32,  97, 108, 108,  32, 118,  97, 108,
  105, 100,  32, 116, 121, 112, 101, 115,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 114, 101, 116, 117, 114, 110,  59,  10,  32,  32,  32,  32, 125, 105, 102,
   32,  40, 123,  46,  46,  46, 125,  32,  61,  61,  32, 123, 125,  41, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114,  40,  34,  78,
  111,  32,  97, 114, 103, 117, 109, 101, 110, 116, 115,  32, 111, 114,  32, 105,
  110, 118,  97, 108, 105, 100,  32, 102, 108,  97, 103, 115,  32, 112, 114, 111,
  118, 105, 100, 101, 100,  46,  34,  41,  10,  32,  32,  32,  32, 125,  10,  10,
   32,  32,  32,  32,  47,  47,  47,  32,  73, 110, 105, 116,  32, 109,  97,  99,
  114, 111, 115,  10,  32,  32,  32,  32, 109,  97,  99, 114, 111, 115,  40,  41,
   10,  10,  32,  32,  32,  32,  47,  47,  32,  49,  58,  32,  83, 112, 108, 105,
  116,  32, 108, 105, 110, 101, 115,  10,  32,  32,  32,  32, 118,  97, 114,  32,
  110, 115, 116, 114,  10,  32,  32,  32,  32, 118,  97, 114,  32, 111, 103, 115,
  116, 114,  32,  61,  32, 111, 117, 116,  32,  63,  32, 115, 116, 114,  32,  58,
   32, 110, 117, 108, 108,  10,  32,  32,  32,  32, 105, 102,  32,  40, 105, 116,
  101, 109, 116, 121, 112, 101,  32,  61,  61,  32,  34, 102, 105, 108, 101,  34,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,
  102, 105, 108, 101,  32,  61,  32, 105, 111,  46, 111, 112, 101, 110,  40, 115,
  116, 114,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,
   33, 102, 105, 108, 101,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 101, 114, 114, 111, 114,  40,  99, 111, 114, 101,  46, 101,
  114, 114, 111, 114,  46, 115, 116, 114, 101, 114, 114, 111, 114,  40,  50,  41,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 110, 115, 116, 114,  32,  61,  32, 102, 105, 108, 101,  45,
   62, 114, 101,  97, 100,  40,  34,  42,  97, 108, 108,  34,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 102, 105, 108, 101,  45,  62,  99, 108, 111, 115,
  101,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,
   33, 110, 115, 116, 114,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 101, 114, 114, 111, 114,  40,  99, 111, 114, 101,  46, 101,
  114, 114, 111, 114,  46, 115, 116, 114, 101, 114, 114, 111, 114,  40,  50,  41,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  47,  47,  32,  48,  58,  32,  82, 117, 110,  32,
  116, 121, 112, 101,  99, 104, 101,  99, 107, 101, 114,  32,  97, 110, 100,  32,
  108,  97, 110, 103, 117,  97, 103, 101,  32, 101, 120, 116, 101, 110, 115, 105,
  111, 110, 115,  10,  32,  32,  32,  32,  10,  32,  32,  32,  32, 105, 102,  32,
   40,  33, 110, 115, 116, 114,  41,  32, 110, 115, 116, 114,  32,  61,  32, 115,
  116, 114,  10,  32,  32,  32,  32, 116, 121, 112, 101,  99, 104, 101,  99, 107,
  101, 114,  46,  99, 104, 101,  99, 107,  40, 110, 115, 116, 114,  41,  10,  32,
   32,  32,  32, 110, 115, 116, 114,  32,  61,  32, 101, 120, 116,  40, 110, 115,
  116, 114,  41,  10,  10,  32,  32,  32,  32,  47,  47,  32,  48,  46,  53,  58,
   32,  83, 112, 108, 105, 116,  32, 108, 105, 110, 101, 115,  10,  32,  32,  32,
   32, 118,  97, 114,  32, 108, 105, 110, 101, 115,  32,  61,  32,  91,  93,  10,
   32,  32,  32,  32, 102, 111, 114,  32,  40, 108, 105, 110, 101,  32, 105, 110,
   32, 110, 115, 116, 114,  45,  62, 103, 109,  97, 116,  99, 104,  40,  34,  91,
   94,  92, 114,  92, 110,  93,  43,  34,  41,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 108, 105, 110, 101, 115,  91,  35, 108, 105, 110, 101,
  115,  32,  43,  32,  49,  93,  32,  61,  32, 108, 105, 110, 101,  10,  32,  32,
   32,  32, 125,  10,  10,  32,  32,  32,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  32, 103, 101, 116, 110,  97, 109, 101,  40,  41, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 105, 102,  32,  40, 111, 103, 115, 116, 114,  41, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   99, 119, 100,  47, 111, 103, 115, 116, 114,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102, 105, 108,
  101, 120,  46, 106, 111, 105, 110,  40, 102, 105, 108, 101, 115, 121, 115, 116,
  101, 109,  46,  99, 117, 114, 114, 101, 110, 116, 100, 105, 114,  40,  41,  44,
   32, 111, 103, 115, 116, 114,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  125, 101, 108, 115, 101, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 100, 101,  98, 117, 103,  46,
  103, 101, 116, 105, 110, 102, 111,  40,  50,  44,  32,  34,  83,  34,  41,  46,
  115, 111, 117, 114,  99, 101,  45,  62, 115, 117,  98,  40,  50,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  10,
   32,  32,  32,  32,  47,  47,  32,  50,  58,  32,  76, 111, 111, 107,  32, 102,
  111, 114,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,  32, 108, 105,
  110, 101, 115,  10,  32,  32,  32,  32, 118,  97, 114,  32, 112, 114, 101, 112,
  114, 111,  99, 101, 115, 115,  32,  61,  32,  91,  93,  10,  32,  32,  32,  32,
  102, 111, 114,  32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105,
  114, 115,  40, 108, 105, 110, 101, 115,  41,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 118,  97, 114,  32, 102, 105, 114, 115, 116,  32,  61,
   32, 118,  45,  62, 115, 117,  98,  40,  49,  44,  32,  49,  41,  32,  10,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  99, 104,  97, 114,  32,
   61,  32,  49,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 105,
  108, 101,  32,  40, 102, 105, 114, 115, 116,  32,  61,  61,  32,  34,  32,  34,
   32, 124, 124,  32, 102, 105, 114, 115, 116,  32,  61,  61,  32,  34,  92, 116,
   34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  99, 104,  97, 114,  43,  43,  59,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 102, 105, 114, 115, 116,  32,  61,  32, 118,  45,  62,
  115, 117,  98,  40,  99, 104,  97, 114,  44,  32,  99, 104,  97, 114,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 102,  32,  40, 102, 105, 114, 115, 116,  32,  61,  61,  32,
   34,  35,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 118,  32,  61,  32, 118,  45,  62, 115, 117,  98,  40,  99, 104,
   97, 114,  44,  32,  35, 118,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98,
  108, 101,  46, 105, 110, 115, 101, 114, 116,  40, 112, 114, 101, 112, 114, 111,
   99, 101, 115, 115,  44,  32,  91, 105,  44,  32, 118,  93,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  10,  32,  32,  32,  32,  47,  47,  32,  51,  58,  32,  69, 120, 101,
   99, 117, 116, 101,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,  32,
  108, 105, 110, 101, 115,  10,  32,  32,  32,  32, 118,  97, 114,  32, 101, 110,
  118,  32,  61,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  34,  99,
  111,  98,  97, 108, 116,  34,  58,  32, 116, 114, 117, 101,  44,  32,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  34,  99, 111,  98,  97, 108, 116, 118, 101,
  114, 115, 105, 111, 110,  34,  58,  32,  34,  50,  51,  34,  44,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  34, 101, 100, 105, 116, 105, 111, 110,  34,  58,
   32,  34, 115, 116,  97, 110, 100,  97, 114, 100,  34,  44,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  34,  99, 112, 108, 117, 115, 112, 108, 117, 115,  34,
   58,  32, 102,  97, 108, 115, 101,  44,  10,  32,  32,  32,  32, 125,  10,  32,
   32,  32,  32,  47,  47,  32, 105, 110, 101, 110, 118,  32, 119, 105, 108, 108,
   32,  98, 101,  32, 108, 105, 107, 101,  58,  32,  45,  88,  61,  34, 116,  34,
   32,  45,  77,  61,  50,  32,  45,  90,  61, 116, 114, 117, 101,  32, 119, 105,
  108, 108,  32,  98, 101,  99, 111, 109, 101,  32, 123,  91,  34,  88,  34,  93,
   61,  34, 116,  34,  44,  32,  91,  34,  77,  34,  93,  61,  50,  44,  32,  91,
   34,  90,  34,  93,  61, 116, 114, 117, 101, 125,  10,  32,  32,  32,  32, 101,
  110, 118, 105, 116, 101, 109, 115,  32,  61,  32, 116,  97,  98, 108, 101,  46,
  112,  97,  99, 107,  40,  46,  46,  46,  41,  10,  32,  32,  32,  32, 105, 110,
  101, 110, 118,  32,  61,  32, 123, 125,  10,  32,  32,  32,  32, 102, 111, 114,
   32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40,
  101, 110, 118, 105, 116, 101, 109, 115,  41,  41, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40, 118,  41,  32,
   61,  61,  32,  34, 110, 117, 109,  98, 101, 114,  34,  41, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 118,  97, 114,  32, 115, 112, 108, 105, 116,  32,  61,  32, 118,
   45,  62, 103, 115, 117,  98,  40,  34,  45,  34,  44,  32,  34,  34,  41,  45,
   62, 115, 112, 108, 105, 116,  40,  34,  61,  34,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 110, 101, 110, 118,  91, 115, 112, 108, 105, 116,  91,
   49,  93,  93,  32,  61,  32, 108, 111,  97, 100, 115, 116, 114, 105, 110, 103,
   40,  34, 114, 101, 116, 117, 114, 110,  32,  34,  46,  46, 115, 112, 108, 105,
  116,  91,  50,  93,  41,  40,  41,  10,  32,  32,  32,  32, 125,  10,  10,  32,
   32,  32,  32,  47,  47,  32,  52,  58,  32,  65, 100, 100,  32, 105, 110, 101,
  110, 118,  32, 116, 111,  32, 101, 110, 118,  10,  32,  32,  32,  32, 102, 111,
  114,  32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,
   40, 105, 110, 101, 110, 118,  41,  41, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40, 118,  41,  32,  61,  61,
   32,  34, 115, 116, 114, 105, 110, 103,  34,  41,  32, 118,  32,  61,  32,  39,
   34,  39,  46,  46, 118,  46,  46,  39,  34,  39,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 101, 110, 118,  91, 105,  93,  32,  61,  32, 118,  10,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32, 118,  97, 114,  32, 110, 101, 119, 108,
  105, 110, 101, 115,  32,  61,  32, 108, 105, 110, 101, 115,  10,  32,  32,  32,
   32, 118,  97, 114,  32,  97,  99, 116, 105, 118, 101, 105, 102, 115,  32,  61,
   32,  91,  93,  10,  32,  32,  32,  32, 118,  97, 114,  32, 114, 117, 110,  32,
   61,  32, 116, 114, 117, 101,  10,  32,  32,  32,  32, 118,  97, 114,  32, 105,
  110,  99, 111, 109, 109, 101, 110, 116,  32,  61,  32, 102,  97, 108, 115, 101,
   10,  10,  32,  32,  32,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32, 101,
  110, 118, 108, 111,  97, 100,  40, 115, 116, 114,  50,  41, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 116,  98, 108, 100,  32,  61,
   32,  34, 123,  34,  10,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,
   32,  40, 107,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40,
  101, 110, 118,  41,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40, 107,  41,  32,
   61,  61,  32,  34, 110, 117, 109,  98, 101, 114,  34,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116,
   98, 108, 100,  32,  61,  32, 116,  98, 108, 100,  32,  46,  46,  32, 118,  32,
   46,  46,  32,  34,  44,  34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125, 101, 108, 115, 101,  32, 105, 102,  32,  40, 116, 121, 112,
  101,  40, 107,  41,  32,  61,  61,  32,  34, 115, 116, 114, 105, 110, 103,  34,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 116,  98, 108, 100,  32,  61,  32, 116,  98, 108, 100,  32,
   46,  46,  32,  39,  34,  39,  32,  46,  46,  32, 107,  32,  46,  46,  32,  39,
   34,  58,  32,  39,  32,  46,  46,  32, 116, 111, 115, 116, 114, 105, 110, 103,
   40, 118,  41,  32,  46,  46,  32,  34,  44,  34,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 116,  98, 108, 100,  32,
   61,  32, 116,  98, 108, 100,  32,  46,  46,  32,  34, 125,  34,  10,  32,  32,
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 108, 111,  97,
  100, 115, 116, 114, 105, 110, 103,  40,  91,  61,  91,  47,  47,  32,  67, 111,
   98,  97, 108, 116,  32, 101, 120, 101,  99, 117, 116, 105, 111, 110,  32, 101,
  110, 118, 105, 114, 111, 110, 109, 101, 110, 116,  58,  32,  73, 103, 110, 111,
  114, 101,  46,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  101, 110, 118,  32,  61,  32,  93,  61,  93,  46,  46, 116,  98, 108, 100,  46,
   46,  91,  61,  91,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 102, 111, 114,  32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,
   97, 105, 114, 115,  40, 101, 110, 118,  41,  41, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  95,  69,  78,  86,
   91, 105,  93,  32,  61,  32, 118,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  99, 111, 114, 101,  32,  61,  32, 105, 109, 112, 111, 114, 116,  40,
   34,  99, 111, 114, 101,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 102, 117, 110,  99, 116, 105, 111, 110,  32, 100, 101, 102,
  105, 110, 101, 100,  40, 118,  97, 108,  41, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  99, 104,
  101,  99, 107,  32, 105, 102,  32, 105, 116,  32, 105, 115,  32, 105, 110,  32,
  101, 110, 118,  44,  32, 105, 102,  32, 105, 116,  32, 114, 101, 116, 117, 114,
  110,  32, 116, 104, 101,  32, 118,  97, 108, 117, 101,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,
  101, 110, 118,  91, 118,  97, 108,  93,  32,  33,  61,  32, 110, 117, 108, 108,
   32,  38,  38,  32, 101, 110, 118,  91, 118,  97, 108,  93,  32,  33,  61,  32,
  102,  97, 108, 115, 101,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116,
  117, 114, 110,  32, 101, 110, 118,  91, 118,  97, 108,  93,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125, 101, 108,
  115, 101, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 106, 105, 116,  32,
   61,  61,  32, 110, 117, 108, 108,  41, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 114, 101, 116, 117, 114, 110,  32, 109,  97,  99, 114, 111, 115,  40,
  118,  97, 108,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125, 101, 108, 115, 101, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 119,  97, 114, 110,  40, 118,  97, 108,
   46,  46,  34,  32, 105, 115,  32, 110, 111, 116,  32, 100, 101, 102, 105, 110,
  101, 100,  32,  97, 110, 100,  32,  67,  32, 109,  97,  99, 114, 111, 115,  32,
   97, 114, 101,  32, 110, 111, 116,  32, 115, 117, 112, 112, 111, 114, 116, 101,
  100,  32, 111, 110,  32, 116, 104, 101,  32,  74,  73,  84,  32,  99, 111, 109,
  112, 105, 108, 101, 114,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  93,  61,  93,
   46,  46, 115, 116, 114,  50,  41,  10,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32, 102, 111, 114,  32,  40, 105,  44,  32, 118,  32, 105, 110,  32, 112,
   97, 105, 114, 115,  40, 108, 105, 110, 101, 115,  41,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  67, 104, 101,  99, 107,  32,
  105, 102,  32, 105,  32, 105, 115,  32, 118,  91,  49,  93,  32, 102, 111, 114,
   32, 111, 110, 101,  32, 111, 102,  32, 116, 104, 101,  32, 112, 114, 101, 112,
  114, 111,  99, 101, 115, 115,  32, 108, 105, 110, 101, 115,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  47,  32,  71, 111,  32, 116, 104, 114, 111,
  117, 103, 104,  32, 101, 118, 101, 114, 121,  32,  99, 104,  97, 114,  97,  99,
  116, 101, 114,  44,  32, 105, 102,  32,  97,  32,  47,  42,  32, 105, 115,  32,
  102, 111, 117, 110, 100,  32, 109,  97, 107, 101,  32, 105, 110,  99, 111, 109,
  109, 101, 110, 116,  32, 116, 114, 117, 101,  44,  32, 105, 102,  32,  97,  32,
   42,  47,  32, 105, 115,  32, 102, 111, 117, 110, 100,  32, 109,  97, 107, 101,
   32, 105, 110,  99, 111, 109, 109, 101, 110, 116,  32, 102,  97, 108, 115, 101,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  47,  32,  73, 102,  32,
  105, 110,  99, 111, 109, 109, 101, 110, 116,  32, 105, 115,  32, 116, 114, 117,
  101,  44,  32, 114, 101, 109, 111, 118, 101,  32, 116, 104, 101,  32, 108, 105,
  110, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40,
  105, 105,  32,  61,  32,  49,  44,  32,  35, 118,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  99, 104,
   97, 114,  32,  61,  32, 118,  45,  62, 115, 117,  98,  40, 105, 105,  44,  32,
  105, 105,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  32,  40,  99, 104,  97, 114,  32,  61,  61,  32,  34,  47,  34,  32,
   38,  38,  32, 118,  45,  62, 115, 117,  98,  40, 105, 105,  32,  43,  32,  49,
   44,  32, 105, 105,  32,  43,  32,  49,  41,  32,  61,  61,  32,  34,  42,  34,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 110,  99, 111, 109, 109, 101, 110, 116,  32,  61,  32,
  116, 114, 117, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  32,  40,  99, 104,  97, 114,  32,  61,  61,  32,  34,  42,  34,  32,  38,
   38,  32, 118,  45,  62, 115, 117,  98,  40, 105, 105,  32,  43,  32,  49,  44,
   32, 105, 105,  32,  43,  32,  49,  41,  32,  61,  61,  32,  34,  47,  34,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 110,  99, 111, 109, 109, 101, 110, 116,  32,  61,  32, 102,
   97, 108, 115, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 105, 102,  32,  40, 105, 110,  99, 111, 109, 109, 101,
  110, 116,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  99, 111, 110, 116, 105, 110, 117, 101,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32, 102, 111, 117, 110, 100,  32,  61,  32, 102,  97, 108, 115, 101,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105,  50,  44,
   32, 118,  50,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115,  41,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 118,  50,  91,  49,
   93,  32,  61,  61,  32, 105,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  32,  61,  32, 118,  50,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 102, 111, 117, 110, 100,  32,  61,  32, 116, 114, 117, 101,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114,
  101,  97, 107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 105, 102,  32,  40,  33, 102, 111, 117, 110, 100,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  32,  40,  33, 114, 117, 110,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105,
  110, 101, 115,  91, 105,  93,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 110, 116, 105, 110, 117, 101,
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32,  71, 101, 116,  32, 116, 104, 101,  32,
  102, 105, 114, 115, 116,  32, 119, 111, 114, 100,  32, 111, 102,  32, 116, 104,
  101,  32, 108, 105, 110, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32, 102,
  117, 110,  99, 116, 105, 111, 110,  32, 101, 114, 114, 111, 114, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  40, 101, 114, 114, 111, 114, 105,
  110,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49, 109,
   80, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32, 101, 114, 114,
  111, 114,  58,  92,  50,  55,  91,  48, 109,  34,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,  34,  92,
   50,  55,  91,  49,  59,  51,  49, 109,  69, 114, 114, 111, 114,  32, 119, 105,
  116, 104,  32, 116, 104, 101,  32,  39,  34,  46,  46, 118,  91,  50,  93,  46,
   46,  34,  39,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,
   32,  99, 111, 109, 109,  97, 110, 100,  46,  92,  50,  55,  91,  48, 109,  92,
  110,  92, 110,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  32,  40, 101, 114, 114, 111, 114, 105, 110,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49,
  109,  34,  46,  46, 101, 114, 114, 111, 114, 105, 110,  46,  46,  34,  92,  50,
   55,  91,  48, 109,  92, 110,  92, 110,  34,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,
   49,  59,  51,  49, 109,  83, 116, 111, 112, 112, 105, 110, 103,  32, 112, 114,
  101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  46,  92,  50,  55,  91,  48,
  109,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  111, 115,  46, 101, 120, 105, 116,  40,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   73, 102,  32, 116, 104, 101,  32, 115, 101,  99, 111, 110, 100,  32,  99, 104,
   97, 114,  97,  99, 116, 101, 114,  32, 105, 115,  32,  97,  32,  33,  44,  32,
  105, 103, 110, 111, 114, 101,  32, 116, 104, 101,  32, 108, 105, 110, 101,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 118,  91,  50,  93,
   45,  62, 115, 117,  98,  40,  50,  44,  32,  50,  41,  32,  61,  61,  32,  34,
   33,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,
   32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  47,  47,  32,  83, 107,
  105, 112,  32, 116, 104, 105, 115,  32, 108, 105, 110, 101,  10,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,
  115, 119, 105, 116,  99, 104,  40, 118,  91,  50,  93,  45,  62, 109,  97, 116,
   99, 104,  40,  34,  37,  83,  43,  34,  41,  44,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  35, 111, 112, 101, 110,  34,
   58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32,  69, 120,  97, 109, 112, 108, 101,  58,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  35, 111, 112,
  101, 110,  32,  88,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32, 116, 104, 105, 115,  32, 105, 115,  32,
   97, 115, 115, 117, 109, 105, 110, 103,  32,  88,  32, 105, 115,  32, 105, 110,
   32, 116, 104, 101,  32, 101, 110, 118,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 118,  97, 114,  32,
   88,  32,  61,  32,  60, 119, 104,  97, 116, 101, 118, 101, 114,  32,  88,  32,
  105, 115,  32, 105, 110,  32, 116, 104, 101,  32, 101, 110, 118,  62,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32, 110,  97, 109, 101,  32,  61,  32, 118,  91,  50,  93,  45,  62,
  103, 115, 117,  98,  40,  34,  35, 111, 112, 101, 110,  32,  34,  44,  32,  34,
   34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 118,  97, 114,  32, 118,  97, 108, 117, 101,  32,  61,  32, 101,
  110, 118,  91, 110,  97, 109, 101,  93,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 118,  97, 108,
  117, 101,  32,  61,  61,  32, 110, 117, 108, 108,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115,
  115, 111, 114,  40,  34,  77,  97,  99, 114, 111,  32,  39,  34,  46,  46, 110,
   97, 109, 101,  46,  46,  34,  39,  32, 105, 115,  32, 110, 111, 116,  32, 100,
  101, 102, 105, 110, 101, 100,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105,
  110, 101, 115,  91, 118,  91,  49,  93,  93,  32,  61,  32,  34, 118,  97, 114,
   32,  34,  46,  46, 116, 111, 115, 116, 114, 105, 110, 103,  40, 110,  97, 109,
  101,  41,  46,  46,  34,  32,  61,  32,  34,  46,  46,  40,  40, 116, 121, 112,
  101,  40, 118,  97, 108, 117, 101,  41,  32,  61,  61,  32,  34, 115, 116, 114,
  105, 110, 103,  34,  32,  38,  38,  32,  40, 115, 116, 114,  45,  62, 115, 117,
   98,  40,  49,  44,  49,  41,  32,  61,  61,  32,  39,  34,  39,  32,  38,  38,
   32, 115, 116, 114,  45,  62, 115, 117,  98,  40,  45,  49,  41,  32,  61,  61,
   32,  39,  34,  39,  41,  32, 124, 124,  32,  40, 115, 116, 114,  45,  62, 115,
  117,  98,  40,  49,  44,  49,  41,  32,  61,  61,  32,  34,  39,  34,  32,  38,
   38,  32, 115, 116, 114,  45,  62, 115, 117,  98,  40,  45,  49,  41,  32,  61,
   61,  32,  34,  39,  34,  41,  41,  32,  63,  32,  39,  34,  39,  46,  46, 118,
   97, 108, 117, 101,  46,  46,  39,  34,  39,  32,  58,  32, 116, 111, 115, 116,
  114, 105, 110, 103,  40, 118,  97, 108, 117, 101,  41,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32,  65, 118, 111, 105, 100,  32, 109, 101, 109, 111, 114, 121,  32, 108, 101,
   97, 107, 115,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 110,  97, 109, 101,  44,  32, 118,  97, 108, 117, 101,  32,
   61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  34,  35, 100, 101, 102, 105, 110, 101,  34,  58,  32, 102, 117, 110,
   99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 115, 112, 108, 105,
  116,  32, 118,  91,  50,  93,  32,  98, 121,  32, 115, 112,  97,  99, 101, 115,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 118,  97, 114,  32, 115, 112, 108, 105, 116,  32,  61,  32, 118,  91,  50,
   93,  45,  62, 115, 112, 108, 105, 116,  40,  34,  32,  34,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32,  49,  58,  32,  71, 101, 116,  32, 116, 104, 101,  32, 110,  97, 109, 101,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 118,  97, 114,  32, 110,  97, 109, 101,  32,  61,  32, 115, 112, 108, 105,
  116,  91,  50,  93,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 105, 102,  32,  40, 115, 116, 114, 105, 110, 103,  46,
  115, 117,  98,  40, 110,  97, 109, 101,  44,  32,  45,  49,  41,  32,  61,  61,
   32,  34,  41,  34,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  69, 120,
   97, 109, 112, 108, 101,  58,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  35, 100,
  101, 102, 105, 110, 101,  32,  82,  65,  68,  84,  79,  68,  69,  71,  40, 114,
   97, 100,  41,  32,  40, 114,  97, 100,  32,  42,  32,  49,  56,  48,  32,  47,
   32,  80,  73,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32, 115, 104, 111, 117,
  108, 100,  32,  98, 101,  99, 111, 109, 101,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32, 118,  97, 114,  32,  82,  65,  68,  84,  79,  68,  69,  71,  32,  61,  32,
  102, 117, 110,  99, 116, 105, 111, 110,  40, 114,  97, 100,  41, 123,  32, 114,
  101, 116, 117, 114, 110,  32,  40, 114,  97, 100,  32,  42,  32,  49,  56,  48,
   32,  47,  32,  80,  73,  41, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   49,  58,  32,  71, 101, 116,  32, 116, 104, 101,  32, 110,  97, 109, 101,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 118,  97, 114,  32, 118,  97, 108, 117, 101, 115,  32,  61,
   32, 115, 116, 114, 105, 110, 103,  46, 115, 112, 108, 105, 116,  40, 118,  91,
   50,  93,  44,  32,  34,  32,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,
   32, 100, 101, 102, 110,  97, 109, 101,  32,  61,  32, 118,  97, 108, 117, 101,
  115,  91,  50,  93,  45,  62, 115, 112, 108, 105, 116,  40,  34,  40,  34,  41,
   91,  49,  93,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  97, 114, 103, 115,
   32,  61,  32, 118,  97, 108, 117, 101, 115,  91,  50,  93,  45,  62, 115, 112,
  108, 105, 116,  40,  34,  40,  34,  41,  91,  50,  93,  45,  62, 103, 115, 117,
   98,  40,  34,  37,  41,  34,  44,  32,  34,  34,  41,  45,  62, 115, 112, 108,
  105, 116,  40,  34,  44,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,
  102, 117, 110,  99,  32,  61,  32, 118,  97, 108, 117, 101, 115,  91,  51,  93,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,  32,  61,  32,  52,
   44,  32,  35, 118,  97, 108, 117, 101, 115,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 102, 117, 110,  99,  32,  61,  32, 102, 117, 110,  99,
   46,  46,  34,  32,  34,  46,  46, 118,  97, 108, 117, 101, 115,  91, 105, 105,
   93,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,
   40, 105, 105,  44,  32, 118, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,
   40,  97, 114, 103, 115,  41,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  97, 114, 103, 115,  91, 105, 105,  93,  32,  61,  32, 118, 118,  45,  62,
  103, 115, 117,  98,  40,  34,  32,  34,  44,  32,  34,  34,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 102, 117, 110,
   99, 100, 101, 102,  32,  61,  32,  34, 102, 117, 110,  99, 116, 105, 111, 110,
   40,  34,  46,  46, 116,  97,  98, 108, 101,  46,  99, 111, 110,  99,  97, 116,
   40,  97, 114, 103, 115,  44,  32,  34,  44,  34,  41,  46,  46,  34,  41, 123,
   32, 114, 101, 116, 117, 114, 110,  32,  34,  46,  46, 102, 117, 110,  99,  46,
   46,  34,  59,  32, 125,  34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 118,
   97, 108, 100, 101, 102,  32,  61,  32,  34, 118,  97, 114,  32,  34,  46,  46,
  100, 101, 102, 110,  97, 109, 101,  46,  46,  34,  32,  61,  32,  34,  46,  46,
  102, 117, 110,  99, 100, 101, 102,  10,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   50,  58,  32,  83, 101, 116,  32, 118,  97, 108, 117, 101, 115,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,
   32,  61,  32, 118,  97, 108, 100, 101, 102,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110,
  118,  91, 110,  97, 109, 101,  93,  32,  61,  32, 102, 117, 110,  99, 100, 101,
  102,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  51,  58,  32,  67, 108, 101,
   97, 114,  32, 109, 101, 109, 111, 114, 121,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  108, 117, 101, 115,  44,  32, 100, 101, 102, 110,  97, 109, 101,  44,  32, 102,
  117, 110,  99, 100, 101, 102,  44,  32, 118,  97, 108, 100, 101, 102,  44,  32,
   97, 114, 103, 115,  44,  32, 102, 117, 110,  99,  32,  61,  32, 110, 117, 108,
  108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125, 101, 108, 115, 101, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   50,  58,  32,  71, 101, 116,  32, 116, 104, 101,  32, 118,  97, 108, 117, 101,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 118,  97, 114,  32, 118,  97, 108, 117, 101,  32,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 118,  97, 114,  32, 102, 117, 110,  44,  32, 101, 114, 114,
   32,  61,  32, 101, 110, 118, 108, 111,  97, 100,  40,  34, 114, 101, 116, 117,
  114, 110,  32,  34,  46,  46, 115, 112, 108, 105, 116,  91,  51,  93,  32, 124,
  124,  32,  34, 102,  97, 108, 115, 101,  34,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,
  102,  32,  40,  33, 102, 117, 110,  41, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115,
  115, 111, 114,  40, 101, 114, 114,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125, 101, 108,
  115, 101, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 108, 117,
  101,  32,  61,  32, 102, 117, 110,  40,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32,  51,  58,  32,  83, 101, 116,  32, 116, 104,
  101,  32, 118,  97, 108, 117, 101,  32, 105, 110,  32, 116, 104, 101,  32, 101,
  110, 118,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 101, 110, 118,  91, 110,  97, 109, 101,  93,
   32,  61,  32, 118,  97, 108, 117, 101,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   52,  58,  32,  82, 101, 109, 111, 118, 101,  32, 116, 104, 101,  32, 108, 105,
  110, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91,
  118,  91,  49,  93,  93,  32,  61,  32,  34, 118,  97, 114,  32,  34,  46,  46,
  110,  97, 109, 101,  46,  46,  34,  32,  61,  32,  34,  46,  46,  40, 116, 121,
  112, 101,  40, 118,  97, 108, 117, 101,  41,  32,  61,  61,  32,  34, 115, 116,
  114, 105, 110, 103,  34,  32,  63,  32,  39,  34,  39,  46,  46, 118,  97, 108,
  117, 101,  46,  46,  39,  34,  39,  32,  58,  32, 116, 111, 115, 116, 114, 105,
  110, 103,  40, 118,  97, 108, 117, 101,  41,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  34,  35,  35, 108, 105, 110, 101,  34,  58,  32, 102, 117, 110,
   99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  69, 120,  97, 109,
  112, 108, 101,  58,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32,  35, 108, 105, 110, 101,  32,  49,  32,
   34, 102, 105, 108, 101,  46,  99, 111,  98,  97, 108, 116,  34,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32,  87, 105, 108, 108,  32,  97, 100, 100,  32, 101, 118, 101, 114, 121, 116,
  104, 105, 110, 103,  32,  97, 102, 116, 101, 114,  32, 116, 104,  97, 116,  32,
  108, 105, 110, 101,  32, 105, 110,  32, 116, 104,  97, 116,  32, 102, 105, 108,
  101,  32, 116, 111,  32, 116, 104, 101,  32, 110, 101, 119, 108, 105, 110, 101,
  115,  91, 105,  93,  32, 116,  97,  98, 108, 101,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  34, 102,
  105, 108, 101,  46,  99, 111,  98,  97, 108, 116,  34,  32, 105, 102,  32, 105,
  116,  32, 105, 115,  32, 110, 111, 116,  32, 112, 114, 111, 118, 105, 100, 101,
  100,  32, 105, 116,  32, 105, 115,  32, 116, 104, 101,  32,  99, 117, 114, 114,
  101, 110, 116,  32, 102, 105, 108, 101,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  49,  32, 105, 115,
   32, 116, 104, 101,  32, 108, 105, 110, 101,  32, 110, 117, 109,  98, 101, 114,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 119,  97, 114, 110,  40,  34,  85, 115, 105, 110, 103,  32,  35, 108, 105,
  110, 101,  32, 105, 115,  32, 110, 111, 116,  32, 114, 101,  99, 111, 109, 109,
  101, 110, 100, 101, 100,  44,  32,  85, 115, 101,  32, 105, 109, 112, 111, 114,
  116,  40,  41,  32, 105, 110, 115, 116, 101,  97, 100,  34,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32, 115, 112, 108, 105, 116,  32,  61,  32, 118,  91,  50,  93,  45,  62,
  115, 112, 108, 105, 116,  40,  34,  32,  34,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 108,
  105, 110, 101,  32,  61,  32, 115, 112, 108, 105, 116,  91,  50,  93,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32, 102, 105, 108, 101, 110,  97, 109, 101,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,
   33, 115, 112, 108, 105, 116,  91,  51,  93,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 102, 105, 108, 101, 110,  97, 109, 101,  32,  61,  32, 103, 101, 116, 110,
   97, 109, 101,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125, 101, 108, 115, 101, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 102, 105, 108, 101, 110,  97, 109, 101,  32,  61,  32, 115, 116, 114, 105,
  110, 103,  46, 115, 117,  98,  40, 115, 112, 108, 105, 116,  91,  51,  93,  44,
   32,  50,  44,  32,  45,  50,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,
  102, 105, 108, 101, 110,  97, 109, 101,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 102,  32,
   61,  32, 105, 111,  46, 111, 112, 101, 110,  40, 102, 105, 108, 101, 110,  97,
  109, 101,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  32,  40,  33, 102,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32, 115,  99, 114, 105, 112, 116,  95, 112,  97, 116,
  104,  32,  61,  32, 103, 101, 116, 110,  97, 109, 101,  40,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32, 115,  99, 114, 105, 112, 116,  95, 100, 105, 114,
   32,  61,  32, 115,  99, 114, 105, 112, 116,  95, 112,  97, 116, 104,  45,  62,
  109,  97, 116,  99, 104,  40,  34,  40,  46,  42,  47,  41,  34,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 102,  32,  40, 115,  99, 114, 105, 112, 116,  95, 100, 105,
  114,  32,  61,  61,  32, 110, 117, 108, 108,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 115,  99, 114, 105, 112, 116,  95, 100, 105, 114,  32,
   61,  32,  34,  46,  47,  34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 102,  32,  61,  32, 105, 111,  46, 111, 112, 101, 110,  40, 115,  99, 114,
  105, 112, 116,  95, 100, 105, 114,  46,  46, 102, 105, 108, 101, 110,  97, 109,
  101,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33, 102,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114,
  101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40,  34,  70, 105, 108, 101,
   32,  39,  34,  46,  46, 115,  99, 114, 105, 112, 116,  95, 100, 105, 114,  46,
   46, 102, 105, 108, 101, 110,  97, 109, 101,  46,  46,  34,  39,  32, 110, 111,
  116,  32, 102, 111, 117, 110, 100,  34,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 118,  97, 114,  32,  99, 111, 110, 116, 101, 110, 116,  32,  61,
   32, 102,  45,  62, 114, 101,  97, 100,  40,  34,  42,  97, 108, 108,  34,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 102,  45,  62,  99, 108, 111, 115, 101,  40,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  83,
  101, 116,  32, 105,  32, 108, 105, 110, 101,  32, 110, 117, 109,  98, 101, 114,
   32, 116, 111,  32, 114,  40,  99, 111, 110, 116, 101, 110, 116,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99,
  111, 110, 116, 101, 110, 116,  32,  61,  32, 112, 114, 111,  99, 101, 115, 115,
   40,  99, 111, 110, 116, 101, 110, 116,  44,  32, 110, 117, 108, 108,  44,  32,
  110, 117, 108, 108,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  47,  47,  32,  83, 112, 108, 105, 116,  32,  99,
  111, 110, 116, 101, 110, 116,  32, 116, 111,  32, 101, 118, 101, 114, 121, 116,
  104, 105, 110, 103,  32,  97, 102, 116, 101, 114,  32, 116, 111, 110, 117, 109,
   98, 101, 114,  40, 108, 105, 110, 101,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 112, 108, 105, 116,  32,
   61,  32,  99, 111, 110, 116, 101, 110, 116,  45,  62, 115, 112, 108, 105, 116,
   40,  34,  92, 110,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 110, 101, 119,  99, 111,
  110, 116, 101, 110, 116,  32,  61,  32,  34,  34,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40,
  105, 105,  32,  61,  32, 116, 111, 110, 117, 109,  98, 101, 114,  40, 108, 105,
  110, 101,  41,  44,  32,  35, 115, 112, 108, 105, 116,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 110, 101, 119,  99, 111, 110, 116, 101, 110, 116,  32,  61,  32,
  110, 101, 119,  99, 111, 110, 116, 101, 110, 116,  46,  46, 115, 112, 108, 105,
  116,  91, 105, 105,  93,  46,  46,  34,  92, 110,  34,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101,
  119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 110,
  101, 119,  99, 111, 110, 116, 101, 110, 116,  10,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  65, 118,
  111, 105, 100,  32, 109, 101, 109, 111, 114, 121,  32, 108, 101,  97, 107, 115,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 102,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 110, 116, 101, 110,
  116,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119,  99, 111, 110, 116,
  101, 110, 116,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 112, 108, 105, 116,
   32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 102, 105, 108, 101,  44,  32, 108, 105,
  110, 101,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  34,  35,  35, 105, 110,  99, 108, 117, 100, 101,  34,
   58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 119,  97,
  114, 110,  40,  34,  85, 115, 105, 110, 103,  32,  35, 105, 110,  99, 108, 117,
  100, 101,  32, 105, 115,  32, 110, 111, 116,  32, 114, 101,  99, 111, 109, 109,
  101, 110, 100, 101, 100,  44,  32,  85, 115, 101,  32, 105, 109, 112, 111, 114,
  116,  40,  41,  32, 105, 110, 115, 116, 101,  97, 100,  34,  41,  10,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32, 102, 105, 108, 101,  32,  61,  32, 118,  91,  50,  93,  45,  62,
  103, 115, 117,  98,  40,  34,  35, 105, 110,  99, 108, 117, 100, 101,  32,  92,
   34,  34,  44,  32,  34,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 111, 103, 102, 105,
  108, 101,  32,  61,  32, 102, 105, 108, 101,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  70, 105, 108,
  101,  32, 115, 104, 111, 117, 108, 100,  32,  98, 101,  32,  97,  32, 115, 116,
  114, 105, 110, 103,  32, 116, 104,  97, 116,  32, 101, 110, 100, 115,  32, 119,
  105, 116, 104,  32,  34,  32,  97, 110, 100,  32, 109,  97, 121,  32, 104,  97,
  118, 101,  32, 115, 116, 117, 102, 102,  32,  97, 102, 116, 101, 114,  32, 116,
  104, 101,  32,  34,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32,  82, 101, 109, 111, 118, 101,  32, 116,
  104, 101,  32, 108,  97, 115, 116,  32,  34,  32,  97, 110, 100,  32, 111, 110,
  108, 121,  32, 107, 101, 101, 112,  32, 101, 118, 101, 114, 121, 116, 104, 105,
  110, 103,  32,  98, 101, 102, 111, 114, 101,  32, 105, 116,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,
   32,  40, 105, 105,  32,  61,  32,  49,  44,  32,  35, 102, 105, 108, 101,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 118, 118,  32,  61,  32,
  102, 105, 108, 101,  45,  62, 115, 117,  98,  40, 105, 105,  44,  32, 105, 105,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 118, 118,  32,  61,  61,  32,
   34,  92,  34,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  102, 105, 108, 101,  32,  61,  32, 102, 105, 108, 101,  45,  62, 115, 117,  98,
   40,  49,  44,  32, 105, 105,  32,  45,  32,  49,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 118,  97, 114,  32, 102,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40,
   95,  44,  32, 118, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 112,
   97,  99, 107,  97, 103, 101,  46, 115, 101,  97, 114,  99, 104, 101, 114, 115,
   41,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  35, 116,  97,  98,
  108, 101,  46, 112,  97,  99, 107,  40, 118, 118,  40, 102, 105, 108, 101,  41,
   41,  32,  61,  61,  32,  50,  32,  38,  38,  32,  32, 116,  97,  98, 108, 101,
   46, 112,  97,  99, 107,  40, 118, 118,  40, 102, 105, 108, 101,  41,  41,  91,
   49,  93,  32,  33,  61,  32, 110, 117, 108, 108,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 102,  32,  61,  32, 116,  97,  98, 108, 101,  46,
  112,  97,  99, 107,  40, 118, 118,  40, 102, 105, 108, 101,  41,  41,  59,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33, 102,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 118,  97, 114,  32, 115,  99, 114, 105, 112, 116,  95,
  112,  97, 116, 104,  32,  61,  32, 103, 101, 116, 110,  97, 109, 101,  40,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 118,  97, 114,  32, 115,  99, 114, 105, 112, 116,  95,
  100, 105, 114,  32,  61,  32, 115,  99, 114, 105, 112, 116,  95, 112,  97, 116,
  104,  45,  62, 109,  97, 116,  99, 104,  40,  34,  40,  46,  42,  47,  41,  34,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 115,  99, 114, 105, 112, 116,
   95, 100, 105, 114,  32,  61,  61,  32, 110, 117, 108, 108,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 115,  99, 114, 105, 112, 116,  95, 100,
  105, 114,  32,  61,  32,  34,  46,  47,  34,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 102,  32,  61,  32,  40, 105, 111,  46, 111, 112, 101,
  110,  40, 115,  99, 114, 105, 112, 116,  95, 100, 105, 114,  46,  46, 102, 105,
  108, 101,  41,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33, 102,  41,
   32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114,
  112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40,  34,  70, 105,
  108, 101,  32,  39,  34,  46,  46, 102, 105, 108, 101,  46,  46,  34,  39,  32,
  110, 111, 116,  32, 102, 111, 117, 110, 100,  34,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  32,  40, 116, 121, 112, 101,  40, 102,  41,  61,
   61,  34, 115, 116, 114, 105, 110, 103,  34,  41, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  102, 105, 108, 101,  32,  61,  32, 105, 111,  46, 111, 112, 101, 110,  40, 102,
   91,  50,  93,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 125, 101, 108, 115, 101, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  102, 105, 108, 101,  32,  61,  32, 102,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  99,
  111, 110, 116, 101, 110, 116,  32,  61,  32, 102, 105, 108, 101,  45,  62, 114,
  101,  97, 100,  40,  34,  42,  97, 108, 108,  34,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 105, 108, 101,
   45,  62,  99, 108, 111, 115, 101,  40,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  83, 101,
  116,  32, 105,  32, 108, 105, 110, 101,  32, 110, 117, 109,  98, 101, 114,  32,
  116, 111,  32, 114,  40,  99, 111, 110, 116, 101, 110, 116,  41,  10,  32,  32,
   32,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,
   93,  44,  32, 110, 101, 119, 105, 110,  99, 108, 117, 100, 101, 115,  32,  61,
   32, 112, 114, 111,  99, 101, 115, 115,  40,  99, 111, 110, 116, 101, 110, 116,
   44,  32, 110, 117, 108, 108,  44,  32, 110, 117, 108, 108,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32,  65, 118, 111, 105, 100,  32, 109, 101, 109, 111, 114, 121,  32, 108, 101,
   97, 107, 115,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 102, 105, 108, 101,  32,  61,  32, 110, 117, 108, 108,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   99, 111, 110, 116, 101, 110, 116,  32,  61,  32, 110, 117, 108, 108,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102,
   32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  34,  35, 105, 102,  34,  58,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  47,  47,  32,  69, 120,  97, 109, 112, 108, 101,
   58,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  47,  47,  32,  35, 105, 102,  32,  40, 116, 114, 117, 101,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  47,  47,  32,  49,  58,  32,  71, 101, 116,  32, 116, 104, 101,  32,  99,
  111, 110, 100, 105, 116, 105, 111, 110,  44,  32,  69, 118, 101, 114, 121, 116,
  104, 105, 110, 103,  32, 105, 110,  32,  98, 101, 116, 119, 101, 101, 110,  32,
  116, 104, 101,  32,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  99, 111, 110, 100, 105,
  116, 105, 111, 110,  32,  61,  32, 118,  91,  50,  93,  45,  62, 103, 115, 117,
   98,  40,  34,  35, 105, 102,  32,  34,  44,  32,  34,  34,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   47,  32,  71, 101, 116,  32, 101, 118, 101, 114, 121, 116, 104, 105, 110, 103,
   32, 105, 110,  32,  98, 101, 116, 119, 101, 101, 110,  32, 116, 104, 101,  32,
   40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 102, 111, 114,  32,  40, 105, 105,  32,  61,  32,  49,  44,  32,
   35,  99, 111, 110, 100, 105, 116, 105, 111, 110,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32, 118, 118,  32,  61,  32,  99, 111, 110, 100, 105,
  116, 105, 111, 110,  45,  62, 115, 117,  98,  40, 105, 105,  44,  32, 105, 105,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 118, 118,  32,  61,  61,  32,
   34,  40,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99,
  111, 110, 100, 105, 116, 105, 111, 110,  32,  61,  32,  99, 111, 110, 100, 105,
  116, 105, 111, 110,  45,  62, 115, 117,  98,  40, 105, 105,  32,  43,  32,  49,
   44,  32,  35,  99, 111, 110, 100, 105, 116, 105, 111, 110,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,  32,  61,  32,  35,
   99, 111, 110, 100, 105, 116, 105, 111, 110,  44,  32,  49,  44,  32,  45,  49,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 118, 118,  32,  61,
   32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40,
  105, 105,  44,  32, 105, 105,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,
  118, 118,  32,  61,  61,  32,  34,  41,  34,  41,  32, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  32,  61,
   32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40,
   49,  44,  32, 105, 105,  32,  45,  32,  49,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  47,  47,  32,  50,  58,  32,  69, 118,  97, 108, 117,  97, 116, 101,
   32, 116, 104, 101,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32, 115, 117,  99,  99, 101, 115, 115,  44,  32, 114, 101, 115, 117,
  108, 116,  32,  61,  32, 120, 112,  99,  97, 108, 108,  40, 102, 117, 110,  99,
  116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117,
  114, 110,  32,  40, 101, 110, 118, 108, 111,  97, 100,  40,  34, 114, 101, 116,
  117, 114, 110,  32,  34,  46,  46,  99, 111, 110, 100, 105, 116, 105, 111, 110,
   41,  32, 124, 124,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,
   99, 101, 115, 115, 111, 114,  40,  34,  70,  97, 105, 108, 101, 100,  32, 116,
  111,  32,  99, 104, 101,  99, 107,  32,  99, 111, 110, 100, 105, 116, 105, 111,
  110,  92, 110,  34,  46,  46, 116,  97,  98, 108, 101,  46, 112,  97,  99, 107,
   40, 101, 110, 118, 108, 111,  97, 100,  40,  34, 114, 101, 116, 117, 114, 110,
   32,  34,  46,  46,  99, 111, 110, 100, 105, 116, 105, 111, 110,  41,  41,  91,
   50,  93,  41,  41,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  44,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  40, 101, 114, 114,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114,
  111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40, 101,
  114, 114,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33, 115, 117,  99,  99,
  101, 115, 115,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114,
  112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40, 114, 101, 115,
  117, 108, 116,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  51,  58,  32,  82, 101, 109,
  111, 118, 101,  32, 116, 104, 101,  32, 108, 105, 110, 101,  32,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101,
  119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 110,
  117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,
   40,  97,  99, 116, 105, 118, 101, 105, 102, 115,  44,  32, 114, 101, 115, 117,
  108, 116,  41,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32,  52,  58,  32,  82, 101, 109, 111, 118,
  101,  32,  97, 108, 108,  32,  99, 111, 100, 101,  32, 105, 102,  32, 114, 101,
  115, 117, 108, 116,  32, 105, 115,  32, 102,  97, 108, 115, 101,  32, 117, 110,
  116, 105, 108,  32,  35, 101, 110, 100, 105, 102,  32, 111, 114,  32,  35, 101,
  108, 115, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 114, 117, 110,  32,  61,  32, 114, 101, 115, 117, 108, 116,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  44,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  35, 105, 102,
  100, 101, 102,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  47,  47,  32,  69, 120,  97, 109, 112, 108, 101,  58,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32,  35, 105, 102, 100, 101, 102,  32,  40,  95,  95,  65,  80,  80,  76,  69,
   95,  95,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32,  49,  58,  32,  71, 101, 116,  32, 116,
  104, 101,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  44,  32,  69, 118,
  101, 114, 121, 116, 104, 105, 110, 103,  32, 105, 110,  32,  98, 101, 116, 119,
  101, 101, 110,  32, 116, 104, 101,  32,  40,  41,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,  99,
  111, 110, 100, 105, 116, 105, 111, 110,  32,  61,  32, 118,  91,  50,  93,  45,
   62, 103, 115, 117,  98,  40,  34,  35, 105, 102,  32,  34,  44,  32,  34,  34,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  47,  47,  47,  32,  71, 101, 116,  32, 101, 118, 101, 114, 121, 116,
  104, 105, 110, 103,  32, 105, 110,  32,  98, 101, 116, 119, 101, 101, 110,  32,
  116, 104, 101,  32,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,  32,  61,
   32,  49,  44,  32,  35,  99, 111, 110, 100, 105, 116, 105, 111, 110,  41,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 118, 118,  32,  61,  32,  99,
  111, 110, 100, 105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40, 105, 105,
   44,  32, 105, 105,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 118, 118,
   32,  61,  61,  32,  34,  40,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  32,  61,  32,  99,
  111, 110, 100, 105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40, 105, 105,
   32,  43,  32,  49,  44,  32,  35,  99, 111, 110, 100, 105, 116, 105, 111, 110,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105, 105,
   32,  61,  32,  35,  99, 111, 110, 100, 105, 116, 105, 111, 110,  44,  32,  49,
   44,  32,  45,  49,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32,
  118, 118,  32,  61,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,  62,
  115, 117,  98,  40, 105,  44,  32, 105,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,
   32,  40, 118, 118,  32,  61,  61,  32,  34,  41,  34,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,
   32,  61,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,  62, 115, 117,
   98,  40,  49,  44,  32, 105, 105,  32,  45,  32,  49,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  47,  47,  32,  50,  58,  32,  69, 118,  97, 108, 117,  97,
  116, 101,  32, 116, 104, 101,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 118,  97, 114,  32, 115, 117,  99,  99, 101, 115, 115,  44,  32, 114, 101,
  115, 117, 108, 116,  32,  61,  32, 120, 112,  99,  97, 108, 108,  40, 102, 117,
  110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101,
  116, 117, 114, 110,  32,  40, 101, 110, 118, 108, 111,  97, 100,  40,  34, 114,
  101, 116, 117, 114, 110,  32, 100, 101, 102, 105, 110, 101, 100,  40,  92,  34,
   34,  46,  46,  40,  99, 111, 110, 100, 105, 116, 105, 111, 110,  32, 124, 124,
   32,  34, 110, 117, 108, 108,  34,  41,  46,  46,  34,  92,  34,  41,  34,  41,
   32, 124, 124,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99,
  101, 115, 115, 111, 114,  40,  34,  70,  97, 105, 108, 101, 100,  32, 116, 111,
   32,  99, 104, 101,  99, 107,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,
   92, 110,  34,  46,  46,  40, 116,  97,  98, 108, 101,  46, 112,  97,  99, 107,
   40, 101, 110, 118, 108, 111,  97, 100,  40,  34, 114, 101, 116, 117, 114, 110,
   32,  34,  46,  46,  40,  99, 111, 110, 100, 105, 116, 105, 111, 110,  32, 124,
  124,  32,  34, 110, 117, 108, 108,  34,  41,  41,  41,  32, 124, 124,  32,  34,
   70,  97, 105, 108, 101, 100,  32, 116, 111,  32, 101, 114, 114, 111, 114,  34,
   41,  91,  50,  93,  41,  41,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  44,  32, 102, 117, 110,  99,
  116, 105, 111, 110,  40, 101, 114, 114,  41, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101,
  114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,
   40, 101, 114, 114,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33, 115, 117,
   99,  99, 101, 115, 115,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114,
  111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40, 114,
  101, 115, 117, 108, 116,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  51,  58,  32,  82,
  101, 109, 111, 118, 101,  32, 116, 104, 101,  32, 108, 105, 110, 101,  32,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,  32,  61,
   32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 116,  97,  98, 108, 101,  46, 105, 110, 115, 101,
  114, 116,  40,  97,  99, 116, 105, 118, 101, 105, 102, 115,  44,  32, 114, 101,
  115, 117, 108, 116,  41,  10,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  52,  58,  32,  82, 101, 109,
  111, 118, 101,  32,  97, 108, 108,  32,  99, 111, 100, 101,  32, 105, 102,  32,
  114, 101, 115, 117, 108, 116,  32, 105, 115,  32, 102,  97, 108, 115, 101,  32,
  117, 110, 116, 105, 108,  32,  35, 101, 110, 100, 105, 102,  32, 111, 114,  32,
   35, 101, 108, 115, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 114, 117, 110,  32,  61,  32, 114, 101, 115, 117,
  108, 116,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,  35,
  105, 102, 110, 100, 101, 102,  34,  58,  32, 102, 117, 110,  99, 116, 105, 111,
  110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  32,  69, 120,  97, 109, 112, 108, 101,  58,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  47,  47,  32,  35, 105, 102, 100, 101, 102,  32,  40,  95,  95,  65,  80,
   80,  76,  69,  95,  95,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  49,  58,  32,  71, 101,
  116,  32, 116, 104, 101,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  44,
   32,  69, 118, 101, 114, 121, 116, 104, 105, 110, 103,  32, 105, 110,  32,  98,
  101, 116, 119, 101, 101, 110,  32, 116, 104, 101,  32,  40,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97,
  114,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  32,  61,  32, 118,  91,
   50,  93,  45,  62, 103, 115, 117,  98,  40,  34,  35, 105, 102,  32,  34,  44,
   32,  34,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  47,  47,  47,  32,  71, 101, 116,  32, 101, 118, 101,
  114, 121, 116, 104, 105, 110, 103,  32, 105, 110,  32,  98, 101, 116, 119, 101,
  101, 110,  32, 116, 104, 101,  32,  40,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,  40, 105,
  105,  32,  61,  32,  49,  44,  32,  35,  99, 111, 110, 100, 105, 116, 105, 111,
  110,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 118, 118,  32,
   61,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,  62, 115, 117,  98,
   40, 105, 105,  44,  32, 105, 105,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,
   40, 118, 118,  32,  61,  61,  32,  34,  40,  34,  41,  32, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  32,
   61,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,  62, 115, 117,  98,
   40, 105, 105,  32,  43,  32,  49,  44,  32,  35,  99, 111, 110, 100, 105, 116,
  105, 111, 110,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,
   97, 107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111, 114,  32,
   40, 105, 105,  32,  61,  32,  35,  99, 111, 110, 100, 105, 116, 105, 111, 110,
   44,  32,  49,  44,  32,  45,  49,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32, 118, 118,  32,  61,  32,  99, 111, 110, 100, 105, 116, 105, 111,
  110,  45,  62, 115, 117,  98,  40, 105, 105,  44,  32, 105, 105,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 105, 102,  32,  40, 118, 118,  32,  61,  61,  32,  34,  41,  34,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 110, 100,
  105, 116, 105, 111, 110,  32,  61,  32,  99, 111, 110, 100, 105, 116, 105, 111,
  110,  45,  62, 115, 117,  98,  40,  49,  44,  32, 105, 105,  32,  45,  32,  49,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  50,  58,  32,  69,
  118,  97, 108, 117,  97, 116, 101,  32, 116, 104, 101,  32,  99, 111, 110, 100,
  105, 116, 105, 111, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 115, 117,  99,  99, 101, 115,
  115,  44,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32, 120, 112,  99,  97,
  108, 108,  40, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  40, 101, 110, 118, 108, 111,
   97, 100,  40,  34, 114, 101, 116, 117, 114, 110,  32,  33, 100, 101, 102, 105,
  110, 101, 100,  40,  92,  34,  34,  46,  46,  99, 111, 110, 100, 105, 116, 105,
  111, 110,  46,  46,  34,  92,  34,  41,  34,  41,  32, 124, 124,  32, 101, 114,
  114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40,
   34,  70,  97, 105, 108, 101, 100,  32, 116, 111,  32,  99, 104, 101,  99, 107,
   32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  92, 110,  34,  46,  46, 116,
   97,  98, 108, 101,  46, 112,  97,  99, 107,  40, 101, 110, 118, 108, 111,  97,
  100,  40,  34, 114, 101, 116, 117, 114, 110,  32,  34,  46,  46,  99, 111, 110,
  100, 105, 116, 105, 111, 110,  41,  41,  91,  50,  93,  41,  41,  40,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 101, 114, 114,  41,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 111, 114,  40, 101, 114, 114,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  105, 102,  32,  40,  33, 115, 117,  99,  99, 101, 115, 115,  41,  32, 123,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99,
  101, 115, 115, 111, 114,  40, 114, 101, 115, 117, 108, 116,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32,  51,  58,  32,  82, 101, 109, 111, 118, 101,  32, 116, 104, 101,
   32, 108, 105, 110, 101,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91,
  118,  91,  49,  93,  93,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116,  97,  98,
  108, 101,  46, 105, 110, 115, 101, 114, 116,  40,  97,  99, 116, 105, 118, 101,
  105, 102, 115,  44,  32, 114, 101, 115, 117, 108, 116,  41,  10,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,
   32,  52,  58,  32,  82, 101, 109, 111, 118, 101,  32,  97, 108, 108,  32,  99,
  111, 100, 101,  32, 105, 102,  32, 114, 101, 115, 117, 108, 116,  32, 105, 115,
   32, 102,  97, 108, 115, 101,  32, 117, 110, 116, 105, 108,  32,  35, 101, 110,
  100, 105, 102,  32, 111, 114,  32,  35, 101, 108, 115, 101,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 117, 110,
   32,  61,  32, 114, 101, 115, 117, 108, 116,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  34,  35, 101, 108, 105, 102,  34,  58,  32, 102, 117,
  110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  69, 120,  97,
  109, 112, 108, 101,  58,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  47,  47,  32,  35, 101, 108, 105, 102,  32,  40,
  116, 114, 117, 101,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 114, 117, 110,  41,  32, 123,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,
   49,  93,  93,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32,  47,  47,  32,  83, 107, 105, 112,  32, 116, 104,
  105, 115,  32, 108, 105, 110, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  49,  58,  32,
   71, 101, 116,  32, 116, 104, 101,  32,  99, 111, 110, 100, 105, 116, 105, 111,
  110,  44,  32,  69, 118, 101, 114, 121, 116, 104, 105, 110, 103,  32, 105, 110,
   32,  98, 101, 116, 119, 101, 101, 110,  32, 116, 104, 101,  32,  40,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  118,  97, 114,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  32,  61,  32,
  118,  91,  50,  93,  45,  62, 103, 115, 117,  98,  40,  34,  35, 101, 108, 105,
  102,  32,  34,  44,  32,  34,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  47,  32,  71, 101, 116,
   32, 101, 118, 101, 114, 121, 116, 104, 105, 110, 103,  32, 105, 110,  32,  98,
  101, 116, 119, 101, 101, 110,  32, 116, 104, 101,  32,  40,  41,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 102, 111,
  114,  32,  40, 105, 105,  32,  61,  32,  49,  44,  32,  35,  99, 111, 110, 100,
  105, 116, 105, 111, 110,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,
   32, 118, 118,  32,  61,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,
   62, 115, 117,  98,  40, 105, 105,  44,  32, 105, 105,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 105, 102,  32,  40, 118, 118,  32,  61,  61,  32,  34,  40,  34,  41,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  99, 111, 110, 100, 105, 116,
  105, 111, 110,  32,  61,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  45,
   62, 115, 117,  98,  40, 105, 105,  32,  43,  32,  49,  44,  32,  35,  99, 111,
  110, 100, 105, 116, 105, 111, 110,  41,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  102, 111, 114,  32,  40, 105, 105,  32,  61,  32,  35,  99, 111, 110, 100, 105,
  116, 105, 111, 110,  44,  32,  49,  44,  32,  45,  49,  41,  32, 123,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32, 118,  97, 114,  32, 118, 118,  32,  61,  32,  99, 111, 110, 100,
  105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40, 105, 105,  44,  32, 105,
  105,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40, 118, 118,  32,  61,  61,
   32,  34,  41,  34,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   99, 111, 110, 100, 105, 116, 105, 111, 110,  32,  61,  32,  99, 111, 110, 100,
  105, 116, 105, 111, 110,  45,  62, 115, 117,  98,  40,  49,  44,  32, 105, 105,
   32,  45,  32,  49,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114,
  101,  97, 107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
   50,  58,  32,  69, 118,  97, 108, 117,  97, 116, 101,  32, 116, 104, 101,  32,
   99, 111, 110, 100, 105, 116, 105, 111, 110,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 115, 117,
   99,  99, 101, 115, 115,  44,  32, 114, 101, 115, 117, 108, 116,  32,  61,  32,
  120, 112,  99,  97, 108, 108,  40, 102, 117, 110,  99, 116, 105, 111, 110,  40,
   41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  40, 101,
  110, 118, 108, 111,  97, 100,  40,  34, 114, 101, 116, 117, 114, 110,  32,  34,
   46,  46,  99, 111, 110, 100, 105, 116, 105, 111, 110,  41,  32, 124, 124,  32,
  101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111,
  114,  40,  34,  70,  97, 105, 108, 101, 100,  32, 116, 111,  32,  99, 104, 101,
   99, 107,  32,  99, 111, 110, 100, 105, 116, 105, 111, 110,  92, 110,  34,  46,
   46, 116,  97,  98, 108, 101,  46, 112,  97,  99, 107,  40, 101, 110, 118, 108,
  111,  97, 100,  40,  34, 114, 101, 116, 117, 114, 110,  32,  34,  46,  46,  99,
  111, 110, 100, 105, 116, 105, 111, 110,  41,  41,  91,  50,  93,  41,  41,  40,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 101, 114,
  114,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  40, 101, 114, 114,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 105, 102,  32,  40,  33, 115, 117,  99,  99, 101, 115, 115,  41,  32,
  123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 111, 114,  40, 114, 101, 115, 117, 108, 116,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  47,  47,  32,  51,  58,  32,  82, 101, 109, 111, 118, 101,  32, 116,
  104, 101,  32, 108, 105, 110, 101,  32,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101,
  115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 110, 117, 108, 108,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116,
   97,  98, 108, 101,  46, 105, 110, 115, 101, 114, 116,  40,  97,  99, 116, 105,
  118, 101, 105, 102, 115,  44,  32, 114, 101, 115, 117, 108, 116,  41,  10,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32,  52,  58,  32,  82, 101, 109, 111, 118, 101,  32,  97, 108, 108,
   32,  99, 111, 100, 101,  32, 105, 102,  32, 114, 101, 115, 117, 108, 116,  32,
  105, 115,  32, 102,  97, 108, 115, 101,  32, 117, 110, 116, 105, 108,  32,  35,
  101, 110, 100, 105, 102,  32, 111, 114,  32,  35, 101, 108, 115, 101,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  117, 110,  32,  61,  32, 114, 101, 115, 117, 108, 116,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  34,  35, 101, 108, 115, 101,  34,  58,  32,
  102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 117, 110,  32,
   61,  32,  33, 114, 117, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91,
  118,  91,  49,  93,  93,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  44,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  34,  35, 101, 110, 100, 105, 102,  34,
   58,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  97,  99,
  116, 105, 118, 101, 105, 102, 115,  91,  35,  97,  99, 116, 105, 118, 101, 105,
  102, 115,  93,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105,
  110, 101, 115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 110, 117, 108, 108,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 114, 117, 110,  32,  61,  32, 116, 114, 117, 101,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  34,  35, 117, 110, 100, 101, 102,  34,  58,
   32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,
  115, 112, 108, 105, 116,  32, 118,  91,  50,  93,  32,  98, 121,  32, 115, 112,
   97,  99, 101, 115,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 118,  97, 114,  32, 115, 112, 108, 105, 116,  32,  61,
   32, 118,  91,  50,  93,  45,  62, 115, 112, 108, 105, 116,  40,  34,  32,  34,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  47,  47,  32,  49,  58,  32,  71, 101, 116,  32, 116, 104, 101,  32,
  110,  97, 109, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 118,  97, 114,  32, 110,  97, 109, 101,  32,  61,  32,
  115, 112, 108, 105, 116,  91,  50,  93,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  50,  58,  32,  82,
  101, 109, 111, 118, 101,  32, 116, 104, 101,  32, 118,  97, 108, 117, 101,  32,
  105, 110,  32, 116, 104, 101,  32, 101, 110, 118,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 118,  91, 110,
   97, 109, 101,  93,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  51,
   58,  32,  82, 101, 109, 111, 118, 101,  32, 116, 104, 101,  32, 108, 105, 110,
  101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,
   32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  34,  35, 101, 114, 114, 111, 114,  34,  58,  32, 102, 117, 110,
   99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,  32, 101, 114, 114,
  111, 114,  32,  61,  32, 118,  91,  50,  93,  45,  62, 103, 115, 117,  98,  40,
   34,  35, 101, 114, 114, 111, 114,  32,  34,  44,  32,  34,  34,  41,  10,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112,
  114, 105, 110, 116,  40,  34,  92,  50,  55,  91,  49,  59,  51,  49, 109,  82,
   97, 105, 115, 101, 100,  32, 101, 114, 114, 111, 114,  58,  92,  50,  55,  91,
   48, 109,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 112, 114, 105, 110, 116,  40,  34,  92,  50,  55,  91,
   49,  59,  51,  49, 109,  34,  46,  46, 101, 114, 114, 111, 114,  46,  46,  34,
   92,  50,  55,  91,  48, 109,  92, 110,  92, 110,  34,  41,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114,
  111, 114,  40,  34,  69, 110, 100, 105, 110, 103,  32, 112, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 111, 114,  34,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  34,  35, 119,  97, 114, 110, 105, 110, 103,  34,  58,
   32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 118,  97, 114,
   32, 119,  97, 114, 110, 105, 110, 103,  32,  61,  32, 118,  91,  50,  93,  45,
   62, 103, 115, 117,  98,  40,  34,  35, 119,  97, 114, 110, 105, 110, 103,  32,
   34,  44,  32,  34,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 119,  97, 114, 110,  40, 119,  97, 114, 110,
  105, 110, 103,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110, 101, 115,  91, 118,  91,
   49,  93,  93,  32,  61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  34,  35,  99, 111, 110, 102, 105, 103,  34,  58,
   32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114,
  111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40,  34,
   67, 111, 110, 102, 105, 103,  32, 105, 115,  32, 110, 111, 116,  32, 115, 117,
  112, 112, 111, 114, 116, 101, 100,  34,  41,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  44,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  34,  35, 101, 120, 116,  34,  58,  32, 102, 117, 110,
   99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  73, 110, 115, 116,
   97, 108, 108, 115,  32,  97, 110,  32, 101, 120, 116, 101, 110, 115, 105, 111,
  110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101, 115,
  115, 111, 114,  40,  34,  69, 120, 116, 101, 110, 115, 105, 111, 110, 115,  32,
   97, 114, 101,  32, 110, 111, 116,  32, 115, 117, 112, 112, 111, 114, 116, 101,
  100,  34,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
  125,  44,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  34,
  100, 101, 102,  97, 117, 108, 116,  34,  58,  32, 102, 117, 110,  99, 116, 105,
  111, 110,  40, 118,  97, 108, 117, 101,  41, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  33,
  114, 117, 110,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101, 119, 108, 105, 110,
  101, 115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 110, 117, 108, 108,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  47,  47,  32,  83, 107,
  105, 112,  32, 116, 104, 105, 115,  32, 108, 105, 110, 101,  10,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 125,  10,  10,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   47,  47,  32,  69, 120, 101,  99, 117, 116, 101,  32, 101, 118, 101, 114, 121,
  116, 104, 105, 110, 103,  32, 112,  97, 115, 116,  32, 116, 104, 101,  32,  35,
   32,  97, 115,  32,  97,  32,  99, 111,  98,  97, 108, 116,  32, 108, 105, 110,
  101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32,  99, 111, 100, 101,  32,  61,  32, 118,  91,  50,
   93,  45,  62, 115, 117,  98,  40,  50,  44,  32,  35, 118,  91,  50,  93,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 118,  97, 114,  32, 115, 117,  99,  99, 101, 115, 115,  44,  32, 114,
  101, 115, 117, 108, 116,  32,  61,  32, 120, 112,  99,  97, 108, 108,  40, 102,
  117, 110,  99, 116, 105, 111, 110,  40,  41, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114,
  101, 116, 117, 114, 110,  32,  40, 101, 110, 118, 108, 111,  97, 100,  40,  99,
  111, 100, 101,  41,  32, 124, 124,  32, 101, 114, 114, 111, 114, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  40,  34,  70,  97, 105, 108, 101,
  100,  32, 116, 111,  32, 108, 111,  97, 100,  32, 112, 114, 101, 112, 114, 111,
   99, 101, 115, 115, 111, 114,  32,  99, 111, 109, 109,  97, 110, 100,  34,  41,
   41,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,
  101, 114, 114,  41, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112,
  114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  40, 101, 114, 114,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32, 125,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  32,  40,  33, 115, 117,  99,  99, 101, 115, 115,
   41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101,
  112, 114, 111,  99, 101, 115, 115, 111, 114,  40, 114, 101, 115, 117, 108, 116,
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32, 125, 101, 108, 115, 101,  32, 123,  10,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 110, 101,
  119, 108, 105, 110, 101, 115,  91, 118,  91,  49,  93,  93,  32,  61,  32, 114,
  101, 115, 117, 108, 116,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 125,  41,
   10,  32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  32,  82, 101, 109, 111,
  118, 101,  32, 108, 105, 110, 101,  32, 102, 114, 111, 109,  32, 110, 101, 119,
  108, 105, 110, 101, 115,  32,  10,  32,  32,  32,  32, 125,  10,  10,  32,  32,
   32,  32,  47,  47,  32,  52,  58,  32,  74, 111, 105, 110,  32, 110, 101, 119,
  108, 105, 110, 101, 115,  32,  97, 110, 100,  32, 114, 101, 116, 117, 114, 110,
   10,  32,  32,  32,  32, 105, 102,  32,  40,  35,  97,  99, 116, 105, 118, 101,
  105, 102, 115,  32,  62,  32,  48,  41,  32, 123,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 101, 114, 114, 111, 114, 112, 114, 101, 112, 114, 111,  99, 101,
  115, 115, 111, 114,  40,  34,  77, 105, 115, 115, 105, 110, 103,  32,  35, 101,
  110, 100, 105, 102,  40, 115,  41,  34,  41,  10,  32,  32,  32,  32, 125,  10,
   32,  32,  32,  32, 108, 105, 110, 101, 115,  32,  61,  32, 110, 117, 108, 108,
   10,  32,  32,  32,  32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115,  32,
   61,  32, 110, 117, 108, 108,  10,  32,  32,  32,  32, 115, 116, 114,  32,  61,
   32, 110, 117, 108, 108,  10,  32,  32,  32,  32, 118,  97, 114,  32, 106, 111,
  105, 110, 101, 100,  32,  61,  32,  34,  47,  42,  32,  80, 114, 101, 112, 114,
  111,  99, 101, 115, 115, 101, 100,  32, 119, 105, 116, 104,  32, 116, 104, 101,
   32,  98, 117, 105, 108, 116,  32, 105, 110,  32,  67, 111,  98,  97, 108, 116,
   32, 112, 114, 101, 112, 114, 111,  99, 101, 115, 115, 111, 114,  32,  42,  47,
   92, 110,  92, 110,  92, 110,  34,  10,  32,  32,  32,  32, 102, 111, 114,  32,
   40, 105,  44,  32, 118,  32, 105, 110,  32, 112,  97, 105, 114, 115,  40, 110,
  101, 119, 108, 105, 110, 101, 115,  41,  41,  32, 123,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 105, 102,  32,  40, 118,  32,  61,  61,  32, 110, 117, 108,
  108,  41,  32, 123,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,
   32,  99, 111, 110, 116, 105, 110, 117, 101,  59,  10,  32,  32,  32,  32,  32,
   32,  32,  32, 125,  10,  32,  32,  32,  32,  32,  32,  32,  32, 106, 111, 105,
  110, 101, 100,  32,  61,  32, 106, 111, 105, 110, 101, 100,  46,  46, 118,  46,
   46,  34,  92, 110,  34,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,
  110, 101, 119, 108, 105, 110, 101, 115,  32,  61,  32, 110, 117, 108, 108,  10,
   32,  32,  32,  32, 105, 102,  32,  40, 111, 117, 116,  41, 123,  10,  32,  32,
   32,  32,  32,  32,  32,  32,  47,  47,  32,  87, 114, 105, 116, 101,  32, 116,
  111,  32, 111, 117, 116,  32,  10,  32,  32,  32,  32,  32,  32,  32,  32, 118,
   97, 114,  32, 102, 105, 108, 101,  32,  61,  32, 105, 111,  46, 111, 112, 101,
  110,  40, 111, 117, 116, 102, 105, 108, 101,  44,  32,  34, 119,  34,  41,  10,
   32,  32,  32,  32,  32,  32,  32,  32, 102, 105, 108, 101,  45,  62, 119, 114,
  105, 116, 101,  40, 106, 111, 105, 110, 101, 100,  41,  10,  32,  32,  32,  32,
   32,  32,  32,  32, 102, 105, 108, 101,  45,  62,  99, 108, 111, 115, 101,  40,
   41,  10,  32,  32,  32,  32, 125,  10,  32,  32,  32,  32,  99, 111, 108, 108,
  101,  99, 116, 103,  97, 114,  98,  97, 103, 101,  40,  41,  32,  47,  47,  32,
   67, 111, 108, 108, 101,  99, 116,  32, 103,  97, 114,  98,  97, 103, 101,  10,
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 106, 111, 105, 110, 101,
  100,  10, 125,  10,  10, 112, 114, 111,  99, 101, 115, 115,  40,  34, 116, 101,
  115, 116,  46,  99, 111,  98,  97, 108, 116,  34,  44,  32,  34, 102, 105, 108,
  101,  34,  44,  32, 116, 114, 117, 101,  44,  32,  34, 116, 101, 115, 116,  50,
   46,  99, 111,  98,  97, 108, 116,  34,  41,  10, 114, 101, 116, 117, 114, 110,
   32, 112, 114, 111,  99, 101, 115, 115,   0
};

#define aot_LUAOPEN_NAME luaopen_init

#include "aot_footer.c"
