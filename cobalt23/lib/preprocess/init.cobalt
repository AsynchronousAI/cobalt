// Built in preprocessor for cobalt
// The preprocesser is not apart of the compiler
// and needs to be built using `make pre` and
// used before compiling the source code

// The preprocessor replaces preprocessor directives with
// cobalt code depending on system and other factors

/* Dependencies
   // Switch (Installed with `make setup`)
   // Filex (Installed with `make setup`)
   // core // Preloaded, needed to get C macros. JIT Ported & Interpreter Core.
   // ffi // Preloaded, needed to get C macros. JIT Ported & Interpreter Core.
   // Base libraries // JIT & Interpreter designed preloaded libraries
*/

/* Notes
    - The preprocessor is not apart of the compiler
    - Using C Macros require GCC to be installed (As of the `core` library dependency)
    - C Macros will NOT work on the JIT compiler
*/

/* TODO:
    None!
*/

/* Supports
    // #open (name): Checks if a Macro is defined and opens it so that the program can use it
    // #define (name) (value <optional>): Sets a macro
    // #define (lambdaname)(args) (function): Sets a macro to a lambda function
    // #undef (name): Removes a macro
    // #ifdef (name): If macro is defined, Condition must be wrapped in ()
    // #ifndef (name): If macro is not defined, Condition must be wrapped in ()
    // #elif (name): Else if macro is defined, Condition must be wrapped in ()
    // #else: Else, no condition
    // #endif: End if
    // #error (message): Raises an error
    // #warning (message): Raises a warning
    // #include "file.cobalt": Includes a file (Cyclic dependencies will leave the preprocessor in an infinite loop) (Name must be in "")
    // #line (line) "file.cobalt <optional>": Sets the line number and file name for the preprocessor (Cyclic dependencies will leave the preprocessor in an infinite loop) (Name must be in "")


    // Everything else that starts with a # will be executed as a cobalt source line
    // C Macros are supported if GCC is installed, if not, they will be ignored.
    // cobalt and cobaltversion are included macros
*/

switch = import("switch") // Switch library for cobalt
filesystem = file || import("file") // File library for cobalt
filex = import("ext.file") // Extended File library for cobalt
core = core || import("core") // Core library for cobalt

typechecker = import("type") // Integrated type checker.

function process(str, itemtype, out, outfile, ...){
    // 0: Init
    
    /// Check mode:
    if (str == "-help" && outfile == "-types"){
        typechecker.all() // Print all valid types
    }

    /// Init macros
    core.macros()
    
    // 0: Run typechecker
    typechecker.check(str)

    // 1: Split lines
    var nstr
    var ogstr = out ? str : null
    if (itemtype == "file") {
        var file = io.open(str)
        if (!file){
            error(core.error.strerror(2))
        }
        nstr = file->read("*all")
        file->close()
        if (!nstr){
            error(core.error.strerror(2))
        }
    }
    if (!nstr) nstr = str
    var lines = []
    for (line in nstr->gmatch("[^\r\n]+")) {
        lines[#lines + 1] = line
    }

    function getname(){
        if (ogstr){
            // cwd/ogstr
            return filex.join(filesystem.currentdir(), ogstr)
        }else{
            return debug.getinfo(2, "S").source->sub(2)
        }
    }

    // 2: Look for preprocess lines
    var preprocess = []
    for (i, v in pairs(lines)) {
        var first = v->sub(1, 1) 
        var char = 1

        while (first == " " || first == "\t") {
            char++;
            first = v->sub(char, char)
        }

        if (first == "#") {
            v = v->sub(char, #v)
        
            table.insert(preprocess, [i, v])
        }
    }
    
    // 3: Execute preprocess lines
    var env = {
        "cobalt": true, 
        "cobaltversion": "23",
        "edition": "standard",
        "cplusplus": false,
    }
    // inenv will be like: -X="t" -M=2 -Z=true will become {["X"]="t", ["M"]=2, ["Z"]=true}
    envitems = table.pack(...)
    inenv = {}
    for (i, v in pairs(envitems)){
        if (type(v) == "number"){
            break;
        }
        var split = v->gsub("-", "")->split("=")
        inenv[split[1]] = loadstring("return "..split[2])()
    }

    // 4: Add inenv to env
    for (i, v in pairs(inenv)){
        if (type(v) == "string") v = '"'..v..'"'
        env[i] = v
    }
    var newlines = lines
    var activeifs = []
    var run = true
    var incomment = false

    function envload(str2){
        var tbld = "{"
        for (k, v in pairs(env)) {
            if (type(k) == "number") {
                tbld = tbld .. v .. ","
            }else if (type(k) == "string") {
                tbld = tbld .. '"' .. k .. '": ' .. tostring(v) .. ","
            }
        }
        tbld = tbld .. "}"
        return loadstring([=[// Cobalt execution environment: Ignore.
            env = ]=]..tbld..[=[;
            for (i, v in pairs(env)){
                _ENV[i] = v
            }
            core = import("core")
            function defined(val){
                // check if it is in env, if it return the value
                if (env[val] != null && env[val] != false) {
                    return env[val]
                }else{
                    if (jit == null){
                        return core.macros(val)
                    }else{
                        warn(val.." is not defined and C macros are not supported on the JIT compiler")
                    }
                }
            }]=]..str2)
    }
    for (i, v in pairs(lines)) {
        // Check if i is v[1] for one of the preprocess lines
        /// Go through every character, if a /* is found make incomment true, if a */ is found make incomment false
        /// If incomment is true, remove the line
        for (ii = 1, #v) {
            var char = v->sub(ii, ii)
            if (char == "/" && v->sub(ii + 1, ii + 1) == "*") {
                incomment = true
            }
            if (char == "*" && v->sub(ii + 1, ii + 1) == "/") {
                incomment = false
            }
        }
        if (incomment) {
            continue;
        }
        var found = false
        for (i2, v2 in pairs(preprocess)) {
            if (v2[1] == i) {
                v = v2
                found = true
                break;
            }
        }
        if (!found) {
            if (!run) {
                newlines[i] = null
            }
            continue;
        }

        // Get the first word of the line
        function errorpreprocessor(errorin){
            print("\27[1;31mPreprocessor error:\27[0m")
            print("\27[1;31mError with the '"..v[2].."' preprocessor command.\27[0m\n\n")
            if (errorin) {
                print("\27[1;31m"..errorin.."\27[0m\n\n")
            }
            print("\27[1;31mStopping preprocessor.\27[0m")
            os.exit()
        }

        // If the second character is a !, ignore the line
        if (v[2]->sub(2, 2) == "!") {
            newlines[v[1]] = null
            return // Skip this line
        }

        switch(v[2]->match("%S+"), {
            "#open": function(){
                // Example:
                // #open X
                // this is assuming X is in the env
                // var X = <whatever X is in the env>
                var name = v[2]->gsub("#open ", "")
                var value = env[name]
                if (value == null) {
                    errorpreprocessor("Macro '"..name.."' is not defined")
                }
                newlines[v[1]] = "var "..tostring(name).." = "..((type(value) == "string" && (str->sub(1,1) == '"' && str->sub(-1) == '"') || (str->sub(1,1) == "'" && str->sub(-1) == "'")) ? '"'..value..'"' : tostring(value))
                
                // Avoid memory leaks
                name, value = null
            },
            "#define": function(){
                // split v[2] by spaces
                var split = v[2]->split(" ")
                // 1: Get the name
                var name = split[2]
                if (string.sub(name, -1) == ")"){
                    // Example:
                    // #define RADTODEG(rad) (rad * 180 / PI)
                    // should become
                    // var RADTODEG = function(rad){ return (rad * 180 / PI)}

                    // 1: Get the name
                    var values = string.split(v[2], " ")
                    var defname = values[2]->split("(")[1]
                    var args = values[2]->split("(")[2]->gsub("%)", "")->split(",")
                    var func = values[3]
                    for (i = 4, #values) {
                        func = func.." "..values[i]
                    }
                    for (i, v in pairs(args)){
                        args[i] = v->gsub(" ", "")
                    }

                    var funcdef = "function("..table.concat(args, ",").."){ return "..func.."; }"
                    var valdef = "var "..defname.." = "..funcdef

                    // 2: Set values
                    newlines[v[1]] = valdef
                    env[name] = funcdef

                    // 3: Clear memory
                    values, defname, funcdef, valdef, args, func = null
                }else{
                    // 2: Get the value
                    var value 
                    var fun, err = envload("return "..split[3] || "false")
                    if (!fun){
                        errorpreprocessor(err)
                    }else{
                        value = fun()
                    }
                    // 3: Set the value in the env
                    env[name] = value
                    // 4: Remove the line
                    newlines[v[1]] = "var "..name.." = "..(type(value) == "string" ? '"'..value..'"' : tostring(value))
                    return
                }
            },
            "#line": function(){
                // Example:
                // #line 1 "file.cobalt"
                // Will add everything after that line in that file to the newlines[i] table
                // "file.cobalt" if it is not provided it is the current file
                // 1 is the line number
                warn("Using #line is not recommended, Use import() instead")
                var split = v[2]->split(" ")
                var line = split[2]
                var filename
                if (!split[3]) {
                    filename = getname()
                }else{
                    filename = string.sub(split[3], 2, -2)
                }
                print(filename)
                var f = io.open(filename)
                if (!f) {
                    var script_path = getname()
                    var script_dir = script_path->match("(.*/)")
                    if (script_dir == null) {
                        script_dir = "./"
                    }
                    f = io.open(script_dir..filename)
                    if (!f) {
                        errorpreprocessor("File '"..script_dir..filename.."' not found")
                    }
                }
                
                var content = f->read("*all")
                f->close()
                // Set i line number to r(content)
                content = process(content, null, null)
                // Split content to everything after tonumber(line)
                split = content->split("\n")
                var newcontent = ""
                for (i = tonumber(line), #split) {
                    newcontent = newcontent..split[i].."\n"
                }
                newlines[v[1]] = newcontent

                // Avoid memory leaks
                f = null
                content = null
                newcontent = null
                split = null
                file, line = null
            },
            "#include": function(){
                warn("Using #include is not recommended, Use import() instead")

                var file = v[2]->gsub("#include \"", "")
                var ogfile = file
                // File should be a string that ends with " and may have stuff after the "
                // Remove the last " and only keep everything before it
                for (i = 1, #file) {
                    var v = file->sub(i, i)
                    if (v == "\"") {
                        file = file->sub(1, i - 1)
                        break;
                    }
                }

                var f;
                for (i, v in pairs(package.searchers)){
                    if (#table.pack(v(file)) == 2 &&  table.pack(v(file))[1] != null) {
                        f = table.pack(v(file));
                        break;
                    }
                }
                if (!f) {
                    var script_path = getname()
                    var script_dir = script_path->match("(.*/)")
                    if (script_dir == null) {
                        script_dir = "./"
                    }

                    f = (io.open(script_dir..file))
                    if (!f) {
                        errorpreprocessor("File '"..file.."' not found")
                    }
                }
                if (type(f)=="string"){
                    file = io.open(f[2])
                }else{
                    file = f
                }
                var content = file->read("*all")
                file->close()
                
                // Set i line number to r(content)
    
                newlines[v[1]], newincludes = process(content, null, null)
                // Avoid memory leaks
                file = null
                content = null
                f = null
            },
            "#if": function(){
                // Example:
                // #if (true)
                
                // 1: Get the condition, Everything in between the ()
                var condition = v[2]->gsub("#if ", "")
                /// Get everything in between the ()
                for (i = 1, #condition) {
                    var v = condition->sub(i, i)
                    if (v == "(") {
                        condition = condition->sub(i + 1, #condition)
                        break;
                    }
                }
                for (i = #condition, 1, -1) {
                    var v = condition->sub(i, i)
                    if (v == ")") {
                        condition = condition->sub(1, i - 1)
                        break;
                    }
                }
                // 2: Evaluate the condition
                var success, result = xpcall(function(){
                    return (envload("return "..condition) || errorpreprocessor("Failed to check condition\n"..table.pack(envload("return "..condition))[2]))()
                }, function(err){
                    errorpreprocessor(err)
                })
                if (!success) {
                    errorpreprocessor(result)
                }
                // 3: Remove the line 
                newlines[v[1]] = null
                table.insert(activeifs, result)

                // 4: Remove all code if result is false until #endif or #else
                run = result
            },
            "#ifdef": function(){
                // Example:
                // #ifdef (__APPLE__)
                
                // 1: Get the condition, Everything in between the ()
                var condition = v[2]->gsub("#if ", "")
                /// Get everything in between the ()
                for (i = 1, #condition) {
                    var v = condition->sub(i, i)
                    if (v == "(") {
                        condition = condition->sub(i + 1, #condition)
                        break;
                    }
                }
                for (i = #condition, 1, -1) {
                    var v = condition->sub(i, i)
                    if (v == ")") {
                        condition = condition->sub(1, i - 1)
                        break;
                    }
                }
                // 2: Evaluate the condition
                var success, result = xpcall(function(){
                    return (envload("return defined(\""..(condition || "null").."\")") || errorpreprocessor("Failed to check condition\n"..(table.pack(envload("return "..(condition || "null"))) || "Failed to error")[2]))()
                }, function(err){
                    errorpreprocessor(err)
                })
                if (!success) {
                    errorpreprocessor(result)
                }
                // 3: Remove the line 
                newlines[v[1]] = null
                table.insert(activeifs, result)

                // 4: Remove all code if result is false until #endif or #else
                run = result
            },
            "#ifndef": function(){
                // Example:
                // #ifdef (__APPLE__)
                
                // 1: Get the condition, Everything in between the ()
                var condition = v[2]->gsub("#if ", "")
                /// Get everything in between the ()
                for (i = 1, #condition) {
                    var v = condition->sub(i, i)
                    if (v == "(") {
                        condition = condition->sub(i + 1, #condition)
                        break;
                    }
                }
                for (i = #condition, 1, -1) {
                    var v = condition->sub(i, i)
                    if (v == ")") {
                        condition = condition->sub(1, i - 1)
                        break;
                    }
                }
                // 2: Evaluate the condition
                var success, result = xpcall(function(){
                    return (envload("return !defined(\""..condition.."\")") || errorpreprocessor("Failed to check condition\n"..table.pack(envload("return "..condition))[2]))()
                }, function(err){
                    errorpreprocessor(err)
                })
                if (!success) {
                    errorpreprocessor(result)
                }
                // 3: Remove the line 
                newlines[v[1]] = null
                table.insert(activeifs, result)

                // 4: Remove all code if result is false until #endif or #else
                run = result
            },
            "#elif": function(){
                // Example:
                // #elif (true)
                if (run) {
                    newlines[v[1]] = null
                    return // Skip this line
                }
                // 1: Get the condition, Everything in between the ()
                var condition = v[2]->gsub("#elif ", "")
                /// Get everything in between the ()
                for (i = 1, #condition) {
                    var v = condition->sub(i, i)
                    if (v == "(") {
                        condition = condition->sub(i + 1, #condition)
                        break;
                    }
                }
                for (i = #condition, 1, -1) {
                    var v = condition->sub(i, i)
                    if (v == ")") {
                        condition = condition->sub(1, i - 1)
                        break;
                    }
                }
                // 2: Evaluate the condition
                var success, result = xpcall(function(){
                    return (envload("return "..condition) || errorpreprocessor("Failed to check condition\n"..table.pack(envload("return "..condition))[2]))()
                }, function(err){
                    errorpreprocessor(err)
                })
                if (!success) {
                    errorpreprocessor(result)
                }
                // 3: Remove the line 
                newlines[v[1]] = null
                table.insert(activeifs, result)

                // 4: Remove all code if result is false until #endif or #else
                run = result
            },
            "#else": function(){
                run = !run
                newlines[v[1]] = null
            },
            "#endif": function(){
                activeifs[#activeifs] = null
                newlines[v[1]] = null
                run = true
            },
            "#undef": function(){
                // split v[2] by spaces
                var split = v[2]->split(" ")
                // 1: Get the name
                var name = split[2]
                // 2: Remove the value in the env
                env[name] = null
                // 3: Remove the line
                newlines[v[1]] = null
            },
            "#error": function(){
                var error = v[2]->gsub("#error ", "")
                print("\27[1;31mRaised error:\27[0m")
                print("\27[1;31m"..error.."\27[0m\n\n")
                error("Ending preprocessor")
            },
            "#warning": function(){
                var warning = v[2]->gsub("#warning ", "")
                warn(warning)
                newlines[v[1]] = null
            },
            "#config": function(){
                errorpreprocessor("Config is not supported")
            },
            "default": function(value){
                if (!run){
                    newlines[v[1]] = null
                    return // Skip this line
                }

                // Execute everything past the # as a cobalt line
                var code = v[2]->sub(2, #v[2])
                
                var success, result = xpcall(function(){
                    return (envload(code) || errorpreprocessor("Failed to load preprocessor command"))()
                }, function(err){
                    errorpreprocessor(err)
                })
                if (!success) {
                    errorpreprocessor(result)
                }else {
                    newlines[v[1]] = result
                }
            }
        })
        // Remove line from newlines 
    }

    // 4: Join newlines and return
    if (#activeifs > 0) {
        errorpreprocessor("Missing #endif(s)")
    }
    lines = null
    preprocess = null
    str = null
    var joined = "/* Processed with cobalt23 Preprocessor | v1 */\n\n\n"
    for (i, v in pairs(newlines)) {
        if (v == null) {
            continue;
        }
        joined = joined..v.."\n"
    }
    newlines = null
    if (out){
        // Write to out 
        var file = io.open(outfile, "w")
        file->write(joined)
        file->close()
    }
    collectgarbage() // Collect garbage
    return joined
}

return process