// Built in preprocessor for cobalt
// The preprocesser is not apart of the compiler
// and needs to be built using `cmake . && make` and
// used before compiling the source code

// The preprocessor replaces preprocessor directives with
// cobalt code depending on system and other factors

// Not used directly, rather compiled to C and included in source.

// INIT
/*
NOT THE SAME VERSION AS IN C. THIS MAY HAVE BUGS
*/
filesystem = file // File library for cobalt
var lfs = {};
var windows = package.config->sub(1,1) == "\\";

var other_sep;
var sep;
var dirsep;

if( windows ) {
	sep = '\\';
	other_sep = '/';
	dirsep = ';';
} else {
	sep = '/';
	dirsep = ':';
}


var function at(s,i) {
	return string.sub(s,i,i);
}

//- returns if the path is an absolute path
function lfs.isabs(path) {
	if( windows ) {
		return at(path, 1) == '/' || at(path, 1) == '\\' || at(path, 2) ==':';
	} else {
		return at(path, 1) == '/';
	}
}

// return the path resulting from combining the individual paths.
// if the second (or later) path is absolute, we return the last absolute path (joined with any non-absolute paths following).
// empty elements (except the last) will be ignored.
function lfs.join(path1, path2,...) {
	if( select('#', ...) > 0 ) {
		var p = lfs.join(path1, path2);
		var args = {...};
		for( i = 1,#args ) {
			p = lfs.join(p, args[i]);
		}
		return p;
	}
	if( lfs.isabs(path2) ) { return path2; }
	var endc = at(path1, #path1);
	if( endc != sep && endc != other_sep && endc != "" ) {
		path1 = path1 .. sep;
	}
	return path1 .. path2;
}

// Returns the users home directory
function lfs.home() {
	var home = os.getenv('HOME');
	if( ! home ) {
		home = os.getenv('USERPROFILE') || (os.getenv('HOMEDRIVE') .. os.getenv('HOMEPATH'));
	}
	return home;
}

// We make the simplifying assumption in these functions that path separators
// are always forward slashes. This is true on *nix and *should* be true on
// windows, but you can never tell what a user will put into a config file
// somewhere. This function enforces this.
function lfs.normalize(path) {
	if( windows ) {
		return (path->gsub("\\", "/"));
	} else {
		return path;
	}
}

var _attributes = lfs.attributes;
function lfs.attributes(path, ...) {
	path = lfs.normalize(path);
	if( windows ) {
		// Windows stat() is kind of awful. If the path has a trailing slash, it
		// will always fail. Except on drive root directories, which *require* a
		// trailing slash. Thankfully, appending a "." will always work if the
		// target is a directory; and if it's not, failing on paths with trailing
		// slashes is consistent with other OSes.
		path = path->gsub("/$", "/.");
	}

	return _attributes(path, ...);
}

function lfs.exists(path) {
	return lfs.attributes(path, "mode") != null;
}

function lfs.dirname(oldpath) {
	var path = lfs.normalize(oldpath)->gsub("[^/]+/*$", "");
	if( path == "" ) {
		return oldpath;
	}
	return path;
}

function lfs.basename(oldpath) {
	var path = lfs.normalize(oldpath)->match("[^/]+/*$");
	if( path == "" ) {
		return oldpath;
	}
	return path;
}

// Recursive directory creation a la mkdir -p. Unlike lfs.mkdir, this will
// create missing intermediate directories, and will not fail if the
// destination directory already exists.
// It assumes that the directory separator is '/' and that the path is valid
// for the OS it's running on, e.g. no trailing slashes on windows -- it's up
// to the caller to ensure this!
function lfs.mkdirs(path) {
	path = lfs.normalize(path);
	if( lfs.exists(path) ) {
		return true;
	}
	if( lfs.dirname(path) == path ) {
		// We're being asked to create the root directory!
		return null,"mkdir: unable to create root directory";
	}
	var r,err = lfs.mkdirs(lfs.dirname(path));
	if( ! r ) {
		return null,err.." (creating "..path..")";
	}
	return lfs.mkdir(path);
}


// Recursive directory deletion. Unlike lfs.rmdir, this will
// delete all files recursivly, and will not fail if the
// directory is not empty.
function lfs.rmdirs(path) {
	for( file in lfs.dir(path) ) {
		var file_path = path .. sep .. file;
		if( file != "." && file != ".." ) {
			if( lfs.attributes(file_path, 'mode') == 'file' ) {
				os.remove(file_path);
			} else if( lfs.attributes(file_path, 'mode') == 'directory' ) {
				deletedir(file_path);
			}
		}
	}
	return lfs.rmdir(path);
}

filex = lfs // Extended File library for cobalt

macros = function(){} // core.macros

function switch(value, cases){
    if (type(cases) != "table"){
        error("Switch expects a table as the second argument")
    }
    
    if(cases[value]){
        if (type(cases[value]) == "string"){
            print(cases[value])
            return
        } else {
            cases[value](value)
            return
        }
    }
    if(cases["default"]){
        if (type(cases["default"]) == "string"){
            print(cases["default"])
            return
        } else {
            cases["default"](value)
            return
        }
    }
    warn("Switch cannot find a case for " .. tostring(value) .. " and no default case was provided")
}




// TYPES
types = {
  "string": function(item){
    // Check if item is a string
    return type(item) == "string"
  },
  "pos": function(item){
    return math.abs(item) == item
  },
  "neg": function(item){
    return math.abs(item) != item
  },
  "posint": function(item){
    return math.abs(item) == item && math.floor(item) == item
  },
  "negint": function(item){
    return math.abs(item) != item && math.floor(item) == item
  },
  "pointer": function(item){
    // Check if the item is a string which is parsed like a pointer
    return type(item) == "string" && (string.sub(item, 1, 1) == "&" || string.sub(item, 1, 2) == "0x")
  },
  "array": function(item){
    // Make sure that all the indexes are integers
    for (i, v in pairs(item)) {
      if (type(i) != "number") {
        return false
      }
    }
  },
  "matrix": function(item){
    // Check if all the values are a table
    for (i, v in pairs(item)) {
      if (type(v) != "table") {
        return false
      }
    }
  },
  "Vector3": function(item){
    // Uses the `Vector3` class and check if tostring(item) == "vec3: <pointer>"
    return type(item) == "userdata" && string.match(tostring(item), "^vec3: ")
  },
  "Vector2": function(item){
    // Uses the `Vector2` class and check if tostring(item) == "vec2: <pointer>"
    return type(item) == "userdata" && string.match(tostring(item), "^vec2: ")
  },
  "Color": function(item){
    // Uses the `Color` class and check if tostring(item) == "color: <pointer>"
    return type(item) == "userdata" && string.match(tostring(item), "^color: ")
  },
  "Transform": function(item){
    // Uses the `Transform` class and check if tostring(item) == "transform: <pointer>"
    return type(item) == "userdata" && string.match(tostring(item), "^transform: ")
  },
  "number": function(item){
    // Check if item is a number
    return type(item) == "number"
  },
  "boolean": function(item){
    // Check if item is a boolean
    return type(item) == "boolean"
  },
  "table": function(item){
    // Check if item is a table
    return type(item) == "table"
  },
  "function": function(item){
    // Check if item is a function
    return type(item) == "function"
  },
  "userdata": function(item){
    // Check if item is a userdata
    return type(item) == "userdata"
  },
  "thread": function(item){
    // Check if item is a thread
    return type(item) == "thread"
  },
  "null": function(item){
    // Check if item is null
    return type(item) == "null"
  },
  "void": function(item){
    // Check if item is void, which is no
    s = 0
    xpcall(function(){
      type(item)// should error
    }, function(){
      s = 1
    })
    if (s) return true
  },
  "char": function(item){
    // Check if the item is a string and 1 character long
    return type(item) == "string" && #item == 1;
  },
  "msg": function(item){
    // Check if tostring(item) == "message: <pointer>"
    // messages are used in the Message library for communication between threads
    return tostring(item) == string.match("^message: ")
  },
  "complex": function(item){
    // Try to get item.__name, if it is "complex number" then it is a complex number
    s, e = pcall(function(){ if (!item.__name){error("Force error")} })
    return s
  },
  "directory": function(item){
    // For `file` directory type
    // return tostring(item) == "directory: <pointer>"
    return tostring(item) == string.match("^directory: ")
  },
  "lock": function(item){
    // For `file` lock type
    // return tostring(item) == "lock: <pointer>"
    return tostring(item) == string.match("^lock: ")
  },
  "protected": function(item){
    // return getmetatable(item).__metatable != nil
    return getmetatable(item).__metatable != null
  },
  "_LUABOX": function(item){
    // Check if tostring(item) == "LUABOX: <pointer>"
    // this shouldnt be used for average code, LUABOX is internal
    return tostring(item) == string.match("^LUABOX: ")
  },
  "any": function(item){
    // Check if item is any type
    return true
  },
  "thread": function(item){
    // Check if item is a thread
    return type(item) == "thread"
  },
  "int": function(item){
    // Check if item is an integer
    return type(item) == "number" && math.floor(item) == item
  },
  "float": function(item){
    // Check if item is a float
    return type(item) == "number" && math.floor(item) != item
  },
  "double": function(item){
    // Check if item is a double
    return type(item) == "number" && math.floor(item) != item
  },
};
// Main

function process(str, itemtype, out, outfile, ...){
    // 0: Init
    
    /// Check mode:
    if (outfile == "-types" || (str == "-types" && !outfile) ){
        typechecker.all() // Print all valid types
        return;
    }if ({...} == {}){
        error("No arguments or invalid flags provided.")
    }

    /// Init macros
    macros()

    // 1: Split lines
    var nstr
    var ogstr = out ? str : null
    if (itemtype == "file") {
        var file = io.open(str)
        if (!file){
            error(core.error.strerror(2).." "..str)
        }
        nstr = file->read("*all")
        file->close()
        if (!nstr){
            error(core.error.strerror(2))
        }
    }
    // 0: Run typechecker and language extensions
    
    if (!nstr) nstr = str

    // 0.5: Split lines
    var lines = []
    for (line in nstr->gmatch("[^\r\n]+")) {
        lines[#lines + 1] = line
    }

    function getname(){
        if (ogstr){
            // cwd/ogstr
            return filex.join(filesystem.currentdir(), ogstr)
        }else{
            return debug.getinfo(2, "S").source->sub(2)
        }
    }

    // 2: Look for preprocess lines
    var preprocess = []
    for (i, v in pairs(lines)) {
        var first = v->sub(1, 1) 
        var char = 1

        while (first == " " || first == "\t") {
            char++;
            first = v->sub(char, char)
        }

        if (first == "#") {
            v = v->sub(char, #v)
        
            table.insert(preprocess, [i, v])
        }
    }
    
    // 3: Execute preprocess lines
    var env = {
        "cobalt": true, 
        "cobaltversion": "23",
        "edition": "standard",
        "cplusplus": false,
    }
    // inenv will be like: -X="t" -M=2 -Z=true will become {["X"]="t", ["M"]=2, ["Z"]=true}
    envitems = table.pack(...)
    inenv = {}
    for (i, v in pairs(envitems)){
        if (type(v) == "number"){
            break;
        }
        var split = v->gsub("-", "")->split("=")
        inenv[split[1]] = loadstring("return "..split[2])()
    }

    // 4: Add inenv to env
    for (i, v in pairs(inenv)){
        if (type(v) == "string") v = '"'..v..'"'
        env[i] = v
    }
    var newlines = lines
    var activeifs = []
    var run = true
    var incomment = false

    function envload(str2){
        var tbld = "{"
        for (k, v in pairs(env)) {
            if (type(k) == "number") {
                tbld = tbld .. v .. ","
            }else if (type(k) == "string") {
                tbld = tbld .. '"' .. k .. '": ' .. tostring(v) .. ","
            }
        }
        tbld = tbld .. "}"
        return loadstring([=[// Cobalt execution environment: Ignore.
            env = ]=]..tbld..[=[;
            for (i, v in pairs(env)){
                _ENV[i] = v
            }
            core = import("core")
            function defined(val){
                // check if it is in env, if it return the value
                if (env[val] != null && env[val] != false) {
                    return env[val]
                }
            }]=]..str2)
    }
    for (i, v in pairs(lines)) {
        // Check if i is v[1] for one of the preprocess lines
        /// Go through every character, if a /* is found make incomment true, if a */ is found make incomment false
        /// If incomment is true, remove the line
        for (ii = 1, #v) {
            var char = v->sub(ii, ii)
            if (char == "/" && v->sub(ii + 1, ii + 1) == "*") {
                incomment = true
            }
            if (char == "*" && v->sub(ii + 1, ii + 1) == "/") {
                incomment = false
            }
        }
        if (incomment) {
            continue;
        }
        var found = false
        for (i2, v2 in pairs(preprocess)) {
            if (v2[1] == i) {
                v = v2
                found = true
                break;
            }
        }
        if (!found) {
            if (!run) {
                newlines[i] = null
            }
            continue;
        }

        // Get the first word of the line
        function errorpreprocessor(errorin){
            print("\27[1;31mPreprocessor error:\27[0m")
            print("\27[1;31mError with the '"..v[2].."' preprocessor command.\27[0m\n\n")
            if (errorin) {
                print("\27[1;31m"..errorin.."\27[0m\n\n")
            }
            print("\27[1;31mStopping preprocessor.\27[0m")
            os.exit()
        }

        // If the second character is a !, ignore the line
        if (v[2]->sub(2, 2) == "!") {
            newlines[v[1]] = null
            return // Skip this line
        }

        switch(v[2]->match("%S+"), {
            "#open": function(){
                // Example:
                // #open X
                // this is assuming X is in the env
                // var X = <whatever X is in the env>
                var name = v[2]->gsub("#open ", "")
                var value = env[name]
                if (value == null) {
                    errorpreprocessor("Macro '"..name.."' is not defined")
                }
                newlines[v[1]] = "var "..tostring(name).." = "..((type(value) == "string" && (str->sub(1,1) == '"' && str->sub(-1) == '"') || (str->sub(1,1) == "'" && str->sub(-1) == "'")) ? '"'..value..'"' : tostring(value))
                
                // Avoid memory leaks
                name, value = null
            },
            "#define": function(){
                // split v[2] by spaces
                var split = v[2]->split(" ")
                // 1: Get the name
                var name = split[2]
                if (string.sub(name, -1) == ")"){
                    // Example:
                    // #define RADTODEG(rad) (rad * 180 / PI)
                    // should become
                    // var RADTODEG = function(rad){ return (rad * 180 / PI)}

                    // 1: Get the name
                    var values = string.split(v[2], " ")
                    var defname = values[2]->split("(")[1]
                    var args = values[2]->split("(")[2]->gsub("%)", "")->split(",")
                    var func = values[3]
                    for (ii = 4, #values) {
                        func = func.." "..values[ii]
                    }
                    for (ii, vv in pairs(args)){
                        args[ii] = vv->gsub(" ", "")
                    }

                    var funcdef = "function("..table.concat(args, ",").."){ return "..func.."; }"
                    var valdef = "var "..defname.." = "..funcdef

                    // 2: Set values
                    newlines[v[1]] = valdef
                    env[name] = funcdef

                    // 3: Clear memory
                    values, defname, funcdef, valdef, args, func = null
                }else{
                    // 2: Get the value
                    var value 
                    var fun, err = envload("return "..split[3] || "false")
                    if (!fun){
                        errorpreprocessor(err)
                    }else{
                        value = fun()
                    }
                    // 3: Set the value in the env
                    env[name] = value
                    // 4: Remove the line
                    newlines[v[1]] = "var "..name.." = "..(type(value) == "string" ? '"'..value..'"' : tostring(value))
                    return
                }
            },
            "##line": function(){
                // Example:
                // #line 1 "file.cobalt"
                // Will add everything after that line in that file to the newlines[i] table
                // "file.cobalt" if it is not provided it is the current file
                // 1 is the line number
                warn("Using #line is not recommended, Use import() instead")
                var split = v[2]->split(" ")
                var line = split[2]
                var filename
                if (!split[3]) {
                    filename = getname()
                }else{
                    filename = string.sub(split[3], 2, -2)
                }
                print(filename)
                var f = io.open(filename)
                if (!f) {
                    var script_path = getname()
                    var script_dir = script_path->match("(.*/)")
                    if (script_dir == null) {
                        script_dir = "./"
                    }
                    f = io.open(script_dir..filename)
                    if (!f) {
                        errorpreprocessor("File '"..script_dir..filename.."' not found")
                    }
                }
                
                var content = f->read("*all")
                f->close()
                // Set i line number to r(content)
                content = process(content, null, null)
                // Split content to everything after tonumber(line)
                split = content->split("\n")
                var newcontent = ""
                for (ii = tonumber(line), #split) {
                    newcontent = newcontent..split[ii].."\n"
                }
                newlines[v[1]] = newcontent

                // Avoid memory leaks
                f = null
                content = null
                newcontent = null
                split = null
                file, line = null
            },
            "##include": function(){
                warn("Using #include is not recommended, Use import() instead")

                var file = v[2]->gsub("#include \"", "")
                var ogfile = file
                // File should be a string that ends with " and may have stuff after the "
                // Remove the last " and only keep everything before it
                for (ii = 1, #file) {
                    var vv = file->sub(ii, ii)
                    if (vv == "\"") {
                        file = file->sub(1, ii - 1)
                        break;
                    }
                }

                var f;
                for (_, vv in pairs(package.searchers)){
                    if (#table.pack(vv(file)) == 2 &&  table.pack(vv(file))[1] != null) {
                        f = table.pack(vv(file));
                        break;
                    }
                }
                if (!f) {
                    var script_path = getname()
                    var script_dir = script_path->match("(.*/)")
                    if (script_dir == null) {
                        script_dir = "./"
                    }

                    f = (io.open(script_dir..file))
                    if (!f) {
                        errorpreprocessor("File '"..file.."' not found")
                    }
                }
                if (type(f)=="string"){
                    file = io.open(f[2])
                }else{
                    file = f
                }
                var content = file->read("*all")
                file->close()
                
                // Set i line number to r(content)
    
                newlines[v[1]], newincludes = process(content, null, null)
                // Avoid memory leaks
                file = null
                content = null
                f = null
            },
            "#if": function(){
                // Example:
                // #if (true)
                
                // 1: Get the condition, Everything in between the ()
                var condition = v[2]->gsub("#if ", "")
                /// Get everything in between the ()
                for (ii = 1, #condition) {
                    var vv = condition->sub(ii, ii)
                    if (vv == "(") {
                        condition = condition->sub(ii + 1, #condition)
                        break;
                    }
                }
                for (ii = #condition, 1, -1) {
                    var vv = condition->sub(ii, ii)
                    if (vv == ")") {
                        condition = condition->sub(1, ii - 1)
                        break;
                    }
                }
                // 2: Evaluate the condition
                var success, result = xpcall(function(){
                    return (envload("return "..condition) || errorpreprocessor("Failed to check condition\n"..table.pack(envload("return "..condition))[2]))()
                }, function(err){
                    errorpreprocessor(err)
                })
                if (!success) {
                    errorpreprocessor(result)
                }
                // 3: Remove the line 
                newlines[v[1]] = null
                table.insert(activeifs, result)

                // 4: Remove all code if result is false until #endif or #else
                run = result
            },
            "#ifdef": function(){
                // Example:
                // #ifdef (__APPLE__)
                
                // 1: Get the condition, Everything in between the ()
                var condition = v[2]->gsub("#if ", "")
                /// Get everything in between the ()
                for (ii = 1, #condition) {
                    var vv = condition->sub(ii, ii)
                    if (vv == "(") {
                        condition = condition->sub(ii + 1, #condition)
                        break;
                    }
                }
                for (ii = #condition, 1, -1) {
                    var vv = condition->sub(i, i)
                    if (vv == ")") {
                        condition = condition->sub(1, ii - 1)
                        break;
                    }
                }
                // 2: Evaluate the condition
                var success, result = xpcall(function(){
                    return (envload("return defined(\""..(condition || "null").."\")") || errorpreprocessor("Failed to check condition\n"..(table.pack(envload("return "..(condition || "null"))) || "Failed to error")[2]))()
                }, function(err){
                    errorpreprocessor(err)
                })
                if (!success) {
                    errorpreprocessor(result)
                }
                // 3: Remove the line 
                newlines[v[1]] = null
                table.insert(activeifs, result)

                // 4: Remove all code if result is false until #endif or #else
                run = result
            },
            "#ifndef": function(){
                // Example:
                // #ifdef (__APPLE__)
                
                // 1: Get the condition, Everything in between the ()
                var condition = v[2]->gsub("#if ", "")
                /// Get everything in between the ()
                for (ii = 1, #condition) {
                    var vv = condition->sub(ii, ii)
                    if (vv == "(") {
                        condition = condition->sub(ii + 1, #condition)
                        break;
                    }
                }
                for (ii = #condition, 1, -1) {
                    var vv = condition->sub(ii, ii)
                    if (vv == ")") {
                        condition = condition->sub(1, ii - 1)
                        break;
                    }
                }
                // 2: Evaluate the condition
                var success, result = xpcall(function(){
                    return (envload("return !defined(\""..condition.."\")") || errorpreprocessor("Failed to check condition\n"..table.pack(envload("return "..condition))[2]))()
                }, function(err){
                    errorpreprocessor(err)
                })
                if (!success) {
                    errorpreprocessor(result)
                }
                // 3: Remove the line 
                newlines[v[1]] = null
                table.insert(activeifs, result)

                // 4: Remove all code if result is false until #endif or #else
                run = result
            },
            "#elif": function(){
                // Example:
                // #elif (true)
                if (run) {
                    newlines[v[1]] = null
                    return // Skip this line
                }
                // 1: Get the condition, Everything in between the ()
                var condition = v[2]->gsub("#elif ", "")
                /// Get everything in between the ()
                for (ii = 1, #condition) {
                    var vv = condition->sub(ii, ii)
                    if (vv == "(") {
                        condition = condition->sub(ii + 1, #condition)
                        break;
                    }
                }
                for (ii = #condition, 1, -1) {
                    var vv = condition->sub(ii, ii)
                    if (vv == ")") {
                        condition = condition->sub(1, ii - 1)
                        break;
                    }
                }
                // 2: Evaluate the condition
                var success, result = xpcall(function(){
                    return (envload("return "..condition) || errorpreprocessor("Failed to check condition\n"..table.pack(envload("return "..condition))[2]))()
                }, function(err){
                    errorpreprocessor(err)
                })
                if (!success) {
                    errorpreprocessor(result)
                }
                // 3: Remove the line 
                newlines[v[1]] = null
                table.insert(activeifs, result)

                // 4: Remove all code if result is false until #endif or #else
                run = result
            },
            "#else": function(){
                run = !run
                newlines[v[1]] = null
            },
            "#endif": function(){
                activeifs[#activeifs] = null
                newlines[v[1]] = null
                run = true
            },
            "#undef": function(){
                // split v[2] by spaces
                var split = v[2]->split(" ")
                // 1: Get the name
                var name = split[2]
                // 2: Remove the value in the env
                env[name] = null
                // 3: Remove the line
                newlines[v[1]] = null
            },
            "#error": function(){
                var error = v[2]->gsub("#error ", "")
                print("\27[1;31mRaised error:\27[0m")
                print("\27[1;31m"..error.."\27[0m\n\n")
                error("Ending preprocessor")
            },
            "#warning": function(){
                var warning = v[2]->gsub("#warning ", "")
                warn(warning)
                newlines[v[1]] = null
            },
            "#config": function(){
                errorpreprocessor("Config is not supported")
            },
            "#ext": function(){
                // Installs an extension
                errorpreprocessor("Extensions are not supported")
            },
            "default": function(value){
                if (!run){
                    newlines[v[1]] = null
                    return // Skip this line
                }

                // Execute everything past the # as a cobalt line
                var code = v[2]->sub(2, #v[2])
                
                var success, result = xpcall(function(){
                    return (envload(code) || errorpreprocessor("Failed to load preprocessor command"))()
                }, function(err){
                    errorpreprocessor(err)
                })
                if (!success) {
                    errorpreprocessor(result)
                }else {
                    newlines[v[1]] = result
                }
            }
        })
        // Remove line from newlines 
    }

    // 4: Join newlines and return
    if (#activeifs > 0) {
        errorpreprocessor("Missing #endif(s)")
    }
    lines = null
    preprocess = null
    str = null
    var joined = "/* Preprocessed with the built in Cobalt preprocessor */\n\n\n"
    for (i, v in pairs(newlines)) {
        if (v == null) {
            continue;
        }
        joined = joined..v.."\n"
    }
    newlines = null
    if (out){
        // Write to out 
        var file = io.open(outfile, "w")
        file->write(joined)
        file->close()
    }
    collectgarbage() // Collect garbage
    return joined
}

process("test.cobalt", "file", true, "test2.cobalt")
return process