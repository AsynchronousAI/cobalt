/*
  Cobalt Language Extension.
  This provides extensions to the standard Cobalt language. 
*/

/* EXTENDS:
- f"{x}" = string.format("%s", x)
- $table = pairs(table)
- @table = ipairs(table)
- x~y = _G.x = y, return y
- removes comments
- var [x, y, z] = tbl (x, y, z are the keys of tbl)
*/

/* TODO:
- Fix the nested string bug
- Strings that are optimized to be ", ' should not lose power
*/

/* SYSTEM:
 This uses the typechecker's dead & alive system to 
 kill all non syntax statements and will look for a 
 f"x {string} {string2}" and replace it with string.format("x %s", string, string2).
*/

typechecker = null
xpcall(function(){
    typechecker = import("type")
}, function(){
    typechecker = import("preprocess.type")
})

function gsub(str, pattern, replace){
  // Raw GSUB function
  var result = ""
  var pattern_len = #pattern
  var i = 1
  while (i <= #str) {
      if (str->sub(i, i + pattern_len - 1) == pattern) {
          result = result .. replace
          i = i + pattern_len
        }else{
          result = result .. str->sub(i, i)
          i = i + 1
        }
    }
  return result
}

function find(str, pattern, init){
  init = init || 1
  var pattern_len = #pattern
  var i = init
  while (i <= #str) {
      if (str->sub(i, i + pattern_len - 1) == pattern) {
          return i, i + pattern_len - 1
      }
      i = i + 1
  }
  return null
}

return function(str){
  cleanedCode, dead = typechecker.clean(str)
  
  lines = cleanedCode->split("\n")


  for (i, v in pairs(lines)){
    vclean =  typechecker.revive(v, dead)

    // Replace $table with pairs(table), and $$table with ipairs(table). Make sure the $$ doesnt render as $
    for (match in vclean->gmatch("@[a-zA-Z0-9_]+")){
      v = v->gsub(match, "ipairs("..(match->sub(2))..")")
    }
    for (match in vclean->gmatch("$[a-zA-Z0-9_]+")){
      v = v->gsub(match, "pairs("..match->sub(2)..")")
    }

    // x~y (y is anything until whitespace (not inside a string)) will add to the start _G.x=y; and then will replace the x~y with x
    for (match in v->gmatch("[a-zA-Z0-9_]+~[^%s]+")){
      /*
      v = "_G[\""..match->sub(1, match->find("~")-1).."\"] = "..match->sub(match->find("~")+1).."; "..v
    
      // replace match with the first part of the match. But do not use gsub
      v = gsub(v, match, match->sub(1, match->find("~")-1))
      */
      arg1 = match->sub(1, match->find("~")-1)
      arg2 = match->sub(match->find("~")+1)
      v = gsub(v, match, "global(\""..arg1.."\", "..arg2..")")
    }

    // table [x, y, z] = tbl
    /*
    for (match in v->gmatch("([a-zA-Z0-9_]+)%s*%[(.-)%]%s*=")){
      print(v)
      // replace the match with the first part of the match
      v = gsub(v, match, match->sub(1, find(match, "[")-1))
      // replace the match with the table.insert(tbl, x, y, z)
      v = gsub(v, match, "table.insert("..match->sub(find(match, "=")+1)..", "..match->sub(find(match, "[")+1, find(match, "]")-1)..")")
    }
    */

    for (match in v->gmatch("f'(.-)'")){
      // replace the f'{}' with string.format("{}", ...)
      v = typechecker.revive(v->gsub("f'(.-)'", "string.format('"..match.."'"), dead)
      // find all {} in the string
      for (it in v->gmatch("{(.-)}")){
        // For each {} add a , and the value
        v = v..", "..it
        // also replace the {} with %s
        v = v->gsub("{(.-)}", "%%s")
      }

      // add the closing bracket
      v = v..")"
    }

    for (match in v->gmatch("f[[(.*)]]")){
      print("\27[1;31mPreprocessor error:\27[0m")
      print("\27[1;31mError with the 'f[[' preprocessor command.\27[0m\n\n")
      if (errorin) {
          print("\27[1;31mMultiline formatted strings are not supported.\27[0m\n\n")
      }
      print("\27[1;31mStopping preprocessor.\27[0m")
      os.exit()
    }

    lines[i] = typechecker.revive(v)
  }


  return table.concat(lines,"\n")
}