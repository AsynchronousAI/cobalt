// Built in preprocessor for cobalt
// The preprocesser is not apart of the compiler
// and needs to be built using `cmake . && make` and
// used before compiling the source code

// The preprocessor replaces preprocessor directives with
// cobalt code depending on system and other factors

// Not used directly, rather compiled to C and included in source.

// INIT
filesystem = file // File library for cobalt
filex = import("ext.file") // Extended File library for cobalt

macros = function(){} // core.macros

function switch(value, cases){
    if (type(cases) != "table"){
        error("Switch expects a table as the second argument")
    }
    
    if(cases[value]){
        if (type(cases[value]) == "string"){
            print(cases[value])
            return
        } else {
            cases[value](value)
            return
        }
    }
    if(cases["default"]){
        if (type(cases["default"]) == "string"){
            print(cases["default"])
            return
        } else {
            cases["default"](value)
            return
        }
    }
    warn("Switch cannot find a case for " .. tostring(value) .. " and no default case was provided")
}


// SECTION 1: TYPECHECKER

/* TODO:
 - Allow custom types
 - Functions can have arguments to be typechecked
 - Generics
 - Fix issue where type can be changed after definiton
*/

/* SYSTEM:
 The system removes all comments and clears strings and saves it to a table of "dead" strings, 
 then it looks for definitions `var x: y = z` to store in a cache and assignments `x: y = z` and even 
 normal assignments `a = z` patterns, and then it checks the types of the values with 
 the "dead" strings reborn.

 It is simple and short, it is in BETA but issues will be rare it has been tested on even this 
 file and it works fine.

 If you do not use the typechecker type annotations are supported by the interpreter but wont
 have any value. But the same cannot be said for preprocessor directives, they are not supported 
 in the interpreter.

 If the typechecker fails to check it will ignore.
*/

// GLOBALS
dead = {}

// ERROR
function typerror(errorin, line, note){
  print("\27[1;31mTypechecker error:\27[0m")
  if (errorin) {
      print("\27[1;31m"..errorin.."\27[0m\n\n")
  }
  print("\27[1;31mSnippet:\27[0m")
  print(revive(line))
  if (note){
    print("\n\27[1;31mTypechecker provided note:\27[0m")
    print("\n\27[1;31m"..note.."\27[0m")
  }
  print("\n\27[1;31mStopping Typechecker.\27[0m")
  os.exit()
}
// LOAD
function tabletostring(tbl){
  // Converts a table to a string
  var result = "{"
  for (i, v in pairs(tbl)) {
    if (!v){
      v = "null"
    }
    v = (loadstring("return "..(v || "null")) || loadenv("return "..(v || "null")))
    xpcall(function(){
      v = v()
    }, 
    function(){
      v = loadenv("return "..(v || "null"))
      xpcall(function(){
        v = v()
      },
      function(err){
        typerror("Error checking value: "..err)
      })
    })

    if (type(v) == "string") {
      result = result..i.." = \""..v.."\","
    } else if (type(v) == "table") {
      result = result..i.." = "..tabletostring(v)..", "
    } else {
      result = result..i.." = "..(v || "null")..","
    }
  }
  result = result.."}"
  return result
}
function loadenv(env, str){
  // Uses loadstring, but the enviourment can be provided. env is a table.
  envstr = tabletostring(env)
  str = [[
    env = ]]..envstr..[[
    for (i, v in pairs(env)) {
      _G[i] = v
    }

  ]]..str

  return loadstring(revive(str));
}

// TYPES
types = {
  "string": function(item){
    // Check if item is a string
    return type(item) == "string"
  },
  "pos": function(item){
    return math.abs(item) == item
  },
  "neg": function(item){
    return math.abs(item) != item
  },
  "posint": function(item){
    return math.abs(item) == item && math.floor(item) == item
  },
  "negint": function(item){
    return math.abs(item) != item && math.floor(item) == item
  },
  "pointer": function(item){
    // Check if the item is a string which is parsed like a pointer
    return type(item) == "string" && (string.sub(item, 1, 1) == "&" || string.sub(item, 1, 2) == "0x")
  },
  "array": function(item){
    // Make sure that all the indexes are integers
    for (i, v in pairs(item)) {
      if (type(i) != "number") {
        return false
      }
    }
  },
  "matrix": function(item){
    // Check if all the values are a table
    for (i, v in pairs(item)) {
      if (type(v) != "table") {
        return false
      }
    }
  },
  "Vector3": function(item){
    // Uses the `Vector3` class and check if tostring(item) == "vec3: <pointer>"
    return type(item) == "userdata" && string.match(tostring(item), "^vec3: ")
  },
  "Vector2": function(item){
    // Uses the `Vector2` class and check if tostring(item) == "vec2: <pointer>"
    return type(item) == "userdata" && string.match(tostring(item), "^vec2: ")
  },
  "Color": function(item){
    // Uses the `Color` class and check if tostring(item) == "color: <pointer>"
    return type(item) == "userdata" && string.match(tostring(item), "^color: ")
  },
  "Transform": function(item){
    // Uses the `Transform` class and check if tostring(item) == "transform: <pointer>"
    return type(item) == "userdata" && string.match(tostring(item), "^transform: ")
  },
  "number": function(item){
    // Check if item is a number
    return type(item) == "number"
  },
  "boolean": function(item){
    // Check if item is a boolean
    return type(item) == "boolean"
  },
  "table": function(item){
    // Check if item is a table
    return type(item) == "table"
  },
  "function": function(item){
    // Check if item is a function
    return type(item) == "function"
  },
  "userdata": function(item){
    // Check if item is a userdata
    return type(item) == "userdata"
  },
  "thread": function(item){
    // Check if item is a thread
    return type(item) == "thread"
  },
  "null": function(item){
    // Check if item is null
    return type(item) == "null"
  },
  "char": function(item){
    // Check if the item is a string and 1 character long
    return type(item) == "string" && #item == 1;
  },
  "msg": function(item){
    // Check if tostring(item) == "message: <pointer>"
    // messages are used in the Message library for communication between threads
    return tostring(item) == string.match("^message: ")
  },
  "complex": function(item){
    // Try to get item.__name, if it is "complex number" then it is a complex number
    s, e = pcall(function(){ if (!item.__name){error("Force error")} })
    return s
  },
  "directory": function(item){
    // For `file` directory type
    // return tostring(item) == "directory: <pointer>"
    return tostring(item) == string.match("^directory: ")
  },
  "lock": function(item){
    // For `file` lock type
    // return tostring(item) == "lock: <pointer>"
    return tostring(item) == string.match("^lock: ")
  },
  "protected": function(item){
    // return getmetatable(item).__metatable != nil
    return getmetatable(item).__metatable != null
  },
  "_LUABOX": function(item){
    // Check if tostring(item) == "LUABOX: <pointer>"
    // this shouldnt be used for average code, LUABOX is internal
    return tostring(item) == string.match("^LUABOX: ")
  },
  "any": function(item){
    // Check if item is any type
    return true
  },
  "thread": function(item){
    // Check if item is a thread
    return type(item) == "thread"
  },
  "int": function(item){
    // Check if item is an integer
    return type(item) == "number" && math.floor(item) == item
  },
  "float": function(item){
    // Check if item is a float
    return type(item) == "number" && math.floor(item) != item
  },
  "double": function(item){
    // Check if item is a double
    return type(item) == "number" && math.floor(item) != item
  },
};
alltypes = []

for (i, v in pairs(types)) {
  table.insert(alltypes, i)
}

// PARSER
function deffind(str) {
    // Takes in code and looks for definitions with annotations
    var pattern = "^%s*var%s+([^%s]+)%s*:%s*([^%s]+)%s*=%s*([^%s]+)%s*$";
        pattern = "^%s*var%s+([^%s]+)%s*:%s*([^%s]+)%s*=%s*(.-)%s*$";
    var result = {};
    for( line in str->gmatch("[^\r\n]+") ) {
      var vart, key, value = line->match(pattern);
      if( vart && key && value ) {
        table.insert(result, {vart, key, value, line});
      }
    }
    return result;
}
function assign(str) {
    // Takes in code looks for assignments with annotations
    var pattern = "%s*([^%s]+)%s*:%s*([^%s]+)%s*=%s*([^%s]+)%s*";
    var result = {};
    for( line in str->gmatch("[^\r\n]+") ) {
      var vart, key, value = line->match(pattern);
      if( vart && key && value ) {
        // Verify var, key, value are not eligible for def
        if( ! deffind(line)[1] ) {
            table.insert(result, {vart, key, value, line});
        }
      }
    }
    return result;
}
function findfunctions(str){
  // Looks for `function x(<?>)` and returns a table of all the functions and source code
  var pattern = "^%s*function%s+([^%s]+)%s*%(([^%s]*)%)%s*$";
  var result = {};
  for( line in str->gmatch("[^\r\n]+") ) {
    var key, value = line->match(pattern);
    if( key && value ) {
      table.insert(result, {key, value, line});
    }
  }
  return result;
}
function allassign(str){
  // Used to look for typeless assignments
  var pattern = "%s*([^%s]+)%s*=%s*([^%s]+)%s*";
  var result = {};
  for( line in str->gmatch("[^\r\n]+") ) {
    var key, value = line->match(pattern);
    if( key && value ) {
      if (! deffind(line)[1] && ! assign(line)[1]) {
        table.insert(result, {key, value, line});
      }
    }
  }
  return result;
}
function findall(str){
  // Used to look for %s=%s
  var pattern = "%s*=%s*";
  var result = {};
  for( line in str->gmatch("[^\r\n]+") ) {
    var key, value = line->match(pattern);
    if( key && value ) {
      table.insert(result, {key, value, line});
    }
  }
  return result;
}
function revive(str){
  for (i, v in pairs(dead)){
    var index = "'DEADVALUESTRTYPECHECK-"..(i).."'"

    // Go character by character and look for index
    // I want to use ->gsub but that doesnt work for sum reason so I am using a 
    // manual method
    var ci = 1;
    var csofar = "";
    for (ii = 1, #str) {
      var char = str->sub(ii, ii);
      if (char == index->sub(ci, ci)) {
        ci++;
        csofar = csofar..char;
        if (csofar == index) {
          str = str->sub(1, ii - #index)..v..str->sub(ii + 1, #str)
          break;
        }
      } else {
        ci = 1;
        csofar = "";
      }
    }
  }
  return str
}
function clean(str) {
  // Takes in code and removes comments, strings.
  // Remove strings and add it to "dead" table
  var dead = {};
  var i = 0;
  ogstr = str;
  if (!str["gsub"]) typerror("string.gsub is not a found function, Are you sure you provided a string?")
  str = str->gsub("'[^']-'", function(match){
    i++;
    dead[i] = match;
    return "'DEADVALUESTRTYPECHECK-"..(i).."'";
  })->gsub('"[^"]-"', function(match){
    i++;
    dead[i] = match;
    return "'DEADVALUESTRTYPECHECK-"..(i).."'";
  })->gsub('%[%[.-%]%]', function(match){
    i++;
    dead[i] = match;
    return "'DEADVALUESTRTYPECHECK-"..(i).."'";
  });
  return str->gsub('//.-\n', '\n')->gsub('/%*.-%*/', '\n'), dead;
}

// CHECKER
typeof = type;
function check(type, value, vname, knownValues, line) {
  value, err = loadenv(knownValues, "return " .. value)
  if (!value){
    typerror("Check error: "..err, line)
  }
  xpcall(function(){
    value = value();
  }, function(err){
    // Ignore and return true
    return true;
  })
  if( types[type] ) {
    if (types[type](value)) {
      return true;
    } else {
      if (typeof(value) == "function") return true; // Ignore for now
      typerror(core.error.strerror(111)->format(type, (tostring(typeof(value)).." (and it's descendents)"), vname), line);
    }
  } else {
    typerror(core.error.strerror(112)->format(type), line, "Use `cobaltpre -types` to see all types");
  }
}

// MAIN
function typecheck(code){
  cleanedCode, newdead = clean(code);
  dead = newdead;
  for (i, v in pairs(cleanedCode->split("\n"))){
    cleanedCode = cleanedCode->split("\n")[i] || "";
    var defs = deffind(cleanedCode);
    var assigns = assign(cleanedCode);
    var allassigns = allassign(cleanedCode);
    var functions = findfunctions(cleanedCode);
    var all = findall(cleanedCode);

    var knownTypes = {};
    var knownValues = {}; 
    for( _, def in pairs(defs) ) {
      check(def[2], def[3], def[1], knownValues, def[4])
      value, err = loadenv(knownValues, "return " .. def[3])
      if (!value){
        typerror("Check error: "..err)
      }
      knownTypes[def[1]] = def[2];
      xpcall(function(){
        knownValues[def[1]] = value();
      }, function(err){})
      
    }
    for( _, allassign in pairs(allassigns) ) {
      if (knownTypes[allassign[1]]) {
        check(knownTypes[allassign[1]], allassign[2], allassign[1], knownValues, allassign[3]);
      }else if(!knownValues[allassign[1]]) {
        knownValues[allassign[1]] = allassign[2];
      }
    }
    for( _, assign in pairs(assigns) ) {
      check(assign[2], assign[3], assign[1], knownValues, assign[4]);
      knownValues[assign[1]] = assign[3];
      knownTypes[assign[1]] = assign[2];
    }
  }
  return true;
}
function all(){
  // Prints all types
  print("All valid checkable types:")
  for (i, v in pairs(alltypes)) {
    print("  "..v)
  }
}

typechecker = {
  "all": all,
  "check": typecheck,
  "clean": clean,
  "revive": revive,
}

// SECTION 2: Language extensions

/* EXTENDS:
- f"{x}" = string.format("%s", x)
- $table = pairs(table)
- @table = ipairs(table)
- x~y = _G.x = y, return y
- removes comments
- var [x, y, z] = tbl (x, y, z are the keys of tbl)
- var x <pre> = y (will calculate y on preprocessor)
- &x = unpack(x)
*/

/* TODO:
  - Fix the nested string bug
  - Strings that are optimized to be ", ' should not lose power
*/

/* SYSTEM:
 This uses the typechecker's dead & alive system to 
 kill all non syntax statements and will look for a 
 f"x {string} {string2}" and replace it with string.format("x %s", string, string2).
*/

function gsub(str, pattern, replace){
  // Raw GSUB function
  var result = ""
  var pattern_len = #pattern
  var i = 1
  while (i <= #str) {
      if (str->sub(i, i + pattern_len - 1) == pattern) {
          result = result .. replace
          i = i + pattern_len
        }else{
          result = result .. str->sub(i, i)
          i = i + 1
        }
    }
  return result
}

function find(str, pattern, init){
  init = init || 1
  var pattern_len = #pattern
  var i = init
  while (i <= #str) {
      if (str->sub(i, i + pattern_len - 1) == pattern) {
          return i, i + pattern_len - 1
      }
      i = i + 1
  }
  return null
}

ext = function(str){
  cleanedCode, dead = typechecker.clean(str)
  
  lines = cleanedCode->split("\n")


  for (i, v in pairs(lines)){
    vclean =  typechecker.revive(v, dead)
    // look for var %s <pre> = %s 
    var pattern = "var%s+([^%s]+)%s+<pre>%s*=%s*(.-)%s*$"
    for (match, match2 in vclean->gmatch(pattern)){
      newval = ""
      xpcall(function(){
        newval = loadstring("return "..match2)()
      }, function(err){
        errorpreprocessor("Error rendering <pre> value: "..err, v)
      })

      // Format newval
      if (type(newval) == "string") newval = '"'..newval..'"'
      if (type(newval) == "table") newval = tabletostring(newval)
      if (type(newval) == "function") newval = errorpreprocessor("Functions are not supported in <pre> values", v)
      if (type(newval) == "userdata") newval = errorpreprocessor("Userdata is not supported in <pre> values", v)
      if (type(newval) == "thread") newval = errorpreprocessor("Threads are not supported in <pre> values", v)
      if (type(newval) == "null") newval = "null"



      v = v->gsub("var%s+([^%s]+)%s+<pre>%s*=%s*(.-)%s*$", "var "..match.." = "..newval)
    }
    // Replace $table with pairs(table), and $$table with ipairs(table). Make sure the $$ doesnt render as $
    for (match in vclean->gmatch("@[a-zA-Z0-9_]+")){
      v = v->gsub(match, "ipairs("..(match->sub(2))..")")
    }
    for (match in vclean->gmatch("$[a-zA-Z0-9_]+")){
      v = v->gsub(match, "pairs("..match->sub(2)..")")
    }
    for (match in vclean->gmatch("&[a-zA-Z0-9_]+")){
      v = v->gsub(match, "table.unpack("..match->sub(2)..")")
    }

    // x~y (y is anything until whitespace (not inside a string)) will add to the start _G.x=y; and then will replace the x~y with x
    for (match in v->gmatch("[a-zA-Z0-9_]+~[^%s]+")){
      /*
      v = "_G[\""..match->sub(1, match->find("~")-1).."\"] = "..match->sub(match->find("~")+1).."; "..v
    
      // replace match with the first part of the match. But do not use gsub
      v = gsub(v, match, match->sub(1, match->find("~")-1))
      */
      arg1 = match->sub(1, match->find("~")-1)
      arg2 = match->sub(match->find("~")+1)
      v = gsub(v, match, "_.global(\""..arg1.."\", "..arg2..")")
    }

    // table [x, y, z] = tbl
    /*
    for (match in v->gmatch("([a-zA-Z0-9_]+)%s*%[(.-)%]%s*=")){
      print(v)
      // replace the match with the first part of the match
      v = gsub(v, match, match->sub(1, find(match, "[")-1))
      // replace the match with the table.insert(tbl, x, y, z)
      v = gsub(v, match, "table.insert("..match->sub(find(match, "=")+1)..", "..match->sub(find(match, "[")+1, find(match, "]")-1)..")")
    }
    */

    for (match in v->gmatch("f'(.-)'")){
      // replace the f'{}' with string.format("{}", ...)
      v = typechecker.revive(v->gsub("f'(.-)'", "string.format('"..match.."'"), dead)
      // find all {} in the string
      for (it in v->gmatch("{(.-)}")){
        // For each {} add a , and the value
        v = v..", "..it
        // also replace the {} with %s
        v = v->gsub("{(.-)}", "%%s")
      }

      // add the closing bracket
      v = v..")"
    }

    for (match in v->gmatch("f[[(.*)]]")){
      print("\27[1;31mPreprocessor error:\27[0m")
      print("\27[1;31mError with the 'f[[' preprocessor command.\27[0m\n\n")
      if (errorin) {
          print("\27[1;31mMultiline formatted strings are not supported.\27[0m\n\n")
      }
      print("\27[1;31mStopping preprocessor.\27[0m")
      os.exit()
    }

    lines[i] = typechecker.revive(v)
  }


  return table.concat(lines,"\n")
}

// SECTION 3: Interface & Preprocessor directives

/* Dependencies
   // filex (Installed with `make setup`)
   // core
   // ffi
   // base libraries
*/

/* Notes
    - The preprocessor is not apart of the compiler
    - Using C Macros require GCC to be installed (As of the `core` library dependency)
*/

/* TODO:
    - Actually substitute macros & definitions
*/

/* Supports
   // Enabled:
    // #open (name): Checks if a Macro is defined and opens it so that the program can use it
    // #define (name) (value <optional>): Sets a macro
    // #define (lambdaname)(args) (function): Sets a macro to a lambda function
    // #undef (name): Removes a macro
    // #ifdef (name): If macro is defined, Condition must be wrapped in ()
    // #ifndef (name): If macro is not defined, Condition must be wrapped in ()
    // #elif (name): Else if macro is defined, Condition must be wrapped in ()
    // #else: Else, no condition
    // #endif: End if
    // #error (message): Raises an error
    // #warning (message): Raises a warning

   // Disabled:
    // #include "file.cobalt": Includes a file (Cyclic dependencies will leave the preprocessor in an infinite loop) (Name must be in "")
    // #line (line) "file.cobalt <optional>": Sets the line number and file name for the preprocessor (Cyclic dependencies will leave the preprocessor in an infinite loop) (Name must be in "")


    // Everything else that starts with a # will be executed as a cobalt source line
    // C Macros are supported if GCC is installed, if not, they will be ignored.
    // cobalt and cobaltversion are included macros
*/

function process(str, itemtype, out, outfile, ...){
    // 0: Init
    
    /// Check mode:
    if (outfile == "-types" || (str == "-types" && !outfile) ){
        typechecker.all() // Print all valid types
        return;
    }if ({...} == {}){
        error("No arguments or invalid flags provided.")
    }

    /// Init macros
    macros()

    // 1: Split lines
    var nstr
    var ogstr = out ? str : null
    if (itemtype == "file") {
        var file = io.open(str)
        if (!file){
            error(core.error.strerror(2))
        }
        nstr = file->read("*all")
        file->close()
        if (!nstr){
            error(core.error.strerror(2))
        }
    }
    // 0: Run typechecker and language extensions
    
    if (!nstr) nstr = str
    typechecker.check(nstr)
    nstr = ext(nstr)

    // 0.5: Split lines
    var lines = []
    for (line in nstr->gmatch("[^\r\n]+")) {
        lines[#lines + 1] = line
    }

    function getname(){
        if (ogstr){
            // cwd/ogstr
            return filex.join(filesystem.currentdir(), ogstr)
        }else{
            return debug.getinfo(2, "S").source->sub(2)
        }
    }

    // 2: Look for preprocess lines
    var preprocess = []
    for (i, v in pairs(lines)) {
        var first = v->sub(1, 1) 
        var char = 1

        while (first == " " || first == "\t") {
            char++;
            first = v->sub(char, char)
        }

        if (first == "#") {
            v = v->sub(char, #v)
        
            table.insert(preprocess, [i, v])
        }
    }
    
    // 3: Execute preprocess lines
    var env = {
        "cobalt": true, 
        "cobaltversion": "23",
        "edition": "standard",
        "cplusplus": false,
    }
    // inenv will be like: -X="t" -M=2 -Z=true will become {["X"]="t", ["M"]=2, ["Z"]=true}
    envitems = table.pack(...)
    inenv = {}
    for (i, v in pairs(envitems)){
        if (type(v) == "number"){
            break;
        }
        var split = v->gsub("-", "")->split("=")
        inenv[split[1]] = loadstring("return "..split[2])()
    }

    // 4: Add inenv to env
    for (i, v in pairs(inenv)){
        if (type(v) == "string") v = '"'..v..'"'
        env[i] = v
    }
    var newlines = lines
    var activeifs = []
    var run = true
    var incomment = false

    function envload(str2){
        var tbld = "{"
        for (k, v in pairs(env)) {
            if (type(k) == "number") {
                tbld = tbld .. v .. ","
            }else if (type(k) == "string") {
                tbld = tbld .. '"' .. k .. '": ' .. tostring(v) .. ","
            }
        }
        tbld = tbld .. "}"
        return loadstring([=[// Cobalt execution environment: Ignore.
            env = ]=]..tbld..[=[;
            for (i, v in pairs(env)){
                _ENV[i] = v
            }
            core = import("core")
            function defined(val){
                // check if it is in env, if it return the value
                if (env[val] != null && env[val] != false) {
                    return env[val]
                }
            }]=]..str2)
    }
    for (i, v in pairs(lines)) {
        // Check if i is v[1] for one of the preprocess lines
        /// Go through every character, if a /* is found make incomment true, if a */ is found make incomment false
        /// If incomment is true, remove the line
        for (ii = 1, #v) {
            var char = v->sub(ii, ii)
            if (char == "/" && v->sub(ii + 1, ii + 1) == "*") {
                incomment = true
            }
            if (char == "*" && v->sub(ii + 1, ii + 1) == "/") {
                incomment = false
            }
        }
        if (incomment) {
            continue;
        }
        var found = false
        for (i2, v2 in pairs(preprocess)) {
            if (v2[1] == i) {
                v = v2
                found = true
                break;
            }
        }
        if (!found) {
            if (!run) {
                newlines[i] = null
            }
            continue;
        }

        // Get the first word of the line
        function errorpreprocessor(errorin){
            print("\27[1;31mPreprocessor error:\27[0m")
            print("\27[1;31mError with the '"..v[2].."' preprocessor command.\27[0m\n\n")
            if (errorin) {
                print("\27[1;31m"..errorin.."\27[0m\n\n")
            }
            print("\27[1;31mStopping preprocessor.\27[0m")
            os.exit()
        }

        // If the second character is a !, ignore the line
        if (v[2]->sub(2, 2) == "!") {
            newlines[v[1]] = null
            return // Skip this line
        }

        switch(v[2]->match("%S+"), {
            "#open": function(){
                // Example:
                // #open X
                // this is assuming X is in the env
                // var X = <whatever X is in the env>
                var name = v[2]->gsub("#open ", "")
                var value = env[name]
                if (value == null) {
                    errorpreprocessor("Macro '"..name.."' is not defined")
                }
                newlines[v[1]] = "var "..tostring(name).." = "..((type(value) == "string" && (str->sub(1,1) == '"' && str->sub(-1) == '"') || (str->sub(1,1) == "'" && str->sub(-1) == "'")) ? '"'..value..'"' : tostring(value))
                
                // Avoid memory leaks
                name, value = null
            },
            "#define": function(){
                // split v[2] by spaces
                var split = v[2]->split(" ")
                // 1: Get the name
                var name = split[2]
                if (string.sub(name, -1) == ")"){
                    // Example:
                    // #define RADTODEG(rad) (rad * 180 / PI)
                    // should become
                    // var RADTODEG = function(rad){ return (rad * 180 / PI)}

                    // 1: Get the name
                    var values = string.split(v[2], " ")
                    var defname = values[2]->split("(")[1]
                    var args = values[2]->split("(")[2]->gsub("%)", "")->split(",")
                    var func = values[3]
                    for (ii = 4, #values) {
                        func = func.." "..values[ii]
                    }
                    for (ii, vv in pairs(args)){
                        args[ii] = vv->gsub(" ", "")
                    }

                    var funcdef = "function("..table.concat(args, ",").."){ return "..func.."; }"
                    var valdef = "var "..defname.." = "..funcdef

                    // 2: Set values
                    newlines[v[1]] = valdef
                    env[name] = funcdef

                    // 3: Clear memory
                    values, defname, funcdef, valdef, args, func = null
                }else{
                    // 2: Get the value
                    var value 
                    var fun, err = envload("return "..split[3] || "false")
                    if (!fun){
                        errorpreprocessor(err)
                    }else{
                        value = fun()
                    }
                    // 3: Set the value in the env
                    env[name] = value
                    // 4: Remove the line
                    newlines[v[1]] = "var "..name.." = "..(type(value) == "string" ? '"'..value..'"' : tostring(value))
                    return
                }
            },
            "##line": function(){
                // Example:
                // #line 1 "file.cobalt"
                // Will add everything after that line in that file to the newlines[i] table
                // "file.cobalt" if it is not provided it is the current file
                // 1 is the line number
                warn("Using #line is not recommended, Use import() instead")
                var split = v[2]->split(" ")
                var line = split[2]
                var filename
                if (!split[3]) {
                    filename = getname()
                }else{
                    filename = string.sub(split[3], 2, -2)
                }
                print(filename)
                var f = io.open(filename)
                if (!f) {
                    var script_path = getname()
                    var script_dir = script_path->match("(.*/)")
                    if (script_dir == null) {
                        script_dir = "./"
                    }
                    f = io.open(script_dir..filename)
                    if (!f) {
                        errorpreprocessor("File '"..script_dir..filename.."' not found")
                    }
                }
                
                var content = f->read("*all")
                f->close()
                // Set i line number to r(content)
                content = process(content, null, null)
                // Split content to everything after tonumber(line)
                split = content->split("\n")
                var newcontent = ""
                for (ii = tonumber(line), #split) {
                    newcontent = newcontent..split[ii].."\n"
                }
                newlines[v[1]] = newcontent

                // Avoid memory leaks
                f = null
                content = null
                newcontent = null
                split = null
                file, line = null
            },
            "##include": function(){
                warn("Using #include is not recommended, Use import() instead")

                var file = v[2]->gsub("#include \"", "")
                var ogfile = file
                // File should be a string that ends with " and may have stuff after the "
                // Remove the last " and only keep everything before it
                for (ii = 1, #file) {
                    var vv = file->sub(ii, ii)
                    if (vv == "\"") {
                        file = file->sub(1, ii - 1)
                        break;
                    }
                }

                var f;
                for (_, vv in pairs(package.searchers)){
                    if (#table.pack(vv(file)) == 2 &&  table.pack(vv(file))[1] != null) {
                        f = table.pack(vv(file));
                        break;
                    }
                }
                if (!f) {
                    var script_path = getname()
                    var script_dir = script_path->match("(.*/)")
                    if (script_dir == null) {
                        script_dir = "./"
                    }

                    f = (io.open(script_dir..file))
                    if (!f) {
                        errorpreprocessor("File '"..file.."' not found")
                    }
                }
                if (type(f)=="string"){
                    file = io.open(f[2])
                }else{
                    file = f
                }
                var content = file->read("*all")
                file->close()
                
                // Set i line number to r(content)
    
                newlines[v[1]], newincludes = process(content, null, null)
                // Avoid memory leaks
                file = null
                content = null
                f = null
            },
            "#if": function(){
                // Example:
                // #if (true)
                
                // 1: Get the condition, Everything in between the ()
                var condition = v[2]->gsub("#if ", "")
                /// Get everything in between the ()
                for (ii = 1, #condition) {
                    var vv = condition->sub(ii, ii)
                    if (vv == "(") {
                        condition = condition->sub(ii + 1, #condition)
                        break;
                    }
                }
                for (ii = #condition, 1, -1) {
                    var vv = condition->sub(ii, ii)
                    if (vv == ")") {
                        condition = condition->sub(1, ii - 1)
                        break;
                    }
                }
                // 2: Evaluate the condition
                var success, result = xpcall(function(){
                    return (envload("return "..condition) || errorpreprocessor("Failed to check condition\n"..table.pack(envload("return "..condition))[2]))()
                }, function(err){
                    errorpreprocessor(err)
                })
                if (!success) {
                    errorpreprocessor(result)
                }
                // 3: Remove the line 
                newlines[v[1]] = null
                table.insert(activeifs, result)

                // 4: Remove all code if result is false until #endif or #else
                run = result
            },
            "#ifdef": function(){
                // Example:
                // #ifdef (__APPLE__)
                
                // 1: Get the condition, Everything in between the ()
                var condition = v[2]->gsub("#if ", "")
                /// Get everything in between the ()
                for (ii = 1, #condition) {
                    var vv = condition->sub(ii, ii)
                    if (vv == "(") {
                        condition = condition->sub(ii + 1, #condition)
                        break;
                    }
                }
                for (ii = #condition, 1, -1) {
                    var vv = condition->sub(i, i)
                    if (vv == ")") {
                        condition = condition->sub(1, ii - 1)
                        break;
                    }
                }
                // 2: Evaluate the condition
                var success, result = xpcall(function(){
                    return (envload("return defined(\""..(condition || "null").."\")") || errorpreprocessor("Failed to check condition\n"..(table.pack(envload("return "..(condition || "null"))) || "Failed to error")[2]))()
                }, function(err){
                    errorpreprocessor(err)
                })
                if (!success) {
                    errorpreprocessor(result)
                }
                // 3: Remove the line 
                newlines[v[1]] = null
                table.insert(activeifs, result)

                // 4: Remove all code if result is false until #endif or #else
                run = result
            },
            "#ifndef": function(){
                // Example:
                // #ifdef (__APPLE__)
                
                // 1: Get the condition, Everything in between the ()
                var condition = v[2]->gsub("#if ", "")
                /// Get everything in between the ()
                for (ii = 1, #condition) {
                    var vv = condition->sub(ii, ii)
                    if (vv == "(") {
                        condition = condition->sub(ii + 1, #condition)
                        break;
                    }
                }
                for (ii = #condition, 1, -1) {
                    var vv = condition->sub(ii, ii)
                    if (vv == ")") {
                        condition = condition->sub(1, ii - 1)
                        break;
                    }
                }
                // 2: Evaluate the condition
                var success, result = xpcall(function(){
                    return (envload("return !defined(\""..condition.."\")") || errorpreprocessor("Failed to check condition\n"..table.pack(envload("return "..condition))[2]))()
                }, function(err){
                    errorpreprocessor(err)
                })
                if (!success) {
                    errorpreprocessor(result)
                }
                // 3: Remove the line 
                newlines[v[1]] = null
                table.insert(activeifs, result)

                // 4: Remove all code if result is false until #endif or #else
                run = result
            },
            "#elif": function(){
                // Example:
                // #elif (true)
                if (run) {
                    newlines[v[1]] = null
                    return // Skip this line
                }
                // 1: Get the condition, Everything in between the ()
                var condition = v[2]->gsub("#elif ", "")
                /// Get everything in between the ()
                for (ii = 1, #condition) {
                    var vv = condition->sub(ii, ii)
                    if (vv == "(") {
                        condition = condition->sub(ii + 1, #condition)
                        break;
                    }
                }
                for (ii = #condition, 1, -1) {
                    var vv = condition->sub(ii, ii)
                    if (vv == ")") {
                        condition = condition->sub(1, ii - 1)
                        break;
                    }
                }
                // 2: Evaluate the condition
                var success, result = xpcall(function(){
                    return (envload("return "..condition) || errorpreprocessor("Failed to check condition\n"..table.pack(envload("return "..condition))[2]))()
                }, function(err){
                    errorpreprocessor(err)
                })
                if (!success) {
                    errorpreprocessor(result)
                }
                // 3: Remove the line 
                newlines[v[1]] = null
                table.insert(activeifs, result)

                // 4: Remove all code if result is false until #endif or #else
                run = result
            },
            "#else": function(){
                run = !run
                newlines[v[1]] = null
            },
            "#endif": function(){
                activeifs[#activeifs] = null
                newlines[v[1]] = null
                run = true
            },
            "#undef": function(){
                // split v[2] by spaces
                var split = v[2]->split(" ")
                // 1: Get the name
                var name = split[2]
                // 2: Remove the value in the env
                env[name] = null
                // 3: Remove the line
                newlines[v[1]] = null
            },
            "#error": function(){
                var error = v[2]->gsub("#error ", "")
                print("\27[1;31mRaised error:\27[0m")
                print("\27[1;31m"..error.."\27[0m\n\n")
                error("Ending preprocessor")
            },
            "#warning": function(){
                var warning = v[2]->gsub("#warning ", "")
                warn(warning)
                newlines[v[1]] = null
            },
            "#config": function(){
                errorpreprocessor("Config is not supported")
            },
            "#ext": function(){
                // Installs an extension
                errorpreprocessor("Extensions are not supported")
            },
            "default": function(value){
                if (!run){
                    newlines[v[1]] = null
                    return // Skip this line
                }

                // Execute everything past the # as a cobalt line
                var code = v[2]->sub(2, #v[2])
                
                var success, result = xpcall(function(){
                    return (envload(code) || errorpreprocessor("Failed to load preprocessor command"))()
                }, function(err){
                    errorpreprocessor(err)
                })
                if (!success) {
                    errorpreprocessor(result)
                }else {
                    newlines[v[1]] = result
                }
            }
        })
        // Remove line from newlines 
    }

    // 4: Join newlines and return
    if (#activeifs > 0) {
        errorpreprocessor("Missing #endif(s)")
    }
    lines = null
    preprocess = null
    str = null
    var joined = "/* Preprocessed with the built in Cobalt preprocessor */\n\n\n"
    for (i, v in pairs(newlines)) {
        if (v == null) {
            continue;
        }
        joined = joined..v.."\n"
    }
    newlines = null
    if (out){
        // Write to out 
        var file = io.open(outfile, "w")
        file->write(joined)
        file->close()
    }
    collectgarbage() // Collect garbage
    return joined
}

//process("test.cobalt", "file", true, "test2.cobalt")
return process